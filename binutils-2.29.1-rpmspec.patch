diff -rupN binutils-2.29.1.orig/Makefile.def binutils-2.29.1/Makefile.def
--- binutils-2.29.1.orig/Makefile.def	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/Makefile.def	2017-10-06 18:33:27.688717345 +0200
@@ -463,6 +463,7 @@ dependencies = { module=configure-gold;
 dependencies = { module=all-gold; on=all-libiberty; };
 dependencies = { module=all-gold; on=all-intl; };
 dependencies = { module=all-gold; on=all-bfd; };
+dependencies = { module=all-gold; on=all-opcodes; };
 dependencies = { module=all-gold; on=all-build-bison; };
 dependencies = { module=all-gold; on=all-gas; };
 dependencies = { module=check-gold; on=all-binutils; };
diff -rupN binutils-2.29.1.orig/Makefile.in binutils-2.29.1/Makefile.in
--- binutils-2.29.1.orig/Makefile.in	2017-09-19 16:06:38.000000000 +0200
+++ binutils-2.29.1/Makefile.in	2017-10-06 18:33:27.692717345 +0200
@@ -49964,6 +49964,14 @@ all-stage3-gold: maybe-all-stage3-bfd
 all-stage4-gold: maybe-all-stage4-bfd
 all-stageprofile-gold: maybe-all-stageprofile-bfd
 all-stagefeedback-gold: maybe-all-stagefeedback-bfd
+all-gold: maybe-all-opcodes
+
+all-stage1-gold: maybe-all-stage1-opcodes
+all-stage2-gold: maybe-all-stage2-opcodes
+all-stage3-gold: maybe-all-stage3-opcodes
+all-stage4-gold: maybe-all-stage4-opcodes
+all-stageprofile-gold: maybe-all-stageprofile-opcodes
+all-stagefeedback-gold: maybe-all-stagefeedback-opcodes
 all-gold: maybe-all-build-bison
 
 all-stage1-gold: maybe-all-build-bison
diff -rupN binutils-2.29.1.orig/bfd/ChangeLog binutils-2.29.1/bfd/ChangeLog
--- binutils-2.29.1.orig/bfd/ChangeLog	2017-09-19 16:00:20.000000000 +0200
+++ binutils-2.29.1/bfd/ChangeLog	2017-10-06 18:32:40.480718372 +0200
@@ -1,3 +1,31 @@
+2017-09-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/22199
+	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Don't pass
+	output_bfd to info->callbacks->minfo.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22170
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Guard against
+	corrupted PLT.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22163
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Also return -1
+	if bfd_canonicalize_dynamic_reloc returns 0.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-21  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Revert previous delta.
+
+2017-09-20  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Set to false.
+
 2017-09-19  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff -rupN binutils-2.29.1.orig/bfd/aout-target.h binutils-2.29.1/bfd/aout-target.h
--- binutils-2.29.1.orig/bfd/aout-target.h	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/bfd/aout-target.h	2017-10-06 18:33:53.360716787 +0200
@@ -634,6 +634,10 @@ MY_close_and_cleanup (bfd *abfd)
 #define AR_PAD_CHAR ' '
 #endif
 
+#ifndef MY_match_priority
+#define MY_match_priority 0
+#endif
+
 #ifndef MY_BFD_TARGET
 const bfd_target MY (vec) =
 {
@@ -653,7 +657,7 @@ const bfd_target MY (vec) =
   MY_symbol_leading_char,
   AR_PAD_CHAR,			/* AR_pad_char.  */
   15,				/* AR_max_namelen.  */
-  0,				/* match priority.  */
+  MY_match_priority,				/* match priority.  */
 #ifdef TARGET_IS_BIG_ENDIAN_P
   bfd_getb64, bfd_getb_signed_64, bfd_putb64,
      bfd_getb32, bfd_getb_signed_32, bfd_putb32,
diff -rupN binutils-2.29.1.orig/bfd/bfd-in.h binutils-2.29.1/bfd/bfd-in.h
--- binutils-2.29.1.orig/bfd/bfd-in.h	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/bfd/bfd-in.h	2017-10-06 18:33:31.568717261 +0200
@@ -23,11 +23,6 @@
 #ifndef __BFD_H_SEEN__
 #define __BFD_H_SEEN__
 
-/* PR 14072: Ensure that config.h is included first.  */
-#if !defined PACKAGE && !defined PACKAGE_VERSION
-#error config.h must be included before this header
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -rupN binutils-2.29.1.orig/bfd/elf32-avr.c binutils-2.29.1/bfd/elf32-avr.c
--- binutils-2.29.1.orig/bfd/elf32-avr.c	2017-09-05 15:12:46.000000000 +0200
+++ binutils-2.29.1/bfd/elf32-avr.c	2017-10-06 18:33:44.512716979 +0200
@@ -4248,6 +4248,8 @@ avr_elf32_property_record_name (struct a
 #define elf_backend_final_write_processing \
 					bfd_elf_avr_final_write_processing
 #define elf_backend_object_p		elf32_avr_object_p
+#define elf_backend_omit_section_dynsym \
+  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
 
 #define bfd_elf32_bfd_relax_section elf32_avr_relax_section
 #define bfd_elf32_bfd_get_relocated_section_contents \
diff -rupN binutils-2.29.1.orig/bfd/elf32-i386.c binutils-2.29.1/bfd/elf32-i386.c
--- binutils-2.29.1.orig/bfd/elf32-i386.c	2017-09-19 09:11:58.000000000 +0200
+++ binutils-2.29.1/bfd/elf32-i386.c	2017-10-06 18:32:40.480718372 +0200
@@ -6342,7 +6342,7 @@ elf_i386_get_synthetic_symtab (bfd *abfd
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */
@@ -6616,6 +6616,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8;
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff -rupN binutils-2.29.1.orig/bfd/elf32-s390.c binutils-2.29.1/bfd/elf32-s390.c
--- binutils-2.29.1.orig/bfd/elf32-s390.c	2017-08-02 08:54:42.000000000 +0200
+++ binutils-2.29.1/bfd/elf32-s390.c	2017-10-06 18:33:20.424717503 +0200
@@ -2746,6 +2746,27 @@ elf_s390_relocate_section (bfd *output_b
 	case R_390_PC24DBL:
 	case R_390_PC32DBL:
 	case R_390_PC32:
+	  /* This is strictly required only for PC32DBL, which
+	     is not handled by ld.so, but let's be helpful to the user also
+	     in the other cases.  */
+	  if (bfd_link_pic (info)
+	      && !SYMBOL_REFERENCES_LOCAL (info, h)
+	      && (input_section->flags & SEC_ALLOC) != 0
+	      && (input_section->flags & SEC_READONLY) != 0
+	      && (!h->def_regular
+		  || r_type != R_390_PC32DBL
+		  || h->type != STT_FUNC
+		  || ELF_ST_VISIBILITY (h->other) != STV_PROTECTED))
+	    {
+	      (*_bfd_error_handler)
+		  (_("%B: relocation %s against `%s' can not be used when "
+		     "making a shared object; recompile with -fPIC"),
+		   input_bfd, elf_howto_table[r_type].name,
+		   h->root.root.string);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+	    }
+
 	  if (h != NULL
 	      && s390_is_ifunc_symbol_p (h)
 	      && h->def_regular
diff -rupN binutils-2.29.1.orig/bfd/elf64-x86-64.c binutils-2.29.1/bfd/elf64-x86-64.c
--- binutils-2.29.1.orig/bfd/elf64-x86-64.c	2017-09-19 09:11:58.000000000 +0200
+++ binutils-2.29.1/bfd/elf64-x86-64.c	2017-10-06 18:32:40.484718372 +0200
@@ -6133,7 +6133,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *o
 	      if (SYMBOL_REFERENCES_LOCAL (info, h))
 		{
 		  info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
-					  output_bfd,
 					  h->root.root.string,
 					  h->root.u.def.section->owner);
 
@@ -6717,7 +6716,7 @@ elf_x86_64_get_synthetic_symtab (bfd *ab
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */
@@ -6970,6 +6969,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8 + 8 * ABI_64_P (abfd);
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff -rupN binutils-2.29.1.orig/bfd/elfnn-aarch64.c binutils-2.29.1/bfd/elfnn-aarch64.c
--- binutils-2.29.1.orig/bfd/elfnn-aarch64.c	2017-09-05 15:12:46.000000000 +0200
+++ binutils-2.29.1/bfd/elfnn-aarch64.c	2017-10-06 18:33:35.856717167 +0200
@@ -9428,7 +9428,7 @@ const struct elf_size_info elfNN_aarch64
 #define ELF_MACHINE_CODE		EM_AARCH64
 #define ELF_MAXPAGESIZE			0x10000
 #define ELF_MINPAGESIZE			0x1000
-#define ELF_COMMONPAGESIZE		0x1000
+#define ELF_COMMONPAGESIZE		0x10000
 
 #define bfd_elfNN_close_and_cleanup             \
   elfNN_aarch64_close_and_cleanup
diff -rupN binutils-2.29.1.orig/bfd/sunos.c binutils-2.29.1/bfd/sunos.c
--- binutils-2.29.1.orig/bfd/sunos.c	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/bfd/sunos.c	2017-10-06 18:33:53.360716787 +0200
@@ -67,6 +67,8 @@ static long        sunos_get_dynamic_rel
 static long        sunos_canonicalize_dynamic_reloc     (bfd *, arelent **, asymbol **);
 
 /* Include the usual a.out support.  */
+#define MY_match_priority 1
+
 #include "aoutf1.h"
 
 /* The SunOS 4.1.4 /usr/include/locale.h defines valid as a macro.  */
diff -rupN binutils-2.29.1.orig/bfd/version.h binutils-2.29.1/bfd/version.h
--- binutils-2.29.1.orig/bfd/version.h	2017-09-19 09:11:58.000000000 +0200
+++ binutils-2.29.1/bfd/version.h	2017-10-06 18:32:40.484718372 +0200
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20170919
+#define BFD_VERSION_DATE 20170928
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff -rupN binutils-2.29.1.orig/binutils/ChangeLog binutils-2.29.1/binutils/ChangeLog
--- binutils-2.29.1.orig/binutils/ChangeLog	2017-09-15 13:51:38.000000000 +0200
+++ binutils-2.29.1/binutils/ChangeLog	2017-10-06 18:32:40.484718372 +0200
@@ -1,3 +1,7 @@
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* readelf.c (get_machine_flags) <E_MIPS_MACH_5900>: New case.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff -rupN binutils-2.29.1.orig/binutils/readelf.c binutils-2.29.1/binutils/readelf.c
--- binutils-2.29.1.orig/binutils/readelf.c	2017-09-05 16:03:15.000000000 +0200
+++ binutils-2.29.1/binutils/readelf.c	2017-10-06 18:32:40.484718372 +0200
@@ -3325,6 +3325,7 @@ get_machine_flags (unsigned e_flags, uns
 	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
 	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
 	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
+	    case E_MIPS_MACH_5900: strcat (buf, ", 5900"); break;
 	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
 	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
   	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
diff -rupN binutils-2.29.1.orig/binutils/size.c binutils-2.29.1/binutils/size.c
--- binutils-2.29.1.orig/binutils/size.c	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/binutils/size.c	2017-10-06 18:33:48.264716897 +0200
@@ -34,10 +34,31 @@
 #include "getopt.h"
 #include "bucomm.h"
 
-#ifndef BSD_DEFAULT
-#define BSD_DEFAULT 1
+typedef enum
+{
+    format_sysv = 0,
+    format_bsd = 1,
+    format_avr = 2,
+} format_type_t;
+
+
+/* Set the default format. */
+#define FORMAT_DEFAULT_SYSV 0
+#define FORMAT_DEFAULT_BSD 1
+#define FORMAT_DEFAULT_AVR 0
+
+#if FORMAT_DEFAULT_SYSV
+    #define FORMAT_DEFAULT format_sysv
+    #define FORMAT_NAME "sysv"
+#elif FORMAT_DEFAULT_BSD
+    #define FORMAT_DEFAULT format_bsd
+    #define FORMAT_NAME "berkeley"
+#elif FORMAT_DEFAULT_AVR
+    #define FORMAT_DEFAULT format_avr
+    #define FORMAT_NAME "avr"
 #endif
 
+
 /* Program options.  */
 
 static enum
@@ -46,9 +67,8 @@ static enum
   }
 radix = decimal;
 
-/* 0 means use AT&T-style output.  */
-static int berkeley_format = BSD_DEFAULT;
 
+format_type_t format = FORMAT_DEFAULT;
 static int show_version = 0;
 static int show_help = 0;
 static int show_totals = 0;
@@ -62,6 +82,246 @@ static bfd_size_type total_textsize;
 /* Program exit status.  */
 static int return_code = 0;
 
+
+/* AVR Size specific stuff */
+
+#define AVR64 64UL
+#define AVR128 128UL
+#define AVR256 256UL
+#define AVR512 512UL
+#define AVR1K 1024UL
+#define AVR2K 2048UL
+#define AVR4K 4096UL
+#define AVR8K 8192UL
+#define AVR16K 16384UL
+#define AVR20K 20480UL
+#define AVR24K 24576UL
+#define AVR32K 32768UL
+#define AVR36K 36864UL
+#define AVR40K 40960UL
+#define AVR64K 65536UL
+#define AVR68K 69632UL
+#define AVR128K 131072UL
+#define AVR136K 139264UL
+#define AVR200K 204800UL
+#define AVR256K 262144UL
+#define AVR264K 270336UL
+
+typedef struct
+{
+    char *name;
+	long flash;
+	long ram;
+	long eeprom;
+} avr_device_t;
+
+avr_device_t avr[] =
+{
+	{"atxmega256a3",  AVR264K, AVR16K, AVR4K},
+	{"atxmega256a3b", AVR264K, AVR16K, AVR4K},
+	{"atxmega256d3",  AVR264K, AVR16K, AVR4K},
+
+	{"atmega2560",    AVR256K, AVR8K,  AVR4K},
+	{"atmega2561",    AVR256K, AVR8K,  AVR4K},
+
+	{"atxmega192a3",  AVR200K, AVR16K, AVR2K},
+	{"atxmega192d3",  AVR200K, AVR16K, AVR2K},
+
+	{"atxmega128a1",  AVR136K, AVR8K,  AVR2K},
+	{"atxmega128a1u", AVR136K, AVR8K,  AVR2K},
+	{"atxmega128a3",  AVR136K, AVR8K,  AVR2K},
+	{"atxmega128d3",  AVR136K, AVR8K,  AVR2K},
+
+	{"at43usb320",    AVR128K, 608UL,  0UL},
+	{"at90can128",    AVR128K, AVR4K,  AVR4K},
+	{"at90usb1286",   AVR128K, AVR8K,  AVR4K},
+	{"at90usb1287",   AVR128K, AVR8K,  AVR4K},
+	{"atmega128",     AVR128K, AVR4K,  AVR4K},
+	{"atmega1280",    AVR128K, AVR8K,  AVR4K},
+	{"atmega1281",    AVR128K, AVR8K,  AVR4K},
+	{"atmega1284p",   AVR128K, AVR16K, AVR4K},
+	{"atmega128rfa1", AVR128K, AVR16K, AVR4K},
+	{"atmega103",     AVR128K, 4000UL, AVR4K},
+
+	{"atxmega64a1",   AVR68K,  AVR4K,  AVR2K},
+	{"atxmega64a1u",  AVR68K,  AVR4K,  AVR2K},
+	{"atxmega64a3",   AVR68K,  AVR4K,  AVR2K},
+	{"atxmega64d3",   AVR68K,  AVR4K,  AVR2K},
+
+	{"at90can64",     AVR64K,  AVR4K,  AVR2K},
+	{"at90scr100",    AVR64K,  AVR4K,  AVR2K},
+	{"at90usb646",    AVR64K,  AVR4K,  AVR2K},
+	{"at90usb647",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega64",      AVR64K,  AVR4K,  AVR2K},
+	{"atmega640",     AVR64K,  AVR8K,  AVR4K},
+	{"atmega644",     AVR64K,  AVR4K,  AVR2K},
+	{"atmega644a",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega644p",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega644pa",   AVR64K,  AVR4K,  AVR2K},
+	{"atmega645",     AVR64K,  AVR4K,  AVR2K},
+	{"atmega645a",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega645p",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega6450",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega6450a",   AVR64K,  AVR4K,  AVR2K},
+	{"atmega6450p",   AVR64K,  AVR4K,  AVR2K},
+	{"atmega649",     AVR64K,  AVR4K,  AVR2K},
+	{"atmega649a",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega649p",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega6490",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega6490a",   AVR64K,  AVR4K,  AVR2K},
+	{"atmega6490p",   AVR64K,  AVR4K,  AVR2K},
+	{"atmega64c1",    AVR64K,  AVR4K,  AVR2K},
+	{"atmega64hve",   AVR64K,  AVR4K,  AVR1K},
+	{"atmega64m1",    AVR64K,  AVR4K,  AVR2K},
+   {"m3000",         AVR64K,  AVR4K,  0UL},
+
+	{"atmega406",     AVR40K,  AVR2K,  AVR512},
+
+	{"atxmega32a4",   AVR36K,  AVR4K,  AVR1K},
+	{"atxmega32d4",   AVR36K,  AVR4K,  AVR1K},
+
+	{"at90can32",     AVR32K,  AVR2K,  AVR1K},
+	{"at94k",         AVR32K,  AVR4K,  0UL},
+	{"atmega32",      AVR32K,  AVR2K,  AVR1K},
+	{"atmega323",     AVR32K,  AVR2K,  AVR1K},
+	{"atmega324a",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega324p",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega324pa",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega325",     AVR32K,  AVR2K,  AVR1K},
+	{"atmega325a",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega325p",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega3250",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega3250a",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega3250p",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega328",     AVR32K,  AVR2K,  AVR1K},
+	{"atmega328p",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega329",     AVR32K,  AVR2K,  AVR1K},
+	{"atmega329a",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega329p",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega329pa",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega3290",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega3290a",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega3290p",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega32hvb",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega32c1",    AVR32K,  AVR2K,  AVR1K},
+   {"atmega32hvb",   AVR32K,  AVR2K,  AVR1K},
+	{"atmega32m1",    AVR32K,  AVR2K,  AVR1K},
+	{"atmega32u2",    AVR32K,  AVR1K,  AVR1K},
+	{"atmega32u4",    AVR32K,  2560UL, AVR1K},
+	{"atmega32u6",    AVR32K,  2560UL, AVR1K},
+
+	{"at43usb355",    AVR24K,  1120UL,   0UL},
+
+	{"atxmega16a4",   AVR20K,  AVR2K,  AVR1K},
+	{"atxmega16d4",   AVR20K,  AVR2K,  AVR1K},
+
+	{"at76c711",      AVR16K,  AVR2K,  0UL},
+	{"at90pwm216",    AVR16K,  AVR1K,  AVR512},
+	{"at90pwm316",    AVR16K,  AVR1K,  AVR512},
+	{"at90usb162",    AVR16K,  AVR512, AVR512},
+	{"atmega16",      AVR16K,  AVR1K,  AVR512},
+	{"atmega16a",     AVR16K,  AVR1K,  AVR512},
+	{"atmega161",     AVR16K,  AVR1K,  AVR512},
+	{"atmega162",     AVR16K,  AVR1K,  AVR512},
+	{"atmega163",     AVR16K,  AVR1K,  AVR512},
+	{"atmega164",     AVR16K,  AVR1K,  AVR512},
+	{"atmega164a",    AVR16K,  AVR1K,  AVR512},
+	{"atmega164p",    AVR16K,  AVR1K,  AVR512},
+	{"atmega165a",    AVR16K,  AVR1K,  AVR512},
+	{"atmega165",     AVR16K,  AVR1K,  AVR512},
+	{"atmega165p",    AVR16K,  AVR1K,  AVR512},
+	{"atmega168",     AVR16K,  AVR1K,  AVR512},
+	{"atmega168a",    AVR16K,  AVR1K,  AVR512},
+	{"atmega168p",    AVR16K,  AVR1K,  AVR512},
+	{"atmega169",     AVR16K,  AVR1K,  AVR512},
+	{"atmega169a",    AVR16K,  AVR1K,  AVR512},
+	{"atmega169p",    AVR16K,  AVR1K,  AVR512},
+	{"atmega169pa",   AVR16K,  AVR1K,  AVR512},
+	{"atmega16hva",   AVR16K,  768UL,  AVR256},
+	{"atmega16hva2",  AVR16K,  AVR1K,  AVR256},
+   {"atmega16hvb",   AVR16K,  AVR1K,  AVR512},
+	{"atmega16m1",    AVR16K,  AVR1K,  AVR512},
+	{"atmega16u2",    AVR16K,  AVR512, AVR512},
+	{"atmega16u4",    AVR16K,  1280UL, AVR512},
+	{"attiny167",     AVR16K,  AVR512, AVR512},
+
+	{"at90c8534",     AVR8K,   352UL,  AVR512},
+	{"at90pwm1",      AVR8K,   AVR512, AVR512},
+	{"at90pwm2",      AVR8K,   AVR512, AVR512},
+	{"at90pwm2b",     AVR8K,   AVR512, AVR512},
+	{"at90pwm3",      AVR8K,   AVR512, AVR512},
+	{"at90pwm3b",     AVR8K,   AVR512, AVR512},
+	{"at90pwm81",     AVR8K,   AVR256, AVR512},
+	{"at90s8515",     AVR8K,   AVR512, AVR512},
+	{"at90s8535",     AVR8K,   AVR512, AVR512},
+	{"at90usb82",     AVR8K,   AVR512, AVR512},
+	{"ata6289",       AVR8K,   AVR512, 320UL},
+	{"atmega8",       AVR8K,   AVR1K,  AVR512},
+	{"atmega8515",    AVR8K,   AVR512, AVR512},
+	{"atmega8535",    AVR8K,   AVR512, AVR512},
+	{"atmega88",      AVR8K,   AVR1K,  AVR512},
+	{"atmega88a",     AVR8K,   AVR1K,  AVR512},
+	{"atmega88p",     AVR8K,   AVR1K,  AVR512},
+	{"atmega88pa",    AVR8K,   AVR1K,  AVR512},
+	{"atmega8hva",    AVR8K,   768UL,  AVR256},
+	{"atmega8u2",     AVR8K,   AVR512, AVR512},
+	{"attiny84",      AVR8K,   AVR512, AVR512},
+	{"attiny84a",     AVR8K,   AVR512, AVR512},
+	{"attiny85",      AVR8K,   AVR512, AVR512},
+	{"attiny861",     AVR8K,   AVR512, AVR512},
+	{"attiny861a",    AVR8K,   AVR512, AVR512},
+	{"attiny87",      AVR8K,   AVR512, AVR512},
+	{"attiny88",      AVR8K,   AVR512, AVR64},
+
+	{"at90s4414",     AVR4K,   352UL,  AVR256},
+	{"at90s4433",     AVR4K,   AVR128, AVR256},
+	{"at90s4434",     AVR4K,   352UL,  AVR256},
+	{"atmega48",      AVR4K,   AVR512, AVR256},
+	{"atmega48a",     AVR4K,   AVR512, AVR256},
+	{"atmega48p",     AVR4K,   AVR512, AVR256},
+	{"attiny4313",    AVR4K,   AVR256, AVR256},
+	{"attiny43u",     AVR4K,   AVR256, AVR64},
+	{"attiny44",      AVR4K,   AVR256, AVR256},
+	{"attiny44a",     AVR4K,   AVR256, AVR256},
+	{"attiny45",      AVR4K,   AVR256, AVR256},
+	{"attiny461",     AVR4K,   AVR256, AVR256},
+	{"attiny461a",    AVR4K,   AVR256, AVR256},
+	{"attiny48",      AVR4K,   AVR256, AVR64},
+
+	{"at86rf401",     AVR2K,   224UL,  AVR128},
+	{"at90s2313",     AVR2K,   AVR128, AVR128},
+	{"at90s2323",     AVR2K,   AVR128, AVR128},
+	{"at90s2333",     AVR2K,   224UL,  AVR128},
+	{"at90s2343",     AVR2K,   AVR128, AVR128},
+   {"attiny20",      AVR2K,   AVR128, 0UL},
+	{"attiny22",      AVR2K,   224UL,  AVR128},
+	{"attiny2313",    AVR2K,   AVR128, AVR128},
+	{"attiny2313a",   AVR2K,   AVR128, AVR128},
+	{"attiny24",      AVR2K,   AVR128, AVR128},
+	{"attiny24a",     AVR2K,   AVR128, AVR128},
+	{"attiny25",      AVR2K,   AVR128, AVR128},
+	{"attiny26",      AVR2K,   AVR128, AVR128},
+	{"attiny261",     AVR2K,   AVR128, AVR128},
+	{"attiny261a",    AVR2K,   AVR128, AVR128},
+	{"attiny28",      AVR2K,   0UL,    0UL},
+   {"attiny40",      AVR2K,   AVR256, 0UL},
+
+	{"at90s1200",     AVR1K,   0UL,    AVR64},
+   {"attiny9",       AVR1K,   32UL,   0UL},
+   {"attiny10",      AVR1K,   32UL,   0UL},
+	{"attiny11",      AVR1K,   0UL,    AVR64},
+	{"attiny12",      AVR1K,   0UL,    AVR64},
+	{"attiny13",      AVR1K,   AVR64,  AVR64},
+	{"attiny13a",     AVR1K,   AVR64,  AVR64},
+	{"attiny15",      AVR1K,   0UL,    AVR64},
+
+   {"attiny4",       AVR512,  32UL,   0UL},
+   {"attiny5",       AVR512,  32UL,   0UL},
+};
+
+static char *avrmcu = NULL;
+
+
 static char *target = NULL;
 
 /* Forward declarations.  */
@@ -77,7 +337,8 @@ usage (FILE *stream, int status)
   fprintf (stream, _(" Displays the sizes of sections inside binary files\n"));
   fprintf (stream, _(" If no input file(s) are specified, a.out is assumed\n"));
   fprintf (stream, _(" The options are:\n\
-  -A|-B     --format={sysv|berkeley}  Select output style (default is %s)\n\
+  -A|-B|-C  --format={sysv|berkeley|avr}  Select output style (default is %s)\n\
+            --mcu=<avrmcu>            MCU name for AVR format only\n\
   -o|-d|-x  --radix={8|10|16}         Display numbers in octal, decimal or hex\n\
   -t        --totals                  Display the total sizes (Berkeley only)\n\
             --common                  Display total size for *COM* syms\n\
@@ -86,11 +347,7 @@ usage (FILE *stream, int status)
   -h        --help                    Display this information\n\
   -v        --version                 Display the program's version\n\
 \n"),
-#if BSD_DEFAULT
-  "berkeley"
-#else
-  "sysv"
-#endif
+FORMAT_NAME
 );
   list_supported_targets (program_name, stream);
   if (REPORT_BUGS_TO[0] && status == 0)
@@ -101,6 +358,7 @@ usage (FILE *stream, int status)
 #define OPTION_FORMAT (200)
 #define OPTION_RADIX (OPTION_FORMAT + 1)
 #define OPTION_TARGET (OPTION_RADIX + 1)
+#define OPTION_MCU (OPTION_TARGET + 1) 
 
 static struct option long_options[] =
 {
@@ -108,6 +366,7 @@ static struct option long_options[] =
   {"format", required_argument, 0, OPTION_FORMAT},
   {"radix", required_argument, 0, OPTION_RADIX},
   {"target", required_argument, 0, OPTION_TARGET},
+  {"mcu", required_argument, 0, 203},
   {"totals", no_argument, &show_totals, 1},
   {"version", no_argument, &show_version, 1},
   {"help", no_argument, &show_help, 1},
@@ -140,7 +399,7 @@ main (int argc, char **argv)
   bfd_init ();
   set_default_bfd_target ();
 
-  while ((c = getopt_long (argc, argv, "ABHhVvdfotx", long_options,
+  while ((c = getopt_long (argc, argv, "ABCHhVvdfotx", long_options,
 			   (int *) 0)) != EOF)
     switch (c)
       {
@@ -149,11 +408,15 @@ main (int argc, char **argv)
 	  {
 	  case 'B':
 	  case 'b':
-	    berkeley_format = 1;
+	    format = format_bsd;
 	    break;
 	  case 'S':
 	  case 's':
-	    berkeley_format = 0;
+	    format = format_sysv;
+	    break;
+	  case 'A':
+	  case 'a':
+	    format = format_avr;
 	    break;
 	  default:
 	    non_fatal (_("invalid argument to --format: %s"), optarg);
@@ -161,6 +424,10 @@ main (int argc, char **argv)
 	  }
 	break;
 
+      case OPTION_MCU:
+	avrmcu = optarg;
+	break;
+
       case OPTION_TARGET:
 	target = optarg;
 	break;
@@ -189,11 +456,14 @@ main (int argc, char **argv)
 	break;
 
       case 'A':
-	berkeley_format = 0;
+	format = format_sysv;
 	break;
       case 'B':
-	berkeley_format = 1;
+	format = format_bsd;
 	break;
+      case 'C':
+    format = format_avr;
+    break;
       case 'v':
       case 'V':
 	show_version = 1;
@@ -239,7 +509,7 @@ main (int argc, char **argv)
     for (; optind < argc;)
       display_file (argv[optind++]);
 
-  if (show_totals && berkeley_format)
+  if (show_totals && format == format_bsd)
     {
       bfd_size_type total = total_textsize + total_datasize + total_bsssize;
 
@@ -605,13 +875,117 @@ print_sysv_format (bfd *file)
   printf ("\n\n");
 }
 
+
+static avr_device_t *
+avr_find_device (void)
+{
+  unsigned int i;
+  if (avrmcu != NULL)
+  {
+    for (i = 0; i < sizeof(avr) / sizeof(avr[0]); i++)
+    {
+      if (strcmp(avr[i].name, avrmcu) == 0)
+      {
+        /* Match found */
+        return (&avr[i]);
+      }
+    }
+  }
+  return (NULL);
+}
+
+
+
+static void
+print_avr_format (bfd *file)
+{
+  char *avr_name = "Unknown";
+  int flashmax = 0;
+  int rammax = 0;
+  int eeprommax = 0;
+  asection *section; 
+  bfd_size_type datasize = 0;
+  bfd_size_type textsize = 0;
+  bfd_size_type bsssize = 0;
+  bfd_size_type bootloadersize = 0;
+  bfd_size_type noinitsize = 0;
+  bfd_size_type eepromsize = 0;
+
+  avr_device_t *avrdevice = avr_find_device();
+  if (avrdevice != NULL)
+  {
+    avr_name = avrdevice->name;
+    flashmax = avrdevice->flash;
+    rammax = avrdevice->ram;
+    eeprommax = avrdevice->eeprom;
+  }
+
+  if ((section = bfd_get_section_by_name (file, ".data")) != NULL)
+    datasize = bfd_section_size (file, section);
+  if ((section = bfd_get_section_by_name (file, ".text")) != NULL)
+    textsize = bfd_section_size (file, section);
+  if ((section = bfd_get_section_by_name (file, ".bss")) != NULL)
+    bsssize = bfd_section_size (file, section);
+  if ((section = bfd_get_section_by_name (file, ".bootloader")) != NULL)
+    bootloadersize = bfd_section_size (file, section);
+  if ((section = bfd_get_section_by_name (file, ".noinit")) != NULL)
+    noinitsize = bfd_section_size (file, section);
+  if ((section = bfd_get_section_by_name (file, ".eeprom")) != NULL)
+    eepromsize = bfd_section_size (file, section);
+  
+  bfd_size_type text = textsize + datasize + bootloadersize;
+  bfd_size_type data = datasize + bsssize + noinitsize;
+  bfd_size_type eeprom = eepromsize;
+  
+  printf ("AVR Memory Usage\n"
+          "----------------\n"
+          "Device: %s\n\n", avr_name);
+  
+  /* Text size */
+  printf ("Program:%8ld bytes", text);
+  if (flashmax > 0)
+  {
+    printf (" (%2.1f%% Full)", ((float)text / flashmax) * 100);
+  }
+  printf ("\n(.text + .data + .bootloader)\n\n");
+  
+  /* Data size */
+  printf ("Data:   %8ld bytes", data);
+  if (rammax > 0)
+  {
+    printf (" (%2.1f%% Full)", ((float)data / rammax) * 100);
+  }
+  printf ("\n(.data + .bss + .noinit)\n\n");
+  
+  /* EEPROM size */
+  if (eeprom > 0) 
+  { 
+    printf ("EEPROM: %8ld bytes", eeprom);
+    if (eeprommax > 0)
+    {
+      printf (" (%2.1f%% Full)", ((float)eeprom / eeprommax) * 100);
+    }
+    printf ("\n(.eeprom)\n\n");
+  }
+}
+
+
 static void
 print_sizes (bfd *file)
 {
   if (show_common)
     calculate_common_size (file);
-  if (berkeley_format)
-    print_berkeley_format (file);
-  else
-    print_sysv_format (file);
+  switch (format)
+  {
+    case format_sysv:
+      print_sysv_format (file);
+      break;
+    case format_bsd:
+      print_berkeley_format (file);
+      break;
+    case format_avr:
+    default:
+      print_avr_format (file);
+      break;
+  }
 }
diff -rupN binutils-2.29.1.orig/binutils/testsuite/binutils-all/windres/windres.exp binutils-2.29.1/binutils/testsuite/binutils-all/windres/windres.exp
--- binutils-2.29.1.orig/binutils/testsuite/binutils-all/windres/windres.exp	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/binutils/testsuite/binutils-all/windres/windres.exp	2017-10-06 18:33:08.360717766 +0200
@@ -39,6 +39,7 @@ set wr "$WINDRES --include-dir $srcdir/$
 if [file exists "$srcdir/../../winsup/w32api/include"] {
     set wr "$wr --include-dir $srcdir/../../winsup/w32api/include"
 } else {
+    return
     send_log "\nWarning: Assuming windres can find the win32 headers\n\n"
 }
 
diff -rupN binutils-2.29.1.orig/gas/ChangeLog binutils-2.29.1/gas/ChangeLog
--- binutils-2.29.1.orig/gas/ChangeLog	2017-09-15 13:52:40.000000000 +0200
+++ binutils-2.29.1/gas/ChangeLog	2017-10-06 18:32:40.484718372 +0200
@@ -1,3 +1,8 @@
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* testsuite/gas/mips/elf_mach_5900.d: New test.
+	* testsuite/gas/mips/mips.exp: Run it.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff -rupN binutils-2.29.1.orig/gas/config/tc-avr-nesc.h binutils-2.29.1/gas/config/tc-avr-nesc.h
--- binutils-2.29.1.orig/gas/config/tc-avr-nesc.h	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.29.1/gas/config/tc-avr-nesc.h	2017-10-06 18:33:39.552717087 +0200
@@ -0,0 +1,248 @@
+/* This file is tc-avr.h
+   Copyright (C) 1999-2017 Free Software Foundation, Inc.
+
+   Contributed by Denis Chertykov <denisc@overta.ru>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* By convention, you should define this macro in the `.h' file.  For
+   example, `tc-m68k.h' defines `TC_M68K'.  You might have to use this
+   if it is necessary to add CPU specific code to the object format
+   file.  */
+#define TC_AVR
+
+/* This macro is the BFD target name to use when creating the output
+   file.  This will normally depend upon the `OBJ_FMT' macro.  */
+#define TARGET_FORMAT "elf32-avr"
+
+/* This macro is the BFD architecture to pass to `bfd_set_arch_mach'.  */
+#define TARGET_ARCH bfd_arch_avr
+
+/* This macro is the BFD machine number to pass to
+   `bfd_set_arch_mach'.  If it is not defined, GAS will use 0.  */
+#define TARGET_MACH 0
+
+/* You should define this macro to be non-zero if the target is big
+   endian, and zero if the target is little endian.  */
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+/* If you define this macro, GAS will warn about the use of
+   nonstandard escape sequences in a string.  */
+#define ONLY_STANDARD_ESCAPES
+
+#define DIFF_EXPR_OK    /* .-foo gets turned into PC relative relocs */
+
+/* GAS will call this function for any expression that can not be
+   recognized.  When the function is called, `input_line_pointer'
+   will point to the start of the expression.  */
+#define md_operand(x)
+
+typedef struct
+{
+  /* Name of the expression modifier allowed with .byte, .word, etc.  */
+  const char *name;
+
+  /* Only allowed with n bytes of data.  */
+  int nbytes;
+
+  /* Associated RELOC.  */
+  bfd_reloc_code_real_type reloc;
+
+  /* Part of the error message.  */
+  const char *error;
+} exp_mod_data_t;
+
+extern const exp_mod_data_t exp_mod_data[];
+#define TC_PARSE_CONS_RETURN_TYPE const exp_mod_data_t *
+#define TC_PARSE_CONS_RETURN_NONE exp_mod_data
+
+/* You may define this macro to parse an expression used in a data
+   allocation pseudo-op such as `.word'.  You can use this to
+   recognize relocation directives that may appear in such directives.  */
+#define TC_PARSE_CONS_EXPRESSION(EXPR,N) avr_parse_cons_expression (EXPR, N)
+extern const exp_mod_data_t *avr_parse_cons_expression (expressionS *, int);
+
+/* You may define this macro to generate a fixup for a data
+   allocation pseudo-op.  */
+#define TC_CONS_FIX_NEW avr_cons_fix_new
+extern void avr_cons_fix_new (fragS *,int, int, expressionS *,
+			      const exp_mod_data_t *);
+
+/* This should just call either `number_to_chars_bigendian' or
+   `number_to_chars_littleendian', whichever is appropriate.  On
+   targets like the MIPS which support options to change the
+   endianness, which function to call is a runtime decision.  On
+   other targets, `md_number_to_chars' can be a simple macro.  */
+#define md_number_to_chars number_to_chars_littleendian
+
+/* `md_short_jump_size'
+   `md_long_jump_size'
+   `md_create_short_jump'
+   `md_create_long_jump'
+   If `WORKING_DOT_WORD' is defined, GAS will not do broken word
+   processing (*note Broken words::.).  Otherwise, you should set
+   `md_short_jump_size' to the size of a short jump (a jump that is
+   just long enough to jump around a long jmp) and
+   `md_long_jump_size' to the size of a long jump (a jump that can go
+   anywhere in the function), You should define
+   `md_create_short_jump' to create a short jump around a long jump,
+   and define `md_create_long_jump' to create a long jump.  */
+#define WORKING_DOT_WORD
+
+/* If you define this macro, it means that `tc_gen_reloc' may return
+   multiple relocation entries for a single fixup.  In this case, the
+   return value of `tc_gen_reloc' is a pointer to a null terminated
+   array.  */
+#undef RELOC_EXPANSION_POSSIBLE
+
+/* No shared lib support, so we don't need to ensure externally
+   visible symbols can be overridden.  */
+#define EXTERN_FORCE_RELOC 0
+
+/* If defined, this macro allows control over whether fixups for a
+   given section will be processed when the linkrelax variable is
+   set. Define it to zero and handle things in md_apply_fix instead.*/
+#define TC_LINKRELAX_FIXUP(SEG) 0
+
+/* If this macro returns non-zero, it guarantees that a relocation will be emitted
+   even when the value can be resolved locally. Do that if linkrelax is turned on */
+#define TC_FORCE_RELOCATION(fix)	avr_force_relocation (fix)
+#define TC_FORCE_RELOCATION_SUB_SAME(fix, seg) \
+  (GENERIC_FORCE_RELOCATION_SUB_SAME (fix, seg)	\
+   || avr_force_relocation (fix))
+extern int avr_force_relocation (struct fix *);
+
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+/* If you define this macro, it should return the offset between the
+   address of a PC relative fixup and the position from which the PC
+   relative adjustment should be made.  On many processors, the base
+   of a PC relative instruction is the next instruction, so this
+   macro would return the length of an instruction.  */
+#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
+extern long md_pcrel_from_section (struct fix *, segT);
+
+/* The number of bytes to put into a word in a listing.  This affects
+   the way the bytes are clumped together in the listing.  For
+   example, a value of 2 might print `1234 5678' where a value of 1
+   would print `12 34 56 78'.  The default value is 4.  */
+#define LISTING_WORD_SIZE 2
+
+/* AVR port uses `$' as a logical line separator and doesn't
+   allow it in symbols. We allow it in the middle of symbols.
+   We also hack get_symbol_end to disallow it at the end of a symbol. */
+#define LEX_DOLLAR 1
+#define TC_EOL_IN_INSN(PTR)   (*(PTR) == '$' && is_part_of_name((PTR)[-1]) && is_part_of_name((PTR)[1]))
+#define TC_FORBID_DOLLAR_AT_END
+
+/* An `.lcomm' directive with no explicit alignment parameter will
+   use this macro to set P2VAR to the alignment that a request for
+   SIZE bytes will have.  The alignment is expressed as a power of
+   two.  If no alignment should take place, the macro definition
+   should do nothing.  Some targets define a `.bss' directive that is
+   also affected by this macro.  The default definition will set
+   P2VAR to the truncated power of two of sizes up to eight bytes.  */
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR) (P2VAR) = 0
+
+/* We don't want gas to fixup the following program memory related relocations.
+   We will need them in case that we want to do linker relaxation.
+   We could in principle keep these fixups in gas when not relaxing.
+   However, there is no serious performance penalty when making the linker
+   make the fixup work.  Check also that fx_addsy is not NULL, in order to make
+   sure that the fixup refers to some sort of label.  */
+#define TC_VALIDATE_FIX(FIXP,SEG,SKIP)                       \
+  if (   (FIXP->fx_r_type == BFD_RELOC_AVR_7_PCREL           \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_13_PCREL          \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_GS        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_GS        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HH8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HH8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_8_LO              \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_8_HI              \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_8_HLO             \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_16_PM)            \
+      && FIXP->fx_addsy != NULL				     \
+      && FIXP->fx_subsy == NULL)			     \
+    {							     \
+      symbol_mark_used_in_reloc (FIXP->fx_addsy);	     \
+      goto SKIP;					     \
+    }
+
+/* This macro is evaluated for any fixup with a fx_subsy that
+   fixup_segment cannot reduce to a number.  If the macro returns
+   false an error will be reported. */
+#define TC_VALIDATE_FIX_SUB(fix, seg)   avr_validate_fix_sub (fix)
+extern int avr_validate_fix_sub (struct fix *);
+
+/* This target is buggy, and sets fix size too large.  */
+#define TC_FX_SIZE_SLACK(FIX) 2
+
+/* AVR instructions are 2 or 4 bytes long.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH 	2
+
+/* 32 bits pseudo-addresses are used on AVR.  */
+#define DWARF2_ADDR_SIZE(bfd) 4
+
+/* Enable cfi directives.  */
+#define TARGET_USE_CFIPOP 1
+
+/* The stack grows down, and is only byte aligned.  */
+#define DWARF2_CIE_DATA_ALIGNMENT -1
+
+/* Define the column that represents the PC.  */
+#define DWARF2_DEFAULT_RETURN_COLUMN  36
+
+/* Define a hook to setup initial CFI state.  */
+extern void tc_cfi_frame_initial_instructions (void);
+#define tc_cfi_frame_initial_instructions tc_cfi_frame_initial_instructions
+
+/* The difference between same-section symbols may be affected by linker
+   relaxation, so do not resolve such expressions in the assembler.  */
+#define md_allow_local_subtract(l,r,s) avr_allow_local_subtract (l, r, s)
+extern bfd_boolean avr_allow_local_subtract (expressionS *, expressionS *, segT);
+
+#define elf_tc_final_processing 	avr_elf_final_processing
+extern void avr_elf_final_processing (void);
+
+#define md_pre_output_hook avr_pre_output_hook ()
+extern void avr_pre_output_hook (void);
+
+#define md_undefined_symbol avr_undefined_symbol
+extern symbolS* avr_undefined_symbol (char*);
+
+#define md_post_relax_hook avr_post_relax_hook ()
+extern void avr_post_relax_hook (void);
+
+#define HANDLE_ALIGN(fragP) avr_handle_align (fragP)
+extern void avr_handle_align (fragS *fragP);
+
+struct avr_frag_data
+{
+  unsigned is_org : 1;
+  unsigned is_align : 1;
+  unsigned has_fill : 1;
+
+  char fill;
+  offsetT alignment;
+};
+#define TC_FRAG_TYPE			struct avr_frag_data
diff -rupN binutils-2.29.1.orig/gas/expr.c binutils-2.29.1/gas/expr.c
--- binutils-2.29.1.orig/gas/expr.c	2017-07-10 11:54:41.000000000 +0200
+++ binutils-2.29.1/gas/expr.c	2017-10-06 18:33:39.552717087 +0200
@@ -2378,6 +2378,15 @@ get_symbol_name (char ** ilp_return)
 	;
       if (is_name_ender (c))
 	c = *input_line_pointer++;
+#ifdef TC_FORBID_DOLLAR_AT_END
+      /* This is for the Atmel AVR platforms. We want to allow $ in symbols
+	 but also as a line separator. Yucky. */
+      if (input_line_pointer[-2] == '$')
+	{
+	  input_line_pointer--;
+	  c = '$';
+	}
+#endif
     }
   else if (c == '"')
     {
diff -rupN binutils-2.29.1.orig/gas/testsuite/gas/mips/elf_mach_5900.d binutils-2.29.1/gas/testsuite/gas/mips/elf_mach_5900.d
--- binutils-2.29.1.orig/gas/testsuite/gas/mips/elf_mach_5900.d	1970-01-01 01:00:00.000000000 +0100
+++ binutils-2.29.1/gas/testsuite/gas/mips/elf_mach_5900.d	2017-10-06 18:32:40.484718372 +0200
@@ -0,0 +1,22 @@
+#readelf: -Ah
+#name: ELF R5900 markings
+#as: -32 -march=r5900
+#source: empty.s
+
+ELF Header:
+#...
+  Flags: +0x..92...., .*5900.*
+#...
+
+MIPS ABI Flags Version: 0
+
+ISA: MIPS3
+GPR size: 32
+CPR1 size: 32
+CPR2 size: 0
+FP ABI: .*
+ISA Extension: Toshiba R5900
+ASEs:
+	None
+FLAGS 1: .*
+FLAGS 2: .*
diff -rupN binutils-2.29.1.orig/gas/testsuite/gas/mips/mips.exp binutils-2.29.1/gas/testsuite/gas/mips/mips.exp
--- binutils-2.29.1.orig/gas/testsuite/gas/mips/mips.exp	2017-08-31 09:05:12.000000000 +0200
+++ binutils-2.29.1/gas/testsuite/gas/mips/mips.exp	2017-10-06 18:32:40.484718372 +0200
@@ -1149,6 +1149,7 @@ if { [istarget mips*-*-vxworks*] } {
     run_dump_test "elf_ase_micromips-2"
 
     # Verify that machine markings are handled properly.
+    run_dump_test "elf_mach_5900"
     run_dump_test "elf_mach_interaptiv-mr2"
 
     run_dump_test "mips-gp32-fp32-pic"
diff -rupN binutils-2.29.1.orig/gold/ChangeLog binutils-2.29.1/gold/ChangeLog
--- binutils-2.29.1.orig/gold/ChangeLog	2017-09-19 15:55:52.000000000 +0200
+++ binutils-2.29.1/gold/ChangeLog	2017-10-06 18:32:40.484718372 +0200
@@ -1,3 +1,14 @@
+2017-08-03  James Clarke  <jrtc27@jrtc27.com>
+
+	* options.h (General_options): Set a non-NULL second help string
+	argument for relax to allow --no-relax.
+
+2017-09-20  Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc::Branch_info::make_stub): Put
+	stubs for ppc32 non-branch relocs in first stub table.
+	(Target_powerpc::Relocate::relocate): Resolve similarly.
+
 2017-09-19  Alan Modra  <amodra@gmail.com>
 
 	* options.h (stub-group-multi): Default to true.  Add
diff -rupN binutils-2.29.1.orig/gold/aarch64.cc binutils-2.29.1/gold/aarch64.cc
--- binutils-2.29.1.orig/gold/aarch64.cc	2017-08-30 09:03:51.000000000 +0200
+++ binutils-2.29.1/gold/aarch64.cc	2017-10-06 18:33:35.860717167 +0200
@@ -3529,7 +3529,7 @@ const Target::Target_info Target_aarch64
   "/lib/ld.so.1",	// program interpreter
   0x400000,		// default_text_segment_address
   0x10000,		// abi_pagesize (overridable by -z max-page-size)
-  0x1000,		// common_pagesize (overridable by -z common-page-size)
+  0x10000,		// common_pagesize (overridable by -z common-page-size)
   false,                // isolate_execinstr
   0,                    // rosegment_gap
   elfcpp::SHN_UNDEF,	// small_common_shndx
@@ -3557,7 +3557,7 @@ const Target::Target_info Target_aarch64
   "/lib/ld.so.1",	// program interpreter
   0x400000,		// default_text_segment_address
   0x10000,		// abi_pagesize (overridable by -z max-page-size)
-  0x1000,		// common_pagesize (overridable by -z common-page-size)
+  0x10000,		// common_pagesize (overridable by -z common-page-size)
   false,                // isolate_execinstr
   0,                    // rosegment_gap
   elfcpp::SHN_UNDEF,	// small_common_shndx
@@ -3585,7 +3585,7 @@ const Target::Target_info Target_aarch64
   "/lib/ld.so.1",	// program interpreter
   0x400000,		// default_text_segment_address
   0x10000,		// abi_pagesize (overridable by -z max-page-size)
-  0x1000,		// common_pagesize (overridable by -z common-page-size)
+  0x10000,		// common_pagesize (overridable by -z common-page-size)
   false,                // isolate_execinstr
   0,                    // rosegment_gap
   elfcpp::SHN_UNDEF,	// small_common_shndx
@@ -3613,7 +3613,7 @@ const Target::Target_info Target_aarch64
   "/lib/ld.so.1",	// program interpreter
   0x400000,		// default_text_segment_address
   0x10000,		// abi_pagesize (overridable by -z max-page-size)
-  0x1000,		// common_pagesize (overridable by -z common-page-size)
+  0x10000,		// common_pagesize (overridable by -z common-page-size)
   false,                // isolate_execinstr
   0,                    // rosegment_gap
   elfcpp::SHN_UNDEF,	// small_common_shndx
diff -rupN binutils-2.29.1.orig/gold/configure binutils-2.29.1/gold/configure
--- binutils-2.29.1.orig/gold/configure	2017-09-15 13:38:28.000000000 +0200
+++ binutils-2.29.1/gold/configure	2017-10-06 18:33:12.752717670 +0200
@@ -3432,7 +3432,8 @@ for targ in $target $canon_targets; do
     . ${srcdir}/configure.tgt
 
     if test "$targ_obj" = "UNKNOWN"; then
-      as_fn_error "\"unsupported target $targ\"" "$LINENO" 5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \"unsupported target $targ\"" >&5
+$as_echo "$as_me: WARNING: \"unsupported target $targ\"" >&2;}
     else
       targetobjs="$targetobjs ${targ_obj}.\$(OBJEXT)"
       if test "$targ_extra_obj" != ""; then
diff -rupN binutils-2.29.1.orig/gold/options.h binutils-2.29.1/gold/options.h
--- binutils-2.29.1.orig/gold/options.h	2017-09-19 15:55:52.000000000 +0200
+++ binutils-2.29.1/gold/options.h	2017-10-06 18:32:40.484718372 +0200
@@ -1164,7 +1164,8 @@ class General_options
 	      N_("Generate relocatable output"), NULL);
 
   DEFINE_bool(relax, options::TWO_DASHES, '\0', false,
-	      N_("Relax branches on certain targets"), NULL);
+	      N_("Relax branches on certain targets"),
+	      N_("Do not relax branches"));
 
   DEFINE_string(retain_symbols_file, options::TWO_DASHES, '\0', NULL,
 		N_("keep only symbols listed in this file"), N_("FILE"));
diff -rupN binutils-2.29.1.orig/gold/powerpc.cc binutils-2.29.1/gold/powerpc.cc
--- binutils-2.29.1.orig/gold/powerpc.cc	2017-08-29 09:10:07.000000000 +0200
+++ binutils-2.29.1/gold/powerpc.cc	2017-10-06 18:32:40.484718372 +0200
@@ -3065,11 +3065,17 @@ Target_powerpc<size, big_endian>::Branch
 	target->glink_section()->add_global_entry(gsym);
       else
 	{
-	  if (stub_table == NULL)
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(this->r_type_)))
 	    stub_table = this->object_->stub_table(this->shndx_);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      stub_table = ifunc_stub_table;
 	    }
 	  gold_assert(stub_table != NULL);
@@ -8052,11 +8058,20 @@ Target_powerpc<size, big_endian>::Reloca
 	}
       else
 	{
-	  Stub_table<size, big_endian>* stub_table
-	    = object->stub_table(relinfo->data_shndx);
+	  Stub_table<size, big_endian>* stub_table = NULL;
+	  if (target->stub_tables().size() == 1)
+	    stub_table = target->stub_tables()[0];
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(r_type)))
+	    stub_table = object->stub_table(relinfo->data_shndx);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      if (target->stub_tables().size() != 0)
 		stub_table = target->stub_tables()[0];
 	    }
diff -rupN binutils-2.29.1.orig/ld/emulparams/elf_i386.sh binutils-2.29.1/ld/emulparams/elf_i386.sh
--- binutils-2.29.1.orig/ld/emulparams/elf_i386.sh	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/emulparams/elf_i386.sh	2017-10-06 18:32:52.832718104 +0200
@@ -33,6 +33,10 @@ case "$target" in
 	LIBPATH_SUFFIX=32
 	LIBPATH_SUFFIX_SKIP=64
 	;;
+      *64*)
+	LIBPATH_SUFFIX=64
+	LIBPATH_SUFFIX_SKIP=32
+	;;
     esac
     ;;
 esac
diff -rupN binutils-2.29.1.orig/ld/emulparams/elf_s390.sh binutils-2.29.1/ld/emulparams/elf_s390.sh
--- binutils-2.29.1.orig/ld/emulparams/elf_s390.sh	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/emulparams/elf_s390.sh	2017-10-06 18:32:49.048718186 +0200
@@ -12,3 +12,18 @@ GENERATE_SHLIB_SCRIPT=yes
 GENERATE_PIE_SCRIPT=yes
 NO_SMALL_DATA=yes
 IREL_IN_PLT=
+
+# Treat a host that matches the target with the possible exception of "x"
+# in the name as if it were native.
+if test `echo "$host" | sed -e s/x//` = `echo "$target" | sed -e s/x//`; then
+  case " $EMULATION_LIBPATH " in
+    *" ${EMULATION_NAME} "*)
+      NATIVE=yes
+      ;;
+  esac
+fi
+
+# Look for 64 bit target libraries in /lib64, /usr/lib64 etc., first.
+case "$EMULATION_NAME" in
+  *64*) LIBPATH_SUFFIX=64 ;;
+esac
diff -rupN binutils-2.29.1.orig/ld/emultempl/elf32.em binutils-2.29.1/ld/emultempl/elf32.em
--- binutils-2.29.1.orig/ld/emultempl/elf32.em	2017-08-03 16:07:37.000000000 +0200
+++ binutils-2.29.1/ld/emultempl/elf32.em	2017-10-06 18:32:44.920718276 +0200
@@ -1629,8 +1629,35 @@ if test x"$LDEMUL_BEFORE_ALLOCATION" !=
   else
     ELF_INTERPRETER_SET_DEFAULT=
   fi
+
+  libpath_nl=`echo ${NATIVE_LIB_DIRS// /\\\n}`
 fragment <<EOF
 
+static int
+gld${EMULATION_NAME}_is_contained (const char *path, const char *dc)
+{
+  while (*dc)
+    {
+      const char *pc = path;
+
+      while (*dc && *pc && *dc == *pc && *dc != '\n'
+            && *pc != ':' && *dc != '=')
+       {
+         dc++;
+         pc++;
+       }
+      if ((*pc == 0 || *pc == ':') && (*dc == '\n' || *dc == '=' || *dc == 0))
+       return 1;
+
+      while (*dc && *dc != '\n')
+       dc++;
+      if (*dc == '\n')
+       dc++;
+    }
+
+  return 0;
+}
+
 /* used by before_allocation and handle_option. */
 static void
 gld${EMULATION_NAME}_append_to_separated_string (char **to, char *op_arg)
@@ -1682,7 +1709,7 @@ static struct bfd_link_hash_entry ehdr_s
 static void
 gld${EMULATION_NAME}_before_allocation (void)
 {
-  const char *rpath;
+  char *rpath;
   asection *sinterp;
   bfd *abfd;
   struct elf_link_hash_entry *ehdr_start = NULL;
@@ -1739,7 +1766,65 @@ gld${EMULATION_NAME}_before_allocation (
      by dynamic linking.  */
   rpath = command_line.rpath;
   if (rpath == NULL)
-    rpath = (const char *) getenv ("LD_RUN_PATH");
+    rpath = getenv ("LD_RUN_PATH");
+
+  if (rpath != NULL && getenv ("SUSE_IGNORED_RPATHS"))
+    {
+      char *dirs = 0;
+      FILE *ldso = fopen (getenv ("SUSE_IGNORED_RPATHS"), "r");
+      if (ldso)
+       {
+         off_t endcur = 0;
+         fseek (ldso, 0, SEEK_END);
+         endcur = ftell (ldso);
+         fseek (ldso, 0, SEEK_SET);
+         dirs = xmalloc (endcur);
+         if (fread (dirs, 1, endcur, ldso) != (size_t) endcur)
+           {
+             free (dirs);
+             dirs = NULL;
+           }
+       }
+      if (dirs)
+       {
+         char *cr;
+         rpath = xstrdup (rpath);
+         cr = rpath; /* cursor read */
+
+         while (*cr)
+            {
+             if (gld${EMULATION_NAME}_is_contained (cr, dirs)
+                 || gld${EMULATION_NAME}_is_contained (cr, "$libpath_nl"))
+               {
+                 char *cc = cr, *cw = cr;
+                 while (*cc && *cc != ':')
+                   cc++;
+                 if (*cc == ':')
+                    {
+                     cc++;
+                     for (; *cc; cc++, cw++)
+                       *cw = *cc;
+                    }
+                  else if (cw > rpath)
+                     cw[-1] = 0;
+
+                 *cw = 0;
+               }
+             else
+               {
+                 while (*cr && *cr != ':')
+                   cr++;
+                 if (*cr == ':')
+                   cr++;
+               }
+           }
+         if (*rpath == '\0')
+           {
+             free (rpath);
+             rpath = NULL;
+           }
+       }
+    }
 
   for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)
     if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
diff -rupN binutils-2.29.1.orig/ld/ld.texinfo binutils-2.29.1/ld/ld.texinfo
--- binutils-2.29.1.orig/ld/ld.texinfo	2017-09-13 13:48:44.000000000 +0200
+++ binutils-2.29.1/ld/ld.texinfo	2017-10-06 18:32:59.760717953 +0200
@@ -2391,7 +2391,7 @@ systems may not understand them. If you
 @option{--enable-new-dtags}, the new dynamic tags will be created as needed
 and older dynamic tags will be omitted.
 If you specify @option{--disable-new-dtags}, no new dynamic tags will be
-created. By default, the new dynamic tags are not created. Note that
+created. By default, the new dynamic tags are created. Note that
 those options are only available for ELF systems.
 
 @kindex --hash-size=@var{number}
diff -rupN binutils-2.29.1.orig/ld/ldfile.c binutils-2.29.1/ld/ldfile.c
--- binutils-2.29.1.orig/ld/ldfile.c	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/ldfile.c	2017-10-06 18:33:57.296716701 +0200
@@ -340,7 +340,10 @@ ldfile_open_file_search (const char *arc
     {
       if (entry->flags.sysrooted && IS_ABSOLUTE_PATH (entry->filename))
 	{
-	  char *name = concat (ld_sysroot, entry->filename,
+	  char *name;
+	  if (strncmp(ld_sysroot, entry->filename, strlen(ld_sysroot)) == 0 && ldfile_try_open_bfd (entry->filename, entry))
+	return TRUE;
+	  name = concat (ld_sysroot, entry->filename,
 			       (const char *) NULL);
 	  if (ldfile_try_open_bfd (name, entry))
 	    {
diff -rupN binutils-2.29.1.orig/ld/ldmain.c binutils-2.29.1/ld/ldmain.c
--- binutils-2.29.1.orig/ld/ldmain.c	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/ldmain.c	2017-10-06 18:33:24.288717419 +0200
@@ -280,9 +280,11 @@ main (int argc, char **argv)
 
   link_info.allow_undefined_version = TRUE;
   link_info.keep_memory = TRUE;
+  link_info.new_dtags = TRUE;
   link_info.combreloc = TRUE;
   link_info.strip_discarded = TRUE;
   link_info.emit_hash = TRUE;
+  link_info.emit_gnu_hash = TRUE;
   link_info.callbacks = &link_callbacks;
   link_info.input_bfds_tail = &link_info.input_bfds;
   /* SVR4 linkers seem to set DT_INIT and DT_FINI based on magic _init
@@ -301,6 +303,8 @@ main (int argc, char **argv)
 #ifdef DEFAULT_NEW_DTAGS
   link_info.new_dtags = DEFAULT_NEW_DTAGS;
 #endif
+  if (getenv ("SUSE_ASNEEDED") && atoi(getenv ("SUSE_ASNEEDED")) > 0)
+    input_flags.add_DT_NEEDED_for_regular = TRUE;
 
   ldfile_add_arch ("");
   emulation = get_emulation (argc, argv);
diff -rupN binutils-2.29.1.orig/ld/lexsup.c binutils-2.29.1/ld/lexsup.c
--- binutils-2.29.1.orig/ld/lexsup.c	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/lexsup.c	2017-10-06 18:33:04.096717859 +0200
@@ -650,6 +650,9 @@ parse_args (unsigned argc, char **argv)
 	}
     }
 
+  optarg = "relro";
+  ldemul_handle_option ('z');
+
   last_optind = -1;
   while (1)
     {
diff -rupN binutils-2.29.1.orig/ld/testsuite/config/default.exp binutils-2.29.1/ld/testsuite/config/default.exp
--- binutils-2.29.1.orig/ld/testsuite/config/default.exp	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/testsuite/config/default.exp	2017-10-06 18:33:16.568717587 +0200
@@ -22,7 +22,7 @@
 #
 
 if ![info exists ld] then {
-    set ld [findfile $base_dir/ld-new $base_dir/ld-new [transform ld]]
+    set ld "[findfile $base_dir/ld-new $base_dir/ld-new [transform ld]] -znorelro --hash-style=sysv"
 }
 
 if ![info exists as] then {
@@ -64,7 +64,7 @@ if {![file isdirectory tmpdir/ld]} then
     catch "exec ln -s ld tmpdir/ld/collect-ld" status
     catch "exec ln -s ../../../gas/as-new tmpdir/ld/as" status
 }
-set gcc_B_opt "-B[pwd]/tmpdir/ld/"
+set gcc_B_opt "-B[pwd]/tmpdir/ld/ -Wl,-z,norelro -Wl,--hash-style=sysv"
 
 # load the linker path
 set ld_L_opt ""
@@ -244,7 +244,7 @@ if ![info exists READELFFLAGS] then {
 }
 
 if ![info exists LD] then {
-    set LD [findfile $base_dir/ld-new ./ld-new [transform ld]]
+    set LD "[findfile $base_dir/ld-new ./ld-new [transform ld]] -znorelro --hash-style=sysv"
 }
 
 if ![info exists LDFLAGS] then {
diff -rupN binutils-2.29.1.orig/ld/testsuite/ld-bootstrap/bootstrap.exp binutils-2.29.1/ld/testsuite/ld-bootstrap/bootstrap.exp
--- binutils-2.29.1.orig/ld/testsuite/ld-bootstrap/bootstrap.exp	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/testsuite/ld-bootstrap/bootstrap.exp	2017-10-06 18:33:04.096717859 +0200
@@ -90,7 +90,12 @@ foreach flags $test_flags {
 
     # This test can only be run if we have the ld build directory,
     # since we need the object files.
-    if {$ld != "$objdir/ld-new"} {
+    set ldexe $ld
+    set ldparm [string first " " $ld]
+    if { $ldparm > 0 } then {
+	set ldexe [string range $ld 0 $ldparm]
+    }
+    if {$ldexe != "$objdir/ld-new"} {
 	untested $testname
 	continue
     }
diff -rupN binutils-2.29.1.orig/ld/testsuite/ld-selective/selective.exp binutils-2.29.1/ld/testsuite/ld-selective/selective.exp
--- binutils-2.29.1.orig/ld/testsuite/ld-selective/selective.exp	2017-07-18 09:20:01.000000000 +0200
+++ binutils-2.29.1/ld/testsuite/ld-selective/selective.exp	2017-10-06 18:32:56.096718033 +0200
@@ -46,8 +46,8 @@ set seltests {
     {A::foo() B::foo() dropme1() dropme2()} {*-*-*}}
 }
 
-set cflags "-w -O -ffunction-sections -fdata-sections"
-set cxxflags "-fno-exceptions -fno-rtti"
+set cflags "-w -O -ffunction-sections -fdata-sections -fno-unit-at-a-time"
+set cxxflags "-fno-exceptions -fno-rtti -fno-unit-at-a-time"
 set ldflags "--gc-sections -Bstatic"
 
 if [istarget mips*-*] {
diff -rupN binutils-2.29.1.orig/ld/testsuite/ld-srec/srec.exp binutils-2.29.1/ld/testsuite/ld-srec/srec.exp
--- binutils-2.29.1.orig/ld/testsuite/ld-srec/srec.exp	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/testsuite/ld-srec/srec.exp	2017-10-06 18:33:08.360717766 +0200
@@ -19,6 +19,9 @@
 # Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
 # MA 02110-1301, USA.
 
+# Too fragile.
+return
+
 # Get the offset from an S-record line to the start of the data.
 
 proc srec_off { l } {
diff -rupN binutils-2.29.1.orig/ld/testsuite/ld-undefined/undefined.exp binutils-2.29.1/ld/testsuite/ld-undefined/undefined.exp
--- binutils-2.29.1.orig/ld/testsuite/ld-undefined/undefined.exp	2017-07-10 11:54:42.000000000 +0200
+++ binutils-2.29.1/ld/testsuite/ld-undefined/undefined.exp	2017-10-06 18:33:08.360717766 +0200
@@ -138,7 +138,7 @@ setup_xfail "msp430-*-*"
 # the function. Therefore the line number in the error message is 8 instead
 # of 9. On 64 bit s/390 this works because of the new brasl instruction that
 # doesn't need a literal pool entry.
-setup_xfail s390-*-*
+#setup_xfail s390-*-*
 
 # See comments above for Xtensa.
 setup_xfail xtensa*-*-linux*
