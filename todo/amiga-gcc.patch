diff --git a/.cproject b/.cproject
new file mode 100755
index 00000000000..3e677a57e45
--- /dev/null
+++ b/.cproject
@@ -0,0 +1,197 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="cdt.managedbuild.config.gnu.cross.exe.debug.452878522">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.cross.exe.debug.452878522" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.Cygwin_PE" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.debug" cleanCommand="rm -rf" description="" id="cdt.managedbuild.config.gnu.cross.exe.debug.452878522" name="Debug" optionalBuildProperties="" parent="cdt.managedbuild.config.gnu.cross.exe.debug">
+					<folderInfo id="cdt.managedbuild.config.gnu.cross.exe.debug.452878522." name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.cygwin.base.2053847551" name="Cygwin GCC" superClass="cdt.managedbuild.toolchain.gnu.cygwin.base">
+							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.Cygwin_PE" id="cdt.managedbuild.target.gnu.platform.cygwin.base.2091243283" name="Debug Platform" osList="win32" superClass="cdt.managedbuild.target.gnu.platform.cygwin.base"/>
+							<builder buildPath="${workspace_loc:/debugwin}/Debug" id="cdt.managedbuild.target.gnu.builder.cygwin.base.1660320342" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Gnu Make Builder" superClass="cdt.managedbuild.target.gnu.builder.cygwin.base">
+								<outputEntries>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name=""/>
+								</outputEntries>
+							</builder>
+							<tool id="cdt.managedbuild.tool.gnu.assembler.cygwin.base.607722454" name="GCC Assembler" superClass="cdt.managedbuild.tool.gnu.assembler.cygwin.base">
+								<option id="gnu.both.asm.option.include.paths.2094451885" name="Include paths (-I)" superClass="gnu.both.asm.option.include.paths" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1425989952" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.archiver.cygwin.base.2119049474" name="GCC Archiver" superClass="cdt.managedbuild.tool.gnu.archiver.cygwin.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.compiler.cygwin.base.1103847968" name="Cygwin C++ Compiler" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.cygwin.base">
+								<option id="gnu.cpp.compiler.option.include.paths.466783605" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/libcpp/include}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+								</option>
+								<option id="gnu.cpp.compiler.option.optimization.level.193715843" name="Optimization Level" superClass="gnu.cpp.compiler.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.none" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.debugging.level.2136883244" name="Debug Level" superClass="gnu.cpp.compiler.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.max" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.preprocessor.def.807277038" name="Defined symbols (-D)" superClass="gnu.cpp.compiler.option.preprocessor.def" useByScannerDiscovery="false" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="IN_GCC=1"/>
+									<listOptionValue builtIn="false" value="HAVE_cc0=1"/>
+									<listOptionValue builtIn="false" value="__ECLIPSE__=1"/>
+									<listOptionValue builtIn="false" value="TARGET_AMIGA=1"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.cygwin.780175803" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input.cygwin"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.compiler.cygwin.base.1920331604" name="Cygwin C Compiler" superClass="cdt.managedbuild.tool.gnu.c.compiler.cygwin.base">
+								<option id="gnu.c.compiler.option.include.paths.692774379" name="Include paths (-I)" superClass="gnu.c.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/libcpp/include}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+								</option>
+								<option defaultValue="gnu.c.optimization.level.none" id="gnu.c.compiler.option.optimization.level.227992926" name="Optimization Level" superClass="gnu.c.compiler.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
+								<option id="gnu.c.compiler.option.debugging.level.748883400" name="Debug Level" superClass="gnu.c.compiler.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.max" valueType="enumerated"/>
+								<option id="gnu.c.compiler.option.preprocessor.def.symbols.1982594045" name="Defined symbols (-D)" superClass="gnu.c.compiler.option.preprocessor.def.symbols" useByScannerDiscovery="false" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="IN_GCC=1"/>
+									<listOptionValue builtIn="false" value="HAVE_cc0=1"/>
+									<listOptionValue builtIn="false" value="__ECLIPSE__=1"/>
+									<listOptionValue builtIn="false" value="TARGET_AMIGA=1"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.cygwin.2078467313" superClass="cdt.managedbuild.tool.gnu.c.compiler.input.cygwin"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.c.linker.cygwin.base.344641511" name="Cygwin C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.cygwin.base"/>
+							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.cygwin.base.968200320" name="Cygwin C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.cygwin.base">
+								<option id="gnu.cpp.link.option.libs.260033787" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs"/>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.1537937183" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
+									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
+									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
+								</inputType>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry excluding="ada/|doc/|fortran/|ginclude/|go/|java/|jit/|lto/|objc/|objcp/|po/|testsuite/|config/aarch64/|config/alpha/|config/arc/|config/arm/|config/avr/|config/bfin/|config/c6x/|config/cr16/|config/cris/|config/epiphany/|config/fr30/|config/frv/|config/ft32/|config/h8300/|config/i386/|config/ia64/|config/iq2000/|config/lm32/|config/m32c/|config/m32r/|config/mcore/|config/mep/|config/microblaze/|config/mips/|config/mmix/|config/mn10300/|config/moxie/|config/msp430/|config/nds32/|config/nios2/|config/nvptx/|config/pa/|config/pdp11/|config/rl78/|config/rs6000/|config/rx/|config/s390/|config/sh/|config/sparc/|config/spu/|config/stormy16/|config/tilegx/|config/tilepro/|config/v850/|config/vax/|config/visium/|config/vms/|config/xtensa/" flags="VALUE_WORKSPACE_PATH" kind="sourcePath" name="gcc"/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+		<cconfiguration id="cdt.managedbuild.config.gnu.cross.exe.release.811454954">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="cdt.managedbuild.config.gnu.cross.exe.release.811454954" moduleId="org.eclipse.cdt.core.settings" name="Release">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.cdt.build.core.buildArtefactType.exe" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.cdt.build.core.buildArtefactType.exe,org.eclipse.cdt.build.core.buildType=org.eclipse.cdt.build.core.buildType.release" cleanCommand="rm -rf" description="" id="cdt.managedbuild.config.gnu.cross.exe.release.811454954" name="Release" parent="cdt.managedbuild.config.gnu.cross.exe.release">
+					<folderInfo id="cdt.managedbuild.config.gnu.cross.exe.release.811454954." name="/" resourcePath="">
+						<toolChain id="cdt.managedbuild.toolchain.gnu.cross.exe.release.101222491" name="Cross GCC" superClass="cdt.managedbuild.toolchain.gnu.cross.exe.release">
+							<targetPlatform archList="all" binaryParser="org.eclipse.cdt.core.ELF" id="cdt.managedbuild.targetPlatform.gnu.cross.1798723854" isAbstract="false" osList="all" superClass="cdt.managedbuild.targetPlatform.gnu.cross"/>
+							<builder buildPath="${workspace_loc:/debugwin}/Release" id="cdt.managedbuild.builder.gnu.cross.507087034" keepEnvironmentInBuildfile="false" managedBuildOn="true" name="Gnu Make Builder" superClass="cdt.managedbuild.builder.gnu.cross"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.c.compiler.1834281466" name="Cross GCC Compiler" superClass="cdt.managedbuild.tool.gnu.cross.c.compiler">
+								<option defaultValue="gnu.c.optimization.level.most" id="gnu.c.compiler.option.optimization.level.1686563067" name="Optimization Level" superClass="gnu.c.compiler.option.optimization.level" useByScannerDiscovery="false" valueType="enumerated"/>
+								<option id="gnu.c.compiler.option.debugging.level.60172226" name="Debug Level" superClass="gnu.c.compiler.option.debugging.level" useByScannerDiscovery="false" value="gnu.c.debugging.level.none" valueType="enumerated"/>
+								<option id="gnu.c.compiler.option.include.paths.696908692" name="Include paths (-I)" superClass="gnu.c.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+								</option>
+								<option id="gnu.c.compiler.option.preprocessor.def.symbols.652362073" name="Defined symbols (-D)" superClass="gnu.c.compiler.option.preprocessor.def.symbols" useByScannerDiscovery="false" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="IN_GCC=1"/>
+									<listOptionValue builtIn="false" value="HAVE_cc0=1"/>
+									<listOptionValue builtIn="false" value="__ECLIPSE__=1"/>
+									<listOptionValue builtIn="false" value="TARGET_AMIGA=1"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.c.compiler.input.1150724656" superClass="cdt.managedbuild.tool.gnu.c.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.cross.cpp.compiler.1042604749" name="Cross G++ Compiler" superClass="cdt.managedbuild.tool.gnu.cross.cpp.compiler">
+								<option id="gnu.cpp.compiler.option.optimization.level.2088586809" name="Optimization Level" superClass="gnu.cpp.compiler.option.optimization.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.optimization.level.most" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.debugging.level.1993778911" name="Debug Level" superClass="gnu.cpp.compiler.option.debugging.level" useByScannerDiscovery="false" value="gnu.cpp.compiler.debugging.level.none" valueType="enumerated"/>
+								<option id="gnu.cpp.compiler.option.include.paths.1936413739" name="Include paths (-I)" superClass="gnu.cpp.compiler.option.include.paths" useByScannerDiscovery="false" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+								</option>
+								<option id="gnu.cpp.compiler.option.preprocessor.def.625117841" name="Defined symbols (-D)" superClass="gnu.cpp.compiler.option.preprocessor.def" useByScannerDiscovery="false" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="IN_GCC=1"/>
+									<listOptionValue builtIn="false" value="HAVE_cc0=1"/>
+									<listOptionValue builtIn="false" value="__ECLIPSE__=1"/>
+									<listOptionValue builtIn="false" value="TARGET_AMIGA=1"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.compiler.input.1133865092" superClass="cdt.managedbuild.tool.gnu.cpp.compiler.input"/>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.cross.c.linker.946489608" name="Cross GCC Linker" superClass="cdt.managedbuild.tool.gnu.cross.c.linker"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.cpp.linker.738916918" name="Cross G++ Linker" superClass="cdt.managedbuild.tool.gnu.cross.cpp.linker">
+								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.1880308865" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
+									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
+									<additionalInput kind="additionalinput" paths="$(LIBS)"/>
+								</inputType>
+							</tool>
+							<tool id="cdt.managedbuild.tool.gnu.cross.archiver.1813524686" name="Cross GCC Archiver" superClass="cdt.managedbuild.tool.gnu.cross.archiver"/>
+							<tool id="cdt.managedbuild.tool.gnu.cross.assembler.1395544547" name="Cross GCC Assembler" superClass="cdt.managedbuild.tool.gnu.cross.assembler">
+								<option id="gnu.both.asm.option.include.paths.1443815690" name="Include paths (-I)" superClass="gnu.both.asm.option.include.paths" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;C:\cygwin\usr\include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/gcc}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/gcc-6/build-gcc/gcc}&quot;"/>
+								</option>
+								<inputType id="cdt.managedbuild.tool.gnu.assembler.input.1421786104" superClass="cdt.managedbuild.tool.gnu.assembler.input"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry excluding="src" flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name=""/>
+						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="src"/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="debugwin.cdt.managedbuild.target.gnu.cross.exe.1884740625" name="Executable" projectType="cdt.managedbuild.target.gnu.cross.exe"/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Debug">
+			<resource resourceType="PROJECT" workspacePath="/gcc-6"/>
+		</configuration>
+		<configuration configurationName="Release">
+			<resource resourceType="PROJECT" workspacePath="/gcc-6"/>
+		</configuration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.release.811454954;cdt.managedbuild.config.gnu.cross.exe.release.811454954.;cdt.managedbuild.tool.gnu.cross.c.compiler.1834281466;cdt.managedbuild.tool.gnu.c.compiler.input.1150724656">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.debug.452878522;cdt.managedbuild.config.gnu.cross.exe.debug.452878522.;cdt.managedbuild.tool.gnu.cross.c.compiler.502147450;cdt.managedbuild.tool.gnu.c.compiler.input.1173428818">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.debug.452878522;cdt.managedbuild.config.gnu.cross.exe.debug.452878522.;cdt.managedbuild.tool.gnu.cpp.compiler.cygwin.base.1103847968;cdt.managedbuild.tool.gnu.cpp.compiler.input.cygwin.780175803">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.debug.452878522;cdt.managedbuild.config.gnu.cross.exe.debug.452878522.;cdt.managedbuild.tool.gnu.c.compiler.cygwin.base.1920331604;cdt.managedbuild.tool.gnu.c.compiler.input.cygwin.2078467313">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.debug.452878522;cdt.managedbuild.config.gnu.cross.exe.debug.452878522.;cdt.managedbuild.tool.gnu.cross.cpp.compiler.216739552;cdt.managedbuild.tool.gnu.cpp.compiler.input.1269341019">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+		<scannerConfigBuildInfo instanceId="cdt.managedbuild.config.gnu.cross.exe.release.811454954;cdt.managedbuild.config.gnu.cross.exe.release.811454954.;cdt.managedbuild.tool.gnu.cross.cpp.compiler.1042604749;cdt.managedbuild.tool.gnu.cpp.compiler.input.1133865092">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+</cproject>
diff --git a/.project b/.project
new file mode 100644
index 00000000000..6c5e72cfb0f
--- /dev/null
+++ b/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>gcc-6</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+	<linkedResources>
+		<link>
+			<name>build-gcc</name>
+			<type>2</type>
+			<locationURI>PARENT-2-PROJECT_LOC/build-CYGWIN_NT-10.0-WOW/gcc</locationURI>
+		</link>
+	</linkedResources>
+</projectDescription>
diff --git a/.settings/language.settings.xml b/.settings/language.settings.xml
new file mode 100755
index 00000000000..99f20f260b1
--- /dev/null
+++ b/.settings/language.settings.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<project>
+	<configuration id="cdt.managedbuild.config.gnu.cross.exe.debug.452878522" name="Debug">
+		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
+			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
+			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
+			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
+			<provider class="org.eclipse.cdt.managedbuilder.internal.language.settings.providers.GCCBuiltinSpecsDetectorCygwin" console="false" env-hash="-1643496762141181171" id="org.eclipse.cdt.managedbuilder.core.GCCBuiltinSpecsDetectorCygwin" keep-relative-paths="false" name="CDT GCC Built-in Compiler Settings Cygwin" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
+				<language-scope id="org.eclipse.cdt.core.gcc"/>
+				<language-scope id="org.eclipse.cdt.core.g++"/>
+			</provider>
+		</extension>
+	</configuration>
+	<configuration id="cdt.managedbuild.config.gnu.cross.exe.release.811454954" name="Release">
+		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
+			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
+			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
+			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
+			<provider class="org.eclipse.cdt.internal.build.crossgcc.CrossGCCBuiltinSpecsDetector" console="false" env-hash="1284625475479736847" id="org.eclipse.cdt.build.crossgcc.CrossGCCBuiltinSpecsDetector" keep-relative-paths="false" name="CDT Cross GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
+				<language-scope id="org.eclipse.cdt.core.gcc"/>
+				<language-scope id="org.eclipse.cdt.core.g++"/>
+			</provider>
+		</extension>
+	</configuration>
+</project>
diff --git a/.settings/org.eclipse.cdt.codan.core.prefs b/.settings/org.eclipse.cdt.codan.core.prefs
new file mode 100755
index 00000000000..b5248c62010
--- /dev/null
+++ b/.settings/org.eclipse.cdt.codan.core.prefs
@@ -0,0 +1,71 @@
+eclipse.preferences.version=1
+org.eclipse.cdt.codan.checkers.errnoreturn=Warning
+org.eclipse.cdt.codan.checkers.errnoreturn.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"No return\\")",implicit\=>false}
+org.eclipse.cdt.codan.checkers.errreturnvalue=Error
+org.eclipse.cdt.codan.checkers.errreturnvalue.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Unused return value\\")"}
+org.eclipse.cdt.codan.checkers.nocommentinside=-Error
+org.eclipse.cdt.codan.checkers.nocommentinside.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Nesting comments\\")"}
+org.eclipse.cdt.codan.checkers.nolinecomment=-Error
+org.eclipse.cdt.codan.checkers.nolinecomment.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Line comments\\")"}
+org.eclipse.cdt.codan.checkers.noreturn=Error
+org.eclipse.cdt.codan.checkers.noreturn.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"No return value\\")",implicit\=>false}
+org.eclipse.cdt.codan.internal.checkers.AbstractClassCreation=Error
+org.eclipse.cdt.codan.internal.checkers.AbstractClassCreation.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Abstract class cannot be instantiated\\")"}
+org.eclipse.cdt.codan.internal.checkers.AmbiguousProblem=Error
+org.eclipse.cdt.codan.internal.checkers.AmbiguousProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Ambiguous problem\\")"}
+org.eclipse.cdt.codan.internal.checkers.AssignmentInConditionProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.AssignmentInConditionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Assignment in condition\\")"}
+org.eclipse.cdt.codan.internal.checkers.AssignmentToItselfProblem=Error
+org.eclipse.cdt.codan.internal.checkers.AssignmentToItselfProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Assignment to itself\\")"}
+org.eclipse.cdt.codan.internal.checkers.CaseBreakProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.CaseBreakProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"No break at end of case\\")",no_break_comment\=>"no break",last_case_param\=>false,empty_case_param\=>false}
+org.eclipse.cdt.codan.internal.checkers.CatchByReference=Warning
+org.eclipse.cdt.codan.internal.checkers.CatchByReference.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Catching by reference is recommended\\")",unknown\=>false,exceptions\=>()}
+org.eclipse.cdt.codan.internal.checkers.CircularReferenceProblem=Error
+org.eclipse.cdt.codan.internal.checkers.CircularReferenceProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Circular inheritance\\")"}
+org.eclipse.cdt.codan.internal.checkers.ClassMembersInitialization=Warning
+org.eclipse.cdt.codan.internal.checkers.ClassMembersInitialization.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Class members should be properly initialized\\")",skip\=>true}
+org.eclipse.cdt.codan.internal.checkers.FieldResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.FieldResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Field cannot be resolved\\")"}
+org.eclipse.cdt.codan.internal.checkers.FunctionResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.FunctionResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Function cannot be resolved\\")"}
+org.eclipse.cdt.codan.internal.checkers.InvalidArguments=Error
+org.eclipse.cdt.codan.internal.checkers.InvalidArguments.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Invalid arguments\\")"}
+org.eclipse.cdt.codan.internal.checkers.InvalidTemplateArgumentsProblem=Error
+org.eclipse.cdt.codan.internal.checkers.InvalidTemplateArgumentsProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Invalid template argument\\")"}
+org.eclipse.cdt.codan.internal.checkers.LabelStatementNotFoundProblem=Error
+org.eclipse.cdt.codan.internal.checkers.LabelStatementNotFoundProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Label statement not found\\")"}
+org.eclipse.cdt.codan.internal.checkers.MemberDeclarationNotFoundProblem=Error
+org.eclipse.cdt.codan.internal.checkers.MemberDeclarationNotFoundProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Member declaration not found\\")"}
+org.eclipse.cdt.codan.internal.checkers.MethodResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.MethodResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Method cannot be resolved\\")"}
+org.eclipse.cdt.codan.internal.checkers.NamingConventionFunctionChecker=-Info
+org.eclipse.cdt.codan.internal.checkers.NamingConventionFunctionChecker.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Name convention for function\\")",pattern\=>"^[a-z]",macro\=>true,exceptions\=>()}
+org.eclipse.cdt.codan.internal.checkers.NonVirtualDestructorProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.NonVirtualDestructorProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Class has a virtual method and non-virtual destructor\\")"}
+org.eclipse.cdt.codan.internal.checkers.OverloadProblem=Error
+org.eclipse.cdt.codan.internal.checkers.OverloadProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Invalid overload\\")"}
+org.eclipse.cdt.codan.internal.checkers.RedeclarationProblem=Error
+org.eclipse.cdt.codan.internal.checkers.RedeclarationProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Invalid redeclaration\\")"}
+org.eclipse.cdt.codan.internal.checkers.RedefinitionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.RedefinitionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Invalid redefinition\\")"}
+org.eclipse.cdt.codan.internal.checkers.ReturnStyleProblem=-Warning
+org.eclipse.cdt.codan.internal.checkers.ReturnStyleProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Return with parenthesis\\")"}
+org.eclipse.cdt.codan.internal.checkers.ScanfFormatStringSecurityProblem=-Warning
+org.eclipse.cdt.codan.internal.checkers.ScanfFormatStringSecurityProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Format String Vulnerability\\")"}
+org.eclipse.cdt.codan.internal.checkers.StatementHasNoEffectProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.StatementHasNoEffectProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Statement has no effect\\")",macro\=>true,exceptions\=>()}
+org.eclipse.cdt.codan.internal.checkers.SuggestedParenthesisProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.SuggestedParenthesisProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Suggested parenthesis around expression\\")",paramNot\=>false}
+org.eclipse.cdt.codan.internal.checkers.SuspiciousSemicolonProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.SuspiciousSemicolonProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Suspicious semicolon\\")",else\=>false,afterelse\=>false}
+org.eclipse.cdt.codan.internal.checkers.TypeResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.TypeResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Type cannot be resolved\\")"}
+org.eclipse.cdt.codan.internal.checkers.UnusedFunctionDeclarationProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.UnusedFunctionDeclarationProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Unused function declaration\\")",macro\=>true}
+org.eclipse.cdt.codan.internal.checkers.UnusedStaticFunctionProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.UnusedStaticFunctionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Unused static function\\")",macro\=>true}
+org.eclipse.cdt.codan.internal.checkers.UnusedVariableDeclarationProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.UnusedVariableDeclarationProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Unused variable declaration in file scope\\")",macro\=>true,exceptions\=>("@(\#)","$Id")}
+org.eclipse.cdt.codan.internal.checkers.VariableResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.VariableResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>true,RUN_ON_INC_BUILD\=>true,RUN_ON_FILE_OPEN\=>false,RUN_ON_FILE_SAVE\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true},suppression_comment\=>"@suppress(\\"Symbol is not resolved\\")"}
diff --git a/.settings/org.eclipse.cdt.core.prefs b/.settings/org.eclipse.cdt.core.prefs
new file mode 100755
index 00000000000..5e569dba562
--- /dev/null
+++ b/.settings/org.eclipse.cdt.core.prefs
@@ -0,0 +1,169 @@
+eclipse.preferences.version=1
+environment/project/cdt.managedbuild.config.gnu.cross.exe.debug.452878522/PATH/delimiter=;
+environment/project/cdt.managedbuild.config.gnu.cross.exe.debug.452878522/PATH/operation=replace
+environment/project/cdt.managedbuild.config.gnu.cross.exe.debug.452878522/PATH/value=C\:\\WINDOWS\\system32;C\:\\WINDOWS;C\:\\Program Files\\SlikSvn\\bin;C\:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;c\:\\cygwin\\bin;c\:\\cygwin\\opt\\amiga\\bin
+environment/project/cdt.managedbuild.config.gnu.cross.exe.debug.452878522/append=true
+environment/project/cdt.managedbuild.config.gnu.cross.exe.debug.452878522/appendContributed=true
+org.eclipse.cdt.core.formatter.alignment_for_arguments_in_method_invocation=18
+org.eclipse.cdt.core.formatter.alignment_for_assignment=16
+org.eclipse.cdt.core.formatter.alignment_for_base_clause_in_type_declaration=80
+org.eclipse.cdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.cdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.cdt.core.formatter.alignment_for_conditional_expression=34
+org.eclipse.cdt.core.formatter.alignment_for_conditional_expression_chain=18
+org.eclipse.cdt.core.formatter.alignment_for_constructor_initializer_list=0
+org.eclipse.cdt.core.formatter.alignment_for_declarator_list=16
+org.eclipse.cdt.core.formatter.alignment_for_enumerator_list=48
+org.eclipse.cdt.core.formatter.alignment_for_expression_list=0
+org.eclipse.cdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.cdt.core.formatter.alignment_for_member_access=0
+org.eclipse.cdt.core.formatter.alignment_for_overloaded_left_shift_chain=16
+org.eclipse.cdt.core.formatter.alignment_for_parameters_in_method_declaration=18
+org.eclipse.cdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.cdt.core.formatter.brace_position_for_array_initializer=next_line_shifted
+org.eclipse.cdt.core.formatter.brace_position_for_block=next_line_shifted
+org.eclipse.cdt.core.formatter.brace_position_for_block_in_case=next_line_shifted
+org.eclipse.cdt.core.formatter.brace_position_for_method_declaration=next_line
+org.eclipse.cdt.core.formatter.brace_position_for_namespace_declaration=next_line
+org.eclipse.cdt.core.formatter.brace_position_for_switch=next_line_shifted
+org.eclipse.cdt.core.formatter.brace_position_for_type_declaration=next_line
+org.eclipse.cdt.core.formatter.comment.line_up_line_comment_in_blocks_on_first_column=false
+org.eclipse.cdt.core.formatter.comment.min_distance_between_code_and_line_comment=1
+org.eclipse.cdt.core.formatter.comment.never_indent_line_comments_on_first_column=true
+org.eclipse.cdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=true
+org.eclipse.cdt.core.formatter.compact_else_if=true
+org.eclipse.cdt.core.formatter.continuation_indentation=2
+org.eclipse.cdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.cdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.cdt.core.formatter.indent_access_specifier_compare_to_type_header=false
+org.eclipse.cdt.core.formatter.indent_access_specifier_extra_spaces=0
+org.eclipse.cdt.core.formatter.indent_body_declarations_compare_to_access_specifier=true
+org.eclipse.cdt.core.formatter.indent_body_declarations_compare_to_namespace_header=true
+org.eclipse.cdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.cdt.core.formatter.indent_declaration_compare_to_template_header=true
+org.eclipse.cdt.core.formatter.indent_empty_lines=false
+org.eclipse.cdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.cdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.cdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.cdt.core.formatter.indent_switchstatements_compare_to_switch=true
+org.eclipse.cdt.core.formatter.indentation.size=2
+org.eclipse.cdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.cdt.core.formatter.insert_new_line_after_template_declaration=insert
+org.eclipse.cdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_catch_in_try_statement=insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_colon_in_constructor_initializer_list=do not insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_else_in_if_statement=insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_identifier_in_function_declaration=insert
+org.eclipse.cdt.core.formatter.insert_new_line_before_while_in_do_statement=insert
+org.eclipse.cdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.cdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.cdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.cdt.core.formatter.insert_space_after_closing_angle_bracket_in_template_arguments=insert
+org.eclipse.cdt.core.formatter.insert_space_after_closing_angle_bracket_in_template_parameters=insert
+org.eclipse.cdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.cdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.cdt.core.formatter.insert_space_after_colon_in_base_clause=insert
+org.eclipse.cdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.cdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.cdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_base_types=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_declarator_list=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_expression_list=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_template_arguments=insert
+org.eclipse.cdt.core.formatter.insert_space_after_comma_in_template_parameters=insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_angle_bracket_in_template_arguments=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_angle_bracket_in_template_parameters=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_bracket=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_exception_specification=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.cdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.cdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.cdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_angle_bracket_in_template_arguments=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_angle_bracket_in_template_parameters=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_bracket=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_exception_specification=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_colon_in_base_clause=insert
+org.eclipse.cdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.cdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_base_types=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_declarator_list=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_expression_list=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_template_arguments=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_comma_in_template_parameters=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_angle_bracket_in_template_arguments=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_angle_bracket_in_template_parameters=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_namespace_declaration=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_bracket=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_exception_specification=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.cdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.cdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.cdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.cdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.cdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.cdt.core.formatter.insert_space_between_empty_brackets=do not insert
+org.eclipse.cdt.core.formatter.insert_space_between_empty_parens_in_exception_specification=do not insert
+org.eclipse.cdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.cdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.cdt.core.formatter.join_wrapped_lines=true
+org.eclipse.cdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.cdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.cdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.cdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.cdt.core.formatter.lineSplit=80
+org.eclipse.cdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.cdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.cdt.core.formatter.tabulation.char=mixed
+org.eclipse.cdt.core.formatter.tabulation.size=8
+org.eclipse.cdt.core.formatter.use_tabs_only_for_leading_indentations=false
diff --git a/.settings/org.eclipse.cdt.ui.prefs b/.settings/org.eclipse.cdt.ui.prefs
new file mode 100755
index 00000000000..e7b49cda9dd
--- /dev/null
+++ b/.settings/org.eclipse.cdt.ui.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+formatter_profile=org.eclipse.cdt.ui.default.gnu_profile
+formatter_settings_version=1
diff --git a/.settings/org.eclipse.core.runtime.prefs b/.settings/org.eclipse.core.runtime.prefs
new file mode 100755
index 00000000000..12511e62a17
--- /dev/null
+++ b/.settings/org.eclipse.core.runtime.prefs
@@ -0,0 +1,5 @@
+content-types/enabled=true
+content-types/org.eclipse.cdt.core.cHeader/file-extensions=def
+content-types/org.eclipse.cdt.core.cxxHeader/file-extensions=h
+content-types/org.eclipse.cdt.core.cxxSource/file-extensions=c
+eclipse.preferences.version=1
diff --git a/config.sub b/config.sub
index 41146e11c6c..35247fe0c47 100755
--- a/config.sub
+++ b/config.sub
@@ -2,7 +2,7 @@
 # Configuration validation subroutine script.
 #   Copyright 1992-2016 Free Software Foundation, Inc.
 
-timestamp='2016-01-01'
+timestamp='2017-04-21'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -500,7 +500,7 @@ case $basic_machine in
 	amiga | amiga-*)
 		basic_machine=m68k-unknown
 		;;
-	amigaos | amigados)
+	amigaos | amigaosvasm | amigados)
 		basic_machine=m68k-unknown
 		os=-amigaos
 		;;
@@ -1380,7 +1380,7 @@ case $os in
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rt* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
 	      | -bitrig* | -openbsd* | -solidbsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
diff --git a/configure b/configure
index b29a7247b96..f587e513014 100755
--- a/configure
+++ b/configure
@@ -7644,7 +7644,7 @@ fi
 # being built; programs in there won't even run.
 if test "${build}" = "${host}" && test -d ${srcdir}/gcc; then
   # Search for pre-installed headers if nothing else fits.
-  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$(build_tooldir)/bin/ -B$(build_tooldir)/lib/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include'
+  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$(build_tooldir)/bin/ -B$(build_tooldir)/lib/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/ndk-include -isystem $(build_tooldir)/sys-include'
 fi
 
 if test "x${use_gnu_ld}" = x &&
diff --git a/configure.ac b/configure.ac
index f23463a2852..69ab4216ed7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3243,7 +3243,7 @@ fi
 # being built; programs in there won't even run.
 if test "${build}" = "${host}" && test -d ${srcdir}/gcc; then
   # Search for pre-installed headers if nothing else fits.
-  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$(build_tooldir)/bin/ -B$(build_tooldir)/lib/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/sys-include'
+  FLAGS_FOR_TARGET=$FLAGS_FOR_TARGET' -B$(build_tooldir)/bin/ -B$(build_tooldir)/lib/ -isystem $(build_tooldir)/include -isystem $(build_tooldir)/ndk-include -isystem $(build_tooldir)/sys-include'
 fi
 
 if test "x${use_gnu_ld}" = x &&
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index f22d756da39..5baf6403cd1 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-6.5.0
+6.5.0b
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index 30a71f8107a..6be84ded4e9 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20181026
+190312232514
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 51e2bc86e9a..92cfca10a49 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -385,7 +385,17 @@ enable_host_shared = @enable_host_shared@
 
 enable_as_accelerator = @enable_as_accelerator@
 
+ifeq ($(DLL),)
 CPPLIB = ../libcpp/libcpp.a
+else
+CPPLIB = libcpp.dll
+
+LDFLAGS += -Xlinker --allow-multiple-definition
+
+DLLYANG = dllyang.o
+DLLYING = dllying.o
+
+endif
 CPPINC = -I$(srcdir)/../libcpp/include
 
 # Where to find decNumber
@@ -393,12 +403,20 @@ enable_decimal_float = @enable_decimal_float@
 DECNUM = $(srcdir)/../libdecnumber
 DECNUMFMT = $(srcdir)/../libdecnumber/$(enable_decimal_float)
 DECNUMINC = -I$(DECNUM) -I$(DECNUMFMT) -I../libdecnumber
+ifeq ($(DLL),)
 LIBDECNUMBER = ../libdecnumber/libdecnumber.a
+else
+LIBDECNUMBER = libdecnumber.dll
+endif
 
 # The backtrace library.
 BACKTRACE = $(srcdir)/../libbacktrace
 BACKTRACEINC = -I$(BACKTRACE)
+ifeq ($(DLL),)
 LIBBACKTRACE = ../libbacktrace/.libs/libbacktrace.a
+else
+LIBBACKTRACE = libbacktrace.dll
+endif
 
 # Target to use when installing include directory.  Either
 # install-headers-tar, install-headers-cpio or install-headers-cp.
@@ -1018,12 +1036,29 @@ ifeq ($(enable_host_shared),yes)
 LIBIBERTY = ../libiberty/pic/libiberty.a
 BUILD_LIBIBERTY = $(build_libobjdir)/libiberty/pic/libiberty.a
 else
+
+ifeq ($(DLL),)
 LIBIBERTY = ../libiberty/libiberty.a
+else
+LIBIBERTY = libiberty.dll
+endif
+
+ifeq ($(DLL),)
+LIBCOMMON = libcommon.a
+LIBCOMMON_TARGET = libcommon-target.a
+LIBBACKEND = libbackend.a
+else
+LIBCOMMON = libcommon.dll
+LIBCOMMON_TARGET = libcommon-target.dll
+LIBBACKEND = libbackend.dll
+endif
+
+
 BUILD_LIBIBERTY = $(build_libobjdir)/libiberty/libiberty.a
 endif
 
 # Dependencies on the intl and portability libraries.
-LIBDEPS= libcommon.a $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) \
+LIBDEPS= $(LIBCOMMON) $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) \
 	$(LIBDECNUMBER) $(LIBBACKTRACE)
 
 # Likewise, for use in the tools that must run on this machine
@@ -1032,7 +1067,7 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)
 
 # How to link with both our special library facilities
 # and the system's installed libraries.
-LIBS = @LIBS@ libcommon.a $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBBACKTRACE) \
+LIBS = @LIBS@ $(LIBCOMMON) $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBBACKTRACE) \
 	$(LIBIBERTY) $(LIBDECNUMBER) $(HOST_LIBS)
 BACKENDLIBS = $(ISLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
 	$(ZLIB)
@@ -1171,7 +1206,7 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \
   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \
   c-family/c-semantics.o c-family/c-ada-spec.o \
   c-family/c-cilkplus.o \
-  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o
+  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o $(DLLYING)
 
 # Language-independent object files.
 # We put the *-match.o and insn-*.o files first so that a parallel make
@@ -1199,6 +1234,7 @@ OBJS = \
 	auto-inc-dec.o \
 	auto-profile.o \
 	bb-reorder.o \
+	bbb-opts.o \
 	bitmap.o \
 	bt-load.o \
 	builtins.o \
@@ -1537,7 +1573,8 @@ OBJS = \
 	xcoffout.o \
 	$(out_object_file) \
 	$(EXTRA_OBJS) \
-	$(host_hook_obj)
+	$(host_hook_obj) \
+	$(DLLYING) $(DLLYANG)
 
 # Objects in libcommon.a, potentially used by all host binaries and with
 # no target dependencies.
@@ -1564,7 +1601,7 @@ ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \
 # compilation or not.
 ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)
 
-BACKEND = libbackend.a main.o libcommon-target.a libcommon.a \
+BACKEND = $(LIBBACKEND) main.o $(LIBCOMMON_TARGET) $(LIBCOMMON) \
 	$(CPPLIB) $(LIBDECNUMBER)
 
 # This is defined to "yes" if Tree checking is enabled, which roughly means
@@ -1588,8 +1625,8 @@ MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \
  gcc-ranlib$(exeext) \
  gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \
  gcov-tool$(exeect) \
- gengtype$(exeext) *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a \
- libcommon-target.a libcommon.a libgcc.mk
+ gengtype$(exeext) *.[0-9][0-9].* *.[si] *-checksum.c $(LIBBACKEND) \
+ $(LIBCOMMON_TARGET) libcommon.a libgcc.mk
 
 # This symlink makes the full installation name of the driver be available
 # from within the *build* directory, for use when running the JIT library
@@ -1849,32 +1886,53 @@ libbackend.a: $(OBJS)
 	$(AR) $(AR_FLAGS) libbackend.a $(OBJS)
 	-$(RANLIB) $(RANLIB_FLAGS) libbackend.a
 
+libbackend.dll: $(OBJS) libcommon.dll libcommon-target.dll libdecnumber.dll libiberty.dll
+	$(CXX) -shared -o $@ $(OBJS) libiberty.dll libcommon.dll libcommon-target.dll libdecnumber.dll -lz -lmpc -lmpfr -lgmp dllyang.o -Xlinker --allow-multiple-definition 
+
 libcommon-target.a: $(OBJS-libcommon-target)
 	-rm -rf libcommon-target.a
 	$(AR) $(AR_FLAGS) libcommon-target.a $(OBJS-libcommon-target)
 	-$(RANLIB) $(RANLIB_FLAGS) libcommon-target.a
 
+libcommon-target.dll: $(OBJS-libcommon-target)
+	$(CXX) -shared -o $@ $(OBJS-libcommon-target) libiberty.dll libcommon.dll
+
 libcommon.a: $(OBJS-libcommon)
 	-rm -rf libcommon.a
 	$(AR) $(AR_FLAGS) libcommon.a $(OBJS-libcommon)
 	-$(RANLIB) $(RANLIB_FLAGS) libcommon.a
+	
+libcommon.dll: $(OBJS-libcommon) libiberty.dll
+	$(MAKE) -C ../libbacktrace/ libbacktrace.dll DLL=1 
+	cp ../libbacktrace/libbacktrace.dll .
+	$(CXX) -shared -o $@ $(OBJS-libcommon) libiberty.dll libbacktrace.dll ../libcpp/libcpp.a -liconv
+	make -C ../libcpp/ libcpp.dll DLL=1
+	cp ../libcpp/libcpp.dll .
+
+libdecnumber.dll:
+	$(MAKE) -C ../libdecnumber libdecnumber.dll DLL=1
+	cp ../libdecnumber/libdecnumber.dll .
+
+libiberty.dll:
+	$(MAKE) -C ../libiberty/ libiberty.dll DLL=1 
+	cp ../libiberty/libiberty.dll .
 
 # We call this executable `xgcc' rather than `gcc'
 # to avoid confusion if the current directory is in the path
 # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
-xgcc$(exeext): $(GCC_OBJS) c/gccspec.o libcommon-target.a $(LIBDEPS) \
+xgcc$(exeext): $(GCC_OBJS) c/gccspec.o $(LIBCOMMON_TARGET) $(LIBDEPS) \
 	$(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
-	  c/gccspec.o $(EXTRA_GCC_OBJS) libcommon-target.a \
+	  c/gccspec.o $(EXTRA_GCC_OBJS) $(LIBCOMMON_TARGET) \
 	  $(EXTRA_GCC_LIBS) $(LIBS)
 
 # cpp is to cpp0 as e.g. g++ is to cc1plus: Just another driver.
 # It is part of c-family because the handled extensions are hard-coded
 # and only contain c-family extensions (see known_suffixes).
-cpp$(exeext): $(GCC_OBJS) c-family/cppspec.o libcommon-target.a $(LIBDEPS) \
+cpp$(exeext): $(GCC_OBJS) c-family/cppspec.o $(LIBCOMMON_TARGET) $(LIBDEPS) \
 	$(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
-	  c-family/cppspec.o $(EXTRA_GCC_OBJS) libcommon-target.a \
+	  c-family/cppspec.o $(EXTRA_GCC_OBJS) $(LIBCOMMON_TARGET) \
 	  $(EXTRA_GCC_LIBS) $(LIBS)
 
 # Dump a specs file to make -B./ read these specs over installed ones.
@@ -1986,7 +2044,7 @@ gcc-nm.c: gcc-ar.c
 	cp $^ $@
 
 COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o \
-  collect-utils.o file-find.o hash-table.o
+  collect-utils.o file-find.o hash-table.o $(EXTRA_COLLECT2_OBJS)
 COLLECT2_LIBS = @COLLECT2_LIBS@
 collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
 # Don't try modifying collect2 (aka ld) in place--it might be linking this.
@@ -1998,9 +2056,9 @@ CFLAGS-collect2.o += -DTARGET_MACHINE=\"$(target_noncanonical)\" \
 	@TARGET_SYSTEM_ROOT_DEFINE@
 
 LTO_WRAPPER_OBJS = lto-wrapper.o collect-utils.o ggc-none.o
-lto-wrapper$(exeext): $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBDEPS)
+lto-wrapper$(exeext): $(LTO_WRAPPER_OBJS) $(LIBCOMMON_TARGET) $(LIBDEPS)
 	+$(LINKER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ \
-	   $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBS)
+	   $(LTO_WRAPPER_OBJS) $(LIBCOMMON_TARGET) $(LIBS)
 	mv -f T$@ $@
 
 # Files used by all variants of C or by the stand-alone pre-processor.
@@ -3270,7 +3328,7 @@ endif
 install-strip: install
 
 # Handle cpp installation.
-install-cpp: installdirs cpp$(exeext)
+install-cpp: installdirs cpp$(exeext) all.cross
 	-if test "$(enable_as_accelerator)" != "yes" ; then \
 	  rm -f $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext); \
 	  $(INSTALL_PROGRAM) -m 755 cpp$(exeext) $(DESTDIR)$(bindir)/$(CPP_INSTALL_NAME)$(exeext); \
diff --git a/gcc/amigacollect2.c b/gcc/amigacollect2.c
new file mode 100755
index 00000000000..941ea0248fb
--- /dev/null
+++ b/gcc/amigacollect2.c
@@ -0,0 +1,348 @@
+/* GG-local whole file: dynamic libraries */
+/* Supplimentary functions that get compiled and linked to collect2 for
+   AmigaOS target.
+   Copyright (C) 1996 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+
+/* From collect2.c:  */
+
+void maybe_unlink(const char *);
+void fatal_error(location_t, const char *, ...);
+void fork_execute(const char *, char **, bool);
+
+extern char *c_file_name;
+extern int debug;
+
+/* Local functions.  */
+
+static void safename (char *);
+static void add_lib (const char *);
+static void cat (const char *, FILE *);
+
+/* Names of temporary files we create.  */
+#define XLIBS_C_NAME "xlibs.c"
+#define XLIBS_O_NAME "xlibs.o"
+#define SHARED_X_NAME "shared.x"
+
+/* Suffix which is prepended to "-l" options for dynamic libraries.  */
+#define DYNAMIC_LIB_SUFFIX "_ixlibrary"
+
+/* Structure that holds library names.  */
+struct liblist
+{
+  struct liblist *next;
+  char *name;
+  char *cname;
+};
+
+/* Not zero if "-static" was specified on GCC command line or if all the
+   libraries are static.  */
+static int flag_static=0;
+
+/* Not zero if linking a base relative executable.  This is recognized by
+   presence of "-m amiga_bss" on the linker's commandline.  */
+static int flag_baserel=0;
+
+/* Not zero if some of the specified libraries are dynamic.  */
+static int found_dynamic_libs=0;
+
+/* List of linker libraries.  */
+struct liblist *head = NULL;
+
+/* Return 1 if collect2 should do something more apart from tlink. We want it
+   to call "postlink" and "strip" if linking with dynamic libraries.  */
+
+int
+amigaos_do_collecting (void)
+{
+  return !flag_static;
+}
+
+/* Check for presence of "-static" on the GCC command line.  We should not do
+   collecting if this flag was specified.  */
+
+void
+amigaos_gccopts_hook (const char *arg)
+{
+  if (strncmp(arg, "-static", strlen("-static"))==0)
+    flag_static=1;
+}
+
+/* Replace unprintable characters with underscores.  Used by "add_lib()".  */
+
+static void
+safename (char *p)
+{
+  if (!ISALPHA(*p))
+    *p = '_';
+  p++;
+  while (*p)
+    {
+      if (!ISALNUM(*p))
+	*p = '_';
+      p++;
+    }
+}
+
+/* Add a library to the list of dynamic libraries.  First make sure that the
+   library is actually dynamic.  Used by "amigaos_libname_hook()".  */
+
+static void
+add_lib (const char *name)
+{
+  struct liblist *lib;
+  static char buf[256];
+
+  for (lib = head; lib; lib = lib->next)
+    if (!strcmp(lib->name, name))
+      return;
+
+  /* A2IXDIR_PREFIX is passed by "make".  */
+  sprintf(buf, A2IXDIR_PREFIX "/ldscripts/%s.x", name);
+  if (access(buf, R_OK))
+    return;
+
+  lib = (struct liblist*)xmalloc(sizeof(struct liblist));
+  lib->name = xstrdup(name);
+  lib->cname = xstrdup(name);
+  safename(lib->cname);
+  lib->next = head;
+  head = lib;
+
+  if (debug)
+    fprintf(stderr, "found dynamic library, name: %s, cname: %s\n", lib->name,
+	    lib->cname);
+
+  found_dynamic_libs=1;
+}
+
+/* Check if the argument is a linker library.  Call "add_lib()" if yes.  */
+
+void
+amigaos_libname_hook (const char *arg)
+{
+  int len = strlen(arg);
+  if (flag_static)
+    return;
+
+  if (len > 2 && !memcmp(arg, "-l", 2))
+    add_lib(arg + 2);
+  else if (len > 2 && !strcmp(arg + len - 2, ".a"))
+    {
+      const char *lib;
+
+      ((char*)arg)[len - 2] = '\0';
+      lib = strrchr(arg, '/');
+      if (lib == NULL)
+	lib = strrchr(arg, ':');
+      if (lib == NULL)
+	lib = arg - 1;
+      if (!strncmp(lib + 1, "lib", 3))
+	add_lib(lib + 4);
+      ((char *)arg)[len - 2] = '.';
+    }
+}
+
+/* Delete temporary files.  */
+
+void
+amigaos_collect2_cleanup (void)
+{
+  if (flag_static)
+    return;
+  maybe_unlink(XLIBS_C_NAME);
+  maybe_unlink(XLIBS_O_NAME);
+  maybe_unlink(SHARED_X_NAME);
+}
+
+/* Copy file named by FNAME to X.  */
+
+static void
+cat (const char *fname, FILE *x)
+{
+#define BUFSIZE 16384
+  FILE *in;
+  static char buf[BUFSIZE];
+  int bytes;
+  
+  in = fopen(fname, "r");
+  if (in == NULL)
+    fatal_error (input_location, "%s", fname);
+  while (!feof(in) && (bytes = fread(buf, 1, BUFSIZE, in)))
+    fwrite(buf, 1, bytes, x);
+  fclose(in);
+}
+
+/* If no dynamic libraries were found, perform like "-static".  Otherwise,
+   create "xlibs.c", "shared.x" and invoke "gcc" to create "xlibs.o".  We also
+   have to adjust the linker commandline.  */
+
+void
+amigaos_prelink_hook (const char **ld1_argv, int *strip_flag)
+{
+  if (flag_static)
+    return;
+
+  if (!found_dynamic_libs)
+    {
+      flag_static=1;
+      /* If the user has not requested "-static", but has requested "-s",
+	 collect2 removes "-s" from the "ld1_argv", and calls "strip" after
+	 linking.  However, this would not be efficient if we linked the
+	 executable without any dynamic library.  In this case, we put "-s"
+	 back.  */
+      if (*strip_flag)
+	{
+	  /* Add "-s" as the last argument on the command line.  */
+	  while (*ld1_argv)
+	    ld1_argv++;
+	  *ld1_argv++="-s";
+	  *ld1_argv=0;
+	  *strip_flag=0;
+	}
+    }
+  else
+    {
+      FILE *x, *out;
+      struct liblist *lib;
+      static const char* argv[]={0, "-c", XLIBS_C_NAME, 0};
+      const char **ld1_end, **ld1;
+
+      /* Prepend suffixes to dynamic lib names. In addition, check if we are
+	 linking a base relative executable.  */
+      for (ld1=ld1_argv; *ld1; ld1++)
+	{
+	  int len=strlen(*ld1);
+	  if (strncmp(*ld1, "-l", strlen("-l"))==0)
+	    {
+	      for (lib=head; lib; lib=lib->next)
+		if (strcmp(*ld1+strlen("-l"), lib->name)==0)
+		  {
+		    char *newname=(char*)
+			    xmalloc(strlen(*ld1)+strlen(DYNAMIC_LIB_SUFFIX)+1);
+		    strcpy(newname, *ld1);
+		    strcat(newname, DYNAMIC_LIB_SUFFIX);
+		    *ld1=newname;
+		    break;
+		  }
+	    }
+	  else if (len > 2 && !strcmp(*ld1 + len - 2, ".a"))
+	    {
+	      const char *libname;
+	      int substituted=0;
+
+	      ((char *)(*ld1))[len - 2] = '\0';
+	      libname = strrchr(*ld1, '/');
+	      if (libname == NULL)
+		libname = strrchr(*ld1, ':');
+	      if (libname == NULL)
+		libname = *ld1 - 1;
+	      if (!strncmp(libname + 1, "lib", 3))
+		for (lib=head; lib; lib=lib->next)
+		  if (strcmp(libname+4, lib->name)==0)
+		    {
+		      char *newname=(char*)xmalloc(strlen(*ld1)+
+					    strlen(DYNAMIC_LIB_SUFFIX)+3);
+		      strcpy(newname, *ld1);
+		      strcat(newname, DYNAMIC_LIB_SUFFIX);
+		      strcat(newname, ".a");
+		      *ld1=newname;
+		      substituted=1;
+		      break;
+		    }
+	      if (!substituted)
+		((char *)(*ld1))[len - 2] = '.';
+	    }
+	  else if (strcmp(ld1[0], "-m")==0 && ld1[1]
+		   && strcmp(ld1[1], "amiga_bss")==0)
+	    {
+	      flag_baserel=1;
+	      break;
+	    }
+	}
+
+      out = fopen(XLIBS_C_NAME, "w");
+      if (out == NULL)
+	fatal_error (input_location, "%s", XLIBS_C_NAME);
+      x = fopen(SHARED_X_NAME, "w");
+      if (x == NULL)
+	fatal_error (input_location, "%s", SHARED_X_NAME);
+
+      cat((flag_baserel ? A2IXDIR_PREFIX "/amiga_exe_baserel_script.x"
+			: A2IXDIR_PREFIX "/amiga_exe_script.x"), x);
+      for (lib = head; lib; lib = lib->next)
+	{
+	  static char buf[256];
+	  sprintf(buf, A2IXDIR_PREFIX "/ldscripts/%s.x", lib->name);
+	  fprintf(out, "extern long %sBase; long *__p%sBase = &%sBase;\n",
+		  lib->cname, lib->cname, lib->cname);
+	  cat(buf, x);
+	} /* {{ */
+      fprintf(x, "}}\n");
+      fclose(out);
+      fclose(x);
+      argv[0]=c_file_name;
+      fork_execute("gcc", (char **)argv, false);
+
+      /* Unfortunately, unlike "-s", "-T" cannot be specified as the last
+	 argument. We put it after "-L" args.  */
+      ld1_end=ld1_argv;
+      while (*ld1_end)
+	ld1_end++;
+      ld1_end++;
+      /* "ld1_end" now points after the terminating 0 of "ld1_argv".  */
+
+      ld1=ld1_end-2;
+      while (ld1>ld1_argv && strncmp(*ld1, "-L", strlen("-L")))
+	ld1--;
+      if (ld1==ld1_argv)
+	fatal_error (input_location, "no -L arguments");
+      ld1++;
+      /* "ld1" now points after "-L".  */
+
+      /* Shift all the arguments after "-L" one position right.  */
+      memmove(ld1+1, ld1, (ld1_end-ld1)*sizeof(*ld1));
+      /* Put -Tshared.x in the now empty space.  */
+      *ld1="-T" SHARED_X_NAME;
+    }
+}
+
+/* Be lazy and just call "postlink".  */
+
+void
+amigaos_postlink_hook (const char *output_file)
+{
+  static const char *argv[]={"postlink", 0, 0, 0};
+  if (flag_static)
+    return;
+
+  if (flag_baserel)
+    {
+      argv[1]="-baserel";
+      argv[2]=output_file;
+    }
+  else
+    argv[1]=output_file;
+  fork_execute("postlink", (char **)argv, false);
+}
diff --git a/gcc/bbb-opts.c b/gcc/bbb-opts.c
new file mode 100644
index 00000000000..d7fbc0ce100
--- /dev/null
+++ b/gcc/bbb-opts.c
@@ -0,0 +1,5627 @@
+/* Bebbo's Optimizations.
+ Copyright (C) 2010-2017 Free Software Foundation, Inc.
+ Copyright (C) 2017 Stefan "Bebbo" Franke.
+
+ This file is part of GCC.
+
+ GCC is free software; you can redistribute it and/or modify it under
+ the terms of the GNU General Public License as published by the Free
+ Software Foundation; either version 3, or (at your option) any later
+ version.
+
+ GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+ WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING3.  If not see
+ <http://www.gnu.org/licenses/>.  */
+
+/**
+ * SBF (Stefan "Bebbo" Franke):
+ *
+ * This pass performs multiple optimizations.
+ *
+ * #1 propagate_moves
+ * check if a->b->a can be moved out of a loop.
+ *
+ * #2 strcpy
+ * check if a temp reg can be eliminated.
+ *
+ * #3 const_comp_sub
+ * convert a compare with int constant into sub statement.
+ *
+ * #4 merge_add
+ * merge adds
+ *
+ * #5 elim_dead_assign
+ * eliminate some dead assignments.
+ *
+ * #6 shrink stack frame
+ * remove push/pop for unused variables
+ *
+ * #7 rename register
+ * rename registers without breaking register parameters, inline asm etc.
+ *
+ * Lessons learned:
+ *
+ * - do not trust existing code, better delete insns and inster a new one.
+ * - do not modify insns, create new insns from pattern
+ * - do not reuse registers, create new reg rtx instances
+ *
+ */
+
+#include "config.h"
+#define INCLUDE_VECTOR
+#define INCLUDE_SET
+#define INCLUDE_MAP
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tm_p.h"
+#include "insn-config.h"
+#include "recog.h"
+#include "cfgrtl.h"
+#include "emit-rtl.h"
+#include "tree.h"
+#include "tree-pass.h"
+#include "conditions.h"
+#include "langhooks.h"
+#include "output.h"
+#include <vector>
+#include <set>
+#include <map>
+
+//#define XUSE(c) fputc(c, stderr)
+#define XUSE(c) done = 0
+
+int be_very_verbose;
+bool be_verbose;
+
+bool optimize_this_for_speed_p;
+extern bool
+optimize_function_for_speed_p (struct function *fun);
+
+extern struct lang_hooks lang_hooks;
+
+static void
+update_insn_infos (void);
+static unsigned
+track_regs ();
+
+/* Lookup of the current function name. */
+extern tree current_function_decl;
+static tree last_function_decl;
+static char fxname[512];
+static char const *
+get_current_function_name ()
+{
+  if (current_function_decl == NULL)
+    strcpy (fxname, "<toplevel>");
+  else
+    strcpy (fxname, lang_hooks.decl_printable_name (current_function_decl, 2));
+  return fxname;
+}
+
+/* a simple log to stdout. */
+static int
+log (char const * fmt, ...)
+{
+  if (!be_verbose)
+    return 0;
+
+  va_list args;
+  va_start(args, fmt);
+  if (last_function_decl != current_function_decl)
+    {
+      last_function_decl = current_function_decl;
+      printf (":bbb: in '%s'\n", get_current_function_name ());
+    }
+  printf (":bbb: ");
+  int retval = vprintf (fmt, args);
+  va_end(args);
+  fflush (stdout);
+  return retval;
+}
+
+enum proepis
+{
+  IN_CODE, IN_PROLOGUE, IN_EPILOGUE, IN_EPILOGUE_PARALLEL_POP
+};
+
+/**
+ * What's needed to track values?
+ */
+class track_var
+{
+  /** The cached value.
+   * CONST_INT: if < 0x100000000: a real int value
+   *            else: a value encoded from the line where the value was created.
+   * MEM: the rtx
+   */
+  rtx value[FIRST_PSEUDO_REGISTER];
+
+  /*
+   * the bitmask of the used registers. needed for invalidation.
+   */
+  unsigned usedRegs[FIRST_PSEUDO_REGISTER];
+
+  /**
+   * contains the bits containing a value.
+   */
+  unsigned andMask[FIRST_PSEUDO_REGISTER];
+
+  bool
+  extend (rtx * z, machine_mode dstMode, rtx x)
+  {
+    switch (GET_CODE(x))
+      {
+      case CONST_INT:
+      case CONST_FIXED:
+      case CONST_DOUBLE:
+      case SYMBOL_REF:
+      case LABEL_REF:
+	/* these can be used directly. */
+	*z = x;
+	return true;
+
+      case REG:
+	{
+	  rtx v = value[REGNO(x)];
+	  unsigned v_usedRegs = usedRegs[REGNO(x)];
+	  /* try to expand the register. */
+	  if (v)
+	    {
+	      if (dstMode != GET_MODE(v) && (GET_CODE(v) != CONST_INT || v_usedRegs == (1 << FIRST_PSEUDO_REGISTER)))
+		return false;
+
+	      *z = v;
+	      return true;
+	    }
+
+	  /* store the reg otherwise. */
+	  if (GET_MODE(x) == dstMode)
+	    *z = x;
+	  else
+	    *z = gen_rtx_REG (dstMode, REGNO(x));
+	  return true;
+	}
+      case PLUS:
+      case MINUS:
+	// handle only in combination with const
+	{
+	  rtx y = XEXP(x, 0);
+	  if (GET_CODE(y) != SYMBOL_REF && GET_CODE(y) == LABEL_REF && amiga_is_const_pic_ref (y))
+	    return false;
+
+	  if (GET_CODE(x) == PLUS) // create an own plus to be able to modify the constant offset (later).
+	    *z = gen_rtx_PLUS(GET_MODE(x), y, XEXP(x, 1));
+	  else
+	    *z = gen_rtx_MINUS(GET_MODE(x), y, XEXP(x, 1));
+	  return true;
+	}
+
+	/* memory reads. */
+      case MEM:
+	{
+	  rtx m = XEXP(x, 0);
+	  switch (GET_CODE(m))
+	    {
+	    case SYMBOL_REF:
+	    case LABEL_REF:
+	      /* these can be used directly. */
+	      *z = x;
+	      return true;
+
+	    case REG:
+	      if (!extend (&m, dstMode, m))
+		return false;
+
+	      *z = gen_rtx_MEM (GET_MODE(x), m);
+	      return true;
+
+	    case PLUS:
+	    case MINUS:
+	      // handle only in combination with const
+	      {
+		rtx y = XEXP(m, 0);
+		if (!REG_P(y) && GET_CODE(y) != SYMBOL_REF && GET_CODE(y) == LABEL_REF && amiga_is_const_pic_ref (y))
+		  return false;
+
+		if (REG_P(y))
+		  if (!extend (&y, dstMode, y))
+		    return false;
+
+		if (GET_CODE(x) == PLUS) // create an own plus to be able to modify the constant offset (later).
+		  m = gen_rtx_PLUS(GET_MODE(m), y, XEXP(m, 1));
+		else
+		  m = gen_rtx_MINUS(GET_MODE(m), y, XEXP(m, 1));
+
+		*z = gen_rtx_MEM (GET_MODE(x), m);
+		return true;
+	      }
+	    default:
+	      return false;
+	    }
+	  break;
+	}
+      default:
+	return false;
+      }
+  }
+
+public:
+  track_var (track_var const * o = 0)
+  {
+    if (o)
+      assign (o);
+    else
+      for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+	{
+	  value[i] = 0;
+	  usedRegs[i] = 0;
+	  andMask[i] = 0xffffffff;
+	}
+  }
+
+  int
+  find_alias (rtx src)
+  {
+    rtx z = 0;
+    if (extend (&z, GET_MODE(src), src))
+      {
+	for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+	  {
+	    // do not alias small int value from -128 ... 127
+	    if (rtx_equal_p (z, value[i]) && (GET_CODE(z) != CONST_INT || INTVAL(z) > 127 || INTVAL(z) < -128))
+	      return i;
+	  }
+      }
+    return -1;
+  }
+  void
+  invalidate_mem (rtx dst)
+  {
+    rtx z = 0;
+    if (extend (&z, GET_MODE(dst), dst))
+      {
+	for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+	  {
+	    if (rtx_equal_p (z, value[i]))
+	      {
+		value[i] = 0;
+		usedRegs[i] = 0;
+		andMask[i] = 0xffffffff;
+	      }
+	  }
+      }
+  }
+
+  rtx
+  get (unsigned regno) const
+  {
+    if (regno >= FIRST_PSEUDO_REGISTER)
+      return 0;
+
+    return value[regno];
+  }
+
+  unsigned getMask(unsigned regno) const
+  {
+    if (regno >= FIRST_PSEUDO_REGISTER)
+      return 0xffffffff;
+
+    return andMask[regno];
+  }
+
+  void
+  set (machine_mode mode, unsigned regno, rtx src, unsigned my_use, unsigned index)
+  {
+    if (regno >= FIRST_PSEUDO_REGISTER)
+      return;
+
+    if (mode == DImode && GET_CODE(src) == CONST_INT)
+      {
+	rtx hi = gen_rtx_CONST_INT(VOIDmode, INTVAL(src) >> 32);
+	rtx lo = gen_rtx_CONST_INT(VOIDmode, INTVAL(src) & 0xffffffff);
+	set(SImode, regno, hi, my_use, index);
+	set(SImode, regno + 1, lo, my_use, index);
+	return;
+      }
+
+    if (mode == SFmode && regno < 16)
+      mode = SImode;
+
+    for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+      {
+	if (usedRegs[i] & (1 << regno))
+	  {
+	    value[i] = 0;
+	    usedRegs[i] = 0;
+	    andMask[i] = 0xffffffff;
+	  }
+      }
+
+    if (extend (&value[regno], mode, src))
+      {
+	if (GET_CODE(src) == CONST_INT)
+	  {
+	    unsigned iv = UINTVAL(src);
+	    iv |= iv >> 16;
+	    iv |= iv >> 8;
+	    iv |= iv >> 4;
+	    iv |= iv >> 2;
+	    iv |= iv >> 1;
+
+	    setMask(regno, iv, mode);
+	  }
+	else
+	  andMask[regno] = 0xffffffff;
+
+	usedRegs[regno] = my_use;
+	// convert reg value int regs value.
+	if (REG_P(value[regno]))
+	  {
+	    unsigned refregno = REGNO(value[regno]);
+	    rtx val = value[refregno];
+	    if (!val)
+	      {
+		val = gen_rtx_CONST_INT(mode, 0x100000000000000LL | ((long long int ) (refregno) << 32) | (0xffffffff & -index));
+		value[refregno] = val;
+	      }
+	    value[regno] = val;
+	    usedRegs[regno] = usedRegs[refregno];
+	  }
+      }
+    else
+      {
+	clear (mode, regno, index);
+      }
+  }
+
+  /** store the and mask or combine it with a previous mask. */
+  void
+  setMask(unsigned regno, unsigned mask, machine_mode mode)
+  {
+    if (GET_MODE_SIZE(mode) < 2)
+      mask |= 0xffffff00;
+    else
+    if (GET_MODE_SIZE(mode) < 4)
+      mask |= 0xffff0000;
+    andMask[regno] &= mask;
+  }
+
+  bool
+  equals (machine_mode dmode, unsigned regno, rtx x)
+  {
+    if (regno >= FIRST_PSEUDO_REGISTER)
+      return false;
+
+    if (x == 0 || value[regno] == 0)
+      return false;
+
+    machine_mode mode = GET_MODE(value[regno]);
+    if (dmode == DImode && mode == VOIDmode && GET_CODE(x) == CONST_INT)
+      {
+	rtx hi = gen_rtx_CONST_INT(VOIDmode, INTVAL(x) >> 32);
+	rtx lo = gen_rtx_CONST_INT(VOIDmode, INTVAL(x) & 0xffffffff);
+	return equals(VOIDmode, regno, hi) && equals(VOIDmode, regno + 1, lo);
+      }
+
+    machine_mode xmode = GET_MODE(x);
+    if (REG_P(x) && REGNO(x) < 16 && xmode == SFmode)
+      xmode = SImode;
+
+    if (mode == SFmode && regno < 16)
+      mode = SImode;
+
+    if (mode != xmode)
+      return false;
+
+    rtx z = 0;
+    if (!extend (&z, GET_MODE(x), x))
+      return false;
+
+    return rtx_equal_p (z, value[regno]);
+  }
+
+  void
+  clear (machine_mode mode, unsigned regno, unsigned index)
+  {
+    if (regno >= FIRST_PSEUDO_REGISTER)
+      return;
+
+    if (mode == SFmode && regno < 16)
+      mode = SImode;
+    value[regno] = gen_rtx_CONST_INT(mode, 0x100000000000000LL | ((long long int ) (regno) << 32) | index);
+    usedRegs[regno] = 1 << FIRST_PSEUDO_REGISTER;
+    andMask[regno] = 0xffffffff;
+  }
+
+  void
+  clear_aftercall (unsigned index)
+  {
+    for (int i = 2; i < FIRST_PSEUDO_REGISTER; ++i)
+      {
+	if (value[i] && MEM_P(value[i]))
+	  {
+	    value[i] = 0;
+	    usedRegs[i] = 0;
+	    andMask[i] = 0xffffffff;
+	  }
+      }
+    clear (SImode, 0, index);
+    clear (SImode, 1, index);
+    clear (SImode, 8, index);
+    clear (SImode, 9, index);
+    clear (SImode, 16, index);
+    clear (SImode, 17, index);
+  }
+
+  void
+  clear_for_mask (unsigned def, unsigned index)
+  {
+    if (!def)
+      return;
+    for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)
+      {
+	// register changed or used somehow
+	if ((1 << regno) & def)
+	  clear (SImode, regno, index);
+      }
+  }
+
+  void
+  assign (track_var const * o)
+  {
+    for (int i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+      {
+	value[i] = o->value[i];
+	usedRegs[i] = o->usedRegs[i];
+	andMask[i] = o->andMask[i];
+      }
+  }
+
+  /* only keep common values in both sides. */
+  void
+  merge (track_var * o, unsigned)
+  {
+    for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+      {
+	if (!rtx_equal_p (value[i], o->value[i]))
+	  {
+	    value[i] = o->value[i] = 0;
+	    usedRegs[i] = 0;
+	  }
+	o->andMask[i] = andMask[i] |= o->andMask[i]; // or the masks
+      }
+  }
+
+  /* true if a merge would not change anything.  */
+  bool
+  no_merge_needed (track_var const * o) const
+  {
+    for (unsigned i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+      {
+	if (!rtx_equal_p (value[i], o->value[i]) || andMask[i] != (andMask[i] | o->andMask[i]))
+	  return false;
+      }
+    return true;
+  }
+};
+
+/* Information for each insn to detect alive registers. Enough for m68k.
+ * Why a class? Maybe extend it for general usage.
+ *
+ * Track use & def separate to determine starting points.
+ */
+class insn_info
+{
+  rtx_insn * insn; // the insn
+
+// usage flags
+  unsigned myuse;  // bit set if registers are used in this statement
+  unsigned hard; // bit set if registers can't be renamed
+  unsigned use;  // bit set if registers are used in program flow
+  unsigned def;  // bit set if registers are defined here
+
+  enum proepis proepi;
+
+  bool stack; // part of stack frame insns
+
+// stuff to analyze insns
+  bool label;
+  bool jump;
+  bool call;
+  bool compare;
+  bool dst_mem;
+  bool src_mem;
+  bool dst_plus;
+  bool src_plus;
+  rtx_code src_op;
+  bool src_ee;
+  bool src_2nd;
+  bool src_const;
+
+  machine_mode mode;
+
+  rtx dst_reg;
+  rtx dst_mem_reg;
+  rtx dst_symbol;
+  rtx src_reg;
+  rtx src_mem_reg;
+  rtx src_symbol;
+  long int dst_mem_addr;
+  long int src_intval;
+  long int src_mem_addr;
+
+  bool visited;
+
+  int sp_offset;
+
+  int dst_autoinc;
+  int src_autoinc;
+
+  unsigned multi_reg; /* bit field for register pairs. */
+
+// values for all variables - if used
+  track_var * track;
+
+public:
+  insn_info (rtx_insn * i = 0, enum proepis p = IN_CODE) :
+      insn (i), myuse (0), hard (0), use (0), def (0), proepi (p), stack (false), label (false), jump (false), call (
+	  false), compare (false), dst_mem (false), src_mem (false), dst_plus (false), src_plus (false), src_op (
+	  (rtx_code) 0), src_ee (false), src_2nd (false), src_const (false), mode (VOIDmode), dst_reg (0), dst_mem_reg (
+	  0), dst_symbol (0), src_reg (0), src_mem_reg (0), src_symbol (0), dst_mem_addr (0), src_intval (0), src_mem_addr (
+	  0), visited (false), sp_offset (0), dst_autoinc (0), src_autoinc (0), multi_reg(0), track (0)
+  {
+  }
+
+  unsigned
+  get_multi_reg () const
+  {
+    return multi_reg;
+  }
+
+  track_var *
+  get_track_var ();
+
+  inline ptrdiff_t
+  operator < (insn_info const & o) const
+  {
+    return this - &o;
+  }
+
+  int
+  get_index () const;
+
+  void
+  plus_to_move (rtx_insn * newinsn);
+
+  void
+  swap_adds (rtx_insn * newinsn, insn_info & ii);
+
+  void
+  absolute2base (unsigned regno, unsigned base, rtx with_symbol);
+
+  rtx
+  make_absolute2base (unsigned regno, unsigned base, rtx with_symbol, bool apply);
+
+  inline bool
+  is_compare () const
+  {
+    return compare;
+  }
+
+  inline machine_mode
+  get_mode () const
+  {
+    return mode;
+  }
+
+  inline bool
+  is_dst_reg () const
+  {
+    return dst_reg;
+  }
+
+  inline bool
+  is_dst_mem () const
+  {
+    return dst_mem;
+  }
+
+  inline bool
+  is_src_mem () const
+  {
+    return src_mem;
+  }
+
+  inline bool
+  is_src_mem_2nd () const
+  {
+    return src_2nd && src_mem;
+  }
+
+  inline bool
+  has_dst_memreg () const
+  {
+    return dst_mem_reg;
+  }
+
+  inline bool
+  has_src_memreg () const
+  {
+    return src_mem_reg;
+  }
+
+  inline rtx
+  get_dst_symbol () const
+  {
+    return dst_symbol;
+  }
+
+  inline rtx
+  get_src_symbol () const
+  {
+    return src_symbol;
+  }
+  inline bool
+  has_dst_addr () const
+  {
+    return dst_mem_addr;
+  }
+
+  inline bool
+  has_src_addr () const
+  {
+    return src_mem_addr;
+  }
+
+  inline bool
+  is_label () const
+  {
+    return label;
+  }
+
+  inline bool
+  is_jump () const
+  {
+    return jump;
+  }
+
+  inline bool
+  is_call () const
+  {
+    return call;
+  }
+
+  inline unsigned
+  get_dst_mem_addr () const
+  {
+    return dst_mem_addr;
+  }
+
+  inline unsigned
+  get_src_mem_addr () const
+  {
+    return src_mem_addr;
+  }
+
+  inline bool
+  is_src_reg () const
+  {
+    return src_reg && !src_op;
+  }
+
+  inline int
+  get_src_op () const
+  {
+    return src_op;
+  }
+
+  inline bool
+  is_src_ee () const
+  {
+    return src_ee;
+  }
+
+  inline bool
+  is_src_mem_plus () const
+  {
+    return src_mem && src_plus;
+  }
+
+  inline bool
+  is_dst_mem_plus () const
+  {
+    return dst_mem && dst_plus;
+  }
+
+  inline int
+  get_dst_regno () const
+  {
+    return dst_reg ? REGNO(dst_reg) : -1;
+  }
+
+  inline int
+  get_src_regno () const
+  {
+    return src_reg ? REGNO(src_reg) : -1;
+  }
+
+  inline rtx
+  get_src_reg () const
+  {
+    return src_reg;
+  }
+
+  inline rtx
+  get_dst_reg () const
+  {
+    return dst_reg;
+  }
+
+  inline int
+  get_src_mem_regno () const
+  {
+    return src_mem_reg ? REGNO(src_mem_reg) : -1;
+  }
+
+  inline int
+  get_dst_mem_regno () const
+  {
+    return dst_mem_reg ? REGNO(dst_mem_reg) : -1;
+  }
+
+  inline rtx
+  get_src_mem_reg () const
+  {
+    return src_mem_reg;
+  }
+
+  inline rtx
+  get_dst_mem_reg () const
+  {
+    return dst_mem_reg;
+  }
+
+  inline int
+  get_src_intval () const
+  {
+    return src_intval;
+  }
+
+  inline int
+  get_dst_intval () const
+  {
+    return dst_mem_addr;
+  }
+
+  inline bool
+  is_src_const () const
+  {
+    return src_const;
+  }
+
+  inline void
+  mark_jump ()
+  {
+    jump = true;
+  }
+  inline void
+  mark_call ()
+  {
+    call = true;
+  }
+  inline void
+  mark_label ()
+  {
+    label = true;
+  }
+
+  void
+  fledder (rtx set);
+
+  void
+  fledder_src_mem (rtx src);
+
+  /* update usage. */
+  void
+  update (insn_info & o)
+  {
+    myuse = o.myuse;
+    hard = o.hard;
+    use = o.use;
+    def = o.def;
+    multi_reg = o.multi_reg;
+  }
+
+  inline rtx_insn *
+  get_insn () const
+  {
+    return insn;
+  }
+
+  void
+  mark_stack ()
+  {
+    stack = true;
+  }
+
+  bool
+  is_stack () const
+  {
+    return stack;
+  }
+
+  inline enum proepis
+  in_proepi () const
+  {
+    return proepi;
+  }
+
+  inline void
+  set_proepi (enum proepis p)
+  {
+    proepi = p;
+  }
+
+  inline void
+  reset_flags ()
+  {
+    label = false;
+    jump = false;
+    compare = false;
+    dst_mem = false;
+    src_mem = false;
+    dst_plus = false;
+    src_plus = false;
+    src_op = (rtx_code) 0;
+    src_ee = false;
+    src_const = false;
+
+    mode = VOIDmode;
+
+    dst_reg = 0;
+    dst_mem_reg = 0;
+    dst_symbol = 0;
+    src_reg = 0;
+    src_mem_reg = 0;
+    src_symbol = 0;
+    dst_mem_addr = 0;
+
+    src_intval = 0;
+    src_mem_addr = 0;
+
+    dst_autoinc = 0;
+    src_autoinc = 0;
+  }
+
+  inline int
+  get_src_autoinc () const
+  {
+    return src_autoinc;
+  }
+
+  inline int
+  get_dst_autoinc () const
+  {
+    return dst_autoinc;
+  }
+
+  inline bool
+  is_empty ()
+  {
+    return !def && !use && !hard;
+  }
+
+  inline void
+  mark_myuse (int regno)
+  {
+    myuse |= 1 << regno;
+    use |= 1 << regno;
+  }
+
+  inline void
+  mark_use (int regno)
+  {
+    use |= 1 << regno;
+  }
+
+  inline void
+  mark_def (int regno)
+  {
+    def |= 1 << regno;
+  }
+
+  inline void
+  mark_hard (int regno)
+  {
+    hard |= 1 << regno;
+  }
+
+  inline void
+  unset (int regno)
+  {
+    use &= ~(1 << regno);
+    def &= ~(1 << regno);
+    hard &= ~(1 << regno);
+  }
+
+  inline unsigned
+  get_use () const
+  {
+    return use;
+  }
+
+  inline void
+  set_use (unsigned u)
+  {
+    use = u;
+  }
+
+  inline unsigned
+  get_myuse () const
+  {
+    return myuse;
+  }
+
+  inline void
+  set_myuse (unsigned u)
+  {
+    myuse = u;
+  }
+
+  inline unsigned
+  get_def () const
+  {
+    return def;
+  }
+
+  inline void
+  set_def(unsigned u)
+  {
+    def = u;
+  }
+
+  inline unsigned
+  get_hard () const
+  {
+    return hard;
+  }
+
+  inline bool
+  is_use (int regno)
+  {
+    return (use & (1 << regno)) != 0;
+  }
+
+  inline bool
+  is_myuse (int regno)
+  {
+    return (myuse & (1 << regno)) != 0;
+  }
+
+  inline bool
+  is_def (int regno)
+  {
+    return (def & (1 << regno)) != 0;
+  }
+
+  inline bool
+  is_hard (int regno)
+  {
+    return (hard & (1 << regno)) != 0;
+  }
+
+  inline void
+  clear_hard_def ()
+  {
+    hard = 0;
+    def = 0;
+  }
+
+  /*
+   * update for previous insn.
+   * - remove regs which are defined here
+   * - add regs which are used here
+   * - reset _def
+   * - restrain _hard to used
+   */
+  inline void
+  updateWith (insn_info const & o)
+  {
+    use &= ~o.def;
+    use |= o.use;
+    def = 0;
+  }
+
+  inline insn_info &
+  merge (insn_info const & o)
+  {
+    myuse = o.myuse;
+    use = (use & ~o.def) | o.use;
+    def |= o.def;
+    hard |= o.hard;
+    multi_reg = o.multi_reg;
+    return *this;
+  }
+
+  inline insn_info &
+  or_def (insn_info const & o)
+  {
+    def |= o.def;
+    return *this;
+  }
+
+  inline insn_info &
+  drop_def ()
+  {
+    use &= ~def;
+    return *this;
+  }
+
+  inline insn_info &
+  make_hard ()
+  {
+    hard = use | def;
+    return *this;
+  }
+
+  inline insn_info &
+  make_clobber ()
+  {
+    hard = use = def = use | def;
+    return *this;
+  }
+
+  inline bool
+  contains (insn_info const & o) const
+  {
+    if (o.def & ~def)
+      return false;
+    if (o.use & ~use)
+      return false;
+    if (o.hard & ~hard)
+      return false;
+    return true;
+  }
+
+  inline int
+  get_sp_offset () const
+  {
+    return sp_offset;
+  }
+
+  inline void
+  set_sp_offset (int sp)
+  {
+    sp_offset = sp;
+  }
+
+  inline bool
+  is_visited () const
+  {
+    return visited;
+  }
+
+  inline void
+  mark_visited ()
+  {
+    visited = true;
+  }
+
+  inline void
+  clear_visited ()
+  {
+    visited = false;
+  }
+
+  void
+  scan ();
+
+  void
+  scan_rtx (rtx);
+
+  bool
+  make_post_inc (int regno);
+
+  void
+  auto_inc_fixup (int regno, int size);
+
+  /* return bits for alternate free registers. */
+  unsigned
+  get_free_mask () const
+  {
+    if (def & hard)
+      return 0;
+
+    if (!def)
+      return 0;
+
+    unsigned def_no_cc = def & ~(1 << FIRST_PSEUDO_REGISTER);
+    if (def_no_cc > 0x4000)
+      return 0;
+
+    unsigned mask = def_no_cc - 1;
+    /* more than one register -> don't touch. */
+    if ((mask & ~def) != mask)
+      return 0;
+
+    if (def_no_cc > 0xff)
+      mask &= 0xff00;
+
+    return mask & ~use;
+  }
+
+  unsigned
+  get_regbit () const
+  {
+    if (GET_MODE_SIZE(mode) > 4)
+      return 0;
+    return def & ~hard & ~use & 0x7fff;
+  }
+
+  void
+  set_insn (rtx_insn * newinsn);
+
+  void
+  a5_to_a7 (rtx a7, int add);
+};
+
+bool
+insn_info::make_post_inc (int regno)
+{
+  rtx pattern = PATTERN (insn);
+  rtx_insn * new_insn = make_insn_raw (pattern);
+
+  // convert into POST_INC
+  rtx set0 = single_set (new_insn);
+  if (!set0)
+    return false;
+
+  rtx set = set0;
+
+  if (is_compare ())
+    set = SET_SRC(set);
+  rtx mem = get_dst_mem_regno () == regno ? SET_DEST(set) : SET_SRC(set);
+
+  if (src_op && get_src_mem_regno () == regno)
+    {
+      if (src_op == NEG || src_op == NOT || (src_op >= SIGN_EXTEND && src_op <= PARITY)
+    		  || src_op == SS_NEG || src_op == US_NEG || src_op == SS_ABS
+			  || src_op == SS_TRUNCATE || src_op == US_TRUNCATE)
+	mem = XEXP(mem, 0);
+      else
+	mem = XEXP(mem, 1);
+    }
+
+  rtx reg = XEXP(mem, 0);
+
+  XEXP(mem, 0) = gen_rtx_POST_INC(SImode, reg);
+
+  if (insn_invalid_p (new_insn, 0))
+    {
+      XEXP(mem, 0) = reg;
+      insn_invalid_p (insn, 0);
+      return 0;
+    }
+
+  SET_INSN_DELETED(insn);
+  (get_dst_mem_regno () == regno ? dst_autoinc : src_autoinc) = GET_MODE_SIZE(mode);
+  insn = emit_insn_after (PATTERN (new_insn), insn);
+  insn_invalid_p (insn, 0);
+
+  return 1;
+}
+
+static rtx
+add_clobbers (rtx_insn * oldinsn)
+{
+  rtx pattern = PATTERN (oldinsn);
+  if (GET_CODE(pattern) != PARALLEL)
+    return pattern;
+
+  int num_clobbers = 0;
+  for (int j = XVECLEN (pattern, 0) - 1; j >= 0; j--)
+    {
+      rtx x = XVECEXP(pattern, 0, j);
+      if (GET_CODE(x) == CLOBBER)
+	++num_clobbers;
+    }
+
+  if (!num_clobbers)
+    return pattern;
+
+  rtx newpat = gen_rtx_PARALLEL(VOIDmode, rtvec_alloc (num_clobbers + 1));
+  for (int j = XVECLEN (pattern, 0) - 1; j >= 0; j--)
+    {
+      rtx x = XVECEXP(pattern, 0, j);
+      if (GET_CODE(x) == CLOBBER)
+	XVECEXP(newpat, 0, num_clobbers--) = x;
+    }
+
+  XVECEXP(newpat, 0, 0) = XVECEXP(pattern, 0, 0);
+  return newpat;
+}
+
+void
+insn_info::auto_inc_fixup (int regno, int size)
+{
+//  debug_rtx (insn);
+  rtx set0 = single_set (insn);
+  rtx set = set0;
+  if (is_compare ())
+    set = SET_SRC(set);
+
+  // add to register
+  if (get_src_regno () == regno)
+    {
+      rtx src = SET_SRC(set);
+      if (get_src_intval () == size)
+	{
+	  src_intval = 0;
+	  src_plus = false;
+	  SET_SRC(set) = XEXP(src, 0);
+	}
+      else
+	XEXP(src, 1) = gen_rtx_CONST_INT (GET_MODE(XEXP(src, 1)), src_intval -= size);
+    }
+  else if (get_src_mem_regno () == regno)
+    {
+      // src mem used ?
+      rtx mem = SET_SRC(set);
+      if (src_op)
+	{
+	  if (MEM_P(XEXP(mem, 0)))
+	    mem = XEXP(mem, 0);
+	  else
+	    mem = XEXP(mem, 1);
+	}
+      rtx plus = XEXP(mem, 0);
+
+      if (src_mem_addr == size)
+	{
+	  XEXP(mem, 0) = XEXP(plus, 0);
+	  src_mem_addr = 0;
+	  src_plus = false;
+	}
+      else
+	XEXP(plus, 1) = gen_rtx_CONST_INT (GET_MODE(XEXP(plus, 1)), src_mem_addr -= size);
+    }
+
+  if (get_dst_mem_regno () == regno)
+    {
+      rtx mem = SET_DEST(set);
+      rtx plus = XEXP(mem, 0);
+      if (dst_mem_addr == size)
+	{
+	  XEXP(mem, 0) = XEXP(plus, 0);
+	  dst_mem_addr = 0;
+	  dst_plus = false;
+	}
+      else
+	XEXP(plus, 1) = gen_rtx_CONST_INT (GET_MODE(XEXP(plus, 1)), dst_mem_addr -= size);
+    }
+
+  rtx pattern = add_clobbers (insn);
+
+  SET_INSN_DELETED(insn);
+  insn = emit_insn_after (pattern, insn);
+}
+
+track_var *
+insn_info::get_track_var ()
+{
+  if (!track)
+    track = new track_var ();
+  return track;
+}
+
+void
+insn_info::scan ()
+{
+  rtx pattern = PATTERN (insn);
+  if (ANY_RETURN_P(pattern))
+    {
+      tree type = TYPE_SIZE(TREE_TYPE (DECL_RESULT (current_function_decl)));
+      int sz = type ? TREE_INT_CST_LOW(type) : 0;
+      // log ("return size %d\n", sz);
+      if (sz && sz <= 64)
+	{
+	  mark_hard (0);
+	  mark_myuse (0);
+	  if (sz > 32)
+	    {
+	      mark_hard (1);
+	      mark_myuse (1);
+	    }
+	}
+    }
+  else if (CALL_P(insn))
+    {
+      /* add mregparm registers. */
+      for (rtx link = CALL_INSN_FUNCTION_USAGE(insn); link; link = XEXP(link, 1))
+	{
+	  rtx op, reg;
+
+	  if (GET_CODE (op = XEXP (link, 0)) == USE && REG_P(reg = XEXP (op, 0)))
+	    for (unsigned r = REGNO(reg); r < END_REGNO (reg); ++r)
+	      mark_myuse (r);
+	}
+      /* mark scratch registers. */
+      mark_def (0);
+      mark_def (1);
+      mark_def (8);
+      mark_def (9);
+      mark_def (16);
+      mark_def (17);
+      /* also mark all registers as not renamable */
+      hard = use;
+    }
+  scan_rtx (pattern);
+}
+
+/* scan rtx for registers and set the corresponding flags. */
+void
+insn_info::scan_rtx (rtx x)
+{
+  if (REG_P(x))
+    {
+      int n0 = REG_NREGS(x);
+      for (int n = n0, r = REGNO(x); n > 0; --n, ++r)
+	{
+	  mark_myuse (r);
+	  if (n0 > 1)
+	    multi_reg |= 1<<r;
+	}
+      return;
+    }
+
+  if (x == cc0_rtx)
+    {
+      mark_myuse (FIRST_PSEUDO_REGISTER);
+      return;
+    }
+
+  RTX_CODE code = GET_CODE(x);
+
+  /* handle SET and record use and def. */
+  if (code == SET)
+    {
+      unsigned u = use;
+      unsigned mu = myuse;
+      use = myuse = 0;
+      rtx dst = SET_DEST(x);
+      scan_rtx (dst);
+      if (REG_P(dst) || ((GET_CODE(dst) == STRICT_LOW_PART || GET_CODE(dst) == SUBREG) && REG_P(XEXP(dst, 0))))
+	{
+	  def |= use;
+	  if ((GET_CODE(dst) == STRICT_LOW_PART || GET_CODE(dst) == SUBREG))
+	    use |= u;
+	  else
+	    use = u;
+	  myuse = mu;
+	}
+
+      // avoid side effects from myuse -> def, e.g. adding the dst reg to def by src auto inc
+      mu = myuse;
+      myuse = 0;
+      scan_rtx (SET_SRC(x));
+      myuse |= mu;
+
+      int code = GET_CODE(SET_SRC(x));
+      if (code == ASM_OPERANDS)
+	hard |= def | use;
+      return;
+    }
+
+  if (code == TRAP_IF)
+    {
+      /* mark all registers used. */
+      hard = use = myuse = (1 << FIRST_PSEUDO_REGISTER) - 1;
+      return;
+    }
+
+  const char *fmt = GET_RTX_FORMAT(code);
+  for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	scan_rtx (XEXP(x, i));
+      else if (fmt[i] == 'E')
+	for (int j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  {
+	    unsigned u = use;
+	    unsigned mu = myuse;
+	    unsigned d = def;
+	    unsigned mr = multi_reg;
+	    scan_rtx (XVECEXP(x, i, j));
+	    use |= u;
+	    myuse |= mu;
+	    def |= d;
+	    multi_reg |= mr;
+	    if ((def - 1) & def)
+	      multi_reg |= def;
+	  }
+    }
+
+  if (code == POST_INC || code == PRE_DEC || code == CLOBBER)
+    def |= myuse;
+  if (code == CLOBBER)
+    multi_reg |= def;
+}
+
+void
+insn_info::fledder_src_mem (rtx src)
+{
+  src_mem = true;
+  rtx mem = XEXP(src, 0);
+
+  if (GET_CODE(mem) == POST_INC)
+    src_autoinc = 1, mem = XEXP(mem, 0);
+  else if (GET_CODE(mem) == PRE_DEC)
+    src_autoinc = -1, mem = XEXP(mem, 0);
+
+  if (REG_P(mem))
+    src_mem_reg = mem;
+  else if (GET_CODE(mem) == CONST_INT)
+    src_mem_addr = INTVAL(mem);
+  else if (GET_CODE(mem) == SYMBOL_REF)
+    src_symbol = mem;
+  else if (GET_CODE(mem) == PLUS)
+    {
+      src_plus = true;
+      rtx reg = XEXP(mem, 0);
+      rtx konst = XEXP(mem, 1);
+      if (REG_P(reg) && GET_CODE(konst) == CONST_INT)
+	{
+	  src_mem_reg = reg;
+	  src_const = true;
+	  src_mem_addr = INTVAL(konst);
+	}
+    }
+  else if (GET_CODE(mem) == CONST)
+    {
+      mem = XEXP(mem, 0);
+      if (GET_CODE(mem) == PLUS)
+	{
+	  rtx sym = XEXP(mem, 0);
+	  if (GET_CODE(sym) == SYMBOL_REF)
+	    {
+	      src_plus = true;
+	      src_symbol = sym;
+	      src_mem_addr = INTVAL(XEXP(mem, 1));
+	    }
+	}
+    }
+}
+
+/* read the set and grab infos */
+void
+insn_info::fledder (rtx set)
+{
+  if (!set || GET_CODE(set) == PARALLEL)
+    return;
+
+  rtx dst = SET_DEST(set);
+  rtx src = SET_SRC(set);
+
+  if (dst == cc0_rtx)
+    {
+      compare = true;
+      set = src;
+      dst = SET_DEST(set);
+      src = SET_SRC(set);
+    }
+
+  if (GET_CODE(dst) == STRICT_LOW_PART || GET_CODE(dst) == SUBREG)
+    dst = XEXP(dst, 0);
+
+  mode = GET_MODE(dst);
+  if (mode == VOIDmode)
+    mode = GET_MODE(src);
+
+  if (REG_P(dst))
+    {
+      dst_reg = dst;
+    }
+  else if (MEM_P(dst))
+    {
+      dst_mem = true;
+      rtx mem = XEXP(dst, 0);
+
+      if (GET_CODE(mem) == POST_INC)
+	dst_autoinc = 1, mem = XEXP(mem, 0);
+      else if (GET_CODE(mem) == PRE_DEC)
+	dst_autoinc = -1, mem = XEXP(mem, 0);
+
+      if (REG_P(mem))
+	dst_mem_reg = mem;
+      else if (GET_CODE(mem) == CONST_INT)
+	dst_mem_addr = INTVAL(mem);
+      else if (GET_CODE(mem) == SYMBOL_REF)
+	dst_symbol = mem;
+      else if (GET_CODE(mem) == PLUS)
+	{
+	  dst_plus = true;
+	  rtx reg = XEXP(mem, 0);
+	  rtx konst = XEXP(mem, 1);
+	  if (REG_P(reg) && GET_CODE(konst) == CONST_INT)
+	    {
+	      dst_mem_reg = reg;
+	      dst_mem_addr = INTVAL(konst);
+	    }
+	}
+      else if (GET_CODE(mem) == CONST)
+	{
+	  mem = XEXP(mem, 0);
+	  if (GET_CODE(mem) == PLUS)
+	    {
+	      rtx sym = XEXP(mem, 0);
+	      if (GET_CODE(sym) == SYMBOL_REF)
+		{
+		  dst_plus = true;
+		  dst_symbol = sym;
+		  dst_mem_addr = INTVAL(XEXP(mem, 1));
+		}
+	    }
+	}
+    }
+
+  /* It' some kind of operation, e.g. PLUS, XOR, NEG, ... */
+  rtx alt_src_reg = 0;
+  int code = GET_CODE(src);
+  if (!REG_P(src) && !MEM_P(src) && code != CONST_INT && code != CONST && code != CONST_WIDE_INT && code != CONST_DOUBLE
+      && code != CONST_FIXED && code != CONST_STRING)
+    {
+      src_op = GET_CODE(src);
+      const char *fmt = GET_RTX_FORMAT(code);
+      if (fmt[0] == 'e' && fmt[1] == 'e')
+	{
+	  src_ee = true;
+	  rtx operand = XEXP(src, 1);
+	  if (GET_CODE(operand) == CONST_INT || GET_CODE(operand) == CONST_WIDE_INT)
+	    src_const = true, src_intval = INTVAL(operand);
+	  else if (REG_P(operand))
+	    {
+	      alt_src_reg = operand;
+	    }
+	  else if (MEM_P(operand))
+	    {
+	      // it' something like reg = op(reg, mem(...))
+	      src_2nd = true;
+	      fledder_src_mem (operand);
+	    }
+	}
+      src = XEXP(src, 0);
+    }
+
+  if (REG_P(src))
+    {
+      src_reg = src;
+    }
+  else if (MEM_P(src))
+    {
+      fledder_src_mem (src);
+    }
+  else if (GET_CODE(src) == CONST_INT)
+    {
+      src_const = true;
+      src_intval = INTVAL(src);
+    }
+  if (alt_src_reg)
+    src_reg = alt_src_reg;
+}
+
+/* create a copy for a reg. Optional specify a new register number. */
+static rtx
+copy_reg (rtx reg, int newregno)
+{
+  if (newregno < 0)
+    newregno = REGNO(reg);
+  rtx x = gen_raw_REG (GET_MODE(reg), newregno);
+  x->jump = reg->jump;
+  x->call = reg->call;
+  x->unchanging = reg->unchanging;
+  x->volatil = reg->volatil;
+  x->in_struct = reg->in_struct;
+  x->used = reg->used;
+  x->frame_related = reg->frame_related;
+  x->return_val = reg->return_val;
+
+  x->u.reg.attrs = reg->u.reg.attrs;
+  return x;
+}
+
+/* Rename the register plus track all locs to undo these changes. */
+static void
+find_reg_modes_by_no (rtx x, unsigned oldregno,std::set<machine_mode> & modes)
+{
+  if (!x)
+    return;
+
+  RTX_CODE code = GET_CODE(x);
+
+  const char *fmt = GET_RTX_FORMAT(code);
+  for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	{
+	  rtx y = XEXP(x, i);
+	  if (REG_P(y))
+	    {
+	      if (REGNO(y) == oldregno)
+		modes.insert(GET_MODE(y));
+	    }
+	  else
+	    find_reg_modes_by_no (y, oldregno, modes);
+	}
+      else if (fmt[i] == 'E')
+	for (int j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  {
+	    rtx z = XVECEXP(x, i, j);
+	    find_reg_modes_by_no (z, oldregno, modes);
+	  }
+    }
+}
+
+/*
+ * Collect some data.
+ */
+static std::vector<insn_info> infos;
+typedef std::vector<insn_info>::iterator insn_info_iterator;
+
+// insn->u2.insn_uid -> rtx_insn *
+static std::multimap<int, rtx_insn *> label2jump;
+typedef std::multimap<int, rtx_insn *>::iterator l2j_iterator;
+
+// index -> index
+static std::multimap<unsigned, unsigned> jump2label;
+typedef std::multimap<unsigned, unsigned>::iterator j2l_iterator;
+
+static std::map<rtx_insn *, insn_info *> insn2info;
+typedef std::map<rtx_insn *, insn_info *>::iterator i2i_iterator;
+
+static std::set<unsigned> scan_starts;
+typedef std::set<unsigned>::iterator su_iterator;
+
+static insn_info * info0;
+static unsigned usable_regs;
+
+// registers used during rename
+static std::vector<rtx> dstregs;
+
+static void
+update_insn2index ()
+{
+  infos.reserve (infos.size () * 8 / 7 + 2);
+  insn2info.clear ();
+  /* needs a separate pass since the insn_infos require fixed addresses for ->get_index() */
+  for (unsigned i = 0; i < infos.size (); ++i)
+    {
+      insn_info & ii = infos[i];
+      insn2info.insert (std::make_pair (ii.get_insn (), &ii));
+    }
+  info0 = &infos[0];
+}
+
+static void
+update_label2jump ()
+{
+  update_insn2index ();
+
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+      if (ii.is_label ())
+	for (l2j_iterator i = label2jump.find (ii.get_insn ()->u2.insn_uid), k = i;
+	    i != label2jump.end () && i->first == k->first; ++i)
+	  jump2label.insert (std::make_pair (insn2info.find (i->second)->second->get_index (), index));
+    }
+}
+
+int
+insn_info::get_index () const
+{
+  insn_info * ii = &infos[0];
+
+  if (ii == info0)
+    {
+      ptrdiff_t diff = ((char const *) this - (char const *) ii);
+      unsigned pos = diff / sizeof(insn_info);
+      if (pos < infos.size ())
+	return pos;
+    }
+
+// realloc happened...
+  for (unsigned i = 0; i < infos.size (); ++i)
+    if (infos[i].get_insn () == this->insn)
+      return i;
+
+// whoops!?
+  return 0;
+}
+
+void
+insn_info::plus_to_move (rtx_insn * newinsn)
+{
+  insn = newinsn;
+  src_op = (rtx_code) 0;
+  src_reg = XEXP(PATTERN (newinsn), 1);
+  insn2info.insert (std::make_pair (insn, this));
+// usage flags did not change
+}
+
+void
+insn_info::swap_adds (rtx_insn * newinsn, insn_info & ii)
+{
+  insn = newinsn;
+
+  std::swap (*this, ii);
+
+  insn2info.insert (std::make_pair (insn, this));
+  insn2info.insert (std::make_pair (ii.insn, &ii));
+
+// usage flags did not change
+}
+
+static
+void
+replace_reg (rtx x, unsigned regno, rtx newreg, int offset)
+{
+  RTX_CODE code = GET_CODE(x);
+  const char *fmt = GET_RTX_FORMAT(code);
+  for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	{
+	  rtx y = XEXP(x, i);
+	  if (REG_P(y) && REGNO(y) == regno)
+	    {
+	      XEXP(x, i) = newreg;
+	      if (offset && i + 1 < GET_RTX_LENGTH(code))
+		{
+		  rtx c = XEXP(x, i + 1);
+		  if (GET_CODE(c) == CONST_INT)
+		    XEXP(x, i + 1) = gen_rtx_CONST_INT (GET_MODE(x), INTVAL(c) + offset);
+		}
+	    }
+	  else
+	    replace_reg (y, regno, newreg, offset);
+	}
+      else if (fmt[i] == 'E')
+	for (int j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  replace_reg (XVECEXP(x, i, j), regno, newreg, offset);
+    }
+}
+
+void
+insn_info::a5_to_a7 (rtx a7, int add)
+{
+  if (proepi == IN_EPILOGUE && src_mem_reg && get_src_mem_regno () == FRAME_POINTER_REGNUM)
+    {
+      rtx set = single_set (insn);
+      if (set)
+	{
+	  SET_SRC(set) = gen_rtx_MEM (mode, gen_rtx_POST_INC(SImode, a7));
+	  return;
+	}
+    }
+  replace_reg (PATTERN (insn), FRAME_POINTER_REGNUM, a7, add-4);
+}
+
+void
+insn_info::set_insn (rtx_insn * newinsn)
+{
+  insn = newinsn;
+
+  reset_flags ();
+
+  fledder (single_set (insn));
+}
+
+rtx
+insn_info::make_absolute2base (unsigned regno, unsigned base, rtx with_symbol, bool apply)
+{
+  rtx set = single_set (get_insn ());
+  rtx src = SET_SRC(set);
+  rtx dst = SET_DEST(set);
+  rtx reg = gen_raw_REG (SImode, regno);
+  bool vola = src->volatil;
+
+  if (is_dst_mem () && (has_dst_addr () || get_dst_symbol ()) && !has_dst_memreg () && get_dst_symbol () == with_symbol)
+    {
+      unsigned addr = get_dst_mem_addr ();
+      unsigned offset = addr - base;
+      if (offset <= 0x7ffe)
+	{
+	  if (base == addr)
+	    dst = gen_rtx_MEM (mode, reg);
+	  else
+	    dst = gen_rtx_MEM (mode, gen_rtx_PLUS(SImode, reg, gen_rtx_CONST_INT (SImode, offset)));
+
+	  if (apply)
+	    {
+	      dst_mem_reg = reg;
+	      dst_mem = true;
+	      dst_mem_addr = offset;
+	      dst_plus = offset != 0;
+	    }
+	}
+    }
+
+  if (is_src_mem () && (has_src_addr () || get_src_symbol ()) && !has_src_memreg () && get_src_symbol () == with_symbol)
+    {
+      unsigned addr = get_src_mem_addr ();
+      unsigned offset = addr - base;
+      if (offset <= 0x7ffe)
+	{
+	  if (base == addr)
+	    src = gen_rtx_MEM (mode, reg);
+	  else
+	    src = gen_rtx_MEM (mode, gen_rtx_PLUS(SImode, reg, gen_rtx_CONST_INT (SImode, offset)));
+
+	  /* some operation to the same value as dst. eg. eor #5,symbol+8 -> eor #5,8(ax) */
+	  if (src_op)
+	    {
+	      if (src_ee)
+		src = gen_rtx_fmt_ee(src_op, mode, src, gen_rtx_CONST_INT (mode, src_intval));
+	      else
+		{
+		  if (src_op == SIGN_EXTEND)
+		    {
+		      PUT_MODE_RAW(src, mode == SImode ? HImode : mode == HImode ? QImode : SImode);
+		      src->call = 1;
+		    }
+		  src = gen_rtx_fmt_e(src_op, mode, src);
+		}
+	    }
+
+	  if (apply)
+	    {
+	      src_mem_reg = reg;
+	      src_mem = true;
+	      src_mem_addr = offset;
+	      src_plus = offset != 0;
+	    }
+	}
+    }
+
+  rtx pattern = gen_rtx_SET(dst, src);
+  src->volatil = vola;
+
+  return pattern;
+}
+
+void
+insn_info::absolute2base (unsigned regno, unsigned base, rtx with_symbol)
+{
+  rtx pattern = make_absolute2base (regno, base, with_symbol, true);
+
+  SET_INSN_DELETED(insn);
+  insn = emit_insn_after (pattern, insn);
+
+  mark_myuse (regno);
+
+  insn2info.insert (std::make_pair (insn, this));
+}
+/*
+ * Reset collected data.
+ */
+static void
+clear (void)
+{
+  label2jump.clear ();
+  jump2label.clear ();
+  insn2info.clear ();
+  infos.clear ();
+  scan_starts.clear ();
+}
+
+/*
+ *  return true if the register is DEAD.
+ *  Do not check at jumps.
+ */
+static bool
+is_reg_dead (unsigned regno, unsigned _pos)
+{
+// skip labels.
+  for (unsigned pos = _pos + 1; pos < infos.size (); ++pos)
+    {
+      insn_info & ii = infos[pos];
+      // skip entries without info
+      if (ii.is_empty ())
+	continue;
+
+      // not dead if usage is reported in the next statement
+      return !ii.is_use (regno) && !ii.is_hard (regno);
+    }
+  return true;
+}
+
+bool dump_cycles;
+bool dump_reg_track;
+void
+append_reg_cache (FILE * f, rtx_insn * insn)
+{
+  i2i_iterator i = insn2info.find (insn);
+  if (i == insn2info.end ())
+    return;
+
+  insn_info & jj = *i->second;
+  unsigned index = jj.get_index ();
+  if (index + 1 < infos.size ())
+    ++index;
+  insn_info & ii = infos[index];
+
+  track_var * track = ii.get_track_var ();
+  if (track == 0)
+    return;
+
+  fprintf (f, "\n");
+
+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)
+    {
+      rtx v = track->get (regno);
+      unsigned mask = track->getMask(regno);
+      if (!v && mask == 0xffffffff)
+	continue;
+
+//      if (GET_CODE(v) == CONST_INT && GET_MODE(v) == VOIDmode)
+//	continue;
+
+      fprintf (f, "%s=", reg_names[regno]);
+
+      if (v)
+	print_inline_rtx (f, v, 12);
+      else
+	fprintf(f, "---");
+
+      fprintf (f, "%08x\n", mask);
+    }
+}
+
+/* helper stuff to enhance the asm output. */
+void
+append_reg_usage (FILE * f, rtx_insn * insn)
+{
+  i2i_iterator i = insn2info.find (insn);
+  if (i == insn2info.end ())
+    return;
+
+  insn_info & ii = *i->second;
+
+  if (f != stderr)
+    {
+      int cost = -1;
+      rtx set = single_set(ii.get_insn());
+      if (set)
+	cost = rtx_cost(set, GET_MODE(SET_DEST(set)), INSN, 0, true);
+      if (be_very_verbose)
+	fprintf (f, "\n\t\t\t\t#%d\t%d %d\t", ii.get_index (), cost, set ? insn_rtx_cost(set, true): 0);
+      else
+	{
+	  fprintf (f, "\t# %d %d", cost, set ? insn_rtx_cost(set, true): 0);
+	  return;
+	}
+    }
+
+  fprintf (f, "%c ", ii.in_proepi () == IN_PROLOGUE ? 'p' : ii.in_proepi () >= IN_EPILOGUE ? 'e' : ' ');
+
+  for (int j = 0; j < 8; ++j)
+    if (ii.is_use (j) || ii.is_def (j))
+      {
+	fprintf (f, ii.is_hard (j) ? "!" : " ");
+	fprintf (f, ii.is_def (j) ? ii.is_use (j) ? "*" : "+" : ii.is_myuse (j) ? "." : " ");
+	fprintf (f, "d%d ", j);
+      }
+    else
+      fprintf (f, "     ");
+
+  for (int j = 8; j < 16; ++j)
+    if (ii.is_use (j) || ii.is_def (j))
+      {
+	fprintf (f, ii.is_hard (j) ? "!" : " ");
+	fprintf (f, ii.is_def (j) ? ii.is_use (j) ? "*" : "+" : ii.is_myuse (j) ? "." : " ");
+	fprintf (f, "a%d ", j - 8);
+      }
+    else
+      fprintf (f, "     ");
+
+  if (ii.is_use (FIRST_PSEUDO_REGISTER))
+    fprintf (f, ii.is_def (FIRST_PSEUDO_REGISTER) ? "+cc " : " cc ");
+  else
+    fprintf (f, "    ");
+
+  // append fp usage info if present
+  if ((ii.get_use () | ii.get_def ()) & ~0xffff)
+    {
+      for (int j = 16; j < 24; ++j)
+	if (ii.is_use (j) || ii.is_def (j))
+	  {
+	    fprintf (f, ii.is_hard (j) ? "!" : " ");
+	    fprintf (f, ii.is_def (j) ? ii.is_use (j) ? "*" : "+" : ii.is_myuse (j) ? "." : " ");
+	    fprintf (f, "f%d ", j - 16);
+	  }
+	else
+	  fprintf (f, "     ");
+    }
+
+  if (f == stderr)
+    fprintf (f, "\n");
+
+}
+
+/*
+ * Helper function to dump the code.
+ * Sometimes used during debugging.
+ */
+static void
+dump_insns (char const * name, bool all)
+{
+  fprintf (stderr, "====================================: %s\n", name);
+  if (all)
+    {
+      for (rtx_insn * insn = get_insns (); insn && insn != infos[0].get_insn (); insn = NEXT_INSN (insn))
+	debug_rtx (insn);
+    }
+  for (unsigned i = 0; i < infos.size (); ++i)
+    {
+      fprintf (stderr, "%d: ", i);
+
+      rtx_insn * insn = infos[i].get_insn ();
+      if (i < infos.size ())
+	append_reg_usage (stderr, insn);
+
+      fprintf (stderr, "\t");
+      debug_rtx (insn);
+
+      if (all)
+	{
+	  rtx_insn * p = i + 1 < infos.size () ? infos[i + 1].get_insn () : 0;
+	  for (rtx_insn * q = NEXT_INSN (insn); q && q != p; q = NEXT_INSN (q))
+	    debug_rtx (q);
+	}
+    }
+}
+
+/* This is the important function to track register usage plus hard/live state.
+ *
+ * Start at bottom and work upwards. On all labels trigger all jumps referring to this label.
+ * A set destination into a register is a def. All other register references are an use.
+ * Hard registers cann't be renamed and are mandatory for regparms and asm_operands.
+ */
+static void
+update_insn_infos (void)
+{
+  /* add all return (jump outs) and start analysis there. */
+  std::set<unsigned> & todo = scan_starts;
+
+  if (todo.begin () == todo.end ())
+    todo.insert (infos.size () - 1);
+
+  bool locka4 = flag_pic >= 3;
+
+  while (!todo.empty ())
+    {
+      int start = *todo.begin ();
+      todo.erase (todo.begin ());
+      insn_info ii = infos[start];
+
+      enum proepis proepi = ii.in_proepi ();
+
+      // mark sp reg as used.
+      if (proepi >= IN_EPILOGUE)
+	ii.mark_use (STACK_POINTER_REGNUM), infos[start].mark_use (STACK_POINTER_REGNUM);
+
+      for (int pos = start; pos >= 0; --pos)
+	{
+	  insn_info & pp = infos[pos];
+	  rtx_insn * insn = pp.get_insn ();
+
+	  // do not run into previous epilogue
+	  if (pp.in_proepi () >= IN_EPILOGUE && !proepi)
+	    break;
+
+	  proepi = pp.in_proepi ();
+
+	  /* no new information -> break. */
+	  if (pos != start && pp.is_visited () && !JUMP_P(insn) && pp.contains (ii))
+	    break;
+
+	  ii.clear_hard_def ();
+	  ii.merge (pp);
+
+	  if (LABEL_P(insn))
+	    {
+	      /* work on all jumps referring to that label. */
+	      l2j_iterator i = label2jump.find (insn->u2.insn_uid);
+
+	      /* no jump to here -> mark all registers as hard regs.
+	       * This label is maybe used in an exception handler.
+	       * Marking as hard also avoids stack frame removal.
+	       */
+	      if (i == label2jump.end ())
+		infos[pos + 1].make_hard ();
+	      else
+		for (l2j_iterator k = i; i != label2jump.end () && i->first == k->first; ++i)
+		  {
+		    i2i_iterator j = insn2info.find (i->second);
+		    if (j != insn2info.end ())
+		      {
+			unsigned index = j->second->get_index ();
+			insn_info & jj = infos[index];
+			if (!jj.is_visited () || !jj.contains (ii))
+			  {
+			    jj.updateWith (ii);
+			    todo.insert (index);
+			  }
+		      }
+		  }
+
+	      if (pos == start)
+		pp.mark_visited ();
+
+	      /* check previous insn for jump */
+	      if (pos > 0 && infos[pos - 1].is_jump ())
+		{
+		  rtx_insn * prev = infos[pos - 1].get_insn ();
+		  rtx set = single_set (prev);
+		  /* unconditional? -> break! */
+		  if (set && SET_DEST(set) == pc_rtx && GET_CODE(SET_SRC(set)) != IF_THEN_ELSE)
+		    break;
+		}
+
+	      continue;
+	    }
+
+	  pp.mark_visited ();
+
+	  rtx pattern = PATTERN (insn);
+	  insn_info use (insn);
+	  use.scan ();
+	  if (locka4 && (use.get_myuse () & (1 << PIC_REG)))
+	    use.mark_hard (PIC_REG);
+
+	  /* do not mark a node as visited, if it's in epilogue and not yet visited. */
+	  if (CALL_P(insn) || JUMP_P(insn))
+	    {
+	      if (pos != start && ii.in_proepi ())
+		{
+		  su_iterator k = scan_starts.find (pos);
+		  if (k != scan_starts.end ())
+		    {
+		      pp.clear_visited ();
+		      break;
+		    }
+		}
+	    }
+	  else if (GET_CODE (pattern) == USE || GET_CODE (pattern) == CLOBBER)
+	    {
+	      use.make_clobber ();
+	    }
+	  else if (single_set (insn) == 0)
+	    use.make_hard ();
+	  else
+	  /* if not cc0 defined check for mod. */
+	  if (!use.is_def (FIRST_PSEUDO_REGISTER))
+	    {
+	      CC_STATUS_INIT;
+	      NOTICE_UPDATE_CC(PATTERN (insn), insn);
+	      if (cc_status.value1 || cc_status.value2)
+		use.mark_def (FIRST_PSEUDO_REGISTER);
+	    }
+
+	  // TODO: use 2 bits for data regs, to indicate mode size
+//	  // also check mode size if < 4, it's also a use for data registers.
+//	  if (pp.get_dst_reg () && pp.get_dst_regno () < 8 && GET_MODE_SIZE(pp.get_mode()) < 4)
+//	    use.mark_use (pp.get_dst_regno ());
+
+	  /* mark not renameable in prologue/epilogue. */
+	  if (pp.in_proepi () != IN_CODE)
+	    use.make_hard ();
+
+	  ii.merge (use);
+	  pp.update (ii);
+	  ii.updateWith (use);
+	}
+    }
+
+  /* fill the mask of regs which are assigned a value. */
+  insn_info zz;
+  for (unsigned i = 0; i < infos.size (); ++i)
+    {
+      insn_info & ii = infos[i];
+      if (ii.in_proepi ())
+	continue;
+
+      zz.or_def (ii);
+    }
+
+  /* always allow a0/a1, d0/d1. */
+  usable_regs = zz.get_def () | 0x303;
+  usable_regs &= 0x7fff;
+
+  /* do not use global registers. */
+  for (unsigned i = 0, j = 1; i < FIRST_PSEUDO_REGISTER; ++i)
+    {
+      if (global_regs[i])
+	usable_regs &= ~j;
+      j <<= 1;
+    }
+}
+
+enum AbortCodes
+{
+  E_OK, E_NO_JUMP_LABEL, E_JUMP_TABLE_MISMATCH, E_JUMP_GOTO_LABEL, E_SP_MISMATCH
+};
+
+/*
+ * Create a filtered view of insns - keep only those to work with.
+ */
+static unsigned
+update_insns ()
+{
+  rtx_insn *insn, *next;
+  unsigned result = 0;
+
+  clear ();
+
+  enum proepis inproepilogue = IN_PROLOGUE;
+  /* create a vector with relevant insn. */
+  for (insn = get_insns (); insn; insn = next)
+    {
+      next = NEXT_INSN (insn);
+
+      if (NONJUMP_INSN_P (insn) || LABEL_P(insn) || JUMP_P(insn) || CALL_P(insn))
+	{
+
+	  infos.push_back (insn_info (insn, inproepilogue));
+	  insn_info & ii = infos[infos.size () - 1];
+
+	  if (JUMP_P(insn))
+	    {
+	      if (inproepilogue || ANY_RETURN_P(PATTERN (insn)))
+		{
+		  if (ANY_RETURN_P(PATTERN (insn)))
+		    ii.set_proepi (IN_EPILOGUE);
+
+		  scan_starts.insert (infos.size () - 1);
+		  inproepilogue = IN_CODE;
+		  rtx set = single_set (insn);
+		  if (ANY_RETURN_P(PATTERN (insn))
+		      || (set && SET_DEST(set) == pc_rtx && GET_CODE(SET_SRC(set)) != IF_THEN_ELSE))
+		    continue;
+		}
+
+	      ii.mark_jump ();
+
+	      rtx table = 0;
+	      rtx_insn * label = (rtx_insn *) JUMP_LABEL(insn);
+	      if (label &&  NEXT_INSN (label) && JUMP_TABLE_DATA_P (NEXT_INSN (label)))
+		table = PATTERN(NEXT_INSN (label));
+	      if (table)
+		{
+		  // -> jump_table_data
+		  if (GET_CODE(table) == ADDR_DIFF_VEC || GET_CODE(table) == ADDR_VEC)
+		    {
+		      int k = GET_CODE(table) == ADDR_DIFF_VEC;
+		      for (int j = 0; j < XVECLEN(table, k); ++j)
+			{
+			  rtx ref = XVECEXP(table, k, j);
+			  if (!LABEL_REF_NONLOCAL_P(ref))
+			    {
+			      rtx label = XEXP(ref, 0);
+			      label2jump.insert (std::make_pair (label->u2.insn_uid, insn));
+			      ii.set_proepi (IN_EPILOGUE);
+			    }
+			}
+		    }
+		  else
+		    {
+		      if (be_very_verbose)
+			{
+			  debug_rtx (insn);
+			  debug_rtx (table);
+			}
+		      result = E_JUMP_GOTO_LABEL;
+		      continue;
+		    }
+		}
+	      else
+		{
+		  rtx_insn * label = (rtx_insn *) JUMP_LABEL(insn);
+		  if (!label)
+		    {
+		      if (be_very_verbose)
+			debug_rtx (insn);
+		      result = E_NO_JUMP_LABEL;
+		      continue;
+		    }
+		  label2jump.insert (std::make_pair (label->u2.insn_uid, insn));
+		}
+	    }
+	  else if (LABEL_P(insn))
+	    {
+	      ii.mark_label ();
+	      ii.set_proepi (inproepilogue = IN_CODE);
+	      if (infos.size () > 1)
+		scan_starts.insert (infos.size () - 1);
+	    }
+	  else if (CALL_P(insn))
+	    {
+	      if (insn->jump)
+		{
+		  ii.set_proepi (IN_EPILOGUE);
+		  ii.mark_jump ();
+		  scan_starts.insert (infos.size () - 1);
+		}
+	      ii.mark_call ();
+	      if (inproepilogue)
+		{
+		  scan_starts.insert (infos.size () - 1);
+		  inproepilogue = IN_CODE;
+		}
+	    }
+	  else
+	    {
+	      rtx set = single_set (insn);
+	      if (set)
+		ii.fledder (set);
+	    }
+	}
+      else if (NOTE_P(insn))
+	{
+	  if (NOTE_KIND(insn) == NOTE_INSN_PROLOGUE_END)
+	    inproepilogue = IN_CODE;
+	  else if (NOTE_KIND(insn) == NOTE_INSN_EPILOGUE_BEG)
+	    inproepilogue = IN_EPILOGUE;
+	}
+    }
+  scan_starts.insert (infos.size () - 1);
+  update_insn2index ();
+  update_insn_infos ();
+
+  return result;
+}
+
+/* convert the lowest set bit into a register number. */
+static int
+bit2regno (unsigned bit)
+{
+  if (!bit)
+    return -1;
+
+  unsigned regno = 0;
+  while (!(bit & 1))
+    {
+      ++regno;
+      bit >>= 1;
+    }
+  return regno;
+}
+
+/* check if that register is touched between from and to, excluding from and to .*/
+static bool
+is_reg_touched_between (unsigned regno, int from, int to)
+{
+  for (int index = from + 1; index < to; ++index)
+    {
+      insn_info & ii = infos[index];
+      if (ii.is_myuse (regno) || ii.is_def (regno))
+	return true;
+    }
+  return false;
+}
+
+/*
+ * search backward and find the initial assignment for that regno.
+ */
+static unsigned
+find_start (unsigned start, unsigned rename_regno)
+{
+  /* search the start. */
+  while (start > 0)
+    {
+      unsigned startm1 = start - 1;
+
+      insn_info & jj = infos[start];
+
+      /* stop at labels. If a label is a start pos, a search is maybe started again. */
+      if (jj.is_label ())
+	break;
+
+      /* do not run over RETURNS */
+      insn_info & bb = infos[startm1];
+      if (jj.in_proepi () == IN_CODE && bb.in_proepi () >= IN_EPILOGUE)
+	break;
+
+      /* found the definition without use. */
+      if (jj.is_def (rename_regno) && !jj.is_use (rename_regno))
+	break;
+
+      start = startm1;
+    }
+  return start;
+}
+
+/*
+ * Always prefer lower register numbers within the class.
+ */
+static unsigned
+opt_reg_rename (void)
+{
+  update_label2jump ();
+
+  if (infos.size () < 2)
+    return 0;
+
+  unsigned changes = 0;
+
+//  dump_insns ("rename", 1);
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+
+      /* do not rename if register is hard or used in same statement. */
+      const unsigned rename_regbit = ii.get_regbit ();
+      if (!rename_regbit)
+	continue;
+
+      const unsigned rename_regno = bit2regno (rename_regbit);
+
+      /* part of multi registers? do not touch! */
+      if (ii.get_multi_reg () & rename_regbit)
+	continue;
+
+      /* get the mask for free registers. */
+      unsigned mask = ii.get_free_mask ();
+
+      /* the mask contains the current src register. Add this register to the mask if it's dead here. */
+      if (ii.get_src_reg () && is_reg_dead (ii.get_src_regno (), index))
+        mask |= ii.get_use ();
+
+      mask &= usable_regs;
+
+      /* do not use a4 if compiling baserel */
+      if (flag_pic >= 3)
+	mask &= ~(1 << PIC_REG);
+
+      if (!mask)
+	continue;
+
+      /* first = pos to start, second indicates to treat def as use. */
+      std::set<unsigned> todo;
+      std::set<unsigned> found;
+      if (index + 1 < infos.size ())
+	todo.insert (index + 1);
+
+      found.insert (index);
+      /* a register was defined, follow all branches. */
+      while (mask && todo.begin () != todo.end ())
+	{
+	  unsigned runpos = *todo.begin ();
+	  todo.erase (todo.begin ());
+
+//	  printf ("runpos %d \n", runpos); fflush (stdout);
+	  for (unsigned pos = runpos; mask && pos < infos.size (); ++pos)
+	    {
+	      /* already searched. */
+	      if (found.find (pos) != found.end ())
+		break;
+
+	      insn_info & jj = infos[pos];
+	      if (jj.is_call()) {
+		  // do not rename registers used or defined in calls
+		  if (jj.is_myuse(rename_regno) || jj.is_def(rename_regno)) {
+		    mask = 0;
+		    break;
+		  }
+	      }
+
+	      rtx_insn * insn = jj.get_insn ();
+	      if (LABEL_P(insn))
+		{
+		  found.insert (pos);
+
+		  /* for each jump to this label:
+		   * check if the reg was used at that jump.
+		   * if used, find def
+		   */
+		  for (l2j_iterator i = label2jump.find (insn->u2.insn_uid), k = i;
+		      i != label2jump.end () && i->first == k->first; ++i)
+		    {
+		      i2i_iterator j = insn2info.find (i->second);
+		      if (j == insn2info.end ())
+			{
+			  mask = 0;
+			  break;
+			}
+
+		      unsigned startat = j->second->get_index ();
+		      if (found.find (startat) != found.end () || !infos[startat].is_use (rename_regno))
+			continue;
+
+		      unsigned start = find_start (startat, rename_regno);
+//		      printf ("label %d <- jump %d : start %d\n", pos, startat, start); fflush (stdout);
+		      todo.insert (start);
+		    }
+
+		  /* if this label is at a start, check if it is reachable from the previous insn,
+		   * and if, check for use then search start. */
+		  if (pos > 0)
+		    {
+		      insn_info & bb = infos[pos - 1];
+		      rtx set = single_set (bb.get_insn ());
+		      if (ANY_RETURN_P(bb.get_insn ())
+			  || (set && SET_DEST(set) == pc_rtx && GET_CODE(SET_SRC(set)) != IF_THEN_ELSE))
+			continue;
+
+//		      printf ("label start check %d use %d\n", pos, bb.is_use (rename_regno) || bb.is_def(rename_regno)); fflush (stdout);
+
+		      // search previous insn if it's a label or the register is used or defined.
+		      if (bb.is_label() || bb.is_use (rename_regno) || bb.is_def (rename_regno))
+			{
+			  unsigned start = find_start (pos - 1, rename_regno);
+			  todo.insert (start);
+//			  printf ("label %d : start %d \n", pos, start); fflush (stdout);
+			}
+		    }
+
+		  continue;
+		}
+
+	      /* marked as hard reg -> invalid rename */
+	      if ((jj.get_use () & jj.get_hard () & rename_regbit)
+		      /* or register is used and defined - with double register usage. */
+		  || (jj.get_multi_reg () & rename_regbit))
+		{
+		  mask = 0;
+		  break;
+		}
+
+	      /* not used. and not a def */
+	      if (pos == runpos && (jj.get_def () & rename_regbit))
+		{
+		  /* continue since this pos was added by start search. */
+		}
+	      else if (!(jj.get_use () & rename_regbit))
+		break;
+
+	      /* abort if some insn using this reg uses more than 1 reg. */
+	      if ((jj.get_myuse () & rename_regbit) && GET_MODE_SIZE(jj.get_mode()) > 4)
+		{
+		  mask = 0;
+		  break;
+		}
+
+	      /* update free regs. */
+	      mask &= ~jj.get_use ();
+	      mask &= ~jj.get_def ();
+	      mask &= ~jj.get_multi_reg();
+	      if (!mask)
+		break;
+
+	      found.insert (pos);
+
+	      /* follow jump and/or next insn. */
+	      if (JUMP_P(insn))
+		{
+		  for (j2l_iterator i = jump2label.find (pos), k = i; i != jump2label.end () && i->first == k->first;
+		      ++i)
+		    {
+		      unsigned label_index = i->second;
+
+		      /* add the label to the search list. */
+		      insn_info & bb = infos[label_index + 1];
+		      if (found.find (label_index) == found.end () && bb.is_use (rename_regno))
+			{
+//			  printf ("jump %d -> label %d \n", pos, label_index); fflush (stdout);
+			  todo.insert (label_index);
+			}
+		    }
+		  rtx set = single_set (insn);
+		  if (!set)
+		    {
+		      // it's a parallel pattern - search the set pc = ...
+		      rtx pat = PATTERN (insn);
+		      for (int j = XVECLEN (pat, 0) - 1; j >= 0; j--)
+			{
+			  rtx x = XVECEXP(pat, 0, j);
+			  if (XEXP(x, 0) == pc_rtx)
+			    {
+			      set = x;
+			      break;
+			    }
+			}
+		    }
+		  rtx jmpsrc = set ? SET_SRC(set) : 0;
+		  if (!jmpsrc || GET_CODE(jmpsrc) != IF_THEN_ELSE)
+		    break;
+		}
+	    }
+	}
+
+      while (mask && found.size() > 1)
+	{
+	  int oldregno = bit2regno (rename_regbit);
+	  int newregno = bit2regno (mask);
+
+	  /* check the renamed insns. */
+	  std::vector<unsigned> positions;
+	  std::set<machine_mode> modes;
+//	  bool ok = true;
+	  for (std::set<unsigned>::iterator i = found.begin (); i != found.end (); ++i)
+	    {
+	      insn_info & rr = infos[*i];
+
+//	      // prevent lea from or to data register.
+//	      if (rr.get_src_op() == PLUS && rr.get_src_regno() != rr.get_dst_regno()) {
+//		  if ((oldregno < 8 && newregno >= 8) || (oldregno >= 8 && newregno < 8)) {
+//		      ok = false;
+//		      break;
+//		  }
+//	      }
+
+	      rtx_insn * insn = rr.get_insn ();
+
+	      /* get rename modes. */
+	      modes.clear();
+	      find_reg_modes_by_no (PATTERN (insn), oldregno, modes);
+	      if (modes.size() > 0)
+		{
+		  for (std::set<machine_mode>::iterator m = modes.begin(); m != modes.end(); ++m)
+		    {
+		      machine_mode mode = *m;
+		      rtx to = gen_raw_REG (mode, newregno);
+		      rtx from = gen_raw_REG (mode, oldregno);
+
+		      validate_replace_rtx_group (from, to, insn);
+		    }
+		  positions.push_back (*i);
+		}
+	    }
+
+	  if (apply_change_group ())
+	    {
+	      log ("(r) opt_reg_rename %s -> %s (%d locs, start at %d)\n", reg_names[oldregno], reg_names[newregno],
+		   positions.size (), index);
+
+	      if (be_verbose)
+		{
+		  for (std::vector<unsigned>::iterator i = positions.begin (); i != positions.end (); ++i)
+		    printf ("%d ", *i);
+		  printf ("\n");
+		  fflush (stdout);
+		}
+#if 0
+	      unsigned oldbit = 1 << oldregno;
+	      unsigned newbit = 1 << newregno;
+	      // update the insn_infos
+	      for (std::vector<unsigned>::iterator i = positions.begin (); i != positions.end (); ++i)
+		{
+		  insn_info & pp = infos[*i];
+		  if (pp.get_def() & oldbit)
+		    {
+		      pp.set_def((pp.get_def() & ~oldbit) | newbit);
+		    }
+		  if (pp.get_use() & oldbit)
+		    {
+		      pp.set_use((pp.get_use() & ~oldbit) | newbit);
+		    }
+		  if (pp.get_myuse() & oldbit)
+		    {
+		      pp.set_myuse((pp.get_myuse() & ~oldbit) | newbit);
+		    }
+		}
+
+	      // continue
+	      ++changes;
+	      break;
+#else
+	      return 1;
+#endif
+	    }
+//	  if (!ok)
+//	    cancel_changes (0);
+
+	  // try next register in mask - but skip those of same kind
+	  if (newregno < 8)
+	    mask &= 0xffff00;
+	  else
+	    mask &= 0xff0000;
+	}
+    }
+  return changes;
+}
+
+/*
+ *  #1 propagate a->b->a moves out of a loop.
+ *
+ * consider a loop:
+ *
+ * .L1
+ *   ...
+ *   move d0, a0 ; (1)
+ *   ...
+ *   move xy, (a0)+
+ *   ...
+ *   move a0, d0 ; (2)
+ *   ...
+ *   jxx .L1
+ *
+ *  Then the statements (1) and (2) can be moved out of the loop:
+ *
+ *   move d0, a0 ; (3)
+ * .L1
+ *   ...
+ *   move *, (a0)+ ; a0 is modified somehow
+ *   ...
+ *   jxx .L1
+ *   move a0, d0 ; (4)
+ *
+ *  if all criteria are met:
+ *
+ *  a) no other jump to .L1 -> (LABEL_NUSES(insn) == 1)
+ *  b) no other use of d0 inside the loop
+ *  c) no other use of a0 before (1)
+ *  d) no other use of a1 after (2)
+ *
+ *  Optional:
+ *  - omit (4) if d0 is dead
+ *
+ *  this will e.g. convert
+ .L6:
+ move.l d0,a1
+ move.b (a1)+,d1
+ move.l a1,d0
+ move.b d1,(a0)+
+ cmp.b #0, d1
+ jne .L6
+ *  to
+ move.l d0,a1
+ .L6:
+ move.b (a1)+,d1
+ move.b d1,(a0)+
+ cmp.b #0, d1
+ jne .L6
+
+ *
+ * Also allow exit jumps, if the modification of the reg is const
+ * and insert a correction after the exit label.
+ * The label must only be reachable by the exit jump.
+ */
+static unsigned
+opt_propagate_moves ()
+{
+  unsigned change_count = 0;
+  rtx_insn * current_label = 0;
+  unsigned current_label_index = 0;
+  std::vector<unsigned> reg_reg;
+  std::vector<rtx_insn *> jump_out;
+
+  /* start at 1 since there must be an insn before the label. */
+  for (unsigned index = 1; index < infos.size (); ++index)
+    {
+      rtx_insn * insn = infos[index].get_insn ();
+
+      if (LABEL_P(insn))
+	{
+	  if (LABEL_NUSES(insn) == 1)
+	    {
+	      current_label = insn;
+	      current_label_index = index;
+	      reg_reg.clear ();
+	      jump_out.clear ();
+	    }
+	  else
+	    current_label = 0;
+	}
+
+      if (current_label == 0)
+	continue;
+
+      if (NONJUMP_INSN_P(insn))
+	{
+	  // check for set reg, reg
+	  rtx set = single_set (insn);
+	  if (set)
+	    {
+	      rtx src = SET_SRC(set);
+	      rtx dst = SET_DEST(set);
+	      if (REG_P(src) && REG_P(dst))
+		reg_reg.push_back (index);
+	    }
+	  else
+	    current_label = 0;
+
+	  continue;
+	}
+
+      if (JUMP_P(insn))
+	{
+	  rtx_insn * label = (rtx_insn *) JUMP_LABEL(insn);
+	  if (label != current_label)
+	    {
+	      /* collect the labels for a later check if a fixup is possible. */
+	      if (LABEL_NUSES(label) == 1 && BARRIER_P(PREV_INSN (label)))
+		jump_out.push_back (label);
+	      else
+		current_label = 0;
+	      continue;
+	    }
+
+	  if (reg_reg.size () > 1)
+	    {
+	      /* Search for reg/reg pairs. */
+	      for (std::vector<unsigned>::iterator i = reg_reg.begin (); i != reg_reg.end () && i + 1 != reg_reg.end ();
+		  )
+		{
+		  bool inc = true;
+		  for (std::vector<unsigned>::iterator j = i + 1; j != reg_reg.end ();)
+		    {
+		      rtx_insn * ii = infos[*i].get_insn ();
+		      rtx seti = single_set (ii);
+		      rtx srci = SET_SRC(seti);
+		      rtx dsti = SET_DEST(seti);
+		      rtx_insn * jj = infos[*j].get_insn ();
+		      rtx setj = single_set (jj);
+		      rtx srcj = SET_SRC(setj);
+		      rtx dstj = SET_DEST(setj);
+
+		      if (rtx_equal_p (srci, dstj) && rtx_equal_p (srcj, dsti))
+			{
+			  /* Ensure correct usage. */
+			  if (is_reg_touched_between (REGNO(srci), current_label_index, *i) // label ... move src,x
+			  || is_reg_touched_between (REGNO(srci), *i, *j) // move src,x ... move x,src
+			      || is_reg_touched_between (REGNO(srci), *j, index) // move x,src ... jcc
+			      || is_reg_touched_between (REGNO(dsti), current_label_index, *i) // label ... move src,x
+			      || is_reg_touched_between (REGNO(dsti), *j, index) // move x,src ... jcc
+							 )
+			    {
+			      ++j;
+			      continue;
+			    }
+
+			  std::vector<int> fixups;
+
+			  /* if there are jumps out of the loop,
+			   * check if the modification occurs before the jump,
+			   * and if, that it's a plus const.
+			   */
+			  if (jump_out.size ())
+			    {
+			      std::vector<rtx_insn *>::iterator label_iter = jump_out.begin ();
+			      int fixup = 0;
+
+			      for (unsigned k = *i + 1; k != *j; ++k)
+				{
+				  rtx_insn * check = infos[k].get_insn ();
+				  if (JUMP_P(check))
+				    {
+				      fixups.push_back (fixup);
+				      if (++label_iter == jump_out.end ())
+					break;
+				      continue;
+				    }
+
+				  if (reg_overlap_mentioned_p (dsti, PATTERN (check)))
+				    {
+				      /* right now only support auto_incs. */
+				      rtx set = single_set (check);
+				      rtx src = SET_SRC(set);
+				      rtx dst = SET_DEST(set);
+
+				      if (reg_overlap_mentioned_p (dsti, dst))
+					{
+					  if (REG_P(dst))
+					    break;
+					  if (!MEM_P(dst))
+					    break;
+
+					  rtx x = XEXP(dst, 0);
+					  if (GET_CODE(x) == REG)
+					    fixup += 0; // direct use
+					  else if (GET_CODE(x) == PRE_INC ||
+					  GET_CODE(x) == POST_INC)
+					    fixup -= GET_MODE_SIZE(GET_MODE(dst));
+					  else if (GET_CODE(dst) == PRE_DEC ||
+					  GET_CODE(dst) == POST_DEC)
+					    fixup += GET_MODE_SIZE(GET_MODE(dst));
+					  else
+					    break;
+					}
+
+				      if (reg_overlap_mentioned_p (dsti, src))
+					{
+					  if (REG_P(src))
+					    fixup += 0;
+					  else
+					    {
+					      if (!MEM_P(src))
+						break;
+
+					      rtx x = XEXP(src, 0);
+					      if (GET_CODE(x) == REG)
+						fixup += 0; // direct use
+					      else if (GET_CODE(x) == PRE_INC ||
+					      GET_CODE(x) == POST_INC)
+						fixup -= GET_MODE_SIZE(GET_MODE(dst));
+					      else if (GET_CODE(dst) == PRE_DEC ||
+					      GET_CODE(dst) == POST_DEC)
+						fixup += GET_MODE_SIZE(GET_MODE(dst));
+					      else
+						break;
+					    }
+					}
+				    }
+				}
+			    }
+
+			  /* got a fixup for all jump_outs? */
+			  if (fixups.size () == jump_out.size ())
+			    {
+			      rtx_insn * before = infos[current_label_index - 1].get_insn ();
+			      rtx_insn * after = infos[index + 1].get_insn ();
+//			      rtx bset = single_set (before);
+
+			      log ("(p) propagate_moves condition met, moving regs %s, %s\n",
+			      reg_names[REGNO(srci)],
+				   reg_names[REGNO(dsti)]);
+
+			      /* Move in front of loop and mark as dead. */
+			      rtx_insn * newii = make_insn_raw (PATTERN (ii));
+			      SET_INSN_DELETED(ii);
+
+//			      /* Plus check if the reg was just loaded. */
+//			      if (bset)
+//				{
+//				  rtx bdst = SET_DEST(bset);
+//				  if (REG_P(bdst) && REGNO(bdst) == REGNO(srci))
+//				    {
+//				      SET_SRC(PATTERN(newii)) = SET_SRC(bset);
+////					  SET_INSN_DELETED(ii);
+//				    }
+//				}
+//			      else
+				add_reg_note (newii, REG_DEAD, srci);
+
+			      add_insn_after (newii, before, 0);
+
+			      /* Move behind loop - into next BB. */
+			      rtx_insn * newjj = make_insn_raw (PATTERN (jj));
+			      add_insn_before (newjj, after, 0);
+			      SET_INSN_DELETED(jj);
+
+			      reg_reg.erase (j);
+			      reg_reg.erase (i);
+			      j = reg_reg.end ();
+			      inc = false;
+
+			      /* add fixes if there were jumps out of the loop. */
+			      if (jump_out.size ())
+				{
+				  log ("(p) propagate_moves fixing %d jump outs\n", jump_out.size ());
+
+				  for (unsigned k = 0; k < jump_out.size (); ++k)
+				    {
+				      if ((REGNO(dsti) < 8 || REGNO(dstj) < 8) && REGNO(dsti) != REGNO(dstj))
+					{
+					  rtx neu = gen_rtx_SET(
+					      dstj, gen_rtx_PLUS (Pmode, dstj, gen_rtx_CONST_INT (Pmode, fixups[k])));
+					  emit_insn_after (neu, jump_out[k]);
+					  rtx move = gen_rtx_SET(dstj, dsti);
+					  emit_insn_after (move, jump_out[k]);
+					}
+				      else
+					{
+					  rtx neu = gen_rtx_SET(
+					      dstj, gen_rtx_PLUS (Pmode, dsti, gen_rtx_CONST_INT (Pmode, fixups[k])));
+					  emit_insn_after (neu, jump_out[k]);
+					}
+				    }
+				}
+			      ++change_count;
+			    }
+			}
+		      if (inc)
+			++j;
+		    }
+		  if (inc)
+		    ++i;
+		}
+	    }
+	  current_label = 0;
+	}
+    }
+  return change_count;
+}
+
+/**
+ * Search for
+ *
+ *   mov x,reg
+ *   mov reg,x
+ *   cmp #0, reg
+ *   jxx
+ *
+ * patterns.
+ *
+ * Use a simple state machine to find the patterns.
+ */
+static unsigned
+opt_strcpy ()
+{
+  unsigned change_count = 0;
+#if HAVE_cc0
+  rtx_insn * x2reg = 0;
+  rtx_insn * reg2x = 0;
+  unsigned int regno = FIRST_PSEUDO_REGISTER;
+
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+      rtx_insn * insn = ii.get_insn ();
+
+      if (!NONJUMP_INSN_P(insn))
+	{
+	  x2reg = 0;
+	  continue;
+	}
+
+      rtx set = single_set (insn);
+      if (!set)
+	{
+	  x2reg = 0;
+	  continue;
+	}
+
+      if (x2reg && reg2x)
+	{
+	  rtx src = SET_SRC(set);
+	  if (GET_CODE(src) == COMPARE)
+	    {
+	      rtx dst = XEXP(src, 0);
+	      src = XEXP(src, 1);
+
+//	      if (CONST_INT_P(src) && INTVAL(src) == 0 && find_reg_note (insn, REG_DEAD, dst))
+	      if (REG_P(dst) && CONST_INT_P(src) && INTVAL(src) == 0 && is_reg_dead (REGNO(dst), index))
+		{
+		  /* now check via NOTICE_UPDATE_CC*/
+		  NOTICE_UPDATE_CC(PATTERN (reg2x), reg2x);
+		  if (cc_status.flags == 0 && rtx_equal_p (dst, cc_status.value2))
+		    {
+		      rtx pattern = gen_rtx_SET(SET_DEST(single_set (reg2x)), SET_SRC(single_set (x2reg)));
+		      rtx_insn * newinsn = make_insn_raw (pattern);
+
+		      if (!insn_invalid_p (newinsn, 0))
+			{
+			  log ("(s) opt_strcpy condition met, removing compare and joining insns - omit reg %s\n",
+			  reg_names[REGNO(dst)]);
+
+			  SET_INSN_DELETED(x2reg);
+			  SET_INSN_DELETED(reg2x);
+			  SET_INSN_DELETED(insn);
+
+			  insn = emit_insn_after (pattern, reg2x);
+			  insn_invalid_p (insn, 0);
+
+			  ++change_count;
+			}
+		    }
+		}
+	      x2reg = 0;
+	      continue;
+	    }
+	  reg2x = 0;
+	}
+
+      /* check for reg2x first, maybe fallback to x2reg. */
+      if (x2reg && reg2x == 0)
+	{
+	  if (REG_P(SET_SRC(set)) && REGNO(SET_SRC(set)) == regno)
+	    {
+	      reg2x = insn;
+	      continue;
+	    }
+	  x2reg = 0;
+	}
+
+      /* check for a match for x2reg. */
+      if (x2reg == 0)
+	{
+	  if (REG_P(SET_DEST(set)) && ii.get_src_op() != ASM_OPERANDS)
+	    {
+	      x2reg = insn;
+	      reg2x = 0;
+	      regno = REGNO(SET_DEST(set));
+	    }
+	}
+    }
+#endif
+  return change_count;
+}
+
+/*
+ * convert
+ *
+ * set reg1, plus (reg2, const)
+ * set mem(reg2), y
+ *
+ * ->
+ * set reg1, reg2
+ * set mem(reg1+), y
+ *
+ * if size of postinc == const
+ *
+ (insn 33 32 35 4 (set (reg/v/f:SI 8 a0 [orig:47 s ] [47])
+ (plus:SI (reg/v/f:SI 9 a1 [orig:46 s ] [46])
+ (const_int 1 [0x1]))) sn.c:5 141 {*addsi3_internal}
+ (nil))
+ (insn 36 35 37 4 (set (mem:QI (reg/v/f:SI 9 a1 [orig:46 s ] [46]) [0 MEM[base: s_17, offset: 4294967295B]+0 S1 A8])
+ (mem:QI (post_inc:SI (reg/v/f:SI 10 a2 [orig:53 s2 ] [53])) [0 MEM[base: s2_19, offset: 4294967295B]+0 S1 A8])) sn.c:5 46 {*m68k.md:1083}
+ (expr_list:REG_INC (reg/v/f:SI 10 a2 [orig:53 s2 ] [53])
+ (nil)))
+ */
+static unsigned
+opt_commute_add_move (void)
+{
+  unsigned change_count = 0;
+
+  for (unsigned index = 0; index + 1 < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+      if (ii.get_dst_regno () < 8 || ii.get_dst_regno () > 15 || ii.get_src_op () != PLUS
+	  || ii.get_src_regno () == ii.get_dst_regno () || !ii.get_src_intval ())
+	continue;
+
+      insn_info & jj = infos[index + 1];
+
+      if (!jj.get_dst_mem_reg () || jj.get_dst_mem_regno () != ii.get_src_regno ()
+	  || jj.get_src_regno () == ii.get_dst_regno () || GET_MODE_SIZE(jj.get_mode()) != ii.get_src_intval ())
+	continue;
+
+      rtx_insn * insn = ii.get_insn ();
+
+      rtx_insn * next = jj.get_insn ();
+      rtx set2 = single_set (next);
+      rtx dst = SET_DEST(set2);
+      if (!MEM_P(dst))
+	continue;
+
+      rtx pinc = gen_rtx_POST_INC(GET_MODE(dst), ii.get_dst_reg ());
+      rtx newmem = replace_equiv_address_nv (dst, pinc);
+
+      rtx_insn * newinsn = make_insn_raw (gen_rtx_SET(ii.get_dst_reg (), ii.get_src_reg ()));
+
+      if (!insn_invalid_p (newinsn, 1) && validate_change (next, &SET_DEST(set2), newmem, 1) && apply_change_group ())
+	{
+	  log ("(a) commute_add_move found\n");
+
+	  SET_INSN_DELETED(insn);
+
+	  insn = emit_insn_before (PATTERN(newinsn), next);
+
+	  add_reg_note (next, REG_INC, ii.get_dst_reg ());
+
+	  ++change_count;
+	}
+      else
+	cancel_changes (0);
+    }
+  return change_count;
+}
+
+/*
+ * Replace
+ *
+ * move x,dx
+ * cmp  dx,dy
+ *
+ * if dx and dy are both dead after compare.
+ *
+ * with
+ *
+ * sub #n,dx
+ *
+ d0 d1 d2 a0 a1 a7       (insn 99 59 41 7 (set (reg:SI 2 d2)
+ (const_int 1 [0x1])) sn.c:8 38 {*movsi_m68k}
+ (nil))
+ d0 d1 d2 a0 a1 a7       (insn 41 99 42 7 (set (cc0)
+ (compare (reg/v:SI 1 d1 [orig:54 n ] [54])
+ (reg:SI 2 d2))) sn.c:8 16 {*m68k.md:499}
+ (expr_list:REG_DEAD (reg:SI 2 d2)
+ (expr_list:REG_DEAD (reg/v:SI 1 d1 [orig:54 n ] [54])
+ (nil))))
+ *
+ */
+static unsigned
+opt_const_cmp_to_sub (void)
+{
+  unsigned change_count = 0;
+#if HAVE_cc0
+  if (infos.size () < 2)
+    return change_count;
+
+  unsigned lastsub = 0;
+  for (unsigned index = infos.size () - 2; index > 0; --index)
+    {
+      insn_info & i1 = infos[index];
+
+      /* we wan't a compare or tst insn, */
+      if (!i1.is_compare ())
+	continue;
+
+      if (GET_MODE_SIZE(i1.get_mode()) > 4 || !i1.is_dst_reg () || REGNO(i1.get_dst_reg()) > 7)
+	continue;
+
+      /* src must be a reg dead register with a constant - or a #0 */
+      if (!i1.get_src_reg () && (!i1.is_src_const () || i1.get_src_op () == PLUS))
+	continue;
+
+      /* allow an alive reg, if life ends at previous handled sub. */
+      int lastsubval = 0;
+      if (lastsub == index + 3)
+	{
+	  insn_info & pp = infos[lastsub];
+	  if (pp.get_dst_regno () != i1.get_dst_regno ())
+	    continue;
+	  lastsubval = pp.get_src_intval ();
+
+	  // but still check for usage after this jump
+	  j2l_iterator l = jump2label.find (index + 2);
+	  if (l == jump2label.end ())
+	    continue;
+
+	  insn_info & label = infos[l->second + 1];
+	  if (label.is_use (i1.get_dst_regno ()))
+	    continue;
+	}
+      else if (!is_reg_dead (i1.get_dst_regno (), index))
+	continue;
+
+      insn_info & i0 = infos[index - 1];
+      int intval = 0;
+      /* compare with register - check previous insn for load with constant. */
+      if (i1.is_src_reg ())
+	{
+	  if (!is_reg_dead (i1.get_src_regno (), index))
+	    continue;
+
+	  if (GET_MODE_SIZE(i0.get_mode()) > 4)
+	    continue;
+
+	  if (!i0.is_dst_reg () || !i0.is_src_const () || i0.get_src_op ())
+	    continue;
+
+	  if (i0.get_dst_regno () != i1.get_src_regno ())
+	    continue;
+
+	  intval = -i0.get_src_intval ();
+	  if (intval < -8 || intval > 7)
+	    continue;
+
+	  /* is the next sub value in range? */
+	  if (lastsub == index + 3 && (lastsubval - intval < -8 || lastsubval - intval > 7))
+	    continue;
+	}
+
+      /* next insn must be the jump. */
+      insn_info & i2 = infos[index + 1];
+      if (!i2.is_jump ())
+	continue;
+
+      rtx jmppattern = single_set (i2.get_insn ());
+      if (!jmppattern)
+	continue;
+
+      rtx jmpsrc = XEXP(jmppattern, 1);
+      if (GET_CODE(jmpsrc) != IF_THEN_ELSE)
+	continue;
+
+      rtx condition = XEXP(jmpsrc, 0);
+      RTX_CODE code = GET_CODE(condition);
+      if (code != EQ && code != NE)
+	continue;
+
+      if (intval)
+	{
+	  rtx copyreg = copy_reg (i1.get_dst_reg (), -1);
+	  /* create the sub statement. */
+	  rtx sub = gen_rtx_PLUS(i1.get_mode (), copyreg, gen_rtx_CONST_INT (i1.get_mode (), intval));
+
+	  rtx_insn * subinsn = make_insn_raw (gen_rtx_SET(copyreg, sub));
+
+	  if (insn_invalid_p (subinsn, 0))
+	    continue;
+
+	  /* delete move #x,dy. */
+	  SET_INSN_DELETED(i0.get_insn ())
+	  /* delete cmp dx,dy */
+	  SET_INSN_DELETED(i1.get_insn ());
+	  /* add a cmp #0 - to be removed in final() */
+
+	  /* convert cmp/tst into sub */
+	  subinsn = emit_insn_before (PATTERN (subinsn), i1.get_insn ());
+	  i1.set_insn (subinsn);
+
+	  rtx neu = gen_rtx_SET(cc0_rtx,
+				gen_rtx_COMPARE (i1.get_mode (), copyreg, gen_rtx_CONST_INT (i1.get_mode (), 0)));
+
+	  emit_insn_before (neu, i2.get_insn ());
+
+	  log ("(c) const_cmp_to_sub replaced %s == %s (%d) with sub %d,%s\n", reg_names[i1.get_dst_regno ()],
+	  reg_names[i0.get_dst_regno ()],
+	       -intval, -intval, reg_names[i1.get_dst_regno ()]);
+
+	  if (index + 3 == lastsub)
+	    {
+	      /* patch previous sub - or even a compare. */
+	      insn_info & pp = infos[lastsub];
+
+	      int diff = lastsubval - intval;
+	      rtx c = gen_rtx_CONST_INT (i1.get_mode (), diff);
+
+	      if (pp.is_compare ())
+		{
+		  /* still a compare with 0 -> insert the sub. */
+		  rtx copyreg = copy_reg (i1.get_dst_reg (), -1);
+		  /* create the sub statement. */
+		  rtx sub = gen_rtx_PLUS(i1.get_mode (), copyreg, c);
+		  rtx set = gen_rtx_SET(copyreg, sub);
+		  emit_insn_before (set, pp.get_insn ());
+		}
+	      else
+		{
+		  /* modify the sub. */
+		  XEXP(SET_SRC(PATTERN(pp.get_insn())), 1) = c;
+		}
+	    }
+
+	  lastsub = index;
+	  ++change_count;
+	}
+    }
+#endif
+  return change_count;
+}
+
+/*
+ * rare and only little gain - but :-)
+ lea (-1,a0),a1
+ add.l d1,a1
+ subq.l #1,d1
+ ->
+ move.l a0,a1
+ subq.l #1,d1
+ add.l d1,a1
+ */
+static unsigned
+opt_merge_add (void)
+{
+  unsigned change_count = 0;
+  for (unsigned index = 0; index + 2 < infos.size (); ++index)
+    {
+      insn_info & ii0 = infos[index];
+      insn_info & ii1 = infos[index + 1];
+      insn_info & ii2 = infos[index + 2];
+
+      if (!ii2.is_dst_reg ())
+	{
+	  index += 2;
+	  continue;
+	}
+
+      if (!ii1.is_dst_reg ())
+	{
+	  ++index;
+	  continue;
+	}
+
+      if (!ii0.is_dst_reg () || ii0.get_src_op () != PLUS || ii1.get_src_op () != PLUS || ii2.get_src_op () != PLUS)
+	continue;
+
+      if (!ii0.is_src_const () || !ii2.is_src_const () || ii0.get_src_intval () != ii2.get_src_intval ())
+	continue;
+
+      if (ii0.get_dst_regno () != ii1.get_dst_regno () || ii1.get_src_regno () != ii2.get_dst_regno ())
+	continue;
+
+      rtx_insn * insn1 = ii1.get_insn ();
+
+      CC_STATUS_INIT;
+      NOTICE_UPDATE_CC(PATTERN (insn1), insn1);
+      if (cc_status.value1 || cc_status.value2)
+	continue;
+
+      log ("(m) %d: merge_add applied\n", index);
+
+      rtx_insn * insn0 = ii0.get_insn ();
+      rtx set = PATTERN (insn0);
+
+      // convert lea (-1,a0),a1 into move.l a0,a1
+      rtx_insn * newins0 = make_insn_raw (gen_rtx_SET(XEXP(set, 0), XEXP(XEXP(set, 1), 0)));
+      add_insn_after (newins0, insn0, 0);
+      SET_INSN_DELETED(insn0);
+      // update infos accordingly
+      ii0.plus_to_move (newins0);
+
+      rtx_insn * insn2 = ii2.get_insn ();
+      rtx_insn * newins1 = make_insn_raw (PATTERN (insn1));
+      add_insn_after (newins1, insn2, 0);
+      SET_INSN_DELETED(insn1);
+      ii1.swap_adds (newins1, ii2);
+
+      ++change_count;
+    }
+  return change_count;
+}
+
+/* Update the insn_infos to 'know' the sp offset. */
+static unsigned
+track_sp (int & a5_touched)
+{
+// reset visited flags - also check if sp is used as REG src.
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+      ii.clear_visited ();
+      ii.set_sp_offset (0);
+
+      if (ii.in_proepi() == IN_CODE)
+	a5_touched |= ii.get_myuse() & 0x2000;
+
+      // if sp is used as source, we cannot shrink the stack yet
+      // too complicated - well, could be done^^
+      if (ii.get_src_regno () == STACK_POINTER_REGNUM)
+	return -1;
+    }
+
+// add entry point
+  std::set<unsigned> todo;
+  todo.insert (0);
+
+  while (todo.begin () != todo.end ())
+    {
+      unsigned startpos = *todo.begin ();
+      todo.erase (todo.begin ());
+
+      int sp_offset = infos[startpos].get_sp_offset ();
+
+      for (unsigned index = startpos; index < infos.size (); ++index)
+	{
+	  insn_info & ii = infos[index];
+	  if (ii.in_proepi () != IN_CODE)
+	    {
+	      ii.set_sp_offset (sp_offset);
+	      continue;
+	    }
+
+	  // already visited? sp_offset must match
+	  if (ii.is_visited ())
+	    {
+	      if (ii.get_sp_offset () != sp_offset)
+		return E_SP_MISMATCH;
+	      break;
+	    }
+
+	  // mark current insn_info and set sp_offset
+	  ii.mark_visited ();
+	  ii.set_sp_offset (sp_offset);
+
+	  // add all referred labels
+	  if (ii.is_jump ())
+	    {
+	      for (j2l_iterator i = jump2label.find (index), k = i; i != jump2label.end () && i->first == k->first; ++i)
+		{
+		  insn_info & ll = infos[i->second];
+		  if (ll.is_visited () && ll.get_sp_offset () != sp_offset)
+		    return E_SP_MISMATCH;
+
+		  ll.set_sp_offset (sp_offset);
+		  todo.insert (i->second);
+		}
+	      continue;
+	    }
+
+	  // is sp modified directly
+	  if (ii.is_dst_reg () && ii.get_dst_regno () == STACK_POINTER_REGNUM)
+	    {
+	      // handle sp = sp + const_int
+	      if (!ii.get_src_reg () || ii.get_src_regno () != STACK_POINTER_REGNUM || ii.get_src_op () != PLUS)
+		return E_SP_MISMATCH;
+
+	      sp_offset = sp_offset + ii.get_src_intval ();
+	      continue;
+	    }
+
+	  // handle dst mem autoinc
+	  if (ii.is_dst_mem () && ii.get_dst_mem_regno () == STACK_POINTER_REGNUM && ii.get_dst_autoinc ())
+	    sp_offset += GET_MODE_SIZE(ii.get_mode()) * ii.get_dst_autoinc ();
+
+	  // handle src mem autoinc
+	  if (ii.is_src_mem () && ii.get_src_mem_regno () == STACK_POINTER_REGNUM && ii.get_src_autoinc ())
+	    sp_offset += GET_MODE_SIZE(ii.get_mode()) * ii.get_src_autoinc ();
+	}
+    }
+
+  return 0;
+}
+
+/* recursive function to patch stack pointer offsets. */
+void
+patch_sp (rtx x, int adjust, int spoffset)
+{
+  int code = GET_CODE(x);
+  if (code == PLUS)
+    {
+      rtx a = XEXP(x, 0);
+      rtx b = XEXP(x, 1);
+      if (REG_P(a) && REGNO(a) == STACK_POINTER_REGNUM && GET_CODE(b) == CONST_INT)
+	{
+	  if (INTVAL(b) > -spoffset)
+	    XEXP(x, 1) = gen_rtx_CONST_INT (GET_MODE(b), INTVAL(b) - adjust);
+	  return;
+	}
+    }
+  const char *fmt = GET_RTX_FORMAT(code);
+  for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	patch_sp (XEXP(x, i), adjust, spoffset);
+      else if (fmt[i] == 'E')
+	for (int j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  patch_sp (XVECEXP(x, i, j), adjust, spoffset);
+    }
+}
+
+/**
+ * 1. scan for all used registers.
+ * 2. scan the stack from for omittable push/pop
+ * 3. adjust stack frame + insns referring to stack pointer
+ * typical code:
+ subq.l #4,sp
+ movem.l #16190,-(sp)
+ move.l 52(sp),d2
+ move.l 56(sp),d3
+
+ * or
+ link a5,#4
+ movem.l #16190,-(sp)
+ move.l 8(a5),d2
+ move.l 12(a5),d3
+ *
+ * => with a5 check only prolog/epilog
+ * => without a5 adjust insns referring sp if offset > startoffset + current sp diff
+ *
+ * startvalue count(pushes)*4
+ * newstartvalue = startvalue - omitted pushes
+ */
+static unsigned
+opt_shrink_stack_frame (void)
+{
+  /* nothing to do. */
+  if (!infos.size ())
+    return 0;
+
+  /* needed to track sp correctly. */
+  update_label2jump ();
+  int a5_touched = 0;
+  if (track_sp (a5_touched))
+    return 0; // do nothing on stack errors
+
+  std::vector<int> a5pos;
+
+  unsigned pos = 0;
+  rtx_insn * insn = infos[pos].get_insn ();
+  if (JUMP_P(insn)) /* return -> empty function*/
+    return 0;
+
+  bool usea5 = false;
+  int paramstart = 4;
+  int a5offset = 0;
+
+  /*
+   * Move prologue to temp.
+   * Only register push and parallel insn unless its a link a5 are moved.
+   */
+  for (; pos < infos.size ();)
+    {
+      insn_info & ii = infos[pos];
+      insn = ii.get_insn ();
+
+      if (ii.in_proepi () != IN_PROLOGUE)
+	break;
+
+      rtx pattern = PATTERN (insn);
+      if (GET_CODE(pattern) == PARALLEL)
+	{
+	  rtx set = XVECEXP(pattern, 0, 0);
+	  rtx dst = SET_DEST(set);
+	  ii.mark_stack ();
+	  /* ignore link a5 */
+	  if (REG_P(dst) && REGNO(dst) == FRAME_POINTER_REGNUM)
+	    {
+	      a5pos.push_back (pos);
+	      usea5 = true;
+	      set = XVECEXP(pattern, 0, 2);
+	      a5offset = INTVAL(XEXP(SET_SRC(set), 1));
+	    }
+	  ++pos;
+	  continue;
+	}
+      if (GET_CODE(pattern) != SET)
+	{
+	  /* (set (mem:BLK (scratch) [0  A8]) (unspec:BLK [ ...)) */
+	  if (MEM_P(SET_DEST(pattern)) && GET_CODE(SET_SRC(pattern)) == UNSPEC)
+	    a5pos.push_back (pos);
+	  ++pos;
+	  continue;
+	}
+
+      /* move only the push statements. */
+      rtx src = SET_SRC(pattern);
+      rtx dest = SET_DEST(pattern);
+      if (REG_P(src))
+	{
+	  if (MEM_P(dest))
+	    {
+	      rtx predec = XEXP(dest, 0);
+	      if (GET_CODE(predec) == PRE_DEC)
+		{
+		  rtx reg = XEXP(predec, 0);
+		  if (REG_P(reg) && REGNO(reg) == STACK_POINTER_REGNUM)
+		    {
+		      ii.mark_stack ();
+		    }
+		}
+	    }
+	}
+      else if (GET_CODE(src) == PLUS && REG_P(dest) && REGNO(dest) == STACK_POINTER_REGNUM)
+	{
+	  /* check for stack variables. */
+	  rtx reg = XEXP(src, 0);
+	  rtx cx = XEXP(src, 1);
+	  if (REG_P(reg) && REGNO(reg) == STACK_POINTER_REGNUM && CONST_INT_P(cx))
+	    paramstart -= INTVAL(cx);
+	}
+
+      if (++pos >= infos.size ())
+	{
+	  return 0;
+	}
+    }
+
+  if (pos == 0)
+    return 0;
+
+  unsigned prologueend = pos;
+
+  /* search epilogues - there can be multiple epilogues. */
+  while (pos < infos.size ())
+    {
+      while (pos < infos.size ())
+	{
+	  if (infos[pos].in_proepi () != IN_CODE)
+	    break;
+	  ++pos;
+	}
+
+      /* move epilogues away. */
+      for (; pos < infos.size (); ++pos)
+	{
+	  insn_info & ii = infos[pos];
+	  insn = ii.get_insn ();
+	  if (JUMP_P(insn) || LABEL_P(insn) || ii.in_proepi () == IN_CODE)
+	    break;
+
+	  /* omit the frame pointer a5. */
+	  rtx pattern = PATTERN (insn);
+	  if (GET_CODE(pattern) == PARALLEL)
+	    {
+	      rtx set = XVECEXP(pattern, 0, 0);
+	      rtx dst = SET_DEST(set);
+	      ii.mark_stack ();
+	      /* unlink is last. */
+	      if (REG_P(dst) && REGNO(dst) == FRAME_POINTER_REGNUM)
+		{
+		  a5pos.push_back (pos);
+		  break;
+		}
+
+	    }
+	  else if (GET_CODE(pattern) == SET)
+	    {
+	      /* check for move (a7+), x */
+	      rtx src = SET_SRC(pattern);
+	      rtx dst = SET_DEST(pattern);
+	      if (REG_P(dst))
+		{
+		  if (MEM_P(src))
+		    {
+		      rtx postinc = XEXP(src, 0);
+		      if (GET_CODE(postinc) == POST_INC)
+			{
+			  rtx reg = XEXP(postinc, 0);
+			  if (REG_P(reg) && REGNO(reg) == STACK_POINTER_REGNUM)
+			    ii.mark_stack ();
+			}
+		      else if (GET_CODE(postinc) == PLUS)
+			{
+			  rtx a5 = XEXP(postinc, 0);
+			  if (REG_P(a5) && REGNO(a5) == FRAME_POINTER_REGNUM)
+			    ii.mark_stack ();
+			}
+		    }
+		}
+	    }
+	}
+      ++pos;
+    }
+
+  unsigned freemask = 0x7fff & ~usable_regs;
+
+  /* do not remove a4 push/pop in baserel modes, if __saveds or commandline demands it. */
+  if (flag_pic > 2)
+    {
+      tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+      tree attr = lookup_attribute ("saveds", attrs);
+      if (attr || TARGET_RESTORE_A4 || TARGET_ALWAYS_RESTORE_A4)
+	freemask &= ~(1 << PIC_REG);
+    }
+
+  rtx a7 = gen_raw_REG (SImode, STACK_POINTER_REGNUM);
+  rtx a5 = gen_raw_REG (SImode, FRAME_POINTER_REGNUM);
+
+  unsigned changed = 0;
+  unsigned adjust = 0;
+  unsigned regs_seen = 0;
+  unsigned regs_total_size = 0;
+  /* now all push/pop insns are in temp. */
+  for (unsigned i = 0; i < infos.size (); ++i)
+    {
+      insn_info & ii = infos[i];
+      if (!ii.is_stack ())
+	continue;
+
+      insn = ii.get_insn ();
+      rtx pattern = PATTERN (insn);
+      /* check the pushed regs, either a vector or single statements */
+      if (GET_CODE(pattern) == PARALLEL)
+	{
+	  // do not touch the frame pointer parallel insn.
+	  rtx set = XVECEXP(pattern, 0, 0);
+	  rtx dst = SET_DEST(set);
+	  if (REG_P(dst) && REGNO(dst) == FRAME_POINTER_REGNUM)
+	    continue;
+
+	  if (ii.in_proepi () == IN_EPILOGUE)
+	    ii.set_proepi (IN_EPILOGUE_PARALLEL_POP);
+
+	  regs_seen = 0;
+	  regs_total_size = 0;
+	  std::vector<rtx> regs;
+	  std::vector<rtx> clobbers;
+	  for (int j = 0; j < XVECLEN(pattern, 0); ++j)
+	    {
+	      rtx set = XVECEXP(pattern, 0, j);
+	      if (GET_CODE(set) == CLOBBER)
+		{
+		  clobbers.push_back (set);
+		  continue;
+		}
+	      rtx dst = SET_DEST(set);
+	      rtx src = SET_SRC(set);
+	      rtx reg;
+	      if (MEM_P(src))
+		reg = dst;
+	      else if (MEM_P(dst))
+		reg = src;
+	      else
+		continue;
+
+	      if (i < prologueend)
+		paramstart += 4;
+	      unsigned regbit = 1 << REGNO(reg);
+
+	      ++regs_seen;
+	      if (freemask & regbit)
+		{
+		  log (i < prologueend ? "(f) remove push for %s\n" : "(f) remove pop for %s\n",
+		  reg_names[REGNO(reg)]);
+		  if (i < prologueend)
+		    adjust += GET_MODE_SIZE(GET_MODE(reg));
+		}
+	      else
+		{
+		  regs_total_size += GET_MODE_SIZE(GET_MODE(reg));
+		  regs.push_back (copy_reg (reg, -1));
+		}
+	    }
+
+	  /* add room for add.
+	   * push is always using -(a7) addressing.
+	   * If a5 is used a movem offset(a5) is generated to pop saved registers..
+	   * Otherwise a7 is used and with (a7)+ addressing.
+	   */
+	  int add1 = i < prologueend || !usea5 ? 1 : 0;
+	  if (regs.size () < regs_seen)
+	    {
+	      log ("(f) shrinking stack frame from %d to %d\n", regs_seen, regs.size ());
+	      if (regs.size () <= 2)
+		{
+		  changed = 1;
+		  for (unsigned k = 0; k < regs.size (); ++k)
+		    {
+		      rtx reg = regs[k];
+		      if (i < prologueend)
+			{
+			  /* push */
+			  rtx dec = gen_rtx_PRE_DEC(REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, a7);
+			  rtx mem = gen_rtx_MEM (REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, dec);
+			  rtx set = gen_rtx_SET(mem, reg);
+			  emit_insn_after (set, insn);
+			}
+		      else
+			{
+			  /* pop */
+			  rtx dec = gen_rtx_POST_INC(REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, a7);
+			  rtx mem = gen_rtx_MEM (REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, dec);
+			  rtx set = gen_rtx_SET(reg, mem);
+			  emit_insn_before (set, insn);
+			}
+		    }
+		}
+	      else
+		{
+		  rtx parallel = gen_rtx_PARALLEL(VOIDmode, rtvec_alloc (regs.size () + add1 + clobbers.size ()));
+		  rtx plus;
+
+		  int x = 0;
+		  for (unsigned k = 0; k < regs.size (); ++k)
+		    x += REGNO(regs[k]) > STACK_POINTER_REGNUM ? 12 : 4;
+
+		  unsigned l = 0;
+		  /* no add if a5 is used with pop */
+		  if (add1)
+		    {
+		      plus = gen_rtx_PLUS(SImode, a7, gen_rtx_CONST_INT (SImode, i < prologueend ? -x : x));
+		      XVECEXP(parallel, 0, l) = gen_rtx_SET(a7, plus);
+		      ++l;
+		    }
+
+		  if (i >= prologueend)
+		    x = usea5 ? -x : 0;
+
+		  for (unsigned k = 0; k < regs.size (); ++k, ++l)
+		    {
+		      if (i < prologueend)
+			{
+			  /* push */
+			  plus = gen_rtx_PLUS(SImode, a7, gen_rtx_CONST_INT (SImode, -x));
+			  x -= REGNO(regs[k]) > STACK_POINTER_REGNUM ? 12 : 4;
+			  rtx mem = gen_rtx_MEM (REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, plus);
+			  rtx set = gen_rtx_SET(mem, regs[k]);
+			  XVECEXP(parallel, 0, l) = set;
+			}
+		      else
+			{
+			  /* pop */
+			  if (usea5)
+			    {
+			      x += REGNO(regs[k]) > STACK_POINTER_REGNUM ? 12 : 4;
+			      plus = gen_rtx_PLUS(SImode, a5, gen_rtx_CONST_INT (SImode, a5offset + x));
+			      rtx mem = gen_rtx_MEM (REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, plus);
+			      rtx set = gen_rtx_SET(regs[k], mem);
+			      XVECEXP(parallel, 0, l) = set;
+			    }
+			  else
+			    {
+			      plus = x ? gen_rtx_PLUS(SImode, a7, gen_rtx_CONST_INT (SImode, x)) : a7;
+			      x += REGNO(regs[k]) > STACK_POINTER_REGNUM ? 12 : 4;
+			      rtx mem = gen_rtx_MEM (REGNO(regs[k]) > STACK_POINTER_REGNUM ? XFmode : SImode, plus);
+			      rtx set = gen_rtx_SET(regs[k], mem);
+			      XVECEXP(parallel, 0, l) = set;
+			    }
+			}
+		    }
+
+		  for (unsigned k = 0; k < clobbers.size (); ++k, ++l)
+		    {
+		      rtx clobber = clobbers[k];
+		      XVECEXP(parallel, 0, l) = clobber;
+		    }
+
+		  rtx_insn * neu;
+		  if (i < prologueend)
+		    neu = emit_insn_after (parallel, insn);
+		  else
+		    neu = emit_insn_before (parallel, insn);
+		  ii.set_insn (neu);
+		}
+	      SET_INSN_DELETED(insn);
+	      changed = 1;
+	    }
+	}
+      else
+	{
+	  rtx set = PATTERN (insn);
+
+	  if (i < prologueend)
+	    {
+	      /* move x,-(a7). */
+	      rtx src = SET_SRC(set);
+	      paramstart += REGNO(src) > STACK_POINTER_REGNUM ? 12 : 4;
+	      unsigned regbit = 1 << REGNO(src);
+	      if (freemask & regbit)
+		{
+		  adjust += REGNO(src) > STACK_POINTER_REGNUM ? 12 : 4;
+		  log ("(f) remove push for %s\n", reg_names[REGNO(src)]);
+		  SET_INSN_DELETED(insn);
+		  ++changed;
+		}
+	      else
+		{
+		  regs_total_size += GET_MODE_SIZE(GET_MODE(src));
+		}
+	    }
+	  else
+	    {
+	      /* move (a7)+,x */
+	      rtx dst = SET_DEST(set);
+	      unsigned regbit = 1 << REGNO(dst);
+	      if (freemask & regbit)
+		{
+		  log ("(f) remove pop for %s\n", reg_names[REGNO(dst)]);
+		  SET_INSN_DELETED(insn);
+		  ++changed;
+		}
+	    }
+	}
+    }
+
+  /* fix sp offsets. */
+  if (!usea5 && adjust)
+    {
+      for (unsigned index = 0; index < infos.size (); ++index)
+	{
+	  insn_info & ii = infos[index];
+	  if (ii.in_proepi () != IN_CODE)
+	    continue;
+
+	  rtx pattern = single_set (ii.get_insn ());
+	  if (pattern)
+	    patch_sp (pattern, adjust, ii.get_sp_offset ());
+	}
+    }
+
+  if (usea5 && a5offset == -4)
+    {
+      /* for now only drop the frame pointer if it's not used.
+       * Needs tracking of the sp to adjust the offsets.
+       */
+      if (!a5_touched)
+	{
+	  log ("(f) dropping unused frame pointer\n");
+	  for (std::vector<int>::reverse_iterator i = a5pos.rbegin (); i != a5pos.rend (); ++i)
+	    {
+	      int index = *i;
+	      SET_INSN_DELETED(infos[index].get_insn ());
+
+	      // move to last insn in epilogue
+	      while (index - 1 > 0 && infos[index - 1].in_proepi () >= IN_EPILOGUE)
+		--index;
+
+	      insn_info & ii = infos[index];
+	      if (ii.in_proepi () >= IN_EPILOGUE && ii.get_sp_offset () != 0)
+		{
+		  log ("(f) adjusting exit sp\n");
+		  rtx pattern = gen_rtx_SET(
+		      a7, gen_rtx_PLUS (SImode, a7, gen_rtx_CONST_INT (SImode, -ii.get_sp_offset ())));
+		  emit_insn_before (pattern, ii.get_insn ());
+		}
+	    }
+
+	  /* convert all parameter accesses via a5 into a7. */
+	  for (unsigned i = 0; i < infos.size (); ++i)
+	    {
+	      insn_info & ii = infos[i];
+
+	      //skip already deleted insns.
+	      if (GET_CODE(ii.get_insn()) == NOTE)
+		continue;
+	      if (ii.get_myuse () & (1 << FRAME_POINTER_REGNUM))
+		{
+		  ii.a5_to_a7 (a7, regs_total_size - ii.get_sp_offset());
+		  if (regs_total_size && regs_seen && ii.in_proepi () == IN_EPILOGUE_PARALLEL_POP)
+		    {
+		      // exit sp insn needs an +
+		      rtx pattern = PATTERN (ii.get_insn ());
+		      unsigned sz = XVECLEN(pattern, 0);
+
+		      rtx parallel = gen_rtx_PARALLEL(VOIDmode, rtvec_alloc (sz + 1));
+		      unsigned n = 0;
+		      for (unsigned j = 0; j < sz; ++j)
+			{
+			  rtx set = XVECEXP(pattern, 0, j);
+			  rtx reg = SET_DEST(set);
+			  rtx mem = SET_SRC(set);
+			  rtx plus = XEXP(mem, 0);
+			  if (n)
+			    {
+			      XEXP(plus, 1) = gen_rtx_CONST_INT (SImode, n);
+			    }
+			  else
+			    {
+			      XEXP(mem, 0) = XEXP(plus, 0);
+			    }
+			  n += GET_MODE_SIZE(GET_MODE(reg));
+			  XVECEXP(parallel, 0, j + 1) = set;
+			}
+
+		      rtx a = copy_reg (a7, -1);
+		      a->frame_related = 1;
+		      rtx plus = gen_rtx_PLUS(SImode, a, gen_rtx_CONST_INT (SImode, regs_total_size));
+		      rtx set = gen_rtx_SET(a, plus);
+		      XVECEXP(parallel, 0, 0) = set;
+		      SET_INSN_DELETED(ii.get_insn ());
+		      ii.set_insn (emit_insn_after (parallel, ii.get_insn ()));
+		    }
+		}
+
+	      ii.unset (FRAME_POINTER_REGNUM);
+	    }
+
+	  update_insn2index ();
+	  ++changed;
+	}
+    }
+
+  return changed;
+}
+
+/* Update the insn_infos to 'know' the value for each register.
+ *
+ * assignments to registers are optimized by knowing the value. If the same value is assigned, omit that insn.
+ *
+ * I'm tracking
+ *
+ *  rtx - the value
+ *
+ *  mask - the referenced registers in the value, 0 means that rtx is const, with baserel a4 is not tracked
+ *
+ *  if there is a value for the referenced register(s), the value is extended
+ *
+ * e.g.
+ *
+ * ; line 2
+ *    move.l 12(a7),a0
+ *
+ * -> rtx = mem(plus(a7, 12));   0x8000
+ *
+ * ; line 10
+ *    move.l 4(a0),d0
+ *
+ * -> rtx = mem(plus(mem(plus(a7, 12)), 4));   0x8000; extended with value from a0, thus a7 is used only
+ *
+ * ;15
+ *    lea _label,a1
+ *
+ * -> rtx = symbol_ref(_label) ; 0x0000 == const
+ *
+ * on jumps the current state is duplicated and merged at the given label
+ *
+ * on merge only identical info is kept, rest is discarded
+ *
+ * for each insn for all defined regs the value and mask  is discarded before a new value is set.
+ *
+ * for each insn which is writing to memory, all non const values are discarded.
+ *
+ *
+ * after the track info is complete, each insn setting a register is evaluated against the track info.
+ *
+ * now redundant loads are found and eliminated
+ *
+ */
+
+static unsigned
+track_regs ()
+{
+// reset visited flags
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+      ii.clear_visited ();
+      ii.set_sp_offset (0);
+    }
+
+  update_label2jump ();
+
+// add entry point
+  std::multimap<unsigned, track_var *> todo;
+  todo.insert (std::make_pair (0, new track_var ()));
+
+  while (todo.begin () != todo.end ())
+    {
+      unsigned startpos = todo.begin ()->first;
+      track_var * const track = todo.begin ()->second;
+      todo.erase (todo.begin ());
+
+      for (unsigned index = startpos; index < infos.size (); ++index)
+	{
+	  insn_info & ii = infos[index];
+
+	  // already visited?
+	  if (index != startpos && ii.is_visited () && ii.get_track_var ()->no_merge_needed (track))
+	    break;
+
+	  // only keep common values at labels
+	  if (ii.is_label ())
+	    {
+	      if (ii.is_visited ())
+		{
+		  ii.get_track_var ()->merge (track, index);
+		}
+	      else
+		{
+		  ii.get_track_var ()->assign (track);
+		  ii.mark_visited ();
+		}
+	      continue;
+	    }
+
+	  // mark current insn_info and set sp_offset
+	  ii.mark_visited ();
+	  ii.get_track_var ()->assign (track);
+
+	  unsigned def = ii.get_def () & 0xffffff;
+	  if (def)
+	    {
+	      // more than one register set? or mask from clobber?
+	      if (((def - 1) & def) || !ii.get_dst_reg ())
+		track->clear_for_mask (def, index);
+	    }
+
+	  // compare must not clear
+	  if (ii.is_compare ())
+	    continue;
+
+	  // do not clear if self assigned unless there is an operator
+	  int dregno = ii.get_dst_regno ();
+	  unsigned dmask = track->getMask(dregno);
+	  if (dregno != ii.get_src_regno () || ii.get_src_op ())
+	    track->clear (ii.get_mode (), dregno, index);
+
+
+	  if (ii.is_call ())
+	    {
+	      track->clear_aftercall (index);
+	      continue;
+	    }
+
+	  rtx set = single_set (ii.get_insn ());
+
+	  // add all referred labels
+	  if (ii.is_jump ())
+	    {
+	      if (ANY_RETURN_P(ii.get_insn ()))
+		break;
+
+	      for (j2l_iterator i = jump2label.find (index), k = i; i != jump2label.end () && i->first == k->first; ++i)
+		todo.insert (std::make_pair (i->second, new track_var (track)));
+
+	      if (set && GET_CODE(SET_SRC(set)) == IF_THEN_ELSE)
+		continue;
+
+	      // unconditional jump
+	      break;
+	    }
+
+	  if (!set || !ii.get_def ())
+	    continue;
+
+	  if (dregno < 0)
+	    {
+	      track->invalidate_mem (SET_DEST(set));
+	      continue;
+	    }
+
+	  // operation, autoinf or more than one register used: can't cache
+	  if (ii.get_src_autoinc () || ((ii.get_myuse () - 1) & ii.get_myuse ()))
+	    continue;
+
+	  if (ii.get_src_op ())
+	    {
+	      if (ii.get_src_op() == AND)
+		{
+		  rtx op = XEXP(SET_SRC(set), 1);
+		  if (GET_CODE(op) == CONST_INT)
+		    track->setMask(dregno, INTVAL(op) & dmask, ii.get_mode());
+		  else if (REG_P(op))
+		    track->setMask(dregno, track->getMask(REGNO(op)) & dmask, ii.get_mode());
+		}
+	      else if (ii.get_src_op() == ZERO_EXTRACT) {
+		  unsigned mask = (1 << INTVAL(XEXP(SET_SRC(set), 1))) - 1;
+		  track->setMask(dregno, mask & dmask, ii.get_mode());
+	      }
+	      continue;
+	    }
+
+	  rtx src = SET_SRC(set);
+	  if (ii.is_src_mem () && src->volatil)
+	    continue;
+
+	  track->set (ii.get_mode (), dregno, src, ii.get_myuse(), index);
+	}
+      delete track;
+    }
+  return 0;
+}
+
+/*
+ * Some optimizations (e.g. propagate_moves) might result into an unused assignment behind the loop.
+ * delete those insns.
+ */
+static unsigned
+opt_elim_dead_assign (int blocked_regno)
+{
+  track_regs ();
+
+  unsigned mask = 0;
+
+  unsigned change_count = 0;
+  for (int index = infos.size () - 1; index >= 0; --index)
+    {
+      insn_info & ii = infos[index];
+      if (ii.in_proepi () || !ii.get_dst_reg () || ii.is_compare ())
+	continue;
+
+      rtx_insn * insn = ii.get_insn ();
+      rtx set = single_set (insn);
+      if (!set)
+	continue;
+
+      if (!ii.is_dst_reg() || ii.get_dst_regno () == blocked_regno)
+	continue;
+
+      if (GET_CODE(SET_SRC(set)) == AND)
+	{
+	  track_var * tv = ii.get_track_var();
+	  unsigned lmask = tv->getMask(ii.get_dst_regno());
+	  unsigned nmask = 0;
+	  rtx andval = XEXP(SET_SRC(set), 1);
+
+	  if (REG_P(andval))
+	    {
+	      rtx val = tv->get(REGNO(andval));
+	      if (val && GET_CODE(val) == CONST_INT)
+		{
+		  long long int lli = INTVAL(val);
+		  if (lli < 0x100000000LL)
+		    {
+		      andval = val;
+		    }
+		  else if (lli & 0x100000000000000LL)
+		    {
+		      unsigned refreg = (lli >> 32) & 0xff;
+		      andval = tv->get(refreg);
+		    }
+		}
+	    }
+	  if (andval && GET_CODE(andval) == CONST_INT)
+	    {
+	      long long int lli = UINTVAL(andval);
+	      if (lli < 0x100000000LL)
+		{
+		  unsigned val = lli;
+		  if (GET_MODE_SIZE(ii.get_mode()) == 1)
+		    val |= 0xffffff00;
+		  else if (GET_MODE_SIZE(ii.get_mode()) < 4)
+		    val |= 0xffff0000;
+
+		  nmask = lmask & val;
+		}
+	    }
+
+	  if (lmask == nmask)
+	    {
+	      log ("(e) %d: eliminate superfluous 'and' to %s  %08x->%08x\n",
+		   index, reg_names[ii.get_dst_regno ()], lmask, nmask);
+	      SET_INSN_DELETED(insn);
+	      ++change_count;
+	    }
+	  continue;
+	}
+
+      if (mask & (1<<ii.get_dst_regno ()))
+	continue;
+
+      if (REG_NREGS(ii.get_dst_reg ()) == 1
+	  && is_reg_dead (ii.get_dst_regno (), index))
+	{
+	  mask |= (1<<ii.get_dst_regno ());
+
+	  log ("(e) %d: eliminate dead assign to %s\n", index, reg_names[ii.get_dst_regno ()]);
+	  SET_INSN_DELETED(insn);
+	  ++change_count;
+	  continue;
+	}
+
+      // check for redundant load
+      if (ii.get_src_op () == 0 && ii.get_dst_reg ()
+	  && (!ii.is_myuse (ii.get_dst_regno ()) || ii.get_dst_regno () == ii.get_src_regno ()))
+	{
+	  track_var * track = ii.get_track_var ();
+
+	  rtx src = SET_SRC(set);
+	  if (track->equals (ii.get_mode(), ii.get_dst_regno (), src))
+	    {
+	      mask |= (1<<ii.get_dst_regno ());
+
+	      log ("(e) %d: eliminate redundant load to %s\n", index, reg_names[ii.get_dst_regno ()]);
+	      SET_INSN_DELETED(insn);
+	      ++change_count;
+	      continue;
+	    }
+
+	  if (ii.get_dst_regno () == ii.get_src_regno () && GET_MODE(ii.get_src_reg()) == GET_MODE(ii.get_dst_reg()) && is_reg_dead(16, index))
+	    {
+	      log ("(e) %d: eliminate self load of %s\n", index, reg_names[ii.get_dst_regno ()]);
+	      SET_INSN_DELETED(insn);
+	      ++change_count;
+	      continue;
+	    }
+
+	  if (ii.get_src_reg () && track->equals (ii.get_mode(), ii.get_src_regno (), SET_DEST(set)))
+	    {
+	      mask |= (1<<ii.get_dst_regno ());
+
+	      log ("(e) %d: eliminate redundant reverse load to %s\n", index, reg_names[ii.get_dst_regno ()]);
+	      SET_INSN_DELETED(insn);
+	      ++change_count;
+	      continue;
+	    }
+
+	  // is there a register holding that value?
+	  if (!ii.get_src_reg ())
+	    {
+	      int aliasRegno = track->find_alias (src);
+	      if (aliasRegno >= 0 && aliasRegno != ii.get_dst_regno ())
+		{
+
+		  if ( (mask & (1<<aliasRegno)))
+		    continue;
+
+		  mask |= (1<<ii.get_dst_regno ()) | (1<<aliasRegno);
+
+		  log ("(e) %d: replace load with %s\n", index, reg_names[aliasRegno]);
+		  validate_change (ii.get_insn (), &SET_SRC(set), gen_rtx_REG (ii.get_mode (), aliasRegno), 0);
+		  ++change_count;
+		}
+	    }
+	}
+    }
+  return change_count;
+}
+
+/*
+ * Convert a series of move into absolute address into register based moves.
+ */
+static unsigned
+opt_absolute (void)
+{
+  unsigned change_count = 0;
+
+  for (unsigned i = 0; i < infos.size (); ++i)
+    {
+      insn_info & ii = infos[i];
+
+      if (ii.is_compare ())
+	continue;
+
+      if (ii.get_src_op () && ii.is_src_ee () && !ii.get_src_intval ())
+	continue;
+
+      bool is_dst = ii.is_dst_mem () && (ii.has_dst_addr () || ii.get_dst_symbol ()) && !ii.has_dst_memreg ();
+      bool is_src = ii.is_src_mem () && (ii.has_src_addr () || ii.get_src_symbol ()) && !ii.has_src_memreg ();
+
+      if (!is_dst && !is_src)
+	continue;
+
+      if (ii.get_mode () == VOIDmode)
+	continue;
+
+      unsigned freemask = ~(ii.get_use () | ii.get_def ()) & 0x7f00 & usable_regs;
+      if (!freemask)
+	continue;
+
+      rtx with_symbol = is_dst ? ii.get_dst_symbol () : ii.get_src_symbol ();
+
+      std::vector<unsigned> found;
+      found.push_back (i);
+      int base = ii.get_dst_mem_addr ();
+      int max = base;
+      unsigned j = i + 1;
+      for (; j < infos.size (); ++j)
+	{
+	  insn_info & jj = infos[j];
+	  /* TODO: continue also at jump target */
+	  if (jj.is_jump ())
+	    continue;
+	  /* TODO: check if label is visited only from jump targets from herein. then the label is ok. */
+	  if (jj.is_label ())
+	    break;
+
+	  unsigned tempmask = freemask & ~(jj.get_use () | jj.get_def ());
+	  if (!tempmask)
+	    break;
+	  freemask = tempmask;
+
+	  if (jj.get_mode () == VOIDmode || jj.is_compare ())
+	    continue;
+
+	  if (jj.get_src_op () && jj.is_src_ee () && !jj.get_src_intval ())
+	    continue;
+
+	  bool j_dst = jj.is_dst_mem () && (jj.has_dst_addr () || jj.get_dst_symbol ()) && !jj.has_dst_memreg ()
+	      && jj.get_dst_symbol () == with_symbol;
+	  bool j_src = jj.is_src_mem () && (jj.has_src_addr () || jj.get_src_symbol ()) && !jj.has_src_memreg ()
+	      && jj.get_src_symbol () == with_symbol;
+
+	  /* exclude operations on that symbol. */
+
+	  if (j_dst)
+	    {
+	      int addr = jj.get_dst_mem_addr ();
+	      if (addr < base)
+		{
+		  if (max - addr <= 0x7ffe)
+		    {
+		      base = addr;
+		      found.push_back (j);
+		      continue;
+		    }
+		}
+	      else if (addr - base <= 0x7ffe)
+		{
+		  if (addr > max)
+		    max = addr;
+		  found.push_back (j);
+		  continue;
+		}
+	    }
+	  if (j_src)
+	    {
+	      int addr = jj.get_src_mem_addr ();
+	      if (addr < base)
+		{
+		  if (max - addr <= 0x7ffe)
+		    {
+		      base = addr;
+		      found.push_back (j);
+		      continue;
+		    }
+		}
+	      else if (addr - base <= 0x7ffe)
+		{
+		  if (addr > max)
+		    max = addr;
+		  found.push_back (j);
+		  continue;
+		}
+	    }
+	}
+
+      if (freemask && found.size () > 2)
+	{
+	  unsigned regno = bit2regno (freemask);
+	  /* check again. */
+	  for (std::vector<unsigned>::iterator k = found.begin (); k != found.end ();)
+	    {
+	      insn_info & kk = infos[*k];
+	      bool k_dst = kk.is_dst_mem () && (kk.has_dst_addr () || kk.get_dst_symbol ()) && !kk.has_dst_memreg ()
+		  && kk.get_dst_symbol () == with_symbol;
+	      bool k_src = kk.is_src_mem () && (kk.has_src_addr () || kk.get_src_symbol ()) && !kk.has_src_memreg ()
+		  && kk.get_src_symbol () == with_symbol;
+	      if (k_dst && kk.get_dst_mem_addr () - base > 0x7ffc)
+		k = found.erase (k);
+	      else if (k_src && kk.get_src_mem_addr () - base > 0x7ffc)
+		k = found.erase (k);
+	      else if (insn_invalid_p (make_insn_raw (kk.make_absolute2base (regno, base, with_symbol, false)), 0))
+		k = found.erase (k);
+	      else
+		++k;
+	    }
+	}
+      if (freemask && found.size () > 2)
+	{
+	  unsigned regno = bit2regno (freemask);
+	  if (with_symbol)
+	    log ("(b) modifying %d symbol addresses for %s using %s\n", found.size (),
+		 with_symbol->u.block_sym.fld[0].rt_str, reg_names[regno]);
+	  else
+	    log ("(b) modifying %d absolute addresses using %s\n", found.size (), reg_names[regno]);
+
+	  unsigned current_use = ii.get_use ();
+
+	  for (std::vector<unsigned>::iterator k = found.begin (); k != found.end (); ++k)
+	    {
+	      insn_info & kk = infos[*k];
+	      kk.absolute2base (regno, base, with_symbol);
+	      insn_invalid_p (kk.get_insn (), 0);
+	    }
+
+	  // load base into reg
+	  rtx lea;
+
+	  if (with_symbol)
+	    {
+	      if (base)
+		lea = gen_rtx_SET(
+		    gen_raw_REG (SImode, regno),
+		    gen_rtx_CONST (SImode, gen_rtx_PLUS (SImode, with_symbol, gen_rtx_CONST_INT (SImode, base))));
+	      else
+		lea = gen_rtx_SET(gen_raw_REG (SImode, regno), with_symbol);
+	    }
+	  else
+	    lea = gen_rtx_SET(gen_raw_REG (SImode, regno), gen_rtx_CONST_INT (SImode, base));
+	  rtx_insn * insn = emit_insn_before (lea, ii.get_insn ());
+	  insn_info nn (insn);
+	  nn.set_use (current_use);
+	  nn.scan ();
+	  nn.fledder (lea);
+	  nn.mark_def (regno);
+	  infos.insert (infos.begin () + i, nn);
+
+	  /* mark until last hit is found. */
+	  for (unsigned k = i + 1; k < infos.size (); ++k)
+	    {
+	      infos[k].mark_use (regno);
+	      if (k == *found.rbegin ())
+		break;
+	    }
+	  ++change_count;
+	  --i;
+	}
+    }
+
+  if (change_count)
+    update_insn2index ();
+
+  return change_count;
+}
+
+static int
+try_auto_inc (unsigned index, insn_info & ii, rtx reg)
+{
+  int const regno = REGNO(reg);
+  rtx iiset = single_set(ii.get_insn());
+  if (!iiset)
+    return 0;
+
+  // move.w (a0)+,a1 reads a word but writes a long...
+  unsigned size = GET_MODE_SIZE(ii.get_mode());
+  if (reg == ii.get_src_mem_reg() && GET_CODE(SET_SRC(iiset)) == SIGN_EXTEND)
+    size /= 2;
+  if (size > 4)
+    return 0;
+
+//      log ("starting auto_inc search for %s at %d\n", reg_names[regno], index);
+
+  // track all fixups to modify
+  std::set<unsigned> fixups;
+
+  // all paths to check
+  std::vector<unsigned> todo;
+  todo.push_back (index + 1);
+
+  bool match_size = false;
+  std::set<unsigned> visited;
+  while (todo.size () > 0)
+    {
+      unsigned pos = todo[todo.size () - 1];
+      todo.pop_back ();
+
+      if (pos == index)
+	return 0;
+
+      if (visited.find (pos) != visited.end ())
+	continue;
+      visited.insert (pos);
+
+      for (; pos < infos.size (); ++pos)
+	{
+	  insn_info & jj = infos[pos];
+
+	  // check all jumps labels for register usage
+	  if (jj.is_label ())
+	    {
+	      for (l2j_iterator j = label2jump.find (jj.get_insn ()->u2.insn_uid), k = j;
+		  j != label2jump.end () && j->first == k->first; ++j)
+		{
+		  insn_info * ll = insn2info.find (j->second)->second;
+		  if (ll->is_use (regno))
+		    return 0;
+		}
+	      break;
+	    }
+
+	  // break if no longer used
+	  if (!jj.is_use (regno))
+	    break;
+
+	  // abort if a parallel insn is touched.
+	  if (GET_CODE(PATTERN(jj.get_insn())) == PARALLEL && (jj.is_def(regno) || jj.is_myuse(regno)))
+	    return 0;
+
+	  if (jj.in_proepi ())
+	    return 0;
+
+	  // add all labels
+	  if (jj.is_jump ())
+	    {
+	      for (j2l_iterator j = jump2label.find (pos), k = j; j != jump2label.end () && j->first == k->first; ++j)
+		todo.push_back (j->second);
+	      continue;
+	    }
+
+	  // not used directly
+	  if (!jj.is_myuse (regno))
+	    continue;
+
+	  // can't fixup such kind of insn (yet)
+	  if (single_set (jj.get_insn ()) == 0)
+	    return 0;
+
+	  // if reg is src reg, op must be add and addend must be large enough
+	  bool fix = false;
+	  if (jj.get_src_mem_regno () == regno)
+	    {
+	      if (jj.get_dst_regno () == regno)
+		return 0;
+
+	      if (jj.get_src_mem_addr () < size)
+		return 0;
+
+	      if (jj.get_src_mem_addr () == size)
+		match_size = true;
+
+	      fix = true;
+	    }
+	  if (jj.get_dst_mem_regno () == regno)
+	    {
+	      if (jj.get_src_regno () == regno)
+		return 0;
+
+	      if (jj.get_dst_mem_addr () < size)
+		return 0;
+
+	      if (jj.get_dst_mem_addr () == size)
+		match_size = true;
+
+	      fix = true;
+	    }
+
+	  if (!fix)
+	    return 0;
+
+	  fixups.insert (pos);
+
+	  // done if this is an add
+	  if (ii.is_def (regno))
+	    break;
+	}
+    }
+
+  if (!match_size || !fixups.size ())
+    return 0;
+
+  if (!ii.make_post_inc (regno))
+    return 0;
+
+  log ("(i) auto_inc for %s at %d - %d fixups\n", reg_names[regno], index, fixups.size ());
+
+  // fix all offsets / adds
+  for (std::set<unsigned>::iterator k = fixups.begin (); k != fixups.end (); ++k)
+    {
+//	  log ("(i) fixup at %d\n", *k);
+      insn_info & kk = infos[*k];
+      kk.auto_inc_fixup (regno, size);
+    }
+  return 1;
+}
+
+/*
+ * Convert a series of reg with offset ( (ax), 4(ax), 8(ax), ...) into autoincx ( (ax+), (ax+), (ax+), ...)
+ *
+ * 1. search a mem(reg) without offset and either src or dst is using that reg
+ * 2. follow paths until reg is dead
+ * 3. if there is another mem(reg) with offset check that
+ *  a) offset fits last mode size
+ *  b) all remaining insn using that reg can be updated by
+ *    i) decrement the offset
+ *    ii) decrement the add value
+ */
+static unsigned
+opt_autoinc ()
+{
+  unsigned change_count = 0;
+
+  update_label2jump ();
+
+  for (unsigned index = 0; index < infos.size (); ++index)
+    {
+      insn_info & ii = infos[index];
+
+      if (ii.in_proepi ())
+	continue;
+
+      if (!INSN_P(ii.get_insn ()))
+	continue;
+
+      if (GET_CODE(PATTERN(ii.get_insn())) == PARALLEL)
+	continue;
+
+      if (ii.is_src_mem () && ii.get_src_mem_regno () >= 8 && !ii.get_src_mem_addr () && !ii.get_src_autoinc ()
+	  && ii.get_src_mem_regno () != ii.get_dst_mem_regno () && ii.get_src_mem_regno () != ii.get_dst_regno ())
+	change_count += try_auto_inc (index, ii, ii.get_src_mem_reg ());
+
+      if (ii.is_dst_mem () && ii.get_dst_mem_regno () >= 8 && !ii.get_dst_intval () && !ii.get_dst_autoinc ()
+	  && ii.get_src_mem_regno () != ii.get_dst_mem_regno () && ii.get_src_regno () != ii.get_dst_mem_regno ())
+	change_count += try_auto_inc (index, ii, ii.get_dst_mem_reg ());
+
+    }
+
+  return change_count;
+}
+
+/*
+ * A final pass, with these optimizations:
+ *
+ * - convert cmp #0,ax int move.l ax,dy if there is a free dy
+ */
+static unsigned
+opt_final()
+{
+  unsigned change_count = 0;
+  for (unsigned index = 0; index < infos.size(); ++index)
+    {
+      insn_info &ii = infos[index];
+
+      // cmp #0,ax
+      if (ii.is_compare() && ii.get_dst_reg() && ii.get_dst_regno() >= 8 && ii.get_dst_regno() <= 15 && !ii.get_src_mem_reg() && ii.is_src_const() && ii.get_src_intval() == 0)
+	{
+	  // if there is a free dx register use a move
+	  unsigned avail_dx = (usable_regs & ~ii.get_use()) & 0xff;
+	  if (avail_dx)
+	    {
+	      unsigned regno = 0;
+	      while ((avail_dx & 1) == 0)
+		{
+		  ++regno;
+		  avail_dx >>= 1;
+		}
+	      rtx dx = gen_raw_REG(SImode, regno);
+	      rtx ax = gen_raw_REG(SImode, ii.get_dst_regno());
+	      rtx set = gen_rtx_SET(dx, ax);
+	      emit_insn_before (set, ii.get_insn());
+
+
+	      rtx cmp = gen_rtx_SET(cc0_rtx,
+	      				gen_rtx_COMPARE (SImode, dx, gen_rtx_CONST_INT (SImode, 0)));
+	      //rtx_insn * neu =
+	      emit_insn_before (cmp, ii.get_insn());
+	      SET_INSN_DELETED(ii.get_insn());
+
+	      log ("(z) cmp.w #0,%s -> move.l %s,%s\n", reg_names[ii.get_dst_regno()], reg_names[ii.get_dst_regno()], reg_names[regno]);
+
+	      ++ change_count;
+	    }
+	  continue;
+	}
+
+      // search moveq #0,dx
+      if (ii.is_dst_reg() && ii.get_dst_regno() < 8 && index + 1 < infos.size())
+	{
+	  rtx set = single_set(ii.get_insn());
+	  if (set)
+	    {
+	      rtx src = SET_SRC(set);
+	      if (GET_CODE(src) == CONST_INT && INTVAL(src) == 0)
+		{
+		  // used in next insn as src and dead?
+		  insn_info & jj = infos[index + 1];
+		  rtx set1 = single_set(jj.get_insn());
+		  if (set1 && jj.get_src_op() == 0 && !jj.is_compare() && !jj.get_multi_reg() && jj.get_src_reg() && jj.get_src_regno() == ii.get_dst_regno()
+		      && is_reg_dead(ii.get_dst_regno(), index + 1))
+		    {
+		      if (validate_change(jj.get_insn(), &SET_SRC(set1), src, 0))
+			{
+			  SET_INSN_DELETED(ii.get_insn());
+			  log("(z) %d: use clear instead of reg %s with #0\n", index, reg_names[jj.get_src_regno()]);
+			  ++ change_count;
+			}
+		    }
+		}
+	    }
+	}
+    }
+  return change_count;
+}
+
+/**
+ * Convert
+ *     lea <y>,ax
+ *     move (ax),...
+ * into
+ *     move (<y>),...
+ *
+ *  if ax is reag dead
+ */
+static unsigned
+opt_lea_mem()
+{
+  unsigned change_count = 0;
+  for (unsigned index = 1; index< infos.size(); ++index)
+    {
+      insn_info &ii = infos[index - 1];
+
+      if (!ii.get_dst_reg())
+	continue;
+
+      rtx set0 = single_set(ii.get_insn());
+      if (!set0)
+	continue;
+
+      insn_info &jj = infos[index ];
+      rtx set = single_set(jj.get_insn());
+      if (!set)
+	continue;
+
+      rtx src = SET_SRC(set);
+      if (!MEM_P(src))
+	continue;
+
+      rtx reg = XEXP(src, 0);
+      if (!REG_P(reg))
+	continue;
+
+      if (REGNO(reg) != (unsigned)ii.get_dst_regno() || !is_reg_dead(REGNO(reg), index))
+	continue;
+
+      // try the conversion
+      if (validate_change(jj.get_insn(), &XEXP(src, 0), SET_SRC(set0), 0))
+	{
+	  SET_INSN_DELETED(ii.get_insn());
+	  log("(l) lea removed at %d\n", index - 1);
+	  ++change_count;
+	}
+    }
+  return change_count;
+}
+
+
+/**
+ * Expand "clr mem" into "moveq #0,dx; move dx,mem", if possible.
+ * Perform the cleanup in opt_final().
+ */
+static unsigned
+opt_clear()
+{
+  unsigned change_count = 0;
+  if (TUNE_68000)
+  for (unsigned index = 0; index< infos.size(); ++index)
+    {
+      insn_info &ii = infos[index];
+
+      if (GET_MODE_SIZE(ii.get_mode()) > 4)
+	continue;
+
+      rtx set0 = single_set(ii.get_insn());
+      if (!set0)
+	continue;
+
+      rtx src = SET_SRC(set0);
+      if (GET_CODE(src) != CONST_INT || INTVAL(src))
+	continue;
+
+      if (!MEM_P(SET_DEST(set0)))
+	continue;
+
+      unsigned regs = ~ii.get_use() & usable_regs & 0xff;
+      if (!regs)
+	continue;
+
+      unsigned regno = 0;
+      while (!(regs & 1))
+	{
+	  ++regno;
+	  regs >>= 1;
+	}
+
+      if (validate_change(ii.get_insn(), &SET_SRC(set0), gen_rtx_REG(GET_MODE(SET_DEST(set0)), regno), 0))
+	{
+	  rtx set = gen_rtx_SET(gen_rtx_REG(SImode, regno), gen_rtx_CONST_INT(SImode, 0));
+	  emit_insn_before (set, ii.get_insn());
+	  ++change_count;
+
+	  log("(z) %d: use reg %s with #0 instead of clear\n", index, reg_names[regno]);
+	}
+    }
+  return change_count;
+}
+
+/**
+ * Exchange insns if dst operand of an insn is used in the next insn as src operand.
+ */
+static void
+opt_pipeline_insns()
+{
+  // up
+  for (unsigned index = 1; index < infos.size() - 1; ++index)
+    {
+      insn_info & ii = infos[index];
+
+      // only check if not in prolog and a register is set
+      rtx iiset = single_set(ii.get_insn());
+      if (ii.in_proepi() || ii.is_compare() || !ii.get_dst_reg() || ii.get_hard() || !iiset)
+	continue;
+
+      insn_info & jj = infos[index + 1];
+      // don't touch compares and check for register overlap
+      if (jj.is_compare() || !(jj.get_myuse() & ii.get_def()))
+	continue;
+
+      // check previous insn
+      insn_info & hh = infos[index - 1];
+      rtx hhset = single_set(hh.get_insn());
+      if (hh.is_call() || hh.is_label() || hh.is_jump() || hh.in_proepi() || hh.is_compare() || hh.get_hard() || !hhset || !hh.get_dst_reg())
+	continue;
+
+      // overlap with current insn
+      if (((ii.get_myuse() | ii.get_def()) & hh.get_def() & ~(1<<FIRST_PSEUDO_REGISTER)) != 0 || (hh.get_myuse() & ii.get_def()) != 0 || rtx_equal_p(SET_SRC(iiset), SET_DEST(hhset)))
+	continue;
+
+      rtx pat = PATTERN(hh.get_insn());
+
+      // don't move volatil insns
+      if (pat->volatil)
+	continue;
+
+//      fprintf(stderr, "reorder insns: ");
+//      debug_rtx(hh.get_insn());
+//      debug_rtx(ii.get_insn());
+
+      // swap da insns
+      rtx_insn * head = PREV_INSN(hh.get_insn());
+      rtx_insn * tail = NEXT_INSN(ii.get_insn());
+
+      SET_NEXT_INSN(head) = ii.get_insn();
+      SET_NEXT_INSN(ii.get_insn()) = hh.get_insn();
+      SET_NEXT_INSN(hh.get_insn()) = tail;
+
+      SET_PREV_INSN(tail) = hh.get_insn();
+      SET_PREV_INSN(hh.get_insn()) = ii.get_insn();
+      SET_PREV_INSN(ii.get_insn()) = head;
+
+      std::swap(infos[index], infos[index - 1]);
+      log("(n) reordered insn %d<->%d\n", index - 1, index);
+    }
+}
+
+
+void print_inline_info()
+{
+  unsigned count = 0;
+  for (unsigned index = 0; index < infos.size(); ++index)
+    {
+      if (!infos[index].in_proepi())
+	++count;
+    }
+
+  for (unsigned m = usable_regs >> 2; m; m>>=1)
+    {
+      if (count && (m&1))
+	--count;
+    }
+
+  printf(":bbb: inline weight = %4d\t%s\n", count, get_current_function_name ());
+}
+
+namespace
+{
+
+  const pass_data pass_data_bbb_optimizations =
+    { RTL_PASS, /* type */
+    "bebbo's-optimizers", /* name */
+    OPTGROUP_NONE, /* optinfo_flags */
+    TV_NONE, /* tv_id */
+    0, /* properties_required */
+    0, /* properties_provided */
+    0, /* properties_destroyed */
+    0, /* todo_flags_start */
+    0, //( TODO_df_finish | TODO_df_verify), /* todo_flags_finish */
+      };
+
+  class pass_bbb_optimizations : public rtl_opt_pass
+  {
+  public:
+    pass_bbb_optimizations (gcc::context *ctxt) :
+	rtl_opt_pass (pass_data_bbb_optimizations, ctxt), pp (0)
+    {
+    }
+
+    /* opt_pass methods: */
+    virtual bool
+    gate (function * fun)
+    {
+  	  ::optimize_this_for_speed_p = optimize_function_for_speed_p (fun);
+
+      if (!string_bbb_opts)
+	string_bbb_opts = "+";
+
+      return TARGET_AMIGA && optimize > 0 && string_bbb_opts && !strchr (string_bbb_opts, '-');
+    }
+
+    virtual unsigned int
+    execute (function *)
+    {
+      return execute_bbb_optimizations ();
+    }
+
+    opt_pass *
+    clone ()
+    {
+      pass_bbb_optimizations * bbb = new pass_bbb_optimizations (m_ctxt);
+      bbb->pp = pp + 1;
+      return bbb;
+    }
+
+    unsigned int pp;
+
+    unsigned
+    execute_bbb_optimizations (void);
+  };
+// class pass_bbb_optimizations
+
+  /* Main entry point to the pass.  */
+  unsigned
+  pass_bbb_optimizations::execute_bbb_optimizations (void)
+  {
+    int done;
+    dump_cycles = strchr (string_bbb_opts, 'C') != 0;
+    dump_reg_track = strchr (string_bbb_opts, 'R') != 0;
+    be_very_verbose = strchr (string_bbb_opts, 'V') != 0;
+    be_verbose = strchr (string_bbb_opts, 'v') != 0;
+    if (be_verbose && be_very_verbose)
+      ++be_very_verbose;
+    if (be_very_verbose)
+      be_verbose = true;
+
+    bool do_commute_add_move = strchr (string_bbb_opts, 'a') || strchr (string_bbb_opts, '+');
+    bool do_absolute = strchr (string_bbb_opts, 'b') || strchr (string_bbb_opts, '+');
+    bool do_const_cmp_to_sub = strchr (string_bbb_opts, 'c') || strchr (string_bbb_opts, '+');
+    bool do_elim_dead_assign = strchr (string_bbb_opts, 'e') || strchr (string_bbb_opts, '+');
+    bool do_shrink_stack_frame = strchr (string_bbb_opts, 'f') || strchr (string_bbb_opts, '+');
+    bool do_autoinc = strchr (string_bbb_opts, 'i') || strchr (string_bbb_opts, '+');
+    bool do_lea_mem = strchr (string_bbb_opts, 'l') || strchr (string_bbb_opts, '+');
+    bool do_merge_add = strchr (string_bbb_opts, 'm') || strchr (string_bbb_opts, '+');
+    bool do_pipeline = strchr (string_bbb_opts, 'n') || strchr (string_bbb_opts, '+');
+    bool do_propagate_moves = strchr (string_bbb_opts, 'p') || strchr (string_bbb_opts, '+');
+    bool do_bb_reg_rename = strchr (string_bbb_opts, 'r') || strchr (string_bbb_opts, '+');
+    bool do_opt_strcpy = strchr (string_bbb_opts, 's') || strchr (string_bbb_opts, '+');
+    bool do_opt_final = strchr (string_bbb_opts, 'z') || strchr (string_bbb_opts, '+');
+
+    if (be_very_verbose)
+      log ("ENTER\n");
+
+    unsigned r = update_insns ();
+    if (!r)
+      {
+	if (do_lea_mem && opt_lea_mem())
+	  update_insns ();
+
+	if (do_opt_final && opt_clear())
+	  update_insns ();
+
+	int pass = 0;
+	for (;;)
+	  {
+	    done = 1;
+	    if (be_very_verbose)
+	      log ("pass %d\n", ++pass);
+	    if (do_opt_strcpy && opt_strcpy ())
+	      {XUSE('s'); done = 0; update_insns (); }
+
+	    if (do_commute_add_move && opt_commute_add_move ())
+	      {XUSE('a'); done = 0; update_insns (); }
+
+	    if (do_propagate_moves && opt_propagate_moves ())
+	      {XUSE('p'); done = 0; update_insns (); }
+
+	    if (do_const_cmp_to_sub && opt_const_cmp_to_sub ())
+	      {XUSE('c'); done = 0; update_insns (); }
+
+	    if (do_merge_add && opt_merge_add ())
+	      {XUSE('m'); done = 0; update_insns(); }
+
+	    if (do_absolute && opt_absolute ())
+	      {XUSE('b'); done = 0; update_insns (); }
+
+	    if (do_autoinc && opt_autoinc ())
+	      {XUSE('i'); done = 0; update_insns (); }
+
+	    if (do_bb_reg_rename)
+	      while (opt_reg_rename ())
+		{
+		  XUSE('r');
+		  update_insns ();
+		  done = 0;
+		}
+
+	    if (do_elim_dead_assign) while(opt_elim_dead_assign (STACK_POINTER_REGNUM))
+	      {
+		XUSE('e');
+		done = 0;
+		update_insns ();
+	      }
+
+	    if (done)
+	      break;
+	  }
+
+	/* convert back to clear befor fixing the stack frame */
+	if (do_opt_final && opt_final())
+	  { XUSE('z'); update_insns(); }
+
+	if (do_shrink_stack_frame && opt_shrink_stack_frame ())
+	  { XUSE('f'); update_insns (); }
+
+	/* elim assignments to the stack pointer last. */
+	if (do_elim_dead_assign && opt_elim_dead_assign (FIRST_PSEUDO_REGISTER))
+	  { XUSE('e'); update_insns (); }
+
+	if (do_pipeline)
+	  opt_pipeline_insns ();
+      }
+    if (r && be_verbose)
+      log ("no bbb optimization code %d\n", r);
+
+    if (strchr (string_bbb_opts, 'X') || strchr (string_bbb_opts, 'x'))
+      dump_insns ("bbb", strchr (string_bbb_opts, 'X'));
+
+    if (dump_reg_track || dump_cycles || be_very_verbose)
+      {
+	update_insns ();
+	if (dump_reg_track)
+	  track_regs ();
+      }
+
+    if (be_verbose)
+      print_inline_info();
+
+    XUSE('\n');
+    return r;
+  }
+
+}      // anon namespace
+
+rtl_opt_pass *
+make_pass_bbb_optimizations (gcc::context * ctxt)
+{
+  return new pass_bbb_optimizations (ctxt);
+}
+namespace
+{
+
+  const pass_data pass_data_bbb_baserel =
+    { RTL_PASS, /* type */
+    "bebbo's-baserel-pass", /* name */
+    OPTGROUP_NONE, /* optinfo_flags */
+    TV_NONE, /* tv_id */
+    0, /* properties_required */
+    0, /* properties_provided */
+    0, /* properties_destroyed */
+    0, /* todo_flags_start */
+    0, //( TODO_df_finish | TODO_df_verify), /* todo_flags_finish */
+      };
+
+  class pass_bbb_baserel : public rtl_opt_pass
+  {
+  public:
+    pass_bbb_baserel (gcc::context *ctxt) :
+	rtl_opt_pass (pass_data_bbb_baserel, ctxt), pp (0)
+    {
+    }
+
+    /* opt_pass methods: */
+    virtual bool
+    gate (function *)
+    {
+      return TARGET_AMIGA && flag_pic >= 3;
+    }
+
+    virtual unsigned int
+    execute (function *)
+    {
+      return execute_bbb_baserel ();
+    }
+
+    opt_pass *
+    clone ()
+    {
+      pass_bbb_baserel * bbb = new pass_bbb_baserel (m_ctxt);
+      return bbb;
+    }
+
+    unsigned int pp;
+
+    unsigned
+    execute_bbb_baserel (void);
+  };
+// class pass_bbb_optimizations
+
+  static rtx a4reg;
+  static int cur_tmp_use;
+  static rtx cur_symbol[8];
+  static rtx cur_tmp_reg[8];
+
+  int make_pic_ref(rtx_insn * insn, rtx * x, bool * use_tmp)
+  {
+    int r = 0;
+    enum rtx_code code = GET_CODE(*x);
+    if (code == SYMBOL_REF)
+      {
+	bool ispic = false;
+	section * sec = 0;
+
+	tree decl = SYMBOL_REF_DECL (*x);
+	if (decl &&  (decl->base.code == VAR_DECL || decl->base.code == CONST_DECL) && !(DECL_SECTION_NAME(decl)))
+	  {
+	    sec = get_variable_section(decl, false);
+	    ispic = (sec->common.flags & 0x200) && !decl->base.readonly_flag; // SECTION_WRITE;
+	  }
+
+//	  if (decl)
+//	    printf("%s: %8x %d\n", decl->decl_minimal.name->identifier.id.str, sec ? sec->common.flags : 0, ispic);
+
+	if (ispic)
+	  {
+	    rtx symbol = *x;
+
+	    // create the pic_ref expression
+	    rtx s = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, *x, GEN_INT (0)),
+						UNSPEC_RELOC16);
+	    s = gen_rtx_CONST (Pmode, s);
+	    s = gen_rtx_PLUS (Pmode, a4reg, s);
+	    s = gen_rtx_CONST (Pmode, s);
+
+	    // try to use it directly.
+	    if (!use_tmp)
+	      validate_unshare_change(insn, x, s, 0);
+	    else if (!*use_tmp)
+	      *use_tmp |= !validate_unshare_change(insn, x, s, 0);
+
+	    // if direct use failed, use a tmp register per symbol
+	    if (use_tmp && *use_tmp)
+	      {
+		rtx r = 0;
+		for (int i = 0; i < cur_tmp_use; ++i)
+		  {
+		    if (rtx_equal_p(cur_symbol[i], symbol))
+		      {
+		        r = cur_tmp_reg[i];
+			break;
+		      }
+		  }
+		if (!r)
+		  {
+		    r = gen_reg_rtx (Pmode);
+		    rtx set = gen_rtx_SET(r, s);
+		    emit_insn_before(set, insn);
+
+		    cur_symbol[cur_tmp_use] = symbol;
+		    cur_tmp_reg[cur_tmp_use] = r;
+		    ++cur_tmp_use;
+		  }
+
+		// if the change does not validate, poke it hard and pray that it's fixed later on. see maybe_fix()
+		if (!validate_unshare_change(insn, x, r, 0))
+		  {
+//		    fprintf(stderr, "can't convert to baserel: ");
+//		    debug_rtx(insn);
+		    *x = r;
+//		    debug_rtx(insn);
+		    return -1;
+		  }
+	      }
+	  }
+
+	return ispic;
+      }
+
+    switch (code)
+    {
+      /*
+       * Handle set: SRC and DEST may each have different symbols, so reset the use_tmp flag.
+       */
+      case SET:
+	r |= make_pic_ref(insn, &SET_DEST(*x), use_tmp);
+	if (use_tmp)
+	  *use_tmp = false;
+	r |= make_pic_ref(insn, &SET_SRC(*x), use_tmp);
+	if (use_tmp)
+	  *use_tmp = false;
+	return r;
+	/*
+	 * No inplace pic ref if a register is seen
+	 */
+      case REG:
+	if (use_tmp)
+	  *use_tmp = true;
+	break;
+	/*
+	 * There are shared CONST(PLUS(SYMBOL, CONST_INT)) rtx! (evil!)
+	 * Make a copy if one is seen, to avoid double replacement.
+	 */
+      case CONST:
+	if (GET_CODE(XEXP(*x, 0)) == PLUS && GET_CODE(XEXP(XEXP(*x, 0), 0)) == SYMBOL_REF)
+	  {
+	    /* copy_rtx can't unshare, so do it by hand. */
+	    rtx c = gen_rtx_CONST(GET_MODE(*x), gen_rtx_PLUS(GET_MODE(XEXP(*x, 0)), XEXP(XEXP(*x, 0), 0), XEXP(XEXP(*x, 0), 1)));
+	    *x = c;
+	  }
+	break;
+	/*
+	 * Default: try in place first.
+	 */
+      default:
+	break;
+    }
+
+    const char *fmt = GET_RTX_FORMAT(code);
+    for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+      {
+        if (fmt[i] == 'e')
+  	{
+  	  r |= make_pic_ref(insn, &XEXP(*x, i), use_tmp);
+  	}
+        else if (fmt[i] == 'E')
+  	for (int j = XVECLEN (*x, i) - 1; j >= 0; j--)
+  	  {
+  	    r |= make_pic_ref(insn, &XVECEXP(*x, i, j), use_tmp);
+  	  }
+      }
+    return r;
+  }
+
+  void
+  maybe_fix(rtx x, rtx_insn * insn)
+  {
+    /* check for necessary fixes
+     * 1. (mem/f:SI (plus:SI (reg:SI 8 a0)
+     *       (const:SI (plus:SI (reg:SI 0 d0 [96])
+     *         (const_int 8 [0x8]))))
+     *
+     *   (mem:SI (plus:SI (plus:SI (reg/v:SI 8 a0)
+     *                             (reg:SI 0 d0))
+     *         (const_int 8 [0x8])))
+     *
+     *
+     *
+     * 2. not converted properly
+     * (mem:SI (plus:SI (mult:SI (reg:SI 31 )
+     *                           (const_int 8 [0x8]))
+     *                  (const:SI (plus:SI (reg:SI 99 )
+     *                                     (const_int 4 [0x4]))))
+     *
+     *
+     * 3. (mem:SI (plus:SI (plus:SI (reg:SI 35 [ _23 ])
+     *                              (reg:SI 31 [ ivtmp.233 ]))
+     *                     (reg:SI 46)) )
+     *
+     * 3 registers are too many.
+     *
+     * 4. (mem/f:SI (plus:SI (plus:SI (mult:SI (reg:SI 1 d1)
+     *                                         (const_int 4 [0x4]))
+     *                                (reg:SI 14 a6))
+     *                       (const:SI (plus:SI (reg:SI 0 d0 [1060])
+     *                                          (const_int 8 [0x8]))))
+     *
+     * again 3 registers.
+     * Also move the const/plus/reg into a separate register.
+     *
+     */
+
+    /* MEM can be nested inside. */
+    if (GET_CODE(x) == ZERO_EXTEND || GET_CODE(x) == SIGN_EXTEND || GET_CODE(x) == STRICT_LOW_PART)
+      x = XEXP(x, 0);
+
+    if (MEM_P(x))
+      {
+	rtx plus = XEXP(x, 0);
+	if (GET_CODE(plus) == CONST)
+	  plus = XEXP(plus, 0);
+
+	// it's really a PLUS
+	if (GET_CODE(plus) == PLUS)
+	  {
+	    rtx op0 = XEXP(plus, 0);
+	    if (GET_CODE(op0) == CONST)
+	      op0 = XEXP(op0, 0);
+	    rtx op1 = XEXP(plus, 1);
+	    if (GET_CODE(op1) == CONST)
+	      op1 = XEXP(op1, 0);
+
+	    // set to MEM - not null
+	    rtx op00 = x;
+	    rtx op01 = x;
+	    rtx op10 = x;
+	    rtx op11 = x;
+	    if (GET_CODE(op0) == PLUS)
+	      {
+		op00 = XEXP(op0, 0);
+		op01 = XEXP(op0, 1);
+	      }
+	    if (GET_CODE(op1) == PLUS)
+	      {
+		op10 = XEXP(op1, 0);
+		op11 = XEXP(op1, 1);
+	      }
+
+	    int regCount0 = REG_P(op00) + REG_P(op01) + REG_P(op0);
+	    int regCount1 = REG_P(op10) + REG_P(op11) + REG_P(op1);
+
+	    // patch needed if too many registers
+	    if (regCount0 + regCount1 <= 2)
+	      return;
+
+	    // use a temp register for op0
+	    if (regCount0 == 2)
+	      {
+		rtx t0 = gen_reg_rtx (Pmode);
+		rtx set = gen_rtx_SET(t0, XEXP(plus, 0));
+		emit_insn_before(set, insn);
+
+		validate_change(insn, &XEXP(plus, 0), t0, 0);
+	      }
+	    // use a temp register for op1
+	    if (regCount1 == 2)
+	      {
+		rtx t1 = gen_reg_rtx (Pmode);
+		rtx set = gen_rtx_SET(t1, XEXP(plus, 1));
+		emit_insn_before(set, insn);
+
+		validate_change(insn, &XEXP(plus, 1), t1, 0);
+	      }
+	  }
+
+#if 0
+	// CONST(PLUS(...)) -> PLUS(...)
+	if (GET_CODE(plus) == CONST && GET_CODE(XEXP(plus, 0)) == PLUS)
+	  {
+	    validate_change (insn, &XEXP(x, 0), XEXP(plus, 0), 0);
+	    plus = XEXP(x, 0);
+	  }
+
+	// it's really a PLUS
+	if (GET_CODE(plus) == PLUS)
+	  {
+	    rtx op10 = XEXP(plus, 0);
+	    rtx op11 = XEXP(plus, 1);
+
+	    if (GET_CODE(op10) == PLUS)
+	      {
+		// DROP CONST from inner PLUS
+		if (GET_CODE(op11) == CONST && GET_CODE(XEXP(op11, 0)) == PLUS)
+		  {
+		    rtx plus2 = XEXP(op11, 0);
+		    rtx op20 = XEXP(plus2, 0);
+		    rtx op21 = XEXP(plus2, 1);
+
+		    rtx p2 = gen_rtx_PLUS(GET_MODE(plus2), op20, op21);
+		    rtx p1 = gen_rtx_PLUS(GET_MODE(plus2), op10, p2);
+
+		    // replace plus
+		    validate_change(insn, &XEXP(x, 0), p1, 0);
+
+		    // update variables
+		    plus = XEXP(x, 0);
+		    op10 = XEXP(plus, 0);
+		    op11 = XEXP(plus1, 1);
+		  }
+	      }
+
+	    // is 2nd operator also a plus?
+	    while ((GET_CODE(op11) == PLUS) && (GET_CODE(op10) == PLUS && (REG_P(XEXP(op10, 0)) || GET_CODE(XEXP(op10, 0)) == MULT) && REG_P(XEXP(op10, 1))))
+	      {
+		// create an additional add insn for pl2
+		rtx r = gen_reg_rtx (Pmode);
+		rtx set = gen_rtx_SET(r, op10);
+		emit_insn_before(set, insn);
+
+		// use that register instead of op10
+		validate_change(insn, &XEXP(plus, 0), r, 0);
+
+		if ((GET_CODE(XEXP(plus, 1)) == CONST && GET_CODE(XEXP(XEXP(plus1, 1), 0)) == PLUS))
+		  {
+		    rtx r2 = gen_reg_rtx (Pmode);
+		    rtx set2 = gen_rtx_SET(r2, XEXP(XEXP(plus, 1), 0));
+		    emit_insn_before(set2, insn);
+
+		    validate_change(insn, &XEXP(plus, 1), r2, 0);
+		  }
+
+		// update variables
+		plus = XEXP(x, 0);
+		op10 = XEXP(plus, 0);
+		op11 = XEXP(plus, 1);
+
+	      }
+	  }
+#endif
+      }
+  }
+
+  /* Main entry point to the pass.  */
+  unsigned
+  pass_bbb_baserel::execute_bbb_baserel (void)
+  {
+    a4reg = gen_rtx_REG (Pmode, PIC_REG);
+
+    rtx_insn *insn, *next;
+    for (insn = get_insns (); insn; insn = next)
+      {
+	next = NEXT_INSN (insn);
+
+	if (NONJUMP_INSN_P(insn))
+	  {
+
+	    rtx set = single_set (insn);
+
+	    bool b = false;
+	    cur_tmp_use = 0;
+	    if (make_pic_ref(insn, &PATTERN(insn), &b) && set)
+	      {
+//		rtx_insn * new_insn = make_insn_raw (PATTERN(insn));
+//		if (insn_invalid_p(new_insn, 0))
+		  {
+		    /* some insns need a further patch to be valid.
+		     * See maybe_fix.
+		     */
+		    rtx dest = SET_DEST(set);
+		    rtx src = SET_SRC(set);
+
+		    if (GET_CODE(src) == COMPARE)
+		      {
+			dest = XEXP(src, 0);
+			src = XEXP(src, 1);
+		      }
+
+		    maybe_fix(dest, insn);
+		    maybe_fix(src, insn);
+		  }
+	      }
+
+	    rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);
+	    if (note)
+	      {
+		make_pic_ref(insn, &XEXP (note, 0), 0);
+	      }
+	  }
+      }
+
+    return 0;
+  }
+
+}      // anon namespace
+
+rtl_opt_pass *
+make_pass_bbb_baserel (gcc::context * ctxt)
+{
+  return new pass_bbb_baserel (ctxt);
+}
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index 2747464b8e2..8283ccc990a 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "c-family/c-ada-spec.h"
 #include "cilk.h"
 #include "builtins.h"
+#include "output.h"
+#include "tm_p.h"
 
 /* In grokdeclarator, distinguish syntactic contexts of declarators.  */
 enum decl_context
@@ -4439,7 +4441,58 @@ c_decl_attributes (tree *node, tree attributes, int flags)
 	attributes = tree_cons (get_identifier ("omp declare target"),
 				NULL_TREE, attributes);
     }
-  return decl_attributes (node, attributes, flags);
+
+  tree returned_attrs = decl_attributes (node, attributes, flags);
+
+#ifdef TARGET_AMIGA
+  /* add an attribute to the function decl's type if there are asm register parameters. */
+  if (TREE_CODE (*node) == FUNCTION_DECL)
+    {
+      char const * synthetic = "";
+      for (tree params = TYPE_ARG_TYPES(TREE_TYPE(*node)); params; params = TREE_CHAIN(params))
+	{
+	  tree asmattr = lookup_attribute("asmreg", TYPE_ATTRIBUTES(TREE_VALUE(params)));
+	  if (asmattr)
+	    synthetic = concat(synthetic, reg_names[TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(asmattr)))], NULL);
+	}
+      if (strlen(synthetic) > 0)
+	{
+	  tree t;
+	  tree asmid = get_identifier("asmregs");
+	  tree syntheticid = get_identifier(synthetic);
+	  tree value = tree_cons(syntheticid, syntheticid, NULL_TREE);
+	  tree newattr = tree_cons(asmid, value, NULL_TREE);
+
+	  /* create a type copy with additional attribute. */
+	  tree atype = copy_node (TREE_TYPE(*node));
+	  tree attrs = TYPE_ATTRIBUTES(atype) = chainon(newattr, TYPE_ATTRIBUTES(atype));
+
+	  tree m = TYPE_MAIN_VARIANT(TREE_TYPE(*node));
+
+	  TYPE_POINTER_TO (atype) = 0;
+	  TYPE_REFERENCE_TO (atype) = 0;
+
+	  /* search if such variant exists. */
+	  for (t = m; t; t = TYPE_NEXT_VARIANT(t))
+	    if (comptypes (t, atype) == 1 && attribute_list_equal (TYPE_ATTRIBUTES(t), attrs))
+	      break;
+
+	  if (t)
+	    TREE_TYPE(*node) = t;
+	  else
+	    {
+	      TREE_TYPE(*node) = atype;
+	      /* Add this type to the chain of variants of TYPE.  */
+	      TYPE_NEXT_VARIANT (atype) = TYPE_NEXT_VARIANT (m);
+	      TYPE_NEXT_VARIANT (m) = atype;
+	    }
+
+	  returned_attrs = TYPE_ATTRIBUTES(TREE_TYPE(*node));
+	}
+    }
+#endif
+
+  return returned_attrs;
 }
 
 
@@ -5024,6 +5077,30 @@ grokparm (const struct c_parm *parm, tree *expr)
   return decl;
 }
 
+#ifdef TARGET_AMIGA
+
+/* Create a new variant of TYPE, equivalent but distinct.
+ This is so the caller can modify it.  */
+
+static tree
+build_type_copy (tree type)
+  {
+    tree t, m = TYPE_MAIN_VARIANT (type);
+
+    t = copy_node (type);
+
+    TYPE_POINTER_TO (t) = 0;
+    TYPE_REFERENCE_TO (t) = 0;
+
+    /* Add this type to the chain of variants of TYPE.  */
+    TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);
+    TYPE_NEXT_VARIANT (m) = t;
+
+    return t;
+  }
+#endif
+
+
 /* Given a parsed parameter declaration, decode it into a PARM_DECL
    and push that on the current scope.  EXPR is a pointer to an
    expression that needs to be evaluated for the side effects of array
@@ -5041,6 +5118,58 @@ push_parm_decl (const struct c_parm *parm, tree *expr)
 
   decl = pushdecl (decl);
 
+#ifdef TARGET_AMIGA
+  if (parm->asmspec)
+    {
+      tree atype = TREE_TYPE(decl);
+      const char *asmspec = TREE_STRING_POINTER(parm->asmspec);
+      if (*asmspec == '%')
+	++asmspec;
+      int reg_number = decode_reg_name (asmspec);
+
+      /* First detect errors in declaring global registers.  */
+      if (reg_number == -1)
+	error ("%Jregister name not specified for %qD", decl, decl);
+      else if (reg_number < 0)
+	error ("%Jinvalid register name for %qD", decl, decl);
+      else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)
+	error ("%Jdata type of %qD isn%'t suitable for a register", decl, decl);
+      else if (!HARD_REGNO_MODE_OK(reg_number, TYPE_MODE (TREE_TYPE (decl))))
+	error ("%Jregister specified for %qD isn%'t suitable for data type",
+	       decl, decl);
+      /* Now handle properly declared static register variables.  */
+      else
+	{
+	  /* Build tree for __attribute__ ((asm(regnum))). */
+	  tree ttasm = get_identifier("asmreg");
+	  tree value = tree_cons(ttasm, build_int_cst(NULL, reg_number), NULL_TREE);
+	  tree t, attrs = tree_cons(ttasm, value, NULL_TREE);
+	  /* First check whether such a type already exists - if yes, use
+	   that one. This is very important, since otherwise
+	   common_type() would think that it sees two different
+	   types and would try to merge them - this could result in
+	   warning messages. */
+	  for (t = TYPE_MAIN_VARIANT(atype); t; t = TYPE_NEXT_VARIANT(t))
+	    if (comptypes (t, atype) == 1
+		&& attribute_list_equal (TYPE_ATTRIBUTES(t), attrs))
+	      break;
+	  if (t)
+	    atype = t;
+	  else
+	    {
+	      /* Create a new variant, with differing attributes.
+	       (Hack! Type with differing attributes should no longer be
+	       a variant of its main type. See comment above for
+	       explanation why this was necessary). */
+	      atype = build_type_copy (atype);
+	      TYPE_ATTRIBUTES(atype) = chainon (attrs, TYPE_ATTRIBUTES(atype));
+	    }
+	  TREE_TYPE(decl) = atype;
+//	  printf("%s using %s, cdecl=%p, type=%p\n", IDENTIFIER_POINTER(DECL_NAME (decl)), asmspec, decl, atype);
+	}
+    }
+#endif
+
   finish_decl (decl, input_location, NULL_TREE, NULL_TREE, NULL_TREE);
 }
 
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index fc20bad8d99..8b55ac3e7c7 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -3837,10 +3837,26 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)
       c_parser_skip_until_found (parser, CPP_COMMA, NULL);
       return NULL;
     }
+  /**
+   * SBF: Add support for __asm("xy") register spec.
+   */
+#ifdef TARGET_AMIGA
+  tree asmspec = NULL_TREE;
+  if (c_parser_next_token_is_keyword (parser, RID_ASM))
+    {
+      asmspec = c_parser_simple_asm_expr (parser);
+//	printf("asmspec: %s\n", TREE_STRING_POINTER(asmspec));
+    }
+#endif
   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))
     postfix_attrs = c_parser_attributes (parser);
-  return build_c_parm (specs, chainon (postfix_attrs, prefix_attrs),
+
+  struct c_parm * cparm = build_c_parm (specs, chainon (postfix_attrs, prefix_attrs),
 		       declarator);
+#ifdef TARGET_AMIGA
+  cparm->asmspec = asmspec;
+#endif
+  return cparm;
 }
 
 /* Parse a string literal in an asm expression.  It should not be
@@ -3892,6 +3908,7 @@ c_parser_asm_string_literal (c_parser *parser)
 static tree
 c_parser_simple_asm_expr (c_parser *parser)
 {
+  extern int in_assembler_directive;
   tree str;
   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));
   /* ??? Follow the C++ parser rather than using the
@@ -3903,7 +3920,13 @@ c_parser_simple_asm_expr (c_parser *parser)
       parser->lex_untranslated_string = false;
       return NULL_TREE;
     }
+
+  // SBF: set in_assembler_directive to enable multi-line strings. And yes, it's a HACK.
+  in_assembler_directive = 1;
   str = c_parser_asm_string_literal (parser);
+  // SBF: in_assembler_directive disabled
+  in_assembler_directive = 0;
+
   parser->lex_untranslated_string = false;
   if (!c_parser_require (parser, CPP_CLOSE_PAREN, "expected %<)%>"))
     {
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index bb12a200f70..634b1fd8ffe 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -453,6 +453,10 @@ struct c_parm {
   tree attrs;
   /* The declarator.  */
   struct c_declarator *declarator;
+#ifdef TARGET_AMIGA
+  /* The optional asm spec to specify the register. */
+  tree asmspec;
+#endif
 };
 
 /* Used when parsing an enum.  Initialized by start_enum.  */
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 6e92d4cdde2..378b1fc595b 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -2001,6 +2001,15 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,
 	{
 	  rtx_insn *insn;
 
+#ifdef TARGET_AMIGA
+	  /*
+	   * we need replicated labels, if the labels are too far away,
+	   * since on 68000 there are only 8 bits for the offset.
+	   */
+	  if (!TARGET_68020 && !TARGET_68040)
+	    return false;
+#endif
+
 	  /* Replace references to LABEL1 with LABEL2.  */
 	  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
 	    {
@@ -2016,8 +2025,9 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,
   /* Avoid splitting if possible.  We must always split when SRC2 has
      EH predecessor edges, or we may end up with basic blocks with both
      normal and EH predecessor edges.  */
-  if (newpos2 == BB_HEAD (src2)
+  if ((newpos2 == BB_HEAD (src2)
       && !(EDGE_PRED (src2, 0)->flags & EDGE_EH))
+      )
     redirect_to = src2;
   else
     {
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 2163bddbbd5..882b37fc8e1 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -2732,6 +2732,10 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)
 {
   /* Conflicts between asm-declared register variables and the clobber
      list are not allowed.  */
+  /*
+   * SBF: Why?
+   */
+#ifndef TARGET_AMIGA
   tree overlap = tree_overlaps_hard_reg_set (t, clobbered_regs);
 
   if (overlap)
@@ -2744,7 +2748,7 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)
       DECL_REGISTER (overlap) = 0;
       return true;
     }
-
+#endif
   return false;
 }
 
@@ -3255,11 +3259,15 @@ expand_asm_stmt (gasm *stmt)
 		if (reg_overlap_mentioned_p (clobbered_reg, output_rvec[k]))
 		  internal_error ("asm clobber conflict with output operand");
 
+/**
+ * SBF: Why?
+ */
+#ifndef TARGET_AMIGA
 	      for (unsigned k = 0; k < ninputs - ninout; ++k)
 		if (reg_overlap_mentioned_p (clobbered_reg, input_rvec[k]))
 		  internal_error ("asm clobber conflict with input operand");
+#endif
 	    }
-
 	  XVECEXP (body, 0, i++) = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);
 	}
 
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 319fcb31e3f..2c8c25df147 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -1307,6 +1307,8 @@ main (int argc, char **argv)
 		  /* Do not pass LTO flag to the linker. */
 		  ld1--;
 		  ld2--;
+
+		  lto_mode = LTO_MODE_LTO;
 #else
 		  error ("LTO support has not been enabled in this "
 			 "configuration");
@@ -1414,6 +1416,11 @@ main (int argc, char **argv)
 		    add_to_list (&static_libs, s);
 	      }
 #endif
+	      /* begin-GG-local: dynamic libraries */
+	      #ifdef COLLECT2_LIBNAME_HOOK
+	      	      COLLECT2_LIBNAME_HOOK(arg);
+	      #endif
+	      /* end-GG-local */
 	      break;
 
 #ifdef COLLECT_EXPORT_LIST
@@ -1516,6 +1523,11 @@ main (int argc, char **argv)
 		add_to_list (&static_libs, arg);
 	    }
 #endif
+	  /* begin-GG-local: dynamic libraries */
+#ifdef COLLECT2_LIBNAME_HOOK
+	  	  COLLECT2_LIBNAME_HOOK(arg);
+#endif
+	  /* end-GG-local */
 	}
     }
 
@@ -1636,6 +1648,11 @@ main (int argc, char **argv)
 
       fprintf (stderr, "\n");
     }
+  /* begin-GG-local: dynamic libraries */
+#ifdef COLLECT2_PRELINK_HOOK
+    COLLECT2_PRELINK_HOOK(ld1_argv, &strip_flag);
+#endif
+  /* end-GG-local */
 
   /* Load the program, searching all libraries and attempting to provide
      undefined symbols from repository information.
@@ -1655,7 +1672,7 @@ main (int argc, char **argv)
        expect the relevant tables to be dragged together with their associated
        functions from precise cross reference insertions by the compiler.  */
 
-    if (early_exit || ld1_filter != SCAN_NOTHING)
+    if (early_exit || (ld1_filter != SCAN_NOTHING && lto_mode != LTO_MODE_LTO))
       do_tlink (ld1_argv, object_lst);
 
     if (early_exit)
@@ -1676,6 +1693,8 @@ main (int argc, char **argv)
       }
   }
 
+  /* begin-GG-local: dynamic libraries */
+#ifndef COLLECT2_POSTLINK_HOOK
   /* Unless we have done it all already, examine the namelist and search for
      static constructors and destructors to call.  Write the constructor and
      destructor tables to a .s file and reload.  */
@@ -1702,6 +1721,10 @@ main (int argc, char **argv)
 				   frame_tables.number),
                          frame_tables.number);
     }
+#else /* COLLECT2_POSTLINK_HOOK */
+  COLLECT2_POSTLINK_HOOK(output_file);
+#endif
+/* end-GG-local */
 
   /* If the scan exposed nothing of special interest, there's no need to
      generate the glue code and relink so return now.  */
@@ -1744,6 +1767,11 @@ main (int argc, char **argv)
 
       maybe_unlink (c_file);
       maybe_unlink (o_file);
+      /* begin-GG-local: dynamic libraries */
+#ifdef COLLECT2_EXTRA_CLEANUP
+            COLLECT2_EXTRA_CLEANUP();
+#endif
+      /* end-GG-local */
       return 0;
     }
 
@@ -1849,6 +1877,11 @@ main (int argc, char **argv)
   maybe_unlink (export_file);
 #endif
 
+  /* begin-GG-local: dynamic libraries */
+#ifdef COLLECT2_EXTRA_CLEANUP
+    COLLECT2_EXTRA_CLEANUP();
+#endif
+  /* end-GG-local */
   return 0;
 }
 
@@ -2302,28 +2335,65 @@ maybe_lto_object_file (const char *prog_name)
   static unsigned char coffmagic[2] = { 0x4c, 0x01 };
   static unsigned char coffmagic_x64[2] = { 0x64, 0x86 };
   static unsigned char machomagic[4][4] = {
-    { 0xcf, 0xfa, 0xed, 0xfe },
-    { 0xce, 0xfa, 0xed, 0xfe },
-    { 0xfe, 0xed, 0xfa, 0xcf },
+      { 0xcf, 0xfa, 0xed, 0xfe },
+      { 0xce, 0xfa, 0xed, 0xfe },
+      { 0xfe, 0xed, 0xfa, 0xcf },
     { 0xfe, 0xed, 0xfa, 0xce }
   };
 
-  f = fopen (prog_name, "rb");
-  if (f == NULL)
-    return false;
-  if (fread (buf, sizeof (buf), 1, f) != 1)
-    buf[0] = 0;
-  fclose (f);
-
-  if (memcmp (buf, elfmagic, sizeof (elfmagic)) == 0
-      || memcmp (buf, coffmagic, sizeof (coffmagic)) == 0
-      || memcmp (buf, coffmagic_x64, sizeof (coffmagic_x64)) == 0)
-    return true;
-  for (i = 0; i < 4; i++)
-    if (memcmp (buf, machomagic[i], sizeof (machomagic[i])) == 0)
-      return true;
-
-  return false;
+  bool r = false;
+  do
+    { // while (0)
+
+      f = fopen (prog_name, "rb");
+      if (f == NULL)
+	break;
+      if (fread (buf, sizeof(buf), 1, f) != 1)
+	break;
+
+      if (memcmp (buf, elfmagic, sizeof(elfmagic)) == 0
+	  || memcmp (buf, coffmagic, sizeof(coffmagic)) == 0
+	  || memcmp (buf, coffmagic_x64, sizeof(coffmagic_x64)) == 0)
+	{
+	  r = true;
+	  break;
+	}
+      for (i = 0; i < 4; i++)
+	if (memcmp (buf, machomagic[i], sizeof(machomagic[i])) == 0)
+	  {
+	    r = true;
+	    break;
+	  }
+
+#ifdef TARGET_AMIGA
+      if (buf[0] == 0 && buf[1] == 0 && buf[2] == 3 && buf[3] == 0xe7)
+	{
+	  // skip file name
+	  if (fread (buf, sizeof(buf), 1, f) != 1)
+	    break;
+	  unsigned len = (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	  if (fseek(f, len * 4 + 0x34, SEEK_CUR))
+	    break;
+
+	  if (fread (buf, sizeof(buf), 1, f) != 1)
+	    break;
+	  // symbol
+	  if (buf[0] != 0x82)
+	    break;
+	  len = (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	  if (len != 4)
+	    break;
+	  char name[16];
+	  if (fread (name, sizeof(name), 1, f) != 1)
+	    break;
+	  r = 0 == strcmp("___gnu_lto_v1", name);
+	}
+#endif
+    }
+  while (0);
+  if (f)
+    fclose (f);
+  return r;
 }
 
 /* Generic version to scan the name list of the loaded program for
diff --git a/gcc/combine.c b/gcc/combine.c
index ed07cb69078..0d32f7d8d86 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -7162,6 +7162,16 @@ expand_compound_operation (rtx x)
   if (GET_CODE (tem) == CLOBBER)
     return x;
 
+#ifdef TARGET_AMIGA
+  /* SBF: prevent conversion of bitfield insns. */
+  if (!TUNE_68000_10
+      && (   (GET_CODE(x) == ZERO_EXTRACT && GET_CODE(tem) == LSHIFTRT)
+	  || (GET_CODE(x) == SIGN_EXTRACT && GET_CODE(tem) == ASHIFTRT))
+      //&& set_src_cost(x, GET_MODE (x), optimize_this_for_speed_p) <= set_src_cost(tem, GET_MODE (tem), optimize_this_for_speed_p)
+      )
+    return x;
+#endif
+
   return tem;
 }
 
diff --git a/gcc/common.opt b/gcc/common.opt
index a25557720b5..78eff2451b3 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -1424,6 +1424,10 @@ floop-nest-optimize
 Common Report Var(flag_loop_nest_optimize) Optimization
 Enable the loop nest optimizer.
 
+floop-size-optimize
+Common Report Var(flag_loop_size_optimize) Optimization Init(-1)
+Enable loop for size optimization.
+
 fstrict-volatile-bitfields
 Common Report Var(flag_strict_volatile_bitfields) Init(-1) Optimization
 Force bitfield accesses to match their type width.
@@ -2275,7 +2279,7 @@ EnumValue
 Enum(tls_model) String(local-exec) Value(TLS_MODEL_LOCAL_EXEC)
 
 ftoplevel-reorder
-Common Report Var(flag_toplevel_reorder) Init(2)
+Common Report Var(flag_toplevel_reorder) Init(0)
 Reorder top level functions, variables, and asms.
 
 ftracer
diff --git a/gcc/common/common-target.h b/gcc/common/common-target.h
index 0bb4a859b52..839ab58517a 100644
--- a/gcc/common/common-target.h
+++ b/gcc/common/common-target.h
@@ -37,7 +37,7 @@ enum opt_levels
   OPT_LEVELS_2_PLUS, /* -O2 and above, including -Os.  */
   OPT_LEVELS_2_PLUS_SPEED_ONLY, /* -O2 and above, but not -Os or -Og.  */
   OPT_LEVELS_3_PLUS, /* -O3 and above.  */
-  OPT_LEVELS_3_PLUS_AND_SIZE, /* -O3 and above and -Os.  */
+  OPT_LEVELS_3_PLUS_AND_SPEED_ONLY, /* -O3 and above and not -Os or -Og.  */
   OPT_LEVELS_SIZE, /* -Os only.  */
   OPT_LEVELS_FAST /* -Ofast only.  */
 };
diff --git a/gcc/config.gcc b/gcc/config.gcc
index bf3f32da08a..00ac68af9fc 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1940,6 +1940,25 @@ m68k-*-elf* | fido-*-elf*)
 		;;
 	esac
 	;;
+m68k*-*-amigaosvasm*)
+	default_m68k_cpu=68000
+	tm_file="${tm_file}  dbx.h newlib-stdint.h m68k/m68kamigaos.h"
+	tm_defines="${tm_defines} MOTOROLA=1 TARGET_AMIGAOS TARGET_AMIGAOS_VASM TARGET_CPU_DEFAULT=0"
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-amigaos"
+	tm_p_file="${tm_p_file} m68k/amigaos-protos.h"
+	extra_options="${extra_options} m68k/amigaos.opt"
+	gnu_ld=yes
+	;;
+m68k*-*-amigaos*)
+	default_m68k_cpu=68000
+	tm_file="${tm_file}  dbx.h newlib-stdint.h m68k/m68kamigaos.h"
+	tm_defines="${tm_defines} MOTOROLA=1 TARGET_AMIGAOS TARGET_CPU_DEFAULT=0"
+	tmake_file="m68k/t-floatlib m68k/t-m68kbare m68k/t-amigaos"
+	tm_p_file="${tm_p_file} m68k/amigaos-protos.h"
+	extra_options="${extra_options} m68k/amigaos.opt"
+	gnu_ld=yes
+	CFLAGS="-Os"
+	;;
 m68k*-*-netbsdelf*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5475
diff --git a/gcc/config/m68k/amigaos-protos.h b/gcc/config/m68k/amigaos-protos.h
new file mode 100644
index 00000000000..e5cd6e950b5
--- /dev/null
+++ b/gcc/config/m68k/amigaos-protos.h
@@ -0,0 +1,55 @@
+/* Configuration for GNU C-compiler for m68k Amiga, running AmigaOS.
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2003
+   Free Software Foundation, Inc.  
+   Contributed by Markus M. Wild (wild@amiga.physik.unizh.ch).
+   Heavily modified by Kamil Iskra (iskra@student.uci.agh.edu.pl).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#undef TARGET_AMIGAOS
+#define TARGET_AMIGAOS 1
+
+extern void amigaos_init_cumulative_args (CUMULATIVE_ARGS *, tree, tree);
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+#undef INIT_CUMULATIVE_ARGS
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
+  (amigaos_init_cumulative_args(&(CUM), (FNTYPE), (INDIRECT)))
+
+#ifdef RTX_CODE
+extern int read_only_operand (rtx);
+extern void amigaos_select_section (tree, int, unsigned HOST_WIDE_INT);
+extern void amigaos_encode_section_info (tree, rtx, int);
+extern void amigaos_alternate_pic_setup (FILE *);
+extern void amigaos_prologue_begin_hook (FILE *, int);
+extern void amigaos_alternate_frame_setup_f (FILE *, int);
+extern void amigaos_alternate_frame_setup (FILE *, int);
+extern struct rtx_def* gen_stack_cleanup_call (rtx, rtx);
+extern void amigaos_alternate_allocate_stack (rtx *);
+#ifdef TREE_CODE
+//extern void amigaos_function_arg_advance (CUMULATIVE_ARGS *);
+extern struct rtx_def *amigaos_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree);
+#endif
+#endif
+#ifdef TREE_CODE
+extern tree amigaos_handle_decl_attribute (tree *, tree, tree, int, bool *);
+extern tree amigaos_handle_type_attribute (tree *, tree, tree, int, bool *);
+#endif 
diff --git a/gcc/config/m68k/amigaos.c b/gcc/config/m68k/amigaos.c
new file mode 100755
index 00000000000..90af21a593f
--- /dev/null
+++ b/gcc/config/m68k/amigaos.c
@@ -0,0 +1,1017 @@
+/* Configuration for GNU C-compiler for m68k Amiga, running AmigaOS.
+ Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2003
+ Free Software Foundation, Inc.
+ Contributed by Markus M. Wild (wild@amiga.physik.unizh.ch).
+ Heavily modified by Kamil Iskra (iskra@student.uci.agh.edu.pl).
+
+ This file is part of GCC.
+
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ GCC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+
+//work without flag_writable_strings which is not in GCC4
+#define REGPARMS_68K 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "output.h"
+#include "tree.h"
+#include "attribs.h"
+#include "flags.h"
+#include "expr.h"
+#include "toplev.h"
+#include "tm_p.h"
+#include "target.h"
+#include "diagnostic-core.h"
+#include "langhooks.h"
+#include "function.h"
+#include "config/m68k/amigaos.h"
+
+//#define MYDEBUG 1
+#ifdef MYDEBUG
+#define DPRINTF(x) fprintf x;
+#else
+#define DPRINTF(x)
+#endif
+
+//int amiga_declare_object;
+
+#if 0
+
+//----- from 68k.c start
+
+/* Stack checking and automatic extension support.  */
+
+void
+amigaos_prologue_begin_hook (FILE *stream, int fsize)
+  {
+    if (TARGET_STACKCHECK)
+      {
+	if (fsize < 256)
+	asm_fprintf (stream, "\tcmpl %s,%Rsp\n"
+	    "\tjcc 0f\n"
+	    "\tjra %U__stkovf\n"
+	    "\t0:\n",
+	    (flag_pic == 3 ? "a4@(___stk_limit:W)" :
+		(flag_pic == 4 ? "a4@(___stk_limit:L)" :
+		    "___stk_limit")));
+	else
+	asm_fprintf (stream, "\tmovel %I%d,%Rd0\n\tjbsr %U__stkchk_d0\n",
+	    fsize);
+      }
+  }
+
+
+//static rtx
+//gen_stack_management_call (rtx stack_pointer, rtx arg, const char *func)
+//{
+//  rtx call_insn, call, seq, name;
+//  start_sequence ();
+//
+//  /* Move arg to d0.  */
+//  emit_move_insn (gen_rtx_REG (SImode, 0), arg);
+//
+//  /* Generate the function reference.  */
+//  name = gen_rtx_SYMBOL_REF (Pmode, func);
+//  SYMBOL_REF_FLAG (name) = 1;
+//  /* If optimizing, put it in a psedo so that several loads can be merged
+//     into one.  */
+//  if (optimize && ! flag_no_function_cse)
+//    name = copy_to_reg (name);
+//
+//  /* Generate the function call.  */
+//  call = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (FUNCTION_MODE, name),
+//		  const0_rtx);
+//  /* If we are doing stack extension, notify about the sp change.  */
+//  if (stack_pointer)
+//    call = gen_rtx_SET (VOIDmode, stack_pointer, call);
+//
+//  /* Generate the call instruction.  */
+//  call_insn = emit_call_insn (call);
+//  /* Stack extension does not change memory in an unpredictable way.  */
+//  RTL_CONST_OR_PURE_CALL_P (call_insn) = 1;
+//  /* We pass an argument in d0.  */
+//  CALL_INSN_FUNCTION_USAGE (call_insn) = gen_rtx_EXPR_LIST (VOIDmode,
+//	gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, 0)), 0);
+//
+//  seq = get_insns ();
+//  end_sequence ();
+//  return seq;
+//}
+//
+//rtx
+//gen_stack_cleanup_call (rtx stack_pointer, rtx sa)
+//{
+//  return gen_stack_management_call (stack_pointer, sa, "__move_d0_sp");
+//}
+//
+//void
+//amigaos_alternate_allocate_stack (rtx *operands)
+//{
+//  if (TARGET_STACKEXTEND)
+//    emit_insn (gen_stack_management_call (stack_pointer_rtx, operands[1],
+//					  "__sub_d0_sp"));
+//  else
+//    {
+//      if (TARGET_STACKCHECK)
+//	emit_insn (gen_stack_management_call (0, operands[1], "__stkchk_d0"));
+//      anti_adjust_stack (operands[1]);
+//    }
+//  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);
+//}
+#endif
+
+/*
+ * begin-GG-local: explicit register specification for parameters.
+ *
+ * Reworked and ported to gcc-6.2.0 by Stefan "Bebbo" Franke.
+ */
+
+/**
+ * Define this here and add it to tm_p -> all know the custom type and allocate/use the correct size.
+ */
+struct amigaos_args
+{
+  int num_of_regs;
+  long regs_already_used;
+  int last_arg_reg;
+  int last_arg_len;
+  tree current_param_type; /* New field: formal type of the current argument.  */
+  tree fntype; /* initial function type */
+};
+
+static struct amigaos_args mycum, othercum;
+
+bool amiga_is_ok_for_sibcall(tree decl, tree exp);
+/**
+ * Sibcall is only ok, if max regs d0/d1/a0 are used.
+ * a1 is used for the sibcall
+ * others might be trashed due to stack pop.
+ */
+bool amiga_is_ok_for_sibcall(tree decl, tree exp)
+{
+  tree fntype = decl ? TREE_TYPE (decl) : TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (exp)));
+  if (othercum.fntype == fntype)
+    return (othercum.regs_already_used & ~0x0103) == 0;
+  return false;
+}
+
+/* Argument-passing support functions.  */
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+ for a call to a function whose data type is FNTYPE.
+ For a library call, FNTYPE is 0.  */
+
+void
+amigaos_init_cumulative_args (CUMULATIVE_ARGS *cump, tree fntype, tree decl)
+{
+  struct amigaos_args * cum = decl == current_function_decl ? &mycum : &othercum;
+  *cump = decl == current_function_decl;
+  cum->num_of_regs = amigaos_regparm > 0 ? amigaos_regparm : 0;
+  DPRINTF((stderr, "0amigaos_init_cumulative_args %s %d -> %d\r\n", decl ? lang_hooks.decl_printable_name (decl, 2) : "?", *cump, cum->num_of_regs));
+
+  /* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+  cum->last_arg_reg = -1;
+  cum->regs_already_used = 0;
+
+  if (!fntype && decl)
+    fntype = TREE_TYPE(decl);
+// SBF: oh my ... - this caused crafted functions to lose asm parameters....
+//  if (decl && DECL_ARTIFICIAL(decl))
+//    fntype = 0;
+  if (fntype)
+    {
+      tree attrs = TYPE_ATTRIBUTES(fntype);
+      DPRINTF((stderr, "1amigaos_init_cumulative_args %s %d attrs: %p\r\n", decl ? lang_hooks.decl_printable_name (decl, 2) : "?", *cump, attrs));
+      if (attrs)
+	{
+	  tree stkp = lookup_attribute ("stkparm", attrs);
+	  tree fnspec = lookup_attribute ("fn spec", attrs);
+	  DPRINTF((stderr, "2amigaos_init_cumulative_args %s %d stkp: %p %s\r\n", decl ? lang_hooks.decl_printable_name (decl, 2) : "?", *cump, stkp ? stkp : fnspec, IDENTIFIER_POINTER(TREE_PURPOSE(attrs))));
+	  if (stkp || fnspec)
+	    cum->num_of_regs = 0;
+	  else
+	    {
+	      tree ratree = lookup_attribute ("regparm", attrs);
+	      cum->num_of_regs = amigaos_regparm != 0 ? amigaos_regparm :
+							AMIGAOS_DEFAULT_REGPARM;
+	      if (ratree)
+		{
+		  int no = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(ratree)));
+		  if (no > 0)
+		    cum->num_of_regs = no < AMIGAOS_MAX_REGPARM ? no : AMIGAOS_MAX_REGPARM;
+		}
+	    }
+	}
+    }
+  else
+    /* Libcall.  */
+    cum->num_of_regs = 0;
+
+  if (cum->num_of_regs)
+    {
+      /* If this is a vararg call, put all arguments on stack.  */
+      tree param, next_param;
+      for (param = TYPE_ARG_TYPES(fntype); param; param = next_param)
+	{
+	  next_param = TREE_CHAIN(param);
+	  if (!next_param && TREE_VALUE (param) != void_type_node)
+	  cum->num_of_regs = 0;
+	}
+    }
+
+#if ! defined (PCC_STATIC_STRUCT_RETURN) && defined (M68K_STRUCT_VALUE_REGNUM)
+  /* If return value is a structure, and we pass the buffer address in a
+   register, we can't use this register for our own purposes.
+   FIXME: Something similar would be useful for static chain.  */
+  if (fntype && aggregate_value_p (TREE_TYPE(fntype), fntype))
+    cum->regs_already_used |= (1 << M68K_STRUCT_VALUE_REGNUM);
+#endif
+
+  if (fntype && DECL_STATIC_CHAIN(fntype))
+    {
+      rtx reg = amigaos_static_chain_rtx (decl, 0);
+      if (reg)
+	cum->regs_already_used |= (1 << REGNO(reg));
+    }
+
+  if (fntype)
+    cum->current_param_type = TYPE_ARG_TYPES(cum->fntype = fntype);
+  else
+    /* Call to compiler-support function. */
+    cum->current_param_type = cum->fntype = 0;
+  DPRINTF((stderr, "9amigaos_init_cumulative_args %p -> %d\r\n", cum, cum->num_of_regs));
+}
+
+int
+amigaos_function_arg_reg (unsigned regno)
+{
+  return (mycum.regs_already_used & (1 << regno)) != 0;
+}
+
+/* Update the data in CUM to advance over an argument.  */
+
+void
+amigaos_function_arg_advance (cumulative_args_t cum_v, machine_mode, const_tree, bool)
+{
+  struct amigaos_args *cum = *get_cumulative_args (cum_v) ? &mycum : &othercum;
+  /* Update the data in CUM to advance over an argument.  */
+
+  DPRINTF((stderr, "amigaos_function_arg_advance1 %p\r\n", cum));
+
+  if (cum->last_arg_reg != -1)
+    {
+      int count;
+      for (count = 0; count < cum->last_arg_len; count++)
+	cum->regs_already_used |= (1 << (cum->last_arg_reg + count));
+      cum->last_arg_reg = -1;
+    }
+
+  if (cum->current_param_type)
+    cum->current_param_type = TREE_CHAIN(cum->current_param_type);
+}
+
+/* Define where to put the arguments to a function.
+ Value is zero to push the argument on the stack,
+ or a hard register in which to store the argument.
+
+ MODE is the argument's machine mode.
+ TYPE is the data type of the argument (as a tree).
+ This is null for libcalls where that information may
+ not be available.
+ CUM is a variable of type CUMULATIVE_ARGS which gives info about
+ the preceding args and about the function being called.  */
+
+static struct rtx_def *
+_m68k_function_arg (struct amigaos_args * cum, machine_mode mode, const_tree type)
+{
+  DPRINTF((stderr, "m68k_function_arg numOfRegs=%d\r\n", cum ? cum->num_of_regs : 0));
+
+  if (cum->num_of_regs)
+    {
+      int regbegin = -1, altregbegin = -1, len;
+
+      /* FIXME: The last condition below is a workaround for a bug.  */
+      if (TARGET_68881 && FLOAT_MODE_P(mode) &&
+      GET_MODE_UNIT_SIZE (mode) <= 12 && (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+	{
+	  regbegin = 16; /* FPx */
+	  len = GET_MODE_NUNITS(mode);
+	}
+      /* FIXME: Two last conditions below are workarounds for bugs.  */
+      else if (INTEGRAL_MODE_P (mode) && mode != CQImode && mode != CHImode)
+	{
+	  if (!type || POINTER_TYPE_P(type))
+	    regbegin = 8; /* Ax */
+	  else
+	    regbegin = 0; /* Dx */
+	  altregbegin = 8 - regbegin;
+	  len = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
+	}
+
+      if (regbegin != -1)
+	{
+	  int reg;
+	  long mask;
+
+	  look_for_reg: mask = 1 << regbegin;
+	  for (reg = 0; reg < cum->num_of_regs; reg++, mask <<= 1)
+	    if (!(cum->regs_already_used & mask))
+	      {
+		int end;
+		for (end = reg; end < cum->num_of_regs && end < reg + len; end++, mask <<= 1)
+		  if (cum->regs_already_used & mask)
+		    break;
+		if (end == reg + len)
+		  {
+		    cum->last_arg_reg = reg + regbegin;
+		    cum->last_arg_len = len;
+		    break;
+		  }
+	      }
+
+	  if (reg == cum->num_of_regs && altregbegin != -1)
+	    {
+	      DPRINTF((stderr, "look for alt reg\n"));
+	      regbegin = altregbegin;
+	      altregbegin = -1;
+	      goto look_for_reg;
+	    }
+	}
+
+      if (cum->last_arg_reg != -1)
+	{
+	  DPRINTF((stderr, "-> gen_rtx_REG %d\r\n", cum->last_arg_reg));
+	  return gen_rtx_REG (mode, cum->last_arg_reg);
+	}
+    }
+  return 0;
+}
+
+/* A C expression that controls whether a function argument is passed
+ in a register, and which register. */
+
+struct rtx_def *
+amigaos_function_arg (cumulative_args_t cum_v, machine_mode mode, const_tree type, bool)
+{
+  DPRINTF((stderr, "amigaos_function_arg %p\r\n", cum_v.p));
+
+  struct amigaos_args *cum = *get_cumulative_args (cum_v) ? &mycum : &othercum;
+
+  tree asmtree = type && cum->current_param_type ? lookup_attribute("asmreg", TYPE_ATTRIBUTES(TREE_VALUE(cum->current_param_type))) : NULL_TREE;
+
+  if (asmtree)
+    {
+      int i;
+      cum->last_arg_reg = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(asmtree)));
+      cum->last_arg_len = HARD_REGNO_NREGS(cum->last_arg_reg, mode);
+
+      for (i = 0; i < cum->last_arg_len; i++)
+	{
+	  if (cum->regs_already_used & (1 << (cum->last_arg_reg + i)))
+	    {
+	      error ("two parameters allocated for one register");
+	      break;
+	    }
+	  cum->regs_already_used |= (1 << (cum->last_arg_reg + i));
+	}
+      return gen_rtx_REG (mode, cum->last_arg_reg);
+    }
+  return _m68k_function_arg (cum, mode, type);
+}
+
+void
+amiga_emit_regparm_clobbers (void)
+{
+  for (int i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+    if (mycum.regs_already_used & (1 << i))
+      {
+	rtx reg = gen_raw_REG (Pmode, i);
+	emit_insn (gen_rtx_CLOBBER(Pmode, gen_rtx_SET(reg, gen_rtx_MEM(Pmode, reg))));
+      }
+}
+
+/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,
+ one if they are compatible, and two if they are nearly compatible
+ (which causes a warning to be generated). */
+
+int
+amigaos_comp_type_attributes (const_tree type1, const_tree type2)
+{
+  DPRINTF((stderr, "amigaos_comp_type_attributes\n"));
+  /* Functions or methods are incompatible if they specify mutually exclusive
+   ways of passing arguments. */
+  if (TREE_CODE(type1) == FUNCTION_TYPE || TREE_CODE(type1) == METHOD_TYPE)
+    {
+      tree attrs1 = TYPE_ATTRIBUTES(type1);
+
+      tree asm1 = lookup_attribute("asmregs", attrs1);
+      tree stack1 = lookup_attribute("stkparm", attrs1);
+      tree reg1 = lookup_attribute("regparm", attrs1);
+
+      tree attrs2 = TYPE_ATTRIBUTES(type2);
+
+      tree asm2 = lookup_attribute("asmregs", attrs2);
+      tree stack2 = lookup_attribute("stkparm", attrs2);
+      tree reg2 = lookup_attribute("regparm", attrs2);
+
+      if ((asm1 && !asm2) || (!asm1 && asm2))
+	return 0;
+
+      if (reg1)
+	{
+	  if (stack2)
+	    return 0;
+
+	  int no1 = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(reg1)));
+	  int no2 = reg2 ? TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(reg2))) : amigaos_regparm;
+	  if (no1 != no2)
+	    return 0;
+	}
+      else if (reg2)
+	{
+	  if (stack1)
+	    return 0;
+
+	  int no2 = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(reg2)));
+	  if (amigaos_regparm != no2)
+	    return 0;
+	}
+
+      if (stack1) {
+	  if (stack2)
+	    return 1;
+	  return amigaos_regparm  <= 0;
+      }
+
+      if (stack2)
+	  return amigaos_regparm  <= 0;
+
+      if (asm1)
+	return 0 == strcmp(IDENTIFIER_POINTER(TREE_VALUE(asm1)), IDENTIFIER_POINTER(TREE_VALUE(asm2)));
+
+    }
+  else
+    {
+      tree attrs1 = TYPE_ATTRIBUTES(type1);
+
+      tree chip1 = lookup_attribute("chip", attrs1);
+      tree fast1 = lookup_attribute("fast", attrs1);
+      tree far1 = lookup_attribute("far", attrs1);
+
+      tree attrs2 = TYPE_ATTRIBUTES(type2);
+
+      tree chip2 = lookup_attribute("chip", attrs2);
+      tree fast2 = lookup_attribute("fast", attrs2);
+      tree far2 = lookup_attribute("far", attrs2);
+
+      if (chip1)
+	return chip2 && !fast2 && !far2;
+
+      if (fast1)
+	return !chip2 && fast2 && !far2;
+
+      if (far1)
+	return !chip2 && !fast2 && far2;
+
+      return !chip2 && !fast2 && !far2;
+    }
+  return 1;
+}
+/* end-GG-local */
+
+/* Handle a regparm, stkparm, saveds attribute;
+ arguments as in struct attribute_spec.handler.  */
+tree
+amigaos_handle_type_attribute (tree *node, tree name, tree args, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  tree nnn = *node;
+  do
+    { // while (0);
+      DPRINTF((stderr, "%p with treecode %d\n", node, TREE_CODE(nnn)));
+      if (TREE_CODE (nnn) == FUNCTION_DECL || TREE_CODE (nnn) == FUNCTION_TYPE || TREE_CODE (nnn) == METHOD_TYPE)
+	{
+	  /* 'regparm' accepts one optional argument - number of registers in
+	   single class that should be used to pass arguments.  */
+	  if (is_attribute_p ("regparm", name))
+	    {
+	      DPRINTF((stderr, "regparm found\n"));
+
+	      if (lookup_attribute ("stkparm", TYPE_ATTRIBUTES(nnn)))
+		{
+		  error ("`regparm' and `stkparm' are mutually exclusive");
+		  break;
+		}
+	      if (args && TREE_CODE (args) == TREE_LIST)
+		{
+		  tree val = TREE_VALUE(args);
+		  DPRINTF((stderr, "regparm with val: %d\n", TREE_CODE(val)));
+		  if (TREE_CODE (val) == INTEGER_CST)
+		    {
+		      unsigned no = TREE_INT_CST_LOW(val);
+		      if (no > AMIGAOS_MAX_REGPARM)
+			{
+			  error ("`regparm' attribute: value %d not in [0 - %d]", no,
+			  AMIGAOS_MAX_REGPARM);
+			  break;
+			}
+		    }
+		  else
+		    {
+		      error ("invalid argument(s) to `regparm' attribute");
+		      break;
+		    }
+		}
+	    }
+	  else if (is_attribute_p ("stkparm", name))
+	    {
+	      if (lookup_attribute ("regparm", TYPE_ATTRIBUTES(nnn)))
+		{
+		  error ("`regparm' and `stkparm' are mutually exclusive");
+		  break;
+		}
+	    }
+	  else if (is_attribute_p ("stackext", name))
+	    {
+	      if (lookup_attribute ("interrupt", TYPE_ATTRIBUTES(nnn)))
+		{
+		  error ("`stackext' and `interrupt' are mutually exclusive");
+		  break;
+		}
+	    }
+	  else if (is_attribute_p ("saveds", name))
+	    {
+	      if (flag_pic < 3)
+		{
+		  warning (OPT_Wattributes, "`%s' attribute is only usable with fbaserel", IDENTIFIER_POINTER(name));
+		}
+	      else
+	      if (flag_resident)
+		{
+		  error ("`saveds' can't be used with resident!\n");
+		}
+	    }
+	  else if (is_attribute_p ("entrypoint", name))
+	    {
+	      if (lookup_attribute ("saveallregs", TYPE_ATTRIBUTES(nnn)))
+		{
+		  error ("`entrypoint' and `saveallregs' are mutually exclusive");
+		  break;
+		}
+	    }
+	  else if (is_attribute_p ("saveallregs", name))
+	    {
+	      if (lookup_attribute ("entrypoint", TYPE_ATTRIBUTES(nnn)))
+		{
+		  error ("`entrypoint' and `saveallregs' are mutually exclusive");
+		  break;
+		}
+	    }
+	  else
+	    {
+	      warning (OPT_Wattributes, "`%s' attribute only applies to data", IDENTIFIER_POINTER(name));
+	    }
+	}
+      else
+	{
+	  if (is_attribute_p ("chip", name) || is_attribute_p ("fast", name) || is_attribute_p ("far", name))
+	    {
+	      // OK
+	    }
+	  else if (is_attribute_p ("asmreg", name))
+	    {
+	      if (args && TREE_CODE (args) == TREE_LIST)
+		{
+		  tree val = TREE_VALUE(args);
+		  if (TREE_CODE (val) == INTEGER_CST)
+		    {
+		      unsigned no = TREE_INT_CST_LOW(val);
+		      if (no >= 23)
+			{
+			  error ("`asmreg' attribute: value %d not in [0 - 23]", no);
+			  break;
+			}
+		    }
+		  else
+		    {
+		      error ("invalid argument(s) to `asmreg' attribute");
+		      break;
+		    }
+		}
+	    }
+	  else
+	    {
+	      warning (OPT_Wattributes, "`%s' attribute only applies to functions", IDENTIFIER_POINTER(name));
+	    }
+	}
+      return NULL_TREE ;
+    }
+  while (0);
+  // error case
+  *no_add_attrs = true;
+  return NULL_TREE ;
+}
+
+#define AMIGA_CHIP_SECTION_NAME ".datachip"
+#define AMIGA_FAST_SECTION_NAME ".datafast"
+#define AMIGA_FAR_SECTION_NAME  ".datafar"
+
+void
+amiga_insert_attribute (tree decl, tree * attr)
+{
+  tree t1;
+  for (t1 = *attr;t1; t1 = TREE_CHAIN (t1))
+    {
+  tree name = TREE_PURPOSE(t1);
+
+  if (is_attribute_p("chip", name) || is_attribute_p("far", name) || is_attribute_p("fast", name))
+    {
+      if (TREE_TYPE(decl)->base.code == VAR_DECL)
+	{
+	  error ("`%s' attribute can only be specified for variables", IDENTIFIER_POINTER(name));
+	  return;
+	}
+
+      if (! TREE_STATIC (decl) && ! DECL_EXTERNAL (decl))
+	{
+	  error ("`%s' attribute cannot be specified for local variables", IDENTIFIER_POINTER(name));
+	  return;
+	}
+
+      char const * section_name;
+      if (is_attribute_p("chip", name))
+	section_name = AMIGA_CHIP_SECTION_NAME;
+      else if (is_attribute_p("fast", name))
+	section_name = AMIGA_FAST_SECTION_NAME;
+      else if (is_attribute_p("far", name))
+	section_name = AMIGA_FAR_SECTION_NAME;
+
+
+      /* The decl may have already been given a section attribute from
+	     a previous declaration.  Ensure they match.  */
+      if (DECL_SECTION_NAME (decl) == NULL)
+	set_decl_section_name(decl, section_name);
+      else if (strcmp (DECL_SECTION_NAME (decl), section_name) )
+	{
+	  error_at (DECL_SOURCE_LOCATION(decl),
+		  "`%s' attribute conflicts with previous declaration", IDENTIFIER_POINTER(name));
+	}
+    }
+  else
+    {
+//      warning (OPT_Wattributes, "`%s' attribute unknown", IDENTIFIER_POINTER(name));
+    }
+    }
+}
+
+/* Output assembly to switch to section NAME with attribute FLAGS.  */
+#ifndef TARGET_AMIGAOS_VASM
+extern void
+amiga_named_section (const char *name, unsigned int flags, tree decl )
+{
+  // only one code section - TODO: with amiga hunk this is no longer mandatory.
+  if (0 == strncmp (".text", name, 5))
+    name = ".text";
+
+  if (0 == strncmp(".data", name, 5) && (!DECL_INITIAL (decl) || initializer_zerop (DECL_INITIAL (decl))))
+    fprintf (asm_out_file, "\t.bss%s\n", name + 5);
+  else if (0 == strncmp(".section ", name, 8) || 0 == strncmp(".text", name, 5) || 0 == strncmp(".data", name, 5) || 0 == strncmp(".bss", name, 4))
+    fprintf (asm_out_file, "\t%s\n", name);
+  else
+    fprintf (asm_out_file, "\t.section %s\n", name);
+}
+#else
+extern void
+amiga_named_section (const char *name, unsigned int flags, tree decl ATTRIBUTE_UNUSED)
+  {
+    if (0 == strncmp(".text", name, 5))
+      name = ".text,code";
+
+    if (0 == strncmp("section ", name, 8))
+      {
+	fprintf (asm_out_file, "\t%s\n", name);
+      }
+    else
+      {
+	if (0 == strncmp(".data", name, 5) && (!DECL_INITIAL (decl) || initializer_zerop (DECL_INITIAL (decl))))
+	  {
+	  if (0 == strncmp(".data_chip", name, 10))
+	    {
+	      fprintf (asm_out_file, "\tsection .bss_chip,bss,chip\n");
+	    }
+	  else
+	    {
+	      fprintf (asm_out_file, "\tsection .bss%s%s,bss\n", name[5]==0 ? "" : "_", name + 5);
+	    }
+	  }
+	else
+	  {
+	    if (0 == strncmp(".datafar", name, 8))
+	      {
+		fprintf (asm_out_file, "\tsection .data_far,data\n");
+	      }
+	    else if (0 == strncmp(".datachip", name, 9))
+	      {
+		fprintf (asm_out_file, "\tsection .data_chip,data,chip\n");
+	      }
+	    else if (0 == strncmp(".bsschip", name, 8))
+	      {
+		fprintf (asm_out_file, "\tsection .bss_chip,bss,chip\n");
+	      }
+	    else
+	      {
+		fprintf (asm_out_file, "\tsection %s\n", name);
+	      }
+	  }
+      }
+  }
+#endif
+
+/* Baserel support.  */
+
+/**
+ * Does x reference the pic_reg and is const or plus?
+ */
+static int
+_amiga_is_const_pic_ref (const_rtx x)
+{
+  if (GET_CODE(x) == PLUS || GET_CODE(x) == MINUS)
+    {
+      if (GET_CODE(XEXP(x, 1)) == CONST_INT)
+	return _amiga_is_const_pic_ref(XEXP(x, 0));
+      return false;
+    }
+
+  if (GET_CODE(x) == CONST)
+    x = XEXP(x, 0);
+  if (GET_CODE(x) != PLUS)
+    return false;
+
+  const_rtx reg = XEXP(x, 0);
+
+  if (GET_CODE(reg) == CONST)
+    {
+      x = XEXP(reg, 0);
+      if (GET_CODE(x) != PLUS)
+        return false;
+      reg = XEXP(x, 0);
+    }
+
+  if (!REG_P(reg) && REGNO(reg) != PIC_REG)
+    return false;
+
+  const_rtx unspec = XEXP(x, 1);
+  while (GET_CODE(unspec) == PLUS || GET_CODE(unspec) == CONST)
+    unspec = XEXP(unspec, 0);
+
+  if (GET_CODE(unspec) != UNSPEC)
+    return false;
+
+  return true;
+}
+
+int
+amiga_is_const_pic_ref (const_rtx cnst)
+{
+  if (flag_pic < 3)
+    return false;
+  int r = _amiga_is_const_pic_ref (cnst);
+//  fprintf(stderr, r ? "valid pic: " : "invalid pic: ");
+//  debug_rtx(cnst);
+  return r;
+}
+
+
+/* Does operand (which is a symbolic_operand) live in text space? If
+ so SYMBOL_REF_FLAG, which is set by ENCODE_SECTION_INFO, will be true.
+
+ This function is used in base relative code generation. */
+
+int
+read_only_operand (rtx operand)
+{
+  if (GET_CODE (operand) == CONST)
+    operand = XEXP(XEXP (operand, 0), 0);
+  if (GET_CODE (operand) == SYMBOL_REF)
+    return SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P(operand);
+  return 1;
+}
+
+rtx
+amigaos_struct_value_rtx (tree fntype, int incoming ATTRIBUTE_UNUSED)
+{
+    return gen_rtx_REG (Pmode, M68K_STRUCT_VALUE_REGNUM);
+}
+
+rtx
+amigaos_static_chain_rtx (const_tree decl, bool incoming ATTRIBUTE_UNUSED)
+{
+  if (!decl || !DECL_STATIC_CHAIN(decl))
+    return 0;
+
+  unsigned used = 0;
+  tree fntype = TREE_TYPE(decl);
+  if (fntype)
+    for (tree current_param_type = TYPE_ARG_TYPES(fntype); current_param_type; current_param_type = TREE_CHAIN(current_param_type))
+      {
+	tree asmtree = TYPE_ATTRIBUTES(TREE_VALUE(current_param_type));
+	if (!asmtree || strcmp ("asmreg", IDENTIFIER_POINTER(TREE_PURPOSE(asmtree))))
+	  continue;
+
+	unsigned regno = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(asmtree)));
+	used |= 1 << regno;
+      }
+
+  if (!(used & (1 << 9)))
+    return gen_rtx_REG (Pmode, 9);
+  if (!(used & (1 << 10)))
+    return gen_rtx_REG (Pmode, 10);
+  if (!(used & (1 << 11)))
+    return gen_rtx_REG (Pmode, 11);
+  if (!(used & (1 << 14)))
+    return gen_rtx_REG (Pmode, 14);
+
+  return 0;
+}
+
+/**
+ * Necessary to block some funny invalid combinations if baserel is used:
+ *
+(const:SI (minus:SI (neg:SI (reg:SI 12 a4))
+      (const:SI (plus:SI (unspec:SI [
+		      (symbol_ref:SI ("xyz") <var_decl 0xffcf0000 xyz>)
+		      (const_int 0 [0])
+		  ] 6)
+
+(plus:SI (reg:SI 10 a2)
+    (const:SI (minus:SI (neg:SI (reg:SI 12 a4))
+	    (const:SI (plus:SI (unspec:SI [
+			    (symbol_ref:SI ("xyz") <var_decl 0xffcf0000 xyz>)
+			    (const_int 0 [0])
+			] 6)
+		    (const_int 1234 [0xe00]))))))) xyz.c:41 465 {*lea}
+
+ */
+bool
+amigaos_legitimate_src (rtx src)
+{
+  if (flag_pic < 3)
+    return true;
+
+  if (MEM_P(src))
+    {
+      rtx x = XEXP(src, 0);
+      if (GET_CODE(x) == PLUS || GET_CODE(x) == MINUS) {
+	  if (amiga_is_const_pic_ref(XEXP(x, 0))
+	      || amiga_is_const_pic_ref(XEXP(x, 1)))
+	    return false;
+      }
+      return true;
+    }
+
+  if (GET_CODE(src) == PLUS || GET_CODE(src) == MINUS)
+    {
+      rtx x = XEXP(src, 0);
+      rtx y = XEXP(src, 1);
+
+      /** handled in print_operand_address(...) */
+      if (amiga_is_const_pic_ref(x))
+	  return GET_CODE(y) == CONST_INT;
+
+      return amigaos_legitimate_src(x) && amigaos_legitimate_src(y) && !amiga_is_const_pic_ref(y);
+    }
+
+  if (GET_CODE(src) == CONST)
+    {
+      rtx op = XEXP(src, 0);
+      if (GET_CODE(op) == MINUS || GET_CODE(op) == PLUS)
+	{
+	  rtx x = XEXP(op, 0);
+	  if (GET_CODE(x) == NOT || GET_CODE(x) == NEG || GET_CODE(x) == SIGN_EXTEND)
+	    {
+	      rtx reg = XEXP(x, 0);
+	      if (!REG_P(reg))
+		return true;
+
+	      return false;
+	    }
+	}
+
+      if (GET_CODE(op) == UNSPEC)
+	return false;
+    }
+
+  return true;
+}
+
+void
+amigaos_restore_a4 (void)
+  {
+    if (flag_pic >= 3 && !flag_resident)
+      {
+	tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+	tree attr = lookup_attribute ("saveds", attrs);
+	if (attr || TARGET_RESTORE_A4 || TARGET_ALWAYS_RESTORE_A4)
+	  {
+	    rtx a4 = gen_rtx_ASM_INPUT_loc(VOIDmode, "\tjsr ___restore_a4", DECL_SOURCE_LOCATION (current_function_decl));
+	    a4->volatil = 1;
+	    emit_insn(a4);
+	  }
+      }
+  }
+
+void
+amigaos_alternate_frame_setup_f (int fsize)
+  {
+#if 0
+    if (fsize < 128)
+    asm_fprintf (stream, "\tcmpl %s,%Rsp\n"
+	"\tjcc 0f\n"
+	"\tmoveq %I%d,%Rd0\n"
+	"\tmoveq %I0,%Rd1\n"
+	"\tjbsr %U__stkext_f\n"
+	"0:\tlink %Ra5,%I%d:W\n",
+	(flag_pic == 3 ? "a4@(___stk_limit:W)" :
+	    (flag_pic == 4 ? "a4@(___stk_limit:L)" :
+		"___stk_limit")),
+	fsize, -fsize);
+    else
+    asm_fprintf (stream, "\tmovel %I%d,%Rd0\n\tjbsr %U__link_a5_d0_f\n",
+	fsize);
+#endif
+  }
+
+void
+amigaos_alternate_frame_setup (int fsize)
+  {
+#if 0
+    if (!fsize)
+    asm_fprintf (stream, "\tcmpl %s,%Rsp\n"
+	"\tjcc 0f\n"
+	"\tmoveq %I0,%Rd0\n"
+	"\tmoveq %I0,%Rd1\n"
+	"\tjbsr %U__stkext_f\n"
+	"0:\n",
+	(flag_pic == 3 ? "a4@(___stk_limit:W)" :
+	    (flag_pic == 4 ? "a4@(___stk_limit:L)" :
+		"___stk_limit")));
+    else if (fsize < 128)
+    asm_fprintf (stream, "\tcmpl %s,%Rsp\n"
+	"\tjcc 0f\n"
+	"\tmoveq %I%d,%Rd0\n"
+	"\tmoveq %I0,%Rd1\n"
+	"\tjbsr %U__stkext_f\n"
+	"0:\taddw %I%d,%Rsp\n",
+	(flag_pic == 3 ? "a4@(___stk_limit:W)" :
+	    (flag_pic == 4 ? "a4@(___stk_limit:L)" :
+		"___stk_limit")),
+	fsize, -fsize);
+    else
+    asm_fprintf (stream, "\tmovel %I%d,%Rd0\n\tjbsr %U__sub_d0_sp_f\n",
+	fsize);
+#endif
+  }
+
+#if 0
+extern bool debug_recog(char const * txt, int which_alternative, int n, rtx * operands)
+{
+  fprintf(stderr, "%s: %d ", txt, which_alternative);
+  for (int i = 0; i < n; ++i)
+    print_rtl(stderr, operands[i]);
+  fprintf(stderr, "\n--\n");
+  return true;
+}
+#endif
+
+int amiga_is_far_symbol(const_rtx x)
+{
+	if (GET_CODE(x) != SYMBOL_REF)
+		return 0;
+
+	tree decl = SYMBOL_REF_DECL(x);
+	if (!decl)
+		return 0;
+
+	if (decl && (decl->base.code == VAR_DECL || decl->base.code == CONST_DECL) && DECL_SECTION_NAME(decl))
+		return 1;
+
+	return 0;
+}
diff --git a/gcc/config/m68k/amigaos.h b/gcc/config/m68k/amigaos.h
new file mode 100644
index 00000000000..2a449072617
--- /dev/null
+++ b/gcc/config/m68k/amigaos.h
@@ -0,0 +1,492 @@
+/* Configuration for GNU C-compiler for m68k Amiga, running AmigaOS.
+ *
+ * This file is only included and used inside m68k.c to define the target.
+ *
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2003
+   Free Software Foundation, Inc.  
+   Contributed by Markus M. Wild (wild@amiga.physik.unizh.ch).
+   Heavily modified by Kamil Iskra (iskra@student.uci.agh.edu.pl).
+   
+ 
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#ifndef TARGET_AMIGAOS
+#define TARGET_AMIGAOS 1
+#endif
+
+#if 0
+/*  The function name __transfer_from_trampoline is not actually used.
+   The function definition just permits use of asm with operands"
+   (though the operand list is empty).  */
+   
+#undef TRANSFER_FROM_TRAMPOLINE				 
+
+/* Call __flush_cache() after building the trampoline: it will call
+   an appropriate OS cache-clearing routine.  */
+
+#undef FINALIZE_TRAMPOLINE
+#define FINALIZE_TRAMPOLINE(TRAMP)					\
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__flush_cache"),	\
+		     0, VOIDmode, 2, (TRAMP), Pmode,			\
+		     GEN_INT (TRAMPOLINE_SIZE), SImode)
+
+#endif
+
+/* Compile using the first 'm68k_regparm' data, address and float
+   registers for arguments passing.  */      
+/*#define SUBTARGET_OPTIONS     { "regparm=",		&m68k_regparm_string,				\
+    N_("Use this register count to pass arguments"), 0},*/	
+
+
+/* Nonzero if we need to generate special stack-allocating insns.
+   On most systems they are not needed.
+   When they are needed, also define ALTERNATE_ALLOCATE_STACK (see m68k.md)
+   to perform the necessary actions.  */
+//#undef TARGET_ALTERNATE_ALLOCATE_STACK
+//#define TARGET_ALTERNATE_ALLOCATE_STACK 0  
+
+
+/* Compile with stack extension.  */
+
+#define MASK_STACKEXTEND 0x40000000 /* 1 << 30 */
+#define TARGET_STACKEXTEND (((target_flags & MASK_STACKEXTEND)		\
+  && !lookup_attribute ("interrupt",					\
+			TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl)))) \
+  || lookup_attribute ("stackext",					\
+		       TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))
+
+///* Compile with stack checking.  */
+//
+#define MASK_STACKCHECK 0x20000000 /* 1 << 29 */
+#define TARGET_STACKCHECK ((target_flags & MASK_STACKCHECK)		\
+  && !(target_flags & MASK_STACKEXTEND)					\
+  && !lookup_attribute ("interrupt",					\
+			TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))) \
+  && !lookup_attribute ("stackext",					\
+			TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))
+
+
+/* Provide a dummy entry for the '-msmall-code' switch.  This is used by
+   the assembler and '*_SPEC'.  */
+
+#undef SUBTARGET_SWITCHES
+#define SUBTARGET_SWITCHES						\
+    { "small-code", 0,							\
+      "" /* Undocumented. */ },						\
+    { "stackcheck", MASK_STACKCHECK,					\
+      N_("Generate stack-check code") },				\
+    { "no-stackcheck", - MASK_STACKCHECK,				\
+      N_("Do not generate stack-check code") },				\
+    { "stackextend", MASK_STACKEXTEND,					\
+      N_("Generate stack-extension code") },				\
+    { "no-stackextend", - MASK_STACKEXTEND,				\
+      N_("Do not generate stack-extension code") },			\
+    { "fixedstack", - (MASK_STACKCHECK|MASK_STACKEXTEND),		\
+      N_("Do not generate stack-check/stack-extension code") },		\
+    { "restore-a4", MASK_RESTORE_A4,					\
+      N_("Restore a4 in public functions") },				\
+    { "no-restore-a4", - MASK_RESTORE_A4,				\
+      N_("Do not restore a4 in public functions") },			\
+    { "always-restore-a4", MASK_ALWAYS_RESTORE_A4,			\
+      N_("Restore a4 in all functions") },				\
+    { "no-always-restore-a4", - MASK_ALWAYS_RESTORE_A4,			\
+      N_("Do not restore a4 in all functions") }
+
+
+/* Support sections in chip, fast memory, currently '.datachip', '.datafast'
+ * and '.datafar' to abs addressing with baserel.  */
+extern void
+amiga_named_section (const char *name, unsigned int flags, tree decl);
+
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION amiga_named_section
+
+/* Various ABI issues.  */
+
+/* This is (almost;-) BSD, so it wants DBX format.  */
+#undef DBX_DEBUGGING_INFO
+#define DBX_DEBUGGING_INFO
+
+/* GDB goes mad if it sees the function end marker.  */
+
+#define NO_DBX_FUNCTION_END 1
+
+/* Allow folding division by zero.  */
+
+#define REAL_INFINITY
+
+/* Don't try using XFmode since we don't have appropriate runtime software
+   support.  */
+#undef LONG_DOUBLE_TYPE_SIZE
+#define LONG_DOUBLE_TYPE_SIZE 64
+
+/* We use A4 for the PIC pointer, not A5, which is the framepointer.  */
+
+#undef PIC_OFFSET_TABLE_REGNUM
+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 12 : INVALID_REGNUM)
+ 
+/* Use A5 as framepointer instead of A6, since the AmigaOS ABI requires A6
+   to be used as a shared library base pointer in direct library calls.  */
+
+#undef FRAME_POINTER_REGNUM
+#define FRAME_POINTER_REGNUM 13
+
+#undef M68K_REGNAME
+#define M68K_REGNAME(r) (reg_names[(r)])
+
+/* The AmigaOS ABI does not define how structures should be returned, so,
+   contrary to 'm68k.h', we prefer a multithread-safe solution.  */
+
+#undef PCC_STATIC_STRUCT_RETURN
+
+/* Setup a default shell return value for those (gazillion..) programs that
+   (inspite of ANSI-C) declare main() to be void (or even VOID...) and thus
+   cause the shell to randomly caugh upon executing such programs (contrary
+   to Unix, AmigaOS scripts are terminated with an error if a program returns
+   with an error code above the `error' or even `failure' level
+   (which is configurable with the FAILAT command)).  */
+
+//+2004-06-24  Ulrich Weigand  <uweigand@de.ibm.com>
+//+
+//+	* c-decl.c (finish_function): Do not check for DEFAULT_MAIN_RETURN.
+//+	* system.h (DEFAULT_MAIN_RETURN): Poison.
+//+	* doc/tm.texi (DEFAULT_MAIN_RETURN): Remove documentation.
+//+
+
+//poison VAR
+//#define DEFAULT_MAIN_RETURN c_expand_return (integer_zero_node)
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "unsigned short"
+
+/* XXX: section support */
+#if 0
+/* We define TARGET_ASM_NAMED_SECTION, but we don't support arbitrary sections,
+   including '.gcc_except_table', so we emulate the standard behaviour.  */
+#undef TARGET_ASM_EXCEPTION_SECTION
+#define TARGET_ASM_EXCEPTION_SECTION amiga_exception_section
+
+#undef TARGET_ASM_EH_FRAME_SECTION
+#define TARGET_ASM_EH_FRAME_SECTION amiga_eh_frame_section
+#endif
+
+/* Use sjlj exceptions because dwarf work only on elf targets */
+#undef DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO	0
+
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+
+#ifndef ALIGN_ASM_OP
+#define ALIGN_ASM_OP "\t.align\t"
+#endif
+
+/* GAS supports alignment up to 32768 bytes.  */
+#undef ASM_OUTPUT_ALIGN
+#define ASM_OUTPUT_ALIGN(FILE, LOG)					\
+do									\
+  {									\
+    if ((LOG) == 1)							\
+      fprintf ((FILE), "\t.even\n");					\
+    else								\
+      fprintf ((FILE), "\t.align %d\n", (LOG));				\
+  }									\
+while (0)
+
+#if 0
+
+/* Define this macro if references to a symbol must be treated
+   differently depending on something about the variable or
+   function named by the symbol (such as what section it is in).
+
+   The macro definition, if any, is executed immediately after the
+   rtl for DECL or other node is created.
+   The value of the rtl will be a `mem' whose address is a
+   `symbol_ref'.
+
+   The usual thing for this macro to do is to a flag in the
+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified
+   name string in the `symbol_ref' (if one bit is not enough
+   information).
+
+   On the Amiga we use this to indicate if references to a symbol should be
+   absolute or base relative.  */
+
+#undef TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO amigaos_encode_section_info
+
+#define LIBCALL_ENCODE_SECTION_INFO(FUN)				\
+do									\
+  {									\
+    if (flag_pic >= 3)							\
+      SYMBOL_REF_FLAG (FUN) = 1;					\
+  }									\
+while (0)
+
+/* Select and switch to a section for EXP.  */
+
+//#undef TARGET_ASM_SELECT_SECTION
+//#define TARGET_ASM_SELECT_SECTION amigaos_select_section
+
+/* Preserve A4 for baserel code if necessary.  */
+
+#define EXTRA_SAVE_REG(REGNO)						\
+do {									\
+  if (flag_pic && flag_pic >= 3 && REGNO == PIC_OFFSET_TABLE_REGNUM	\
+      && amigaos_restore_a4())						\
+    return true;							\
+} while (0)
+
+/* Predicate for ALTERNATE_PIC_SETUP.  */
+
+#define HAVE_ALTERNATE_PIC_SETUP (flag_pic >= 3)
+
+/* Make a4 point at data hunk.  */
+
+#define ALTERNATE_PIC_SETUP(STREAM)					\
+  (amigaos_alternate_pic_setup (STREAM))
+
+/* Attribute support.  */
+
+/* Generate the test of d0 before return to set cc register in 'interrupt'
+   function.  */
+
+#define EPILOGUE_END_HOOK(STREAM)					\
+do									\
+  {									\
+    if (lookup_attribute ("interrupt",					\
+			  TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl)))) \
+      asm_fprintf ((STREAM), "\ttstl %Rd0\n");				\
+  }									\
+while (0)
+
+
+/* Stack checking and automatic extension support.  */
+
+#define PROLOGUE_BEGIN_HOOK(STREAM, FSIZE)				\
+  (amigaos_prologue_begin_hook ((STREAM), (FSIZE)))
+
+#define HAVE_ALTERNATE_FRAME_DESTR_F(FSIZE)				\
+  (TARGET_STACKEXTEND && current_function_calls_alloca)
+
+#define ALTERNATE_FRAME_DESTR_F(STREAM, FSIZE)				\
+  (asm_fprintf ((STREAM), "\tjra %U__unlk_a5_rts\n"))
+
+#define HAVE_ALTERNATE_RETURN						\
+  (TARGET_STACKEXTEND && frame_pointer_needed &&			\
+   current_function_calls_alloca)
+
+#define ALTERNATE_RETURN(STREAM)
+
+#if 0
+#define HAVE_restore_stack_nonlocal TARGET_STACKEXTEND
+#define gen_restore_stack_nonlocal gen_stack_cleanup_call
+
+#define HAVE_restore_stack_function TARGET_STACKEXTEND
+#define gen_restore_stack_function gen_stack_cleanup_call
+
+#define HAVE_restore_stack_block TARGET_STACKEXTEND
+#define gen_restore_stack_block gen_stack_cleanup_call
+
+#undef TARGET_ALTERNATE_ALLOCATE_STACK
+#define TARGET_ALTERNATE_ALLOCATE_STACK 1
+
+#define ALTERNATE_ALLOCATE_STACK(OPERANDS)				\
+do									\
+  {									\
+    amigaos_alternate_allocate_stack (OPERANDS);			\
+    DONE;								\
+  }									\
+while (0)
+#endif
+
+/* begin-GG-local: dynamic libraries */
+
+extern int amigaos_do_collecting (void);
+extern void amigaos_gccopts_hook (const char *);
+extern void amigaos_libname_hook (const char* arg);
+extern void amigaos_collect2_cleanup (void);
+extern void amigaos_prelink_hook (const char **, int *);
+extern void amigaos_postlink_hook (const char *);
+
+/* This macro is used to check if all collect2 facilities should be used.
+   We need a few special ones, like stripping after linking.  */
+
+#define DO_COLLECTING (do_collecting || amigaos_do_collecting())
+#define COLLECT2_POSTLINK_HOOK(OUTPUT_FILE) amigaos_postlink_hook(OUTPUT_FILE) //new
+
+/* This macro is called in collect2 for every GCC argument name.
+   ARG is a part of commandline (without '\0' at the end).  */
+
+#define COLLECT2_GCC_OPTIONS_HOOK(ARG) amigaos_gccopts_hook(ARG)
+
+/* This macro is called in collect2 for every ld's "-l" or "*.o" or "*.a"
+   argument.  ARG is a complete argument, with '\0' at the end.  */
+
+#define COLLECT2_LIBNAME_HOOK(ARG) amigaos_libname_hook(ARG)
+
+/* This macro is called at collect2 exit, to clean everything up.  */
+
+#define COLLECT2_EXTRA_CLEANUP amigaos_collect2_cleanup
+
+/* This macro is called just before the first linker invocation.
+   LD1_ARGV is "char** argv", which will be passed to "ld".  STRIP is an
+   *address* of "strip_flag" variable.  */
+
+#define COLLECT2_PRELINK_HOOK(LD1_ARGV, STRIP) \
+amigaos_prelink_hook((const char **)(LD1_ARGV), (STRIP))
+
+/* This macro is called just after the first linker invocation, in place of
+   "nm" and "ldd".  OUTPUT_FILE is the executable's filename.  */
+
+#define COLLECT2_POSTLINK_HOOK(OUTPUT_FILE) amigaos_postlink_hook(OUTPUT_FILE)
+/* end-GG-local */ 
+
+#endif
+
+/* begin-GG-local: explicit register specification for parameters */
+
+/* Note: this is an extension of m68k_args */
+
+
+#undef CLASS_MAX_NREGS
+#define CLASS_MAX_NREGS(CLASS, MODE)	\
+ ((CLASS) == FP_REGS ? GET_MODE_NUNITS (MODE) \
+ : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
+
+
+/*
+   On the m68k, this is a structure:
+   num_of_regs: number of data, address and float registers to use for
+     arguments passing (if it's 2, than pass arguments in d0, d1, a0, a1,
+     fp0 and fp1). 0 - pass everything on stack. vararg calls are
+     always passed entirely on stack.
+   regs_already_used: bitmask of the already used registers.
+   last_arg_reg - register number of the most recently passed argument.
+     -1 if passed on stack.
+   last_arg_len - number of registers used by the most recently passed
+     argument.
+*/
+
+extern void amigaos_init_cumulative_args (CUMULATIVE_ARGS *cum, tree);
+extern void amigaos_function_arg_advance (cumulative_args_t, machine_mode, const_tree, bool);
+extern rtx amigaos_function_arg (cumulative_args_t, machine_mode, const_tree, bool);
+extern cumulative_args_t amigaos_pack_cumulative_args (CUMULATIVE_ARGS *);
+extern int amigaos_comp_type_attributes (const_tree, const_tree);
+extern tree amigaos_handle_type_attribute(tree *, tree, tree, int, bool*);
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE amigaos_function_arg_advance
+
+/* A C expression that controls whether a function argument is passed
+   in a register, and which register. */
+
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG amigaos_function_arg
+
+#undef TARGET_PACK_CUMULATIVE_ARGS
+#define TARGET_PACK_CUMULATIVE_ARGS(CUM) \
+    (amigaos_pack_cumulative_args(&(CUM)))
+
+#undef  TARGET_COMP_TYPE_ATTRIBUTES
+#define TARGET_COMP_TYPE_ATTRIBUTES amigaos_comp_type_attributes
+
+
+/* end-GG-local */
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do									\
+  {									\
+    if (flag_resident)							\
+      {									\
+        if (flag_pic)							\
+	  error ("-fbaserel and -resident are mutual exclusiv\n");	\
+        flag_pic = flag_resident;					\
+      }									\
+    if (!TARGET_68020 && flag_pic==4)					\
+      error ("-fbaserel32 is not supported on the 68000 or 68010\n");	\
+    if (amigaos_regparm > 0 && amigaos_regparm > AMIGAOS_MAX_REGPARM)   \
+      error ("-mregparm=x with 1 <= x <= %d\n", AMIGAOS_MAX_REGPARM);   \
+  }									\
+while (0)
+
+/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
+     affects_type_identity } */
+#define SUBTARGET_ATTRIBUTES                                            \
+  { "asmreg", 1, 1, false, true, false, amigaos_handle_type_attribute, true }, \
+  { "asmregs", 1, 1, false,  false, true, 0, true }, \
+  { "chip", 0, 0, false, true, false, amigaos_handle_type_attribute, false }, \
+  { "fast", 0, 0, false, true, false, amigaos_handle_type_attribute, false }, \
+  { "far",  0, 0, false, true, false, amigaos_handle_type_attribute, false }, \
+  { "saveds", 0, 0, false, true, true, amigaos_handle_type_attribute, false }, \
+  { "entrypoint", 0, 0, false, true, true, amigaos_handle_type_attribute, false }, \
+  { "saveallregs", 0, 0, false, true, true, amigaos_handle_type_attribute, false }, \
+  { "regparm", 1, 1, false,  true, true, amigaos_handle_type_attribute,\
+    true }, \
+  { "stkparm", 0, 0, false,  true, true, amigaos_handle_type_attribute,\
+    true },
+
+#define GOT_SYMBOL_NAME ""
+
+#undef TARGET_STRUCT_VALUE_RTX
+#define TARGET_STRUCT_VALUE_RTX amigaos_struct_value_rtx
+rtx
+amigaos_struct_value_rtx(tree fntype,
+			       int incoming ATTRIBUTE_UNUSED);
+
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN amigaos_static_chain_rtx
+rtx
+amigaos_static_chain_rtx(const_tree fntype,
+			       bool incoming ATTRIBUTE_UNUSED);
+
+
+extern bool
+amigaos_legitimate_src (rtx src);
+
+extern void
+amigaos_restore_a4 (void);
+
+extern void
+amigaos_alternate_frame_setup_f (int fsize);
+
+extern void
+amigaos_alternate_frame_setup (int fsize);
+
+
+#define HAVE_ALTERNATE_FRAME_SETUP_F(FSIZE) TARGET_STACKEXTEND
+
+#define ALTERNATE_FRAME_SETUP_F(FSIZE)				\
+  (amigaos_alternate_frame_setup_f ((FSIZE)))
+
+#define HAVE_ALTERNATE_FRAME_SETUP(FSIZE) TARGET_STACKEXTEND
+
+#define ALTERNATE_FRAME_SETUP(FSIZE)				\
+  (amigaos_alternate_frame_setup ((FSIZE)))
+
+#undef TARGET_INSERT_ATTRIBUTES
+#define TARGET_INSERT_ATTRIBUTES amiga_insert_attribute
+
+void
+amiga_insert_attribute (tree decl, tree * attr);
diff --git a/gcc/config/m68k/amigaos.opt b/gcc/config/m68k/amigaos.opt
new file mode 100644
index 00000000000..366c8eb86fc
--- /dev/null
+++ b/gcc/config/m68k/amigaos.opt
@@ -0,0 +1,74 @@
+
+mregparm=
+Target RejectNegative Var(amigaos_regparm) Joined UInteger Init(-1)
+Pass arguments through registers.
+
+mregparm
+Target RejectNegative Alias(mregparm=, 2)
+Same as -mregparm=2
+
+noixemul
+Target RejectNegative
+Do not use ixemul.library - use libnix instead to link
+
+ramiga-lib
+Target RejectNegative
+Use libinit.o as start file
+
+ramiga-libr
+Target RejectNegative
+Use libinitr.o as start file
+
+ramiga-dev
+Target RejectNegative
+Use devinit.o as start file
+
+msmall-code
+Target RejectNegative Var(flag_smallcode,1)
+small code model
+
+fbaserel
+Target Report Var(flag_pic,3) 
+data is addressed relative to a4
+
+fbaserel32
+Target Report Var(flag_pic,4)
+data is addressed relative to a4 with 32 bit offsets
+
+resident
+Target Common Report Var(flag_resident,3)
+data is addressed relative to a4, linked as resident
+
+resident32
+Target Common Report Var(flag_resident,4)
+data is addressed relative to a4 with 32 bit offsets, linked as resident
+
+mcrt=
+Target RejectNegative Var(amigaos_crt) Joined
+Specify startup binary
+
+malways-restore-a4
+Restore a4 in all functions
+Target Common Report Mask(ALWAYS_RESTORE_A4)
+
+fbbb=
+Target RejectNegative Report Var(help_columns,80) Var(string_bbb_opts) Joined 
+Enable Bebbo's optimizations.\n
++    enable all optimizations (default)\n
+a    commute add move instructions\n
+b    use register for base addresses\n
+c    convert load const and compare into a sub\n
+e    eliminate dead assignments + redundant loads\n
+f    shrink stack frame\n
+i    use post increment on addresses\n
+l    remove single used lea if possible\n
+n    pipeline instructions\n
+m    merge add and move statements\n
+p    propagate move assignment pairs out of loops\n
+r    register renaming to maybe save registers\n
+s    a strcpy optimization\n
+z    final pass with simple substitutions\n
+v    be verbose\n
+V    be very verbose\n
+x    dump insns\n
+Default: -fbbb=+ which yields -fbbb=abcefilmnprsz
diff --git a/gcc/config/m68k/constraints.md b/gcc/config/m68k/constraints.md
index b6212089530..1223852570c 100644
--- a/gcc/config/m68k/constraints.md
+++ b/gcc/config/m68k/constraints.md
@@ -1,5 +1,5 @@
 ;; Constraint definitions for m68k
-;; Copyright (C) 2007-2016 Free Software Foundation, Inc.
+;; Copyright (C) 2007-2015 Free Software Foundation, Inc.
 
 ;; This file is part of GCC.
 
diff --git a/gcc/config/m68k/host-amigaos.c b/gcc/config/m68k/host-amigaos.c
new file mode 100755
index 00000000000..8c72d516a37
--- /dev/null
+++ b/gcc/config/m68k/host-amigaos.c
@@ -0,0 +1,42 @@
+/* AmigaOS/m68k host-specific hook definitions.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "hosthooks.h"
+#include "hosthooks-def.h"
+#include "toplev.h"
+
+static void * amigaos_m68k_gt_pch_get_address (size_t);
+
+/* Return the address of the PCH address space, if the PCH will fit in it.  */
+
+static void *
+amigaos_m68k_gt_pch_get_address (size_t sz ATTRIBUTE_UNUSED)
+{
+  fatal_error ("PCH not supported\n");
+}
+
+#undef HOST_HOOKS_GT_PCH_GET_ADDRESS
+#define HOST_HOOKS_GT_PCH_GET_ADDRESS amigaos_m68k_gt_pch_get_address
+
+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER; 
\ No newline at end of file
diff --git a/gcc/config/m68k/m68k-devices.def b/gcc/config/m68k/m68k-devices.def
index 7d7d6670268..5f311fc2844 100644
--- a/gcc/config/m68k/m68k-devices.def
+++ b/gcc/config/m68k/m68k-devices.def
@@ -76,6 +76,7 @@ M68K_DEVICE ("68020", m68020,   "68020", "68020", 68020,    isa_20,    FL_MMU |
 M68K_DEVICE ("68030", m68030,   "68030", "68020", 68030,    isa_20,    FL_MMU | FL_UCLINUX)
 M68K_DEVICE ("68040", m68040,   "68040", "68040", 68040,    isa_40,    FL_MMU)
 M68K_DEVICE ("68060", m68060,   "68060", "68060", 68060,    isa_40,    FL_MMU)
+M68K_DEVICE ("68080", m68080,   "68080", "68080", 68080,    isa_80,    FL_MMU)
 M68K_DEVICE ("68302", m68302,   "68302", "68000", 68000,    isa_00,    FL_MMU)
 M68K_DEVICE ("68332", m68332,   "68332", "cpu32", cpu32,    isa_cpu32, FL_MMU)
 M68K_DEVICE ("cpu32", cpu32,    "cpu32", "cpu32", cpu32,    isa_cpu32, FL_MMU)
diff --git a/gcc/config/m68k/m68k-isas.def b/gcc/config/m68k/m68k-isas.def
index 69369f2f840..0f959fa9d87 100644
--- a/gcc/config/m68k/m68k-isas.def
+++ b/gcc/config/m68k/m68k-isas.def
@@ -34,6 +34,7 @@ M68K_ISA ("68020",    m68020,     68020, isa_20,    FL_FOR_isa_20)
 M68K_ISA ("68030",    m68030,     68030, isa_20,    FL_FOR_isa_20)
 M68K_ISA ("68040",    m68040,     68040, isa_40,    FL_FOR_isa_40)
 M68K_ISA ("68060",    m68060,     68060, isa_40,    FL_FOR_isa_40)
+M68K_ISA ("68080",    m68080,     68080, isa_80,    FL_FOR_isa_80)
 M68K_ISA ("cpu32",    cpu32,      cpu32, isa_20,    FL_FOR_isa_cpu32)
 M68K_ISA ("isaa",     mcf5206e,   cfv2,  isa_a,     FL_FOR_isa_a | FL_CF_HWDIV)
 M68K_ISA ("isaaplus", mcf5271,    cfv2,  isa_aplus, FL_FOR_isa_aplus | FL_CF_HWDIV)
diff --git a/gcc/config/m68k/m68k-microarchs.def b/gcc/config/m68k/m68k-microarchs.def
index c8998a7389e..4a2206fdeea 100644
--- a/gcc/config/m68k/m68k-microarchs.def
+++ b/gcc/config/m68k/m68k-microarchs.def
@@ -33,9 +33,11 @@ M68K_MICROARCH ("68010",    m68010,  68010,    isa_10,  FL_FOR_isa_10)
 M68K_MICROARCH ("68020",    m68020,  68020,    isa_20,  FL_FOR_isa_20)
 M68K_MICROARCH ("68020-40", m68020,  68020_40, isa_20,  FL_FOR_isa_20)
 M68K_MICROARCH ("68020-60", m68020,  68020_60, isa_20,  FL_FOR_isa_20)
+M68K_MICROARCH ("68020-80", m68020,  68020_80, isa_20,  FL_FOR_isa_20)
 M68K_MICROARCH ("68030",    m68030,  68030,    isa_20,  FL_FOR_isa_20)
 M68K_MICROARCH ("68040",    m68040,  68040,    isa_40,  FL_FOR_isa_40)
 M68K_MICROARCH ("68060",    m68060,  68060,    isa_40,  FL_FOR_isa_40)
+M68K_MICROARCH ("68080",    m68080,  68080,    isa_80,  FL_FOR_isa_80)
 M68K_MICROARCH ("cpu32",    cpu32,   cpu32,    isa_20,  FL_FOR_isa_cpu32)
 M68K_MICROARCH ("cfv1",     mcf51qe, cfv1,     isa_c,   FL_FOR_isa_c)
 M68K_MICROARCH ("cfv2",     mcf5206, cfv2,     isa_a,   FL_FOR_isa_a)
diff --git a/gcc/config/m68k/m68k-tables.opt b/gcc/config/m68k/m68k-tables.opt
index 414252a42ee..c7eb169cabd 100644
--- a/gcc/config/m68k/m68k-tables.opt
+++ b/gcc/config/m68k/m68k-tables.opt
@@ -42,6 +42,9 @@ Enum(target_device) String(68040) Value(m68040)
 EnumValue
 Enum(target_device) String(68060) Value(m68060)
 
+EnumValue
+Enum(target_device) String(68080) Value(m68080)
+
 EnumValue
 Enum(target_device) String(68302) Value(m68302)
 
@@ -379,6 +382,9 @@ Enum(uarch_type) String(68020-40) Value(u68020_40)
 EnumValue
 Enum(uarch_type) String(68020-60) Value(u68020_60)
 
+EnumValue
+Enum(uarch_type) String(68020-80) Value(u68020_80)
+
 EnumValue
 Enum(uarch_type) String(68030) Value(u68030)
 
@@ -388,6 +394,9 @@ Enum(uarch_type) String(68040) Value(u68040)
 EnumValue
 Enum(uarch_type) String(68060) Value(u68060)
 
+EnumValue
+Enum(uarch_type) String(68080) Value(u68080)
+
 EnumValue
 Enum(uarch_type) String(cpu32) Value(ucpu32)
 
@@ -429,17 +438,20 @@ EnumValue
 Enum(m68k_isa) String(68060) Value(5)
 
 EnumValue
-Enum(m68k_isa) String(cpu32) Value(6)
+Enum(m68k_isa) String(68080) Value(6)
+
+EnumValue
+Enum(m68k_isa) String(cpu32) Value(7)
 
 EnumValue
-Enum(m68k_isa) String(isaa) Value(7)
+Enum(m68k_isa) String(isaa) Value(8)
 
 EnumValue
-Enum(m68k_isa) String(isaaplus) Value(8)
+Enum(m68k_isa) String(isaaplus) Value(9)
 
 EnumValue
-Enum(m68k_isa) String(isab) Value(9)
+Enum(m68k_isa) String(isab) Value(10)
 
 EnumValue
-Enum(m68k_isa) String(isac) Value(10)
+Enum(m68k_isa) String(isac) Value(11)
 
diff --git a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
index 03f474e1b63..f44b4fc3b73 100644
--- a/gcc/config/m68k/m68k.c
+++ b/gcc/config/m68k/m68k.c
@@ -174,10 +174,12 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static void m68k_trampoline_init (rtx, tree, rtx);
 static int m68k_return_pops_args (tree, tree, int);
 static rtx m68k_delegitimize_address (rtx);
+#ifndef TARGET_AMIGA
 static void m68k_function_arg_advance (cumulative_args_t, machine_mode,
 				       const_tree, bool);
 static rtx m68k_function_arg (cumulative_args_t, machine_mode,
 			      const_tree, bool);
+#endif
 static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);
 static bool m68k_output_addr_const_extra (FILE *, rtx);
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
@@ -186,7 +188,11 @@ static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 
 #if INT_OP_GROUP == INT_OP_DOT_WORD
 #undef TARGET_ASM_ALIGNED_HI_OP
+#ifndef TARGET_AMIGAOS_VASM
 #define TARGET_ASM_ALIGNED_HI_OP "\t.word\t"
+#else
+#define TARGET_ASM_ALIGNED_HI_OP "\tdc.w\t"
+#endif
 #endif
 
 #if INT_OP_GROUP == INT_OP_NO_DOT
@@ -322,6 +328,10 @@ static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL
 #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128
 
+#ifdef TARGET_AMIGA
+#include "amigaos.h"
+#endif
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
@@ -332,6 +342,9 @@ static const struct attribute_spec m68k_attribute_table[] =
     m68k_handle_fndecl_attribute, false },
   { "interrupt_thread", 0, 0, true,  false, false,
     m68k_handle_fndecl_attribute, false },
+#ifdef SUBTARGET_ATTRIBUTES
+  SUBTARGET_ATTRIBUTES
+#endif
   { NULL,                0, 0, false, false, false, NULL, false }
 };
 
@@ -340,14 +353,27 @@ struct gcc_target targetm = TARGET_INITIALIZER;
 /* Base flags for 68k ISAs.  */
 #define FL_FOR_isa_00    FL_ISA_68000
 #define FL_FOR_isa_10    (FL_FOR_isa_00 | FL_ISA_68010)
-/* FL_68881 controls the default setting of -m68881.  gcc has traditionally
+/* "FL_68881 controls the default setting of -m68881.  gcc has traditionally
    generated 68881 code for 68020 and 68030 targets unless explicitly told
-   not to.  */
+   not to."
+
+   This is not true at least for the AMIGA.
+   gcc 2.93 does not set the 68881 flag.
+
+   */
+#ifdef TARGET_AMIGA
+#define FL_FOR_isa_20    (FL_FOR_isa_10 | FL_ISA_68020 \
+			  | FL_BITFIELD)
+#else
 #define FL_FOR_isa_20    (FL_FOR_isa_10 | FL_ISA_68020 \
 			  | FL_BITFIELD | FL_68881 | FL_CAS)
+#endif
 #define FL_FOR_isa_40    (FL_FOR_isa_20 | FL_ISA_68040)
 #define FL_FOR_isa_cpu32 (FL_FOR_isa_10 | FL_ISA_68020)
 
+#define FL_FOR_isa_80    (FL_FOR_isa_20 | FL_ISA_68040 | FL_ISA_68080)
+
+
 /* Base flags for ColdFire ISAs.  */
 #define FL_FOR_isa_a     (FL_COLDFIRE | FL_ISA_A)
 #define FL_FOR_isa_aplus (FL_FOR_isa_a | FL_ISA_APLUS | FL_CF_USP)
@@ -363,6 +389,7 @@ enum m68k_isa
   isa_10,
   isa_20,
   isa_40,
+  isa_80,
   isa_cpu32,
   /* ColdFire instruction set variants.  */
   isa_a,
@@ -545,7 +572,7 @@ m68k_option_override (void)
 	      : (m68k_cpu_flags & FL_COLDFIRE) != 0 ? FPUTYPE_COLDFIRE
 	      : FPUTYPE_68881);
 
-  /* Sanity check to ensure that msep-data and mid-sahred-library are not
+  /* Sanity check to ensure that msep-data and mid-shared-library are not
    * both specified together.  Doing so simply doesn't make sense.
    */
   if (TARGET_SEP_DATA && TARGET_ID_SHARED_LIBRARY)
@@ -556,24 +583,30 @@ m68k_option_override (void)
    * -fpic but it hasn't been tested properly.
    */
   if (TARGET_SEP_DATA || TARGET_ID_SHARED_LIBRARY)
-    flag_pic = 2;
+    flag_pic = TARGET_68020 ? 2 : 1;
 
   /* -mpcrel -fPIC uses 32-bit pc-relative displacements.  Raise an
      error if the target does not support them.  */
   if (TARGET_PCREL && !TARGET_68020 && flag_pic == 2)
     error ("-mpcrel -fPIC is not currently supported on selected cpu");
 
+#ifndef TARGET_AMIGA
   /* ??? A historic way of turning on pic, or is this intended to
      be an embedded thing that doesn't have the same name binding
      significance that it does on hosted ELF systems?  */
   if (TARGET_PCREL && flag_pic == 0)
     flag_pic = 1;
+#endif
 
-  if (!flag_pic)
+  /* SBF: use normal jumps/calls with baserel(32) modes. */
+  if (!flag_pic || flag_pic > 2)
     {
       m68k_symbolic_call_var = M68K_SYMBOLIC_CALL_JSR;
-
+#ifndef TARGET_AMIGAOS_VASM
       m68k_symbolic_jump = "jra %a0";
+#else
+      m68k_symbolic_jump = "jmp %a0";
+#endif
     }
   else if (TARGET_ID_SHARED_LIBRARY)
     /* All addresses must be loaded from the GOT.  */
@@ -862,12 +895,27 @@ m68k_initial_elimination_offset (int from, int to)
 static bool
 m68k_save_reg (unsigned int regno, bool interrupt_handler)
 {
+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+  if (lookup_attribute ("entrypoint", attrs))
+    return false;
+
+  if (regno != 15 && lookup_attribute ("saveallregs", attrs))
+    return true;
+
   if (flag_pic && regno == PIC_REG)
     {
       if (crtl->saves_all_registers)
 	return true;
+      /* always save if __saveds is used or an options forces setting of a4. */
+      if (flag_pic > 2)
+	{
+	  tree attr = lookup_attribute ("saveds", attrs);
+	  if (attr || TARGET_RESTORE_A4 || TARGET_ALWAYS_RESTORE_A4)
+	    return true;
+	}
+      /* SBF: do not save the PIC_REG with baserel(32) modes.*/
       if (crtl->uses_pic_offset_table)
-	return true;
+	return flag_pic < 3;
       /* Reload may introduce constant pool references into a function
 	 that thitherto didn't need a PIC register.  Note that the test
 	 above will not catch that case because we will only set
@@ -978,6 +1026,8 @@ m68k_set_frame_related (rtx_insn *insn)
 
 /* Emit RTL for the "prologue" define_expand.  */
 
+extern void amiga_emit_regparm_clobbers(void);
+
 void
 m68k_expand_prologue (void)
 {
@@ -986,6 +1036,10 @@ m68k_expand_prologue (void)
 
   m68k_compute_frame_layout ();
 
+#ifdef TARGET_AMIGA
+  amiga_emit_regparm_clobbers();
+#endif
+
   if (flag_stack_usage_info)
     current_function_static_stack_size
       = current_frame.size + current_frame.offset;
@@ -1021,6 +1075,11 @@ m68k_expand_prologue (void)
 
   if (frame_pointer_needed)
     {
+#ifdef TARGET_AMIGA
+      if (HAVE_ALTERNATE_FRAME_SETUP_F (fsize_with_regs))
+	ALTERNATE_FRAME_SETUP_F (fsize_with_regs);
+      else
+#endif
       if (fsize_with_regs == 0 && TUNE_68040)
 	{
 	  /* On the 68040, two separate moves are faster than link.w 0.  */
@@ -1030,6 +1089,10 @@ m68k_expand_prologue (void)
 	  m68k_set_frame_related (emit_move_insn (frame_pointer_rtx,
 						  stack_pointer_rtx));
 	}
+#ifdef TARGET_AMIGA
+  else if (HAVE_ALTERNATE_FRAME_SETUP (fsize_with_regs))
+    ALTERNATE_FRAME_SETUP (fsize_with_regs);
+#endif
       else if (fsize_with_regs < 0x8000 || TARGET_68020)
 	m68k_set_frame_related
 	  (emit_insn (gen_link (frame_pointer_rtx,
@@ -1127,9 +1190,14 @@ m68k_expand_prologue (void)
 			    current_frame.reg_mask, true, true));
     }
 
+  /* SBF: do not load the PIC_REG with baserel(32) */
   if (!TARGET_SEP_DATA
-      && crtl->uses_pic_offset_table)
+      && crtl->uses_pic_offset_table && flag_pic < 3)
     emit_insn (gen_load_got (pic_offset_table_rtx));
+
+#ifdef TARGET_AMIGA
+  amigaos_restore_a4 ();
+#endif
 }
 
 /* Return true if a simple (return) instruction is sufficient for this
@@ -1373,13 +1441,19 @@ m68k_reg_present_p (const_rtx parallel, unsigned int regno)
   return false;
 }
 
+extern bool amiga_is_ok_for_sibcall(tree decl, tree exp);
 /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL_P.  */
 
 static bool
 m68k_ok_for_sibcall_p (tree decl, tree exp)
 {
   enum m68k_function_kind kind;
-  
+
+#ifdef TARGET_AMIGA
+  if (!amiga_is_ok_for_sibcall(decl, exp))
+    return false;
+#endif
+
   /* We cannot use sibcalls for nested functions because we use the
      static chain register for indirect calls.  */
   if (CALL_EXPR_STATIC_CHAIN (exp))
@@ -1419,6 +1493,7 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
   return false;
 }
 
+#ifndef TARGET_AMIGA
 /* On the m68k all args are always pushed.  */
 
 static rtx
@@ -1440,6 +1515,7 @@ m68k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
 	   ? (GET_MODE_SIZE (mode) + 3) & ~3
 	   : (int_size_in_bytes (type) + 3) & ~3);
 }
+#endif
 
 /* Convert X to a legitimate function call memory reference and return the
    result.  */
@@ -1796,13 +1872,21 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx_insn *insn, int signpos
 	      && next_insn_tests_no_inequality (insn))
 	    {
 	    cc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N | CC_NO_OVERFLOW;
+#ifndef TARGET_AMIGAOS_VASM
 	    return "move%.w %1,%%ccr";
+#else
+	    return "move%.w %1,ccr";
+#endif	    
 	    }
 	  if (count == 2 && DATA_REG_P (operands[1])
 	      && next_insn_tests_no_inequality (insn))
 	    {
 	    cc_status.flags = CC_NOT_NEGATIVE | CC_INVERTED | CC_NO_OVERFLOW;
+#ifndef TARGET_AMIGAOS_VASM
 	    return "move%.w %1,%%ccr";
+#else
+	    return "move%.w %1,ccr";
+#endif	    
 	    }
 	  /* count == 1 followed by bvc/bvs and
 	     count == 0 followed by bcc/bcs are also possible, but need
@@ -1918,13 +2002,18 @@ m68k_legitimate_constant_address_p (rtx x, unsigned int reach, bool strict_p)
 {
   rtx base, offset;
 
+  if (GET_CODE(x) == PLUS && SYMBOL_REF_P(XEXP(x, 0)) && GET_CODE(XEXP(x, 1)) == CONST_INT)
+    return true;
+
   if (!CONSTANT_ADDRESS_P (x))
     return false;
 
-  if (flag_pic
+  if (flag_pic && flag_pic < 3
       && !(strict_p && TARGET_PCREL)
       && symbolic_operand (x, VOIDmode))
-    return false;
+    {
+      return false;
+    }
 
   if (M68K_OFFSETS_MUST_BE_WITHIN_SECTIONS_P && reach > 1)
     {
@@ -2053,6 +2142,17 @@ m68k_decompose_address (machine_mode mode, rtx x,
 	{
 	  address->offset = XEXP (x, 1);
 	  x = XEXP (x, 0);
+
+	  if (GET_CODE(address->offset) == CONST)
+	    {
+	      rtx y = XEXP(address->offset, 0);
+	      if (GET_CODE(y) == PLUS && REG_P(XEXP(y, 0)))
+		{
+		  address->index = XEXP(y, 0);
+		  address->offset = XEXP (y, 1);
+		  address->scale = 1;
+		}
+	    }
 	}
 
       /* Check for a suppressed index register.  */
@@ -2111,6 +2211,18 @@ m68k_legitimate_address_p (machine_mode mode, rtx x, bool strict_p)
 {
   struct m68k_address address;
 
+#ifdef TARGET_AMIGA
+  if (MEM_P(x))
+    return false;
+  /* SBF: the baserel(32) const plus pic_ref, symbol is an address. */
+  if (amiga_is_const_pic_ref(x))
+    return true;
+
+  if (!amigaos_legitimate_src(x))
+    return false;
+
+#endif
+
   return m68k_decompose_address (mode, x, strict_p, &address);
 }
 
@@ -2131,7 +2243,11 @@ m68k_legitimate_mem_p (rtx x, struct m68k_address *address)
 bool
 m68k_legitimate_constant_p (machine_mode mode, rtx x)
 {
-  return mode != XFmode && !m68k_illegitimate_symbolic_constant_p (x);
+  return mode != XFmode && !m68k_illegitimate_symbolic_constant_p (x)
+#ifdef TARGET_AMIGA
+      &&  amigaos_legitimate_src (x)
+#endif
+      ;
 }
 
 /* Return true if X matches the 'Q' constraint.  It must be a memory
@@ -2172,6 +2288,8 @@ m68k_get_gp (void)
   if (pic_offset_table_rtx == NULL_RTX)
     pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_REG);
 
+//  debug_rtx(pic_offset_table_rtx);
+
   crtl->uses_pic_offset_table = 1;
 
   return pic_offset_table_rtx;
@@ -2437,12 +2555,13 @@ legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,
 		        rtx reg)
 {
   rtx pic_ref = orig;
+  if (flag_pic >= 3)
+    return orig;
 
   /* First handle a simple SYMBOL_REF or LABEL_REF */
   if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)
     {
       gcc_assert (reg);
-
       pic_ref = m68k_wrap_symbol_into_got_ref (orig, RELOC_GOT, reg);
       pic_ref = m68k_move_to_reg (pic_ref, orig, reg);
     }
@@ -2465,8 +2584,6 @@ legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,
 
       if (GET_CODE (orig) == CONST_INT)
 	pic_ref = plus_constant (Pmode, base, INTVAL (orig));
-      else
-	pic_ref = gen_rtx_PLUS (Pmode, base, orig);
     }
 
   return pic_ref;
@@ -2762,178 +2879,44 @@ m68k_const_method (HOST_WIDE_INT i)
   return MOVL;
 }
 
-/* Return the cost of moving constant I into a data register.  */
-
-static int
-const_int_cost (HOST_WIDE_INT i)
-{
-  switch (m68k_const_method (i))
-    {
-    case MOVQ:
-      /* Constants between -128 and 127 are cheap due to moveq.  */
-      return 0;
-    case MVZ:
-    case MVS:
-    case NOTB:
-    case NOTW:
-    case NEGW:
-    case SWAP:
-      /* Constants easily generated by moveq + not.b/not.w/neg.w/swap.  */
-      return 1;
-    case MOVL:
-      return 2;
-    default:
-      gcc_unreachable ();
-    }
-}
-
-static bool
-m68k_rtx_costs (rtx x, machine_mode mode, int outer_code,
-		int opno ATTRIBUTE_UNUSED,
-		int *total, bool speed ATTRIBUTE_UNUSED)
-{
-  int code = GET_CODE (x);
+extern bool
+m68k_68000_10_costs (rtx x, machine_mode mode, int outer_code,
+		int opno, int *total, bool speed );
 
-  switch (code)
-    {
-    case CONST_INT:
-      /* Constant zero is super cheap due to clr instruction.  */
-      if (x == const0_rtx)
-	*total = 0;
-      else
-        *total = const_int_cost (INTVAL (x));
-      return true;
+extern bool
+m68k_68020_costs (rtx x, machine_mode mode, int outer_code,
+		int opno, int *total, bool speed );
 
-    case CONST:
-    case LABEL_REF:
-    case SYMBOL_REF:
-      *total = 3;
-      return true;
+extern bool
+m68k_68030_costs (rtx x, machine_mode mode, int outer_code,
+		int opno, int *total, bool speed );
 
-    case CONST_DOUBLE:
-      /* Make 0.0 cheaper than other floating constants to
-         encourage creating tstsf and tstdf insns.  */
-      if (outer_code == COMPARE
-          && (x == CONST0_RTX (SFmode) || x == CONST0_RTX (DFmode)))
-	*total = 4;
-      else
-	*total = 5;
-      return true;
+extern bool
+m68k_68040_costs (rtx x, machine_mode mode, int outer_code,
+		int opno, int *total, bool speed );
 
-    /* These are vaguely right for a 68020.  */
-    /* The costs for long multiply have been adjusted to work properly
-       in synth_mult on the 68020, relative to an average of the time
-       for add and the time for shift, taking away a little more because
-       sometimes move insns are needed.  */
-    /* div?.w is relatively cheaper on 68000 counted in COSTS_N_INSNS
-       terms.  */
-#define MULL_COST				\
-  (TUNE_68060 ? 2				\
-   : TUNE_68040 ? 5				\
-   : (TUNE_CFV2 && TUNE_EMAC) ? 3		\
-   : (TUNE_CFV2 && TUNE_MAC) ? 4		\
-   : TUNE_CFV2 ? 8				\
-   : TARGET_COLDFIRE ? 3 : 13)
-
-#define MULW_COST				\
-  (TUNE_68060 ? 2				\
-   : TUNE_68040 ? 3				\
-   : TUNE_68000_10 ? 5				\
-   : (TUNE_CFV2 && TUNE_EMAC) ? 3		\
-   : (TUNE_CFV2 && TUNE_MAC) ? 2		\
-   : TUNE_CFV2 ? 8				\
-   : TARGET_COLDFIRE ? 2 : 8)
-
-#define DIVW_COST				\
-  (TARGET_CF_HWDIV ? 11				\
-   : TUNE_68000_10 || TARGET_COLDFIRE ? 12 : 27)
-
-    case PLUS:
-      /* An lea costs about three times as much as a simple add.  */
-      if (mode == SImode
-	  && GET_CODE (XEXP (x, 1)) == REG
-	  && GET_CODE (XEXP (x, 0)) == MULT
-	  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG
-	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
-	  && (INTVAL (XEXP (XEXP (x, 0), 1)) == 2
-	      || INTVAL (XEXP (XEXP (x, 0), 1)) == 4
-	      || INTVAL (XEXP (XEXP (x, 0), 1)) == 8))
-	{
-	    /* lea an@(dx:l:i),am */
-	    *total = COSTS_N_INSNS (TARGET_COLDFIRE ? 2 : 3);
-	    return true;
-	}
-      return false;
 
-    case ASHIFT:
-    case ASHIFTRT:
-    case LSHIFTRT:
-      if (TUNE_68060)
-	{
-          *total = COSTS_N_INSNS(1);
-	  return true;
-	}
-      if (TUNE_68000_10)
-        {
-	  if (GET_CODE (XEXP (x, 1)) == CONST_INT)
-	    {
-	      if (INTVAL (XEXP (x, 1)) < 16)
-	        *total = COSTS_N_INSNS (2) + INTVAL (XEXP (x, 1)) / 2;
-	      else
-	        /* We're using clrw + swap for these cases.  */
-	        *total = COSTS_N_INSNS (4) + (INTVAL (XEXP (x, 1)) - 16) / 2;
-	    }
-	  else
-	    *total = COSTS_N_INSNS (10); /* Worst case.  */
-	  return true;
-        }
-      /* A shift by a big integer takes an extra instruction.  */
-      if (GET_CODE (XEXP (x, 1)) == CONST_INT
-	  && (INTVAL (XEXP (x, 1)) == 16))
-	{
-	  *total = COSTS_N_INSNS (2);	 /* clrw;swap */
-	  return true;
-	}
-      if (GET_CODE (XEXP (x, 1)) == CONST_INT
-	  && !(INTVAL (XEXP (x, 1)) > 0
-	       && INTVAL (XEXP (x, 1)) <= 8))
-	{
-	  *total = COSTS_N_INSNS (TARGET_COLDFIRE ? 1 : 3);	 /* lsr #i,dn */
-	  return true;
-	}
-      return false;
+static bool
+m68k_rtx_costs (rtx x, machine_mode mode, int outer_code,
+		int opno,
+		int *total, bool speed )
+{
+  if (TUNE_68000_10)
+    return m68k_68000_10_costs(x, mode, outer_code, opno, total, speed);
 
-    case MULT:
-      if ((GET_CODE (XEXP (x, 0)) == ZERO_EXTEND
-	   || GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)
-	  && mode == SImode)
-        *total = COSTS_N_INSNS (MULW_COST);
-      else if (mode == QImode || mode == HImode)
-        *total = COSTS_N_INSNS (MULW_COST);
-      else
-        *total = COSTS_N_INSNS (MULL_COST);
-      return true;
+  if (m68k_tune == u68020)
+    return m68k_68020_costs(x, mode, outer_code, opno, total, speed);
 
-    case DIV:
-    case UDIV:
-    case MOD:
-    case UMOD:
-      if (mode == QImode || mode == HImode)
-        *total = COSTS_N_INSNS (DIVW_COST);	/* div.w */
-      else if (TARGET_CF_HWDIV)
-        *total = COSTS_N_INSNS (18);
-      else
-	*total = COSTS_N_INSNS (43);		/* div.l */
-      return true;
+  if (m68k_tune == u68030)
+    return m68k_68030_costs(x, mode, outer_code, opno, total, speed);
 
-    case ZERO_EXTRACT:
-      if (outer_code == COMPARE)
-        *total = 0;
-      return false;
+  if (m68k_tune == u68040 || m68k_tune == u68020_40)
+    return m68k_68040_costs(x, mode, outer_code, opno, total, speed);
 
-    default:
-      return false;
-    }
+// if (m68k_tune == u68060 || m68k_tune == u68020_60)
+// if (m68k_tune == u68080 || m68k_tune == u68020_80 || !speed)
+  *total = 1;
+  return true;
 }
 
 /* Return an instruction to move CONST_INT OPERANDS[1] into data register
@@ -4021,9 +4004,9 @@ m68k_output_movem (rtx *operands, rtx pattern,
   else
     {
       if (store_p)
-	return "movem%.l %1,%a0";
+	return "movem%.l %M1,%a0";
       else
-	return "movem%.l %a0,%1";
+	return "movem%.l %a0,%N1";
     }
 }
 
@@ -4033,7 +4016,7 @@ m68k_output_movem (rtx *operands, rtx pattern,
 static rtx
 find_addr_reg (rtx addr)
 {
-  while (GET_CODE (addr) == PLUS)
+  while (GET_CODE (addr) == PLUS || GET_CODE (addr) == MULT)
     {
       if (GET_CODE (XEXP (addr, 0)) == REG)
 	addr = XEXP (addr, 0);
@@ -4424,7 +4407,35 @@ floating_exact_log2 (rtx x)
 void
 print_operand (FILE *file, rtx op, int letter)
 {
-  if (letter == '.')
+  if (letter == 'N')
+    { // movem regs,ax
+      unsigned regbits = INTVAL (op);
+      unsigned regno;
+      for (regno = 0; regbits; ++regno, regbits >>= 1)
+	{
+	  if (regbits & 1)
+	    {
+	      fprintf (file, reg_names[regno]);
+	      if (regbits > 1)
+		fprintf (file, "/");
+	    }
+	}
+    }
+  else if (letter == 'M')
+    { // movem regs,ax
+      unsigned regbits = INTVAL (op);
+      unsigned regno;
+      for (regno = 15; regbits; --regno, regbits >>= 1)
+	{
+	  if (regbits & 1)
+	    {
+	      fprintf (file, reg_names[regno]);
+	      if (regbits > 1)
+		fprintf (file, "/");
+	    }
+	}
+    }
+  else if (letter == '.')
     {
       if (MOTOROLA)
 	fprintf (file, ".");
@@ -4456,7 +4467,9 @@ print_operand (FILE *file, rtx op, int letter)
   else if (letter == 'p')
     {
       output_addr_const (file, op);
-      if (!(GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op)))
+      /* SBF: do not add @PLTPC with baserel(32). */
+      if (flag_pic < 3
+          && !(GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op)))
 	fprintf (file, "@PLTPC");
     }
   else if (GET_CODE (op) == REG)
@@ -4475,34 +4488,52 @@ print_operand (FILE *file, rtx op, int letter)
 	  && CONSTANT_ADDRESS_P (XEXP (op, 0))
 	  && !(GET_CODE (XEXP (op, 0)) == CONST_INT
 	       && INTVAL (XEXP (op, 0)) < 0x8000
-	       && INTVAL (XEXP (op, 0)) >= -0x8000))
-	fprintf (file, MOTOROLA ? ".l" : ":l");
+	       && INTVAL (XEXP (op, 0)) >= -0x8000)
+#ifdef TARGET_AMIGA
+/* SBF: Do not append some 'l' with baserel(32). */
+	       && !amiga_is_const_pic_ref(XEXP(op, 0))
+#endif
+	       )
+		fprintf (file, MOTOROLA ? ".l" : ":l");
     }
   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == SFmode)
     {
       long l;
       REAL_VALUE_TO_TARGET_SINGLE (*CONST_DOUBLE_REAL_VALUE (op), l);
+#ifndef TARGET_AMIGAOS_VASM
       asm_fprintf (file, "%I0x%lx", l & 0xFFFFFFFF);
+#else
+      asm_fprintf (file, "%I$%lx", l & 0xFFFFFFFF);      
+#endif
     }
   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == XFmode)
     {
       long l[3];
       REAL_VALUE_TO_TARGET_LONG_DOUBLE (*CONST_DOUBLE_REAL_VALUE (op), l);
+#ifndef TARGET_AMIGAOS_VASM      
       asm_fprintf (file, "%I0x%lx%08lx%08lx", l[0] & 0xFFFFFFFF,
 		   l[1] & 0xFFFFFFFF, l[2] & 0xFFFFFFFF);
+#else
+      asm_fprintf (file, "%I$%lx%08lx%08lx", l[0] & 0xFFFFFFFF,
+		   l[1] & 0xFFFFFFFF, l[2] & 0xFFFFFFFF);
+#endif
     }
   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == DFmode)
     {
       long l[2];
       REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (op), l);
+#ifndef TARGET_AMIGAOS_VASM      
       asm_fprintf (file, "%I0x%lx%08lx", l[0] & 0xFFFFFFFF, l[1] & 0xFFFFFFFF);
+#else
+      asm_fprintf (file, "%I$%lx%08lx", l[0] & 0xFFFFFFFF, l[1] & 0xFFFFFFFF);
+#endif
     }
   else
     {
       /* Use `print_operand_address' instead of `output_addr_const'
 	 to ensure that we print relevant PIC stuff.  */
       asm_fprintf (file, "%I");
-      if (TARGET_PCREL
+      if ((TARGET_PCREL || flag_pic > 2)
 	  && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST))
 	print_operand_address (file, op);
       else
@@ -4521,7 +4552,32 @@ m68k_get_reloc_decoration (enum m68k_reloc reloc)
   switch (reloc)
     {
     case RELOC_GOT:
-      if (MOTOROLA)
+      /* SBF: add the proper extension for baserel relocs with baserel(32). */
+      if (TARGET_AMIGA)
+	{
+#ifndef TARGET_AMIGAOS_VASM
+	  if (flag_pic == 1)
+	    return ".w";
+	  else if (flag_pic == 3)
+	    return ":W";
+	  else if (flag_pic == 4)
+	    return ":L";
+	  else
+	    return "";
+#else
+	  if (flag_pic == 1)
+            return ".w";
+          else if (flag_pic == 3)
+            return ".w";
+          else if (flag_pic == 4)
+            return ".l";
+          else
+            return "";
+
+#endif
+
+	}
+	if (MOTOROLA)
 	{
 	  if (flag_pic == 1 && TARGET_68020)
 	    return "@GOT.w";
@@ -4671,8 +4727,61 @@ print_operand_address (FILE *file, rtx addr)
 {
   struct m68k_address address;
 
+#ifdef TARGET_AMIGA
+  /*
+   * SBF: remove the const wrapper.
+   */
+  if (GET_CODE(addr) == CONST && GET_CODE(XEXP(addr, 0)) == CONST)
+    addr = XEXP(addr, 0);
+  if (GET_CODE(addr) == CONST && GET_CODE(XEXP(addr, 0)) == PLUS && amiga_is_const_pic_ref(XEXP(XEXP(addr, 0), 0)))
+    addr = XEXP(addr, 0);
+  if (GET_CODE(addr) == PLUS && amiga_is_const_pic_ref(XEXP(addr, 0)))
+    {
+      fprintf (file, "%d+", (int) INTVAL (XEXP(addr, 1)));
+      print_operand_address(file, XEXP(XEXP(addr, 0),0));
+      return;
+    }
+  if (amiga_is_const_pic_ref(addr))
+    {
+      /* handle (plus (unspec ) (const_int) */
+      rtx *x = &addr;
+      while (GET_CODE(*x) != PLUS)
+	x = &XEXP(*x, 0);
+
+      x = &XEXP(*x, 1); // CONST
+      if (GET_CODE(*x) == CONST)
+	x = &XEXP(*x, 0);
+
+      /* if there is a plus - swap it.
+       * we want n+symbol:W (not symbol:W+n)
+       */
+      if (GET_CODE(*x) == PLUS)
+	{
+	  rtx plus = *x;
+	  fprintf (file, "%d+", (int) INTVAL (XEXP(plus, 1)));
+
+	  *x = XEXP(plus, 0);
+	  print_operand_address(file, XEXP(addr, 0));
+	  *x = plus;
+	}
+      else
+	print_operand_address(file, XEXP(addr, 0));
+
+      return;
+    }
+
+  if (symbolic_operand(addr, VOIDmode))
+    {
+      memset (&address, 0, sizeof (address));
+      address.offset = addr;
+    }
+  else
+#endif
   if (!m68k_decompose_address (QImode, addr, true, &address))
-    gcc_unreachable ();
+    {
+      debug_rtx(addr);
+      gcc_unreachable ();
+    }
 
   if (address.code == PRE_DEC)
     fprintf (file, MOTOROLA ? "-(%s)" : "%s@-",
@@ -4697,7 +4806,11 @@ print_operand_address (FILE *file, rtx addr)
 	  /* (d16,PC) or (bd,PC,Xn) (with suppressed index register).  */
 	  fputc ('(', file);
 	  output_addr_const (file, addr);
+#ifdef TARGET_AMIGA
+	  asm_fprintf (file, ",%Rpc)");
+#else
 	  asm_fprintf (file, flag_pic == 1 ? ":w,%Rpc)" : ":l,%Rpc)");
+#endif
 	}
       else
 	{
@@ -4714,6 +4827,14 @@ print_operand_address (FILE *file, rtx addr)
 	    }
 	  else
 	    output_addr_const (file, addr);
+
+#ifdef TARGET_AMIGA
+	  if (SYMBOL_REF_FUNCTION_P(addr))
+	    {
+	      if (flag_smallcode)
+		asm_fprintf(file, ":w(pc)");
+	    }
+#endif
 	}
     }
   else
@@ -5155,7 +5276,9 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,
 
 /* Value is true if hard register REGNO can hold a value of machine-mode
    MODE.  On the 68000, we let the cpu registers can hold any mode, but
-   restrict the 68881 registers to floating-point modes.  */
+   restrict the 68881 registers to floating-point modes.  
+   SBF: Disallow the frame pointer register, if the frame pointer is used.
+   */
 
 bool
 m68k_regno_mode_ok (int regno, machine_mode mode)
@@ -5168,8 +5291,11 @@ m68k_regno_mode_ok (int regno, machine_mode mode)
     }
   else if (ADDRESS_REGNO_P (regno))
     {
+      if (TARGET_68881 && (GET_MODE_CLASS (mode) == MODE_FLOAT
+	   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT))
+	return false;
       if (regno + GET_MODE_SIZE (mode) / 4 <= 16)
-	return true;
+	return !frame_pointer_needed || regno != FRAME_POINTER_REGNUM;
     }
   else if (FP_REGNO_P (regno))
     {
@@ -5190,6 +5316,13 @@ m68k_secondary_reload_class (enum reg_class rclass,
 			     machine_mode mode, rtx x)
 {
   int regno;
+#ifdef TARGET_AMIGA  
+  /* SBF: check for baserel's const pic_ref
+   * and return ADDR_REGS or NO_REGS
+   */
+  if (!MEM_P(x) && amiga_is_const_pic_ref(x))
+    return rclass == ADDR_REGS ? NO_REGS : ADDR_REGS;
+#endif
 
   regno = true_regnum (x);
 
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index 2aa858fa23b..ed90bc6dd32 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -204,7 +204,11 @@ along with GCC; see the file COPYING3.  If not see
 #define INT_OP_DC	3	/* dc.b, dc.w, dc.l */
 
 /* Set the default.  */
+#ifndef TARGET_AMIGAOS_VASM
 #define INT_OP_GROUP INT_OP_DOT_WORD
+#else
+#define INT_OP_GROUP INT_OP_DC
+#endif
 
 /* Bit values used by m68k-devices.def to identify processor capabilities.  */
 #define FL_BITFIELD  (1 << 0)    /* Support bitfield instructions.  */
@@ -226,12 +230,14 @@ along with GCC; see the file COPYING3.  If not see
 #define FL_ISA_C     (1 << 16)
 #define FL_FIDOA     (1 << 17)
 #define FL_CAS	     (1 << 18)	/* Support cas insn.  */
+#define FL_ISA_68080 (1 << 19)
 #define FL_MMU 	     0   /* Used by multilib machinery.  */
 #define FL_UCLINUX   0   /* Used by multilib machinery.  */
 
 #define TARGET_68010		((m68k_cpu_flags & FL_ISA_68010) != 0)
 #define TARGET_68020		((m68k_cpu_flags & FL_ISA_68020) != 0)
 #define TARGET_68040		((m68k_cpu_flags & FL_ISA_68040) != 0)
+#define TARGET_68080		((m68k_cpu_flags & FL_ISA_68080) != 0)
 #define TARGET_COLDFIRE		((m68k_cpu_flags & FL_COLDFIRE) != 0)
 #define TARGET_COLDFIRE_FPU	(m68k_fpu == FPUTYPE_COLDFIRE)
 #define TARGET_68881		(m68k_fpu == FPUTYPE_68881)
@@ -385,7 +391,6 @@ along with GCC; see the file COPYING3.  If not see
   16, 17, 18, 19, 20, 21, 22, 23\
 }
 
-
 /* On the m68k, ordinary registers hold 32 bits worth;
    for the 68881 registers, a single register is always enough for
    anything that can be stored in them at all.  */
@@ -440,8 +445,8 @@ along with GCC; see the file COPYING3.  If not see
 /* The m68k has three kinds of registers, so eight classes would be
    a complete set.  One of them is not needed.  */
 enum reg_class {
-  NO_REGS, DATA_REGS,
-  ADDR_REGS, FP_REGS,
+  NO_REGS, DATA_REGS, D0_REGS,
+  ADDR_REGS, A0_REGS, FP_REGS,
   GENERAL_REGS, DATA_OR_FP_REGS,
   ADDR_OR_FP_REGS, ALL_REGS,
   LIM_REG_CLASSES };
@@ -449,8 +454,8 @@ enum reg_class {
 #define N_REG_CLASSES (int) LIM_REG_CLASSES
 
 #define REG_CLASS_NAMES \
- { "NO_REGS", "DATA_REGS",              \
-   "ADDR_REGS", "FP_REGS",              \
+ { "NO_REGS", "DATA_REGS", "D0_REGS"              \
+   "ADDR_REGS", "A0_REGS", "FP_REGS",              \
    "GENERAL_REGS", "DATA_OR_FP_REGS",   \
    "ADDR_OR_FP_REGS", "ALL_REGS" }
 
@@ -458,7 +463,9 @@ enum reg_class {
 {					\
   {0x00000000},  /* NO_REGS */		\
   {0x000000ff},  /* DATA_REGS */	\
+  {0x00000001},  /* D0_REGS */	\
   {0x0100ff00},  /* ADDR_REGS */	\
+  {0x00000100},  /* A0_REGS */	\
   {0x00ff0000},  /* FP_REGS */		\
   {0x0100ffff},  /* GENERAL_REGS */	\
   {0x00ff00ff},  /* DATA_OR_FP_REGS */	\
@@ -614,11 +621,11 @@ __transfer_from_trampoline ()					\
 
 #define REGNO_OK_FOR_INDEX_P(REGNO)			\
   (INT_REGNO_P (REGNO)					\
-   || INT_REGNO_P (reg_renumber[REGNO]))
+   || (reg_renumber && INT_REGNO_P (reg_renumber[REGNO])))
 
 #define REGNO_OK_FOR_BASE_P(REGNO)			\
   (ADDRESS_REGNO_P (REGNO)				\
-   || ADDRESS_REGNO_P (reg_renumber[REGNO]))
+   || (reg_renumber && ADDRESS_REGNO_P (reg_renumber[REGNO])))
 
 #define REGNO_OK_FOR_INDEX_NONSTRICT_P(REGNO)		\
   (INT_REGNO_P (REGNO)					\
@@ -727,9 +734,49 @@ do { if (cc_prev_status.flags & CC_IN_68881)			\
   if (cc_prev_status.flags & CC_NO_OVERFLOW)			\
     return NO_OV;						\
   return NORMAL; } while (0)
+
+#ifdef TARGET_AMIGAOS_VASM
+#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \
+  do {                                                                        \
+    FILE *_hide_asm_out_file = (MYFILE);                                      \
+    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);        \
+    int _hide_thissize = (MYLENGTH);                                          \
+    {                                                                         \
+      FILE *asm_out_file = _hide_asm_out_file;                                \
+      const unsigned char *p = _hide_p;                                       \
+      int thissize = _hide_thissize;                                          \
+      int i;                                                                  \
+      fprintf (asm_out_file, "\tdc.b \"");                                    \
+                                                                              \
+      for (i = 0; i < thissize; i++)                                          \
+        {                                                                     \
+          int c = p[i];                                                       \
+          if (c == '\"' || c == '\\')                                         \
+            putc ('\\', asm_out_file);                                        \
+          if (ISPRINT (c))                                                    \
+            putc (c, asm_out_file);                                           \
+          else                                                                \
+            {                                                                 \
+              fprintf (asm_out_file, "\\%o", c);                              \
+              /* After an octal-escape, if a digit follows,                   \
+                 terminate one string constant and start another.             \
+                 The VAX assembler fails to stop reading the escape           \
+                 after three digits, so this is the only way we               \
+                 can get it to parse the data properly.  */                   \
+              if (i < thissize - 1 && ISDIGIT (p[i + 1]))                     \
+                fprintf (asm_out_file, "\"\n\tdc.b \"");                      \
+          }                                                                   \
+        }                                                                     \
+      fprintf (asm_out_file, "\"\n");                                         \
+    }                                                                         \
+  }                                                                           \
+  while (0)
+#endif
 
+
 /* Control the assembler format that we output.  */
 
+#ifndef TARGET_AMIGAOS_VASM
 #define ASM_APP_ON "#APP\n"
 #define ASM_APP_OFF "#NO_APP\n"
 #define TEXT_SECTION_ASM_OP "\t.text"
@@ -739,6 +786,17 @@ do { if (cc_prev_status.flags & CC_IN_68881)			\
 #define LOCAL_LABEL_PREFIX ""
 #define USER_LABEL_PREFIX "_"
 #define IMMEDIATE_PREFIX "#"
+#else
+#define ASM_APP_ON ""
+#define ASM_APP_OFF ""
+#define TEXT_SECTION_ASM_OP "\tsection .text,code"
+#define DATA_SECTION_ASM_OP "\tsection .data,data"
+#define GLOBAL_ASM_OP "\txdef\t"
+#define REGISTER_PREFIX ""
+#define LOCAL_LABEL_PREFIX "_."
+#define USER_LABEL_PREFIX "_"
+#define IMMEDIATE_PREFIX "#"
+#endif
 
 #define REGISTER_NAMES \
 {REGISTER_PREFIX"d0", REGISTER_PREFIX"d1", REGISTER_PREFIX"d2",	\
@@ -858,11 +916,17 @@ do { if (cc_prev_status.flags & CC_IN_68881)			\
 
 /* The m68k does not use absolute case-vectors, but we must define this macro
    anyway.  */
-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)	\
   asm_fprintf (FILE, "\t.long %LL%d\n", VALUE)
-
-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)	\
   asm_fprintf (FILE, "\t.word %LL%d-%LL%d\n", VALUE, REL)
+#else
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)	\
+ asm_fprintf (FILE, "\tdc.l %LL%d\n", VALUE)
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
+  asm_fprintf (FILE, "\tdc.w %LL%d-%LL%d\n", VALUE, REL)
+#endif
 
 /* We don't have a way to align to more than a two-byte boundary, so do the
    best we can and don't complain.  */
@@ -872,13 +936,24 @@ do { if (cc_prev_status.flags & CC_IN_68881)			\
 
 #ifdef HAVE_GAS_BALIGN_AND_P2ALIGN
 /* Use "move.l %a4,%a4" to advance within code.  */
+#ifndef TARGET_AMIGAOS_VASM
 #define ASM_OUTPUT_ALIGN_WITH_NOP(FILE,LOG)			\
   if ((LOG) > 0)						\
     fprintf ((FILE), "\t.balignw %u,0x284c\n", 1 << (LOG));
 #endif
+#else
+#define ASM_OUTPUT_ALIGN_WITH_NOP(FILE,LOG)			\
+  if ((LOG) > 0)						\
+    fprintf ((FILE), "\tcnop 0,%u\n", 1 << (LOG));
+#endif
 
+#ifndef TARGET_AMIGAOS_VASM
 #define ASM_OUTPUT_SKIP(FILE,SIZE)  \
   fprintf (FILE, "\t.skip %u\n", (int)(SIZE))
+#else
+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \
+  fprintf (FILE, "\tds.b %u\n", (int)(SIZE))
+#endif
 
 #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \
 ( fputs (".comm ", (FILE)),			\
@@ -971,3 +1046,8 @@ extern int m68k_sched_address_bypass_p (rtx_insn *, rtx_insn *);
 extern int m68k_sched_indexed_address_bypass_p (rtx_insn *, rtx_insn *);
 
 #define CPU_UNITS_QUERY 1
+
+#if 1
+extern void default_stabs_asm_out_constructor (rtx, int);
+extern void default_stabs_asm_out_destructor (rtx, int);
+#endif
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index ec37bd76f55..b3c7935ce79 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -128,13 +128,11 @@
    (UNSPECV_TAS_2	4)
   ])
 
-;; Registers by name.
+;; Registers by name. SBF: Do not define PIC_REG / A6_REG here!
 (define_constants
   [(D0_REG		0)
    (A0_REG		8)
    (A1_REG		9)
-   (PIC_REG		13)
-   (A6_REG		14)
    (SP_REG		15)
    (FP0_REG		16)
   ])
@@ -818,13 +816,13 @@
    pea %a1"
   [(set_attr "type" "clr_l,mov3q_l,pea")])
 
-;This is never used.
-;(define_insn "swapsi"
-;  [(set (match_operand:SI 0 "nonimmediate_operand" "+r")
-;	(match_operand:SI 1 "general_operand" "+r"))
-;   (set (match_dup 1) (match_dup 0))]
-;  ""
-;  "exg %1,%0")
+;This is used if spill registers are sold out.
+(define_insn "swapsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
+	(match_operand:SI 1 "nonimmediate_operand" "=r"))
+   (set (match_dup 1) (match_dup 0))]
+  ""
+  "exg %1,%0")
 
 ;; Special case of fullword move when source is zero for 68000_10.
 ;; moveq is faster on the 68000.
@@ -1566,7 +1564,7 @@
 ;; so we will prefer it to them.
 
 (define_insn "pushasi"
-  [(set (match_operand:SI 0 "push_operand" "=m")
+  [(set (match_operand:SI 0 "push_operand" "=<")
 	(match_operand:SI 1 "address_operand" "p"))]
   ""
   "pea %a1"
@@ -4573,12 +4571,12 @@
 
 ;; On the 68000, this makes faster code in a special case.
 
-(define_insn "ashlsi_17_24"
+(define_insn "ashlsi_18_24"
   [(set (match_operand:SI 0 "register_operand" "=d")
 	(ashift:SI (match_operand:SI 1 "register_operand" "0")
 		   (match_operand:SI 2 "const_int_operand" "n")))]
   "TUNE_68000_10
-   && INTVAL (operands[2]) > 16
+   && INTVAL (operands[2]) > 17
    && INTVAL (operands[2]) <= 24"
 {
   CC_STATUS_INIT;
@@ -4587,6 +4585,20 @@
   return "lsl%.w %2,%0\;swap %0\;clr%.w %0";
 })
 
+(define_insn "ashlsi_17"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0")
+		   (match_operand:SI 2 "const_int_operand" "n")))]
+  "TUNE_68000_10
+   && INTVAL (operands[2]) == 17"
+{
+  CC_STATUS_INIT;
+
+  operands[2] = GEN_INT (INTVAL (operands[2]) - 16);
+  return "add.w %0,%0\;swap %0\;clr%.w %0";
+})
+
+
 (define_insn "ashlsi3"
   [(set (match_operand:SI 0 "register_operand" "=d")
 	(ashift:SI (match_operand:SI 1 "register_operand" "0")
@@ -5505,7 +5517,7 @@
 
 (define_insn "*extv_bfexts_mem"
   [(set (match_operand:SI 0 "register_operand" "=d")
-	(sign_extract:SI (match_operand:QI 1 "memory_operand" "o")
+	(sign_extract:SI (match_operand:SI 1 "memory_operand" "o")
 			 (match_operand:SI 2 "nonmemory_operand" "dn")
 			 (match_operand:SI 3 "nonmemory_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
@@ -5521,7 +5533,7 @@
 
 (define_insn "*extzv_bfextu_mem"
   [(set (match_operand:SI 0 "register_operand" "=d")
-	(zero_extract:SI (match_operand:QI 1 "memory_operand" "o")
+	(zero_extract:SI (match_operand:SI 1 "memory_operand" "o")
 			 (match_operand:SI 2 "nonmemory_operand" "dn")
 			 (match_operand:SI 3 "nonmemory_operand" "dn")))]
   "TARGET_68020 && TARGET_BITFIELD"
@@ -5539,7 +5551,7 @@
 })
 
 (define_insn "*insv_bfchg_mem"
-  [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
+  [(set (zero_extract:SI (match_operand:SI 0 "memory_operand" "+o")
 			 (match_operand:SI 1 "nonmemory_operand" "dn")
 			 (match_operand:SI 2 "nonmemory_operand" "dn"))
         (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))
@@ -5554,7 +5566,7 @@
 })
 
 (define_insn "*insv_bfclr_mem"
-  [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
+  [(set (zero_extract:SI (match_operand:SI 0 "memory_operand" "+o")
 			 (match_operand:SI 1 "nonmemory_operand" "dn")
 			 (match_operand:SI 2 "nonmemory_operand" "dn"))
 	(const_int 0))]
@@ -5565,7 +5577,7 @@
 })
 
 (define_insn "*insv_bfset_mem"
-  [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
+  [(set (zero_extract:SI (match_operand:SI 0 "memory_operand" "+o")
 			 (match_operand:SI 1 "general_operand" "dn")
 			 (match_operand:SI 2 "general_operand" "dn"))
 	(const_int -1))]
@@ -5595,7 +5607,7 @@
 }")
 
 (define_insn "*insv_bfins_mem"
-  [(set (zero_extract:SI (match_operand:QI 0 "memory_operand" "+o")
+  [(set (zero_extract:SI (match_operand:SI 0 "memory_operand" "+o")
 			 (match_operand:SI 1 "nonmemory_operand" "dn")
 			 (match_operand:SI 2 "nonmemory_operand" "dn"))
 	(match_operand:SI 3 "register_operand" "d"))]
@@ -5677,7 +5689,7 @@
 
 (define_insn "*tst_bftst_mem"
   [(set (cc0)
-	(compare (zero_extract:SI (match_operand:QI 0 "memory_operand" "o")
+	(compare (zero_extract:SI (match_operand:SI 0 "memory_operand" "o")
 				  (match_operand:SI 1 "const_int_operand" "n")
 				  (match_operand:SI 2 "general_operand" "dn"))
 	         (const_int 0)))]
@@ -7204,6 +7216,7 @@
   "operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);")
 
 ;; Changing pea X.w into a move.l is no real win here.
+;; SBF: also disable converting pea for baserel insns!
 (define_peephole2
   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)
 				 (match_operand:SI 0 "const_int_operand" "")))
@@ -7213,7 +7226,8 @@
    && !reg_mentioned_p (stack_pointer_rtx, operands[2])
    && !(CONST_INT_P (operands[2]) && INTVAL (operands[2]) != 0
 	&& IN_RANGE (INTVAL (operands[2]), -0x8000, 0x7fff)
-	&& !valid_mov3q_const (INTVAL (operands[2])))"
+	&& !valid_mov3q_const (INTVAL (operands[2])))
+   && !amiga_is_const_pic_ref(operands[2])"
   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_dup 0)))
    (set (match_dup 1) (match_dup 2))]
 {
diff --git a/gcc/config/m68k/m68k.opt b/gcc/config/m68k/m68k.opt
index e44539f2b7a..5277c4e4dda 100644
--- a/gcc/config/m68k/m68k.opt
+++ b/gcc/config/m68k/m68k.opt
@@ -77,6 +77,10 @@ m68060
 Target RejectNegative Alias(mcpu=, 68060)
 Generate code for a 68060.
 
+m68080
+Target RejectNegative Alias(mcpu=, 68080)
+Generate code for a 68080.
+
 m68302
 Target RejectNegative Alias(mcpu=, 68302)
 Generate code for a 68302.
diff --git a/gcc/config/m68k/m68k_68000_10_costs.c b/gcc/config/m68k/m68k_68000_10_costs.c
new file mode 100644
index 00000000000..2b32d0013af
--- /dev/null
+++ b/gcc/config/m68k/m68k_68000_10_costs.c
@@ -0,0 +1,407 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "cfghooks.h"
+#include "tree.h"
+#include "rtl.h"
+
+#define USE_MOVQ(i)	((unsigned) ((i) + 128) <= 255)
+
+/* Return the cost of moving constant I into a data register.  */
+
+static int
+const_int_cost (HOST_WIDE_INT i)
+{
+  switch (m68k_const_method (i))
+    {
+    case MOVQ:
+      /* Constants between -128 and 127 are cheap due to moveq.  */
+      return 0;
+    case MVZ:
+    case MVS:
+    case NOTB:
+    case NOTW:
+    case NEGW:
+    case SWAP:
+      /* Constants easily generated by moveq + not.b/not.w/neg.w/swap.  */
+      return 1;
+    case MOVL:
+      return 2;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+
+bool
+m68k_68000_10_costs (rtx x, machine_mode mode, int outer_code,
+		int opno,
+		int *total, bool speed )
+{
+  int code = GET_CODE (x);
+
+  /*
+   *  SBF: defining a cost model for the 68000.
+   *
+   *  Use the cycles from MC68000UM.pdf.
+   *
+   */
+  int total2 = 0;
+  switch (code)
+    {
+    case CALL:
+      {
+	rtx a = XEXP(x, 0);
+	if (MEM_P(a))
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (REG_P(b))
+	      {
+		*total = 16;
+		return true;
+	      }
+	    if (GET_CODE(b) == PLUS)
+	      {
+		if (REG_P(XEXP(b, 0)))
+		  {
+		    *total = 18;
+		    return true;
+		  }
+	      }
+	    else if (SYMBOL_REF_P(b))
+	      {
+		tree decl = SYMBOL_REF_DECL (b);
+
+		*total = 20;
+		return true;
+	      }
+	  }
+	*total = 22;
+	return true;
+      }
+    case EQ:
+    case NE:
+    case GE:
+    case GT:
+    case GTU:
+    case LE:
+    case LT:
+    case CC0:
+    case ZERO_EXTRACT:
+      return false;
+    case POST_INC:
+    case TRUNCATE:
+      *total = 0;
+      return true;
+    case PRE_DEC:
+      *total = 2;
+      return true;
+    case REG:
+      *total = opno ? 4 : 0;
+      return true;
+    case SYMBOL_REF:
+      *total = 12;
+      return true;
+    case IF_THEN_ELSE:
+      *total = 10;
+      return true;
+    case SET:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (m68k_68000_10_costs (a, mode, code, 0, total, speed)
+	    && m68k_68000_10_costs (b, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2;
+	    if (MEM_P(a) && GET_CODE(b) == CONST_INT && INTVAL(b) == 0)
+	      {
+		// penalty for clr
+		*total += GET_MODE_SIZE(mode) > 2 ? 8 : 4;
+		if (GET_CODE(XEXP(a, 0)) == PRE_DEC)
+		  *total += 2;
+	      }
+	    return true;
+	  }
+	break;
+      }
+    case CONST:
+      {
+	rtx a = XEXP(x, 0);
+	if (GET_CODE(a) == PLUS && SYMBOL_REF_P(XEXP(a,0)) && GET_CODE(XEXP(a, 1)) == CONST_INT)
+	  {
+	    *total = 12;
+	    return true;
+	  }
+	*total = 0;
+	break;
+      }
+    case MULT:
+      {
+	/* umul, smul or call to __mulsi3? */
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+
+	/* if there is an extended HImode, mul.w might be a candidate. */
+	if (GET_CODE (a) == ZERO_EXTEND
+	     || GET_CODE (a) == SIGN_EXTEND)
+	  {
+	    *total = 0;
+	    mode = HImode;
+	  }
+	else
+	if (!m68k_68000_10_costs (a, mode, code, 0, total, speed))
+	  break;
+
+	if (speed)
+	  {
+	    int f = GET_MODE_SIZE(mode) > 2 ? 150 : 50;
+	    if (GET_CODE(b) == CONST_INT && GET_MODE_SIZE(mode) == 2)
+	      {
+		unsigned i = INTVAL(b);
+		int bits = 0, l = 0;
+		if (i > 0)
+		  {
+		    if (GET_CODE (a) == ZERO_EXTEND)
+		      while (i)
+			{
+			  ++bits;
+			  i>>=1;
+			}
+		    else // SIGN_EXTEND
+		      while (i || l)
+			{
+			  if ((i&1) != l)
+			    {
+			      l = !l;
+			      ++bits;
+			    }
+			  i >>= 1;
+			}
+
+		    f = 38 + 2 * bits;
+		  }
+	      }
+	    *total += f;
+	  }
+	else
+	  *total = GET_MODE_SIZE(mode) > 2 ? 48 : 16;
+
+	return true;
+      }
+    case DIV:
+    case UDIV:
+    case MOD:
+    case UMOD:
+      {
+	rtx a = XEXP(x, 0);
+	if (m68k_68000_10_costs (a, mode, code, 0, total, speed))
+	  {
+	    if (speed)
+	      *total += GET_MODE_SIZE(mode) > 2 ? 410 : 136;
+	    else
+	      *total += GET_MODE_SIZE(mode) > 2 ? 108 : 36;
+	    return true;
+	  }
+	break;
+      }
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = (GET_MODE_SIZE(mode) > 2 ? 8 : 6);
+		*total += 2 * INTVAL(b);
+		return true;
+	      }
+	    *total = (GET_MODE_SIZE(mode) > 2 ? 8 : 6) ;
+	    if (speed)
+	      *total += 16;
+	    return true;
+	  }
+	if (m68k_68000_10_costs (XEXP(x, 0), mode, code, 0, total, speed))
+	  {
+	    *total += 8;
+	    return true;
+	  }
+	break;
+      }
+    case SUBREG:
+    case STRICT_LOW_PART:
+      return m68k_68000_10_costs (XEXP(x, 0), GET_MODE(XEXP(x, 0)), code, 0, total, speed);
+    case ZERO_EXTEND:
+    case SIGN_EXTEND:
+      if (m68k_68000_10_costs (XEXP(x, 0), GET_MODE(XEXP(x, 0)), code, 0, total, speed))
+	{
+	  *total += 8;
+	  return true;
+	}
+      return false;
+    case CONST_INT:
+      {
+	int kind = const_int_cost (INTVAL(x));
+	if (kind == 0)
+	  *total = 4;
+	else if (kind == 1)
+	  *total = GET_MODE_SIZE(mode) > 2 ? 10 : 8;
+	else
+	  *total = GET_MODE_SIZE(mode) > 2 ? 12 : 8;
+	return true;
+      }
+    case NEG:
+    case NOT:
+      {
+	rtx a = XEXP(x, 0);
+	if (REG_P(a))
+	  {
+	    *total = GET_MODE_SIZE(mode) > 2 ? 6 : 4;
+	    return true;
+	  }
+	if (m68k_68000_10_costs (a, mode, code, 0, total, speed))
+	  {
+	    *total += GET_MODE_SIZE(mode) > 2 ? 12 : 8;
+	    return true;
+	  }
+	break;
+      }
+    case MINUS:
+    case PLUS:
+      {
+	/* add const,reg, add ea,reg, add reg, mem */
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+
+	// handle lea n(ax,dy),az
+	if (GET_CODE(a) == PLUS && GET_CODE(b) == CONST_INT && (unsigned)(INTVAL(b) + 128) < 255)
+	  {
+	    if (REG_P(XEXP(a,0)) && REG_P(XEXP(a,1)))
+	      {
+		*total = 12;
+		return true;
+	      }
+	  }
+
+	// handle lea n(ax),ay
+	if (REG_P(a) && REGNO(a) >= 8 && REGNO(a) < 16) {
+	    if (GET_CODE(b) == CONST && GET_CODE(XEXP(b, 0)) == UNSPEC)
+	    {
+		    *total = 8; // 12 - 4
+		    return true;
+	    }
+	    if (GET_CODE(b) == CONST_INT && (unsigned)(INTVAL(b) + 32768) < 65535)
+	    {
+		    *total = 8;
+		    return true;
+	    }
+	}
+
+	// handle add reg,reg
+	if (REG_P(a) && REG_P(b))
+	  {
+	    *total = GET_MODE_SIZE(mode) > 2 ? 8 : 4;
+	    return true;
+	  }
+
+	if (GET_CODE(b) == CONST_INT)
+	  {
+	    int i = INTVAL(b);
+	    if (REG_P(a) && (USE_MOVQ(i) || (REGNO(a) >= 8 && REGNO(a) < 16 && (unsigned)(INTVAL(b) + 32768) < 65535)))
+	      *total = GET_MODE_SIZE(mode) > 2 ? 8 : 4;
+	    else
+	      *total = GET_MODE_SIZE(mode) > 2 ? 16 : 8;
+	    return true;
+	  }
+
+	if (GET_CODE(b) == SYMBOL_REF ||
+		    (GET_CODE(b) == CONST && GET_CODE(XEXP(b,0)) == PLUS && GET_CODE(XEXP(XEXP(b,0),0)) == SYMBOL_REF))
+	{
+	    *total = 16;
+	    return true;
+	}
+
+	if (!m68k_68000_10_costs (a, mode, code, 0, total, speed))
+	  break;
+	if (!m68k_68000_10_costs (b, mode, code, 1, &total2, speed))
+	  break;
+
+	*total += total2 + GET_MODE_SIZE(mode) > 2 ? 6 : 4;
+	return true;
+      }
+    case COMPARE:
+    case AND:
+    case XOR:
+    case IOR:
+      {
+	/* add const,reg, add ea,reg, add reg, mem */
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (GET_CODE(b) == CONST_INT)
+	  {
+	    if (REG_P(a))
+	      {
+		*total = GET_MODE_SIZE(mode) > 2 ? (code == AND ? 14 : 16) : 8;
+		return true;
+	      }
+	    if (m68k_68000_10_costs (a, mode, code, 0, total, speed))
+	      {
+		*total += GET_MODE_SIZE(mode) > 2 ? 20 : 12;
+		return true;
+	      }
+	  }
+	else
+	if (REG_P(a))
+	  {
+	    if (m68k_68000_10_costs (b, mode, code, 1, total, speed))
+	      {
+		*total += GET_MODE_SIZE(mode) > 2 ? 4 : (code == XOR ? 8 : 6);
+		return true;
+	      }
+	  }
+	else
+	if (REG_P(b))
+	  if (m68k_68000_10_costs (a, mode, code, 1, total, speed))
+	    {
+	      *total += GET_MODE_SIZE(mode) > 2 ? 12 : 8;
+	      return true;
+	    }
+
+	if (m68k_68000_10_costs (a, mode, code, 0, total, speed)
+	    && m68k_68000_10_costs (b, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2 + GET_MODE_SIZE(mode) > 2 ? 4 : (code == XOR ? 8 : 6);
+	    return true;
+	  }
+	break;
+      }
+    case MEM:
+      {
+      /* simple but not exact */
+	rtx y = XEXP(x, 0);
+	int yc = GET_CODE(y);
+	if (yc == REG || yc == PRE_INC || yc == POST_INC || yc == POST_DEC || yc == PRE_DEC)
+	  *total = 4;
+	else if (yc == SYMBOL_REF || (yc == PLUS && GET_CODE(XEXP(y, 0)) == SYMBOL_REF))
+	  *total = 12;
+	else if (yc == PLUS && GET_CODE(XEXP(y, 0)) == PLUS)
+	  *total = 10;
+	else
+	  *total = 8;
+
+	if (mode != QImode && mode != HImode)
+	  *total += 4;
+
+	if (opno && yc == PRE_DEC)
+	  *total += 2;
+
+	return true;
+      }
+    default:
+      break;
+    }
+  return false;
+}
diff --git a/gcc/config/m68k/m68k_68020_costs.c b/gcc/config/m68k/m68k_68020_costs.c
new file mode 100644
index 00000000000..7f07febffba
--- /dev/null
+++ b/gcc/config/m68k/m68k_68020_costs.c
@@ -0,0 +1,324 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "cfghooks.h"
+#include "tree.h"
+#include "rtl.h"
+
+/**
+ * calculate costs for the 68020.
+ * opno == 1: calculate as if dst is a register
+ * opno == 0: calculate difference to register assignment
+ */
+bool
+m68k_68020_costs (rtx x, machine_mode mode, int outer_code, int opno,
+		  int *total, bool speed)
+{
+  int code = GET_CODE(x);
+  int total2 = 0;
+  *total = 0;
+  switch (code)
+    {
+    case CALL:
+      {
+	rtx a = XEXP(x, 0);
+	if (MEM_P(a))
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (REG_P(b) || GET_CODE(b) == PC)
+	      {
+		*total = 13;
+		return true;
+	      }
+	    if (GET_CODE(b) == PLUS)
+	      {
+		if (REG_P(XEXP(b, 0)))
+		  {
+		    *total = 15;
+		    return true;
+		  }
+	      }
+	    else if (SYMBOL_REF_P(b))
+	      {
+		tree decl = SYMBOL_REF_DECL(b);
+
+		*total = 13;
+		return true;
+	      }
+	  }
+	*total = 19;
+	return true;
+      }
+    case NE:
+    case EQ:
+    case GE:
+    case GT:
+    case LE:
+    case LT:
+    case GEU:
+    case GTU:
+    case LEU:
+    case LTU:
+      return m68k_68020_costs (XEXP(x, 0), mode, code, 0, total, speed);
+    case CONST:
+      {
+	rtx a = XEXP(x, 0);
+	if (GET_CODE(a) == PLUS)
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (GET_CODE(b) == SYMBOL_REF || GET_CODE(b) == LABEL_REF)
+	      {
+		*total = GET_MODE_SIZE(mode) > 2 ? 6 : 4;
+		return true;
+	      }
+	    *total = 9;
+	    return true;
+	  }
+      }
+      break;
+    case LABEL_REF:
+    case SYMBOL_REF:
+      *total = GET_MODE_SIZE(mode) > 2 ? 6 : 4;
+      return true;
+    case CONST_INT:
+      if (INTVAL(x) >= -128 && INTVAL(x) <= 127)
+	*total = 1;
+      else
+	*total = GET_MODE_SIZE(mode) > 2 ? 5 : 3;
+      return true;
+    case CONST_DOUBLE:
+      *total = GET_MODE_SIZE(mode) > 4 ? 10 : 5;
+      return true;
+    case POST_INC:
+      *total = 0;
+      return true;
+    case PRE_DEC:
+      *total = opno ? 1 : 3;
+      return true;
+    case REG:
+    case PC:
+      *total = 3;
+      return true;
+    case SUBREG:
+    case STRICT_LOW_PART:
+      *total = 0;
+      return true;
+    case SIGN_EXTRACT:
+    case ZERO_EXTRACT:
+      *total = 8;
+      return true;
+    case TRUNCATE:
+    case ZERO_EXTEND:
+      *total = GET_MODE_SIZE(mode) > 2 ? 5 : 3;
+      return true;
+    case NOT:
+    case NEG:
+      *total = 3;
+      return true;
+    case SIGN_EXTEND:
+      *total = 4;
+      return true;
+    case UDIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 79 : 44;
+      return true;
+    case MOD:
+    case DIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 91 : 57;
+      return true;
+    case MEM:
+      {
+	rtx a = XEXP(x, 0);
+	if (REG_P(a))
+	  {
+	    *total = opno ? 7 : 5;
+	    if (REGNO(a) < 8)
+	      *total += 5;
+	    return true;
+	  }
+	if (GET_CODE(a) == POST_INC)
+	  {
+	    *total = opno ? 7 : 5;
+	    return true;
+	  }
+	if (GET_CODE(a) == PRE_DEC)
+	  {
+	    *total = opno ? 8 : 6;
+	    return true;
+	  }
+	if (GET_CODE(a) == SYMBOL_REF || GET_CODE(a) == LABEL_REF)
+	  {
+	    *total = opno ? 10 : 9;
+	    return true;
+	  }
+	if (GET_CODE(a) == PLUS)
+	  {
+	    rtx b = XEXP(a, 0);
+	    rtx c = XEXP(a, 1);
+	    if (REG_P(b)
+		&& (GET_CODE(c) == CONST_INT || GET_CODE(c) == SYMBOL_REF))
+	      {
+		*total = opno ? 10 : 9;
+		if (REGNO(b) < 8)
+		  *total += 5;
+		return true;
+	      }
+	    if (REG_P(b) && REG_P(c))
+	      {
+		*total = opno ? 12 : 10;
+		return true;
+	      }
+	  }
+	*total = opno ? 15 : 13;
+	return true;
+      }
+      break;
+    case SET:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (REG_P(dst) || GET_CODE(dst) == CC0)
+	  {
+	    if (m68k_68020_costs (src, mode, code, 1, total, speed))
+	      return true;
+	  }
+	else if (m68k_68020_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68020_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2;
+	    if (!REG_P(dst))
+	      *total -= 3;
+	    return true;
+	  }
+      }
+      break;
+    case PLUS:
+    case MINUS:
+    case AND:
+    case IOR:
+    case XOR:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (m68k_68020_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68020_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2 + 2;
+	    if (REG_P(dst))
+	      *total -= REG_P(src) ? 5 : 2;
+	    return true;
+	  }
+      }
+      break;
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = 4;
+		return true;
+	      }
+	  }
+	*total = 6;
+	return true;
+      }
+      break;
+    case MULT:
+      {
+	/* umul, smul or call to __mulsi3? */
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+
+	if (GET_CODE(src) == CONST_INT)
+	  {
+	    unsigned i = INTVAL(src);
+	    int bits = 0, l = 0;
+	    if (i > 0)
+	      {
+		if (GET_CODE (dst) == ZERO_EXTEND || REG_P(dst))
+		  {
+		    while (i)
+		      {
+			if (i & 1)
+			  ++bits;
+			i >>= 1;
+		      }
+		    // it's a shift
+		    if (bits == 1 && REG_P(dst))
+		      {
+			*total = 4;
+			return true;
+		      }
+		  }
+		else
+		  // SIGN_EXTEND
+		  while (i || l)
+		    {
+		      if ((i & 1) != l)
+			{
+			  l = !l;
+			  ++bits;
+			}
+		      i >>= 1;
+		    }
+
+		*total = 12 + bits;
+		return true;
+	      }
+	  }
+
+	*total = GET_MODE_SIZE(mode) > 2 ? 44 : 28;
+	return true;
+      }
+      break;
+    case COMPARE:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = INTVAL(b) == 0 ? 0 : 1;
+		return true;
+	      }
+	    m68k_68020_costs (b, mode, code, 1, total, speed);
+	    *total += 3;
+	    return true;
+	  }
+	if (m68k_68020_costs (a, mode, code, 0, total, speed))
+	  {
+	    if (GET_CODE(b) == CONST_INT && INTVAL(b) == 0)
+	      return true;
+
+	    if (m68k_68020_costs (b, mode, code, 1, &total2, speed))
+	      {
+		*total += total2 + 3;
+		return true;
+	      }
+	  }
+      }
+      break;
+    case IF_THEN_ELSE:
+      *total = 7;
+      return true;
+    case FLOAT:
+    case FLOAT_TRUNCATE:
+    case FIX:
+      // maybe check for 68881?
+      *total = 4;
+      return true;
+    case ASM_OPERANDS:
+    case ASM_INPUT:
+      return false;
+    }
+  *total = 1;
+//  fprintf (stderr, "%d: ", outer_code);
+//  debug_rtx (x);
+  return true;
+}
diff --git a/gcc/config/m68k/m68k_68030_costs.c b/gcc/config/m68k/m68k_68030_costs.c
new file mode 100644
index 00000000000..7e14be58e11
--- /dev/null
+++ b/gcc/config/m68k/m68k_68030_costs.c
@@ -0,0 +1,324 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "cfghooks.h"
+#include "tree.h"
+#include "rtl.h"
+
+/**
+ * calculate costs for the 68030.
+ * opno == 1: calculate as if dst is a register
+ * opno == 0: calculate difference to register assignment
+ */
+bool
+m68k_68030_costs (rtx x, machine_mode mode, int outer_code, int opno,
+		  int *total, bool speed)
+{
+  int code = GET_CODE(x);
+  int total2 = 0;
+  *total = 0;
+  switch (code)
+    {
+    case CALL:
+      {
+	rtx a = XEXP(x, 0);
+	if (MEM_P(a))
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (REG_P(b) || GET_CODE(b) == PC)
+	      {
+		*total = 7;
+      return true;
+	      }
+	    if (GET_CODE(b) == PLUS)
+	      {
+		if (REG_P(XEXP(b, 0)))
+		  {
+		    *total = 9;
+		    return true;
+		  }
+	      }
+	    else if (SYMBOL_REF_P(b))
+	      {
+		tree decl = SYMBOL_REF_DECL(b);
+
+		*total = 7;
+		return true;
+	      }
+	  }
+	*total = 13;
+	return true;
+      }
+    case NE:
+    case EQ:
+    case GE:
+    case GT:
+    case LE:
+    case LT:
+    case GEU:
+    case GTU:
+    case LEU:
+    case LTU:
+      return m68k_68030_costs (XEXP(x, 0), mode, code, 0, total, speed);
+    case CONST:
+      {
+	rtx a = XEXP(x, 0);
+	if (GET_CODE(a) == PLUS)
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (GET_CODE(b) == SYMBOL_REF || GET_CODE(b) == LABEL_REF)
+	      {
+		*total = GET_MODE_SIZE(mode) > 2 ? 5 : 4;
+		return true;
+	      }
+	    *total = 7;
+	    return true;
+	  }
+      }
+      break;
+    case LABEL_REF:
+    case SYMBOL_REF:
+      *total = GET_MODE_SIZE(mode) > 2 ? 4 : 2;
+      return true;
+    case CONST_INT:
+      if (INTVAL(x) >= -128 && INTVAL(x) <= 127)
+	*total = 1;
+      else
+	*total = GET_MODE_SIZE(mode) > 2 ? 4 : 2;
+      return true;
+    case CONST_DOUBLE:
+      *total = GET_MODE_SIZE(mode) > 4 ? 8 : 4;
+      return true;
+    case POST_INC:
+      *total = 0;
+      return true;
+    case PRE_DEC:
+      *total = opno ? 0 : 2;
+      return true;
+    case REG:
+    case PC:
+      *total = 2;
+      return true;
+    case SUBREG:
+    case STRICT_LOW_PART:
+      *total = 0;
+      return true;
+    case SIGN_EXTRACT:
+    case ZERO_EXTRACT:
+      *total = 10;
+      return true;
+    case TRUNCATE:
+    case ZERO_EXTEND:
+      *total = GET_MODE_SIZE(mode) > 2 ? 4 : 2;
+      return true;
+    case NOT:
+    case NEG:
+      *total = 2;
+      return true;
+    case SIGN_EXTEND:
+      *total = 4;
+      return true;
+    case UDIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 79 : 44;
+      return true;
+    case MOD:
+    case DIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 90 : 56;
+      return true;
+    case MEM:
+      {
+	rtx a = XEXP(x, 0);
+	if (REG_P(a))
+	  {
+	    *total = opno ? 4 : 3;
+	    if (REGNO(a) < 8)
+	      *total += 5;
+	    return true;
+	  }
+	if (GET_CODE(a) == POST_INC)
+	  {
+	    *total = opno ? 4 : 3;
+	    return true;
+	  }
+	if (GET_CODE(a) == PRE_DEC)
+	  {
+	    *total = 4;
+	    return true;
+	  }
+	if (GET_CODE(a) == SYMBOL_REF || GET_CODE(a) == LABEL_REF)
+	  {
+	    *total = opno ? 10 : 9;
+	    return true;
+	  }
+	if (GET_CODE(a) == PLUS)
+	  {
+	    rtx b = XEXP(a, 0);
+	    rtx c = XEXP(a, 1);
+	    if (REG_P(b)
+		&& (GET_CODE(c) == CONST_INT || GET_CODE(c) == SYMBOL_REF))
+	      {
+		*total = opno ? 7 : 5;
+		if (REGNO(b) < 8)
+		  *total += 5;
+		return true;
+	      }
+	    if (REG_P(b) && REG_P(c))
+	      {
+		*total = opno ? 12 : 10;
+		return true;
+	      }
+	  }
+	*total = opno ? 15 : 13;
+	return true;
+      }
+      break;
+    case SET:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (REG_P(dst) || GET_CODE(dst) == CC0)
+		  {
+	    if (m68k_68030_costs (src, mode, code, 1, total, speed))
+		    return true;
+		  }
+	else if (m68k_68030_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68030_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2;
+	    if (!REG_P(dst))
+	      *total -= 2;
+	    return true;
+	  }
+      }
+      break;
+    case PLUS:
+    case MINUS:
+    case AND:
+    case IOR:
+    case XOR:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (m68k_68030_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68030_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2 + 2;
+	    if (REG_P(dst))
+	      *total -= REG_P(src) ? 4 : 2;
+	    return true;
+	  }
+      }
+      break;
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = 4;
+		return true;
+	      }
+	  }
+	*total = 6;
+	return true;
+      }
+      break;
+    case MULT:
+      {
+	/* umul, smul or call to __mulsi3? */
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+
+	if (GET_CODE(src) == CONST_INT)
+	  {
+	    unsigned i = INTVAL(src);
+	    int bits = 0, l = 0;
+	    if (i > 0)
+	      {
+		if (GET_CODE (dst) == ZERO_EXTEND || REG_P(dst))
+		  {
+		    while (i)
+		      {
+			if (i & 1)
+			  ++bits;
+			i >>= 1;
+		      }
+		    // it's a shift
+		    if (bits == 1 && REG_P(dst))
+		      {
+			*total = 4;
+			return true;
+		      }
+		  }
+		else
+		  // SIGN_EXTEND
+		  while (i || l)
+		    {
+		      if ((i & 1) != l)
+			{
+			  l = !l;
+			  ++bits;
+			}
+		      i >>= 1;
+		    }
+
+		*total = 12 + bits;
+		return true;
+	      }
+	  }
+
+	*total = GET_MODE_SIZE(mode) > 2 ? 44 : 28;
+	return true;
+      }
+      break;
+    case COMPARE:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = INTVAL(b) == 0 ? 0 : 1;
+		return true;
+	      }
+	    m68k_68030_costs (b, mode, code, 1, total, speed);
+	    *total += 2;
+	    return true;
+	  }
+	if (m68k_68030_costs (a, mode, code, 0, total, speed))
+	  {
+	    if (GET_CODE(b) == CONST_INT && INTVAL(b) == 0)
+	      return true;
+
+	    if (m68k_68030_costs (b, mode, code, 1, &total2, speed))
+	      {
+	    *total += total2 + 2;
+	    return true;
+	  }
+      }
+      }
+      break;
+    case IF_THEN_ELSE:
+      *total = 7;
+      return true;
+    case FLOAT:
+    case FLOAT_TRUNCATE:
+    case FIX:
+      // maybe check for 68881?
+      *total = 3;
+      return true;
+    case ASM_OPERANDS:
+    case ASM_INPUT:
+      return false;
+    }
+  *total = 1;
+//  fprintf (stderr, "%d: ", outer_code);
+//  debug_rtx (x);
+  return true;
+}
diff --git a/gcc/config/m68k/m68k_68040_costs.c b/gcc/config/m68k/m68k_68040_costs.c
new file mode 100644
index 00000000000..ebbbeb7637c
--- /dev/null
+++ b/gcc/config/m68k/m68k_68040_costs.c
@@ -0,0 +1,290 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "cfghooks.h"
+#include "tree.h"
+#include "rtl.h"
+
+/**
+ * calculate costs for the 68040.
+ * opno == 1: calculate as if dst is a register
+ * opno == 0: calculate difference to register assignment
+ */
+bool
+m68k_68040_costs (rtx x, machine_mode mode, int outer_code, int opno,
+		  int *total, bool speed)
+{
+  int code = GET_CODE(x);
+  int total2 = 0;
+  *total = 0;
+  switch (code)
+    {
+    case CALL:
+      {
+	rtx a = XEXP(x, 0);
+	if (MEM_P(a))
+	  {
+	    rtx b = XEXP(a, 0);
+	    if (REG_P(b) || GET_CODE(b) == PC)
+	      {
+		*total = 6;
+      return true;
+	      }
+	    if (GET_CODE(b) == PLUS)
+	      {
+		if (REG_P(XEXP(b, 0)))
+		  {
+		    *total = 8;
+		    return true;
+		  }
+	      }
+	    else if (SYMBOL_REF_P(b))
+	      {
+		tree decl = SYMBOL_REF_DECL(b);
+
+		*total = 6;
+      return true;
+	      }
+	  }
+	*total = 12;
+	return true;
+      }
+    case NE:
+    case EQ:
+    case GE:
+    case GT:
+    case LE:
+    case LT:
+    case GEU:
+    case GTU:
+    case LEU:
+    case LTU:
+      return m68k_68040_costs (XEXP(x, 0), mode, code, 0, total, speed);
+    case CONST:
+		*total = 1;
+		return true;
+	  break;
+    case LABEL_REF:
+    case SYMBOL_REF:
+      *total = 1;
+      return true;
+    case CONST_INT:
+      *total = 0;
+      return true;
+    case CONST_DOUBLE:
+      *total = GET_MODE_SIZE(mode) > 4 ? 2 : 1;
+      return true;
+    case POST_INC:
+      *total = 0;
+      return true;
+    case PRE_DEC:
+      *total = 0;
+      return true;
+    case REG:
+    case SUBREG:
+    case STRICT_LOW_PART:
+    case PC:
+      *total = 0;
+      return true;
+    case SIGN_EXTRACT:
+    case ZERO_EXTRACT:
+      *total = 4;
+      return true;
+    case TRUNCATE:
+    case ZERO_EXTEND:
+      *total = 1;
+      return true;
+    case NOT:
+    case NEG:
+    case SIGN_EXTEND:
+      *total = 1;
+      return true;
+    case UDIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 44 : 27;
+      return true;
+    case MOD:
+    case DIV:
+      *total = GET_MODE_SIZE(mode) > 2 ? 44 : 27;
+      return true;
+    case MEM:
+      {
+	rtx a = XEXP(x, 0);
+	if (REG_P(a))
+	  {
+	    *total = 1;
+	    return true;
+	  }
+	if (GET_CODE(a) == POST_INC)
+	  {
+	    *total = 1;
+	    return true;
+	  }
+	if (GET_CODE(a) == PRE_DEC)
+	  {
+	    *total = 1;
+	    return true;
+	  }
+	if (GET_CODE(a) == PLUS)
+	  {
+	    rtx b = XEXP(a, 0);
+	    rtx c = XEXP(a, 1);
+	    if (REG_P(b) && GET_CODE(c) == CONST_INT)
+	      {
+		*total = 1;
+		return true;
+	      }
+	    if (REG_P(b) && REG_P(c))
+	      {
+		*total = 1;
+		return true;
+	      }
+	  }
+	*total = 2;
+	return true;
+      }
+      break;
+    case SET:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (REG_P(dst) || GET_CODE(dst) == CC0)
+		  {
+	    if (m68k_68040_costs (src, mode, code, 1, total, speed))
+		    return true;
+		  }
+	else if (m68k_68040_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68040_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2;
+	    return true;
+	  }
+      }
+      break;
+    case PLUS:
+    case MINUS:
+    case AND:
+    case IOR:
+    case XOR:
+      {
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+	if (m68k_68040_costs (dst, mode, code, 0, total, speed)
+	    && m68k_68040_costs (src, mode, code, 1, &total2, speed))
+	  {
+	    *total += total2;
+	    return true;
+	  }
+      }
+      break;
+    case ASHIFT:
+    case ASHIFTRT:
+    case LSHIFTRT:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = 3;
+		return true;
+	      }
+	  }
+	*total = 4;
+	return true;
+      }
+      break;
+    case MULT:
+      {
+	/* umul, smul or call to __mulsi3? */
+	rtx dst = XEXP(x, 0);
+	rtx src = XEXP(x, 1);
+
+	if (GET_CODE(src) == CONST_INT)
+	  {
+	    unsigned i = INTVAL(src);
+	    int bits = 0, l = 0;
+	    if (i > 0)
+	      {
+		if (GET_CODE (dst) == ZERO_EXTEND || REG_P(dst))
+		  {
+		    while (i)
+		      {
+			if (i & 1)
+			  ++bits;
+			i >>= 1;
+	  }
+		    // it's a shift
+		    if (bits == 1 && REG_P(dst))
+	  {
+			*total = 3;
+			return true;
+		      }
+		  }
+		else
+		  // SIGN_EXTEND
+		  while (i || l)
+		    {
+		      if ((i & 1) != l)
+			{
+			  l = !l;
+			  ++bits;
+			}
+		      i >>= 1;
+		    }
+
+		*total = 12 + (bits>>2);
+	    return true;
+	  }
+      }
+
+	*total = GET_MODE_SIZE(mode) > 2 ? 20 : 16;
+	return true;
+      }
+      break;
+    case COMPARE:
+      {
+	rtx a = XEXP(x, 0);
+	rtx b = XEXP(x, 1);
+	if (REG_P(a))
+	  {
+	    if (GET_CODE(b) == CONST_INT)
+	      {
+		*total = 0;
+		return true;
+	      }
+	    m68k_68040_costs (b, mode, code, 1, total, speed);
+	    return true;
+	  }
+	if (m68k_68040_costs (a, mode, code, 0, total, speed))
+	  {
+	    if (GET_CODE(b) == CONST_INT && INTVAL(b) == 0)
+	      return true;
+
+	    if (m68k_68040_costs (b, mode, code, 1, &total2, speed))
+	      {
+	    *total += total2;
+	    return true;
+	  }
+      }
+      }
+      break;
+    case IF_THEN_ELSE:
+      *total = 3;
+      return true;
+    case FLOAT:
+    case FLOAT_TRUNCATE:
+    case FIX:
+      // maybe check for 68881?
+      *total = 2;
+      return true;
+    case ASM_OPERANDS:
+    case ASM_INPUT:
+      return false;
+    }
+  *total = 1;
+//  fprintf (stderr, "%d: ", outer_code);
+//  debug_rtx (x);
+  return true;
+}
diff --git a/gcc/config/m68k/m68kamigaos.h b/gcc/config/m68k/m68kamigaos.h
new file mode 100644
index 00000000000..3e9b08b3bd1
--- /dev/null
+++ b/gcc/config/m68k/m68kamigaos.h
@@ -0,0 +1,802 @@
+/* m68kelf support, derived from m68kv4.h */
+
+/* Target definitions for GNU compiler for mc680x0 running AmigaOs
+   Copyright (C) 1991-2016 Free Software Foundation, Inc.
+
+   Written by Ron Guilmette (rfg@netcom.com) and Fred Fish (fnf@cygnus.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef TARGET_AMIGA
+#define TARGET_AMIGA 1
+#endif
+
+#define HAS_INIT_SECTION
+
+#ifndef SWBEG_ASM_OP
+#define SWBEG_ASM_OP "\t.swbeg\t"
+#endif
+
+#ifdef TARGET_AMIGAOS_VASM
+#undef ASM_STABS_OP
+#define  ASM_STABS_OP "|\t.stabs\t"
+
+#undef ASM_STABD_OP
+#define ASM_STABD_OP "|\t.stabd\t"
+
+#undef ASM_STABN_OP
+#define ASM_STABN_OP "|\t.stabn\t"
+#endif
+
+#undef PIC_REG
+#define PIC_REG 12
+
+#undef FRAME_POINTER_REGNUM
+#define FRAME_POINTER_REGNUM 13
+
+#undef M68K_REGNAME
+#define M68K_REGNAME(r) ( \
+  ( ((r) == FRAME_POINTER_REGNUM) \
+    && frame_pointer_needed) ? \
+    M68K_FP_REG_NAME : reg_names[(r)])
+
+
+
+/* Here are three prefixes that are used by asm_fprintf to
+   facilitate customization for alternate assembler syntaxes.
+   Machines with no likelihood of an alternate syntax need not
+   define these and need not use asm_fprintf.  */
+
+/* The prefix for register names.  Note that REGISTER_NAMES
+   is supposed to include this prefix. Also note that this is NOT an
+   fprintf format string, it is a literal string */
+
+#undef REGISTER_PREFIX
+#define REGISTER_PREFIX ""
+
+/* The prefix for local (compiler generated) labels.
+   These labels will not appear in the symbol table.  */
+
+#undef LOCAL_LABEL_PREFIX
+#ifndef TARGET_AMIGAOS_VASM
+#define LOCAL_LABEL_PREFIX "."
+#else
+#define LOCAL_LABEL_PREFIX "_."
+#endif
+
+/* The prefix to add to user-visible assembler symbols.  */
+
+#undef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX "_"
+
+/* config/m68k.md has an explicit reference to the program counter,
+   prefix this by the register prefix.  */
+
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_RETURN_CASE_JUMP \
+  do { \
+      return "jmp %%pc@(2,%0:w)"; \
+  } while (0)
+#else
+#define ASM_RETURN_CASE_JUMP \
+  do { \
+     return "jmp (2,pc,%0.w)"; \
+  } while (0)
+#endif
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+
+#ifndef TARGET_AMIGAOS_VASM
+#ifndef ALIGN_ASM_OP
+#define ALIGN_ASM_OP "\t.align\t"
+#endif
+#else
+#define ALIGN_ASM_OP "\talign\t"
+#endif
+
+#undef ASM_OUTPUT_ALIGN
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_OUTPUT_ALIGN(FILE,LOG) \
+do { \
+  if ((LOG) > 0) \
+    fprintf ((FILE), "%s%u\n", ALIGN_ASM_OP, 1 << (LOG)); \
+} while (0)
+#else
+#define ASM_OUTPUT_ALIGN(FILE,LOG) \
+do { \
+  if ((LOG) > 0) \
+    fprintf ((FILE), "%s%u\n", ALIGN_ASM_OP, (LOG)); \
+} while (0)
+#endif
+
+#if 0
+extern int amiga_declare_object;
+
+#define ASM_DECLARE_OBJECT_NAME(FILE,NAME,DECL) \
+if (!DECL_INITIAL (DECL) || \
+    initializer_zerop (DECL_INITIAL (decl))) \
+  { \
+    amiga_declare_object = 1; \
+    fprintf ((FILE), ".comm\t%s,", NAME); \
+  } \
+else \
+ASM_OUTPUT_LABEL (FILE, NAME)
+
+#undef ASM_OUTPUT_SKIP
+#define ASM_OUTPUT_SKIP(FILE,SIZE) \
+if (amiga_declare_object) \
+  fprintf (FILE, "%u\n", (int)(SIZE)); \
+else \
+  fprintf (FILE, "\t.skip %u\n", (int)(SIZE)); \
+amiga_declare_object = 0
+#endif
+
+/* Register in which address to store a structure value is passed to a
+   function.  The default in m68k.h is a1.  For m68k/SVR4 it is a0.  */
+
+#undef M68K_STRUCT_VALUE_REGNUM
+#define M68K_STRUCT_VALUE_REGNUM A0_REG
+
+/* The static chain regnum defaults to a0, but we use that for
+   structure return, so have to use a1 for the static chain.  */
+
+#undef STATIC_CHAIN_REGNUM
+#define STATIC_CHAIN_REGNUM A1_REG
+#undef M68K_STATIC_CHAIN_REG_NAME
+#define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a1"
+
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_COMMENT_START "|"
+#else
+#define ASM_COMMENT_START "|"
+#endif
+
+/* Define how the m68k registers should be numbered for Dwarf output.
+   The numbering provided here should be compatible with the native
+   SVR4 SDB debugger in the m68k/SVR4 reference port, where d0-d7
+   are 0-7, a0-a8 are 8-15, and fp0-fp7 are 16-23.  */
+
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
+
+#if 0
+/* SVR4 m68k assembler is bitching on the `comm i,1,1' which askes for
+   1 byte alignment. Don't generate alignment for COMMON seems to be
+   safer until we the assembler is fixed.  */
+#undef ASM_OUTPUT_ALIGNED_COMMON
+/* Same problem with this one.  */
+#undef ASM_OUTPUT_ALIGNED_LOCAL
+#endif
+
+#undef ASM_OUTPUT_COMMON
+#undef ASM_OUTPUT_LOCAL
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \
+( fputs (".comm ", (FILE)), \
+  assemble_name ((FILE), (NAME)), \
+  fprintf ((FILE), ",%u\n", (int)(SIZE)))
+#else
+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \
+  ( switch_to_section (bss_section), \
+  fputs ("|.comm\n\tcnop 0,4\n", (FILE)), \
+  assemble_name ((FILE), (NAME)), \
+  fprintf ((FILE), ":\n\tds.b %u\n", (int)(SIZE)), \
+  fputs ("\txdef ", (FILE)), \
+  assemble_name ((FILE), (NAME)), \
+  fprintf ((FILE), "\n"))
+#endif
+
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \
+( fputs (".lcomm ", (FILE)), \
+  assemble_name ((FILE), (NAME)), \
+  fprintf ((FILE), ",%u\n", (int)(SIZE)))
+#else
+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \
+( switch_to_section (bss_section), \
+  fputs ("|.lcomm\n\tcnop 0,4\n", (FILE)), \
+  assemble_name ((FILE), (NAME)), \
+  fprintf ((FILE), ":\n\tds.b %u\n", (int)(SIZE)))
+#endif
+
+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to
+   keep switch tables in the text section.  */
+
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+
+/* In m68k svr4, using swbeg is the standard way to do switch
+   table.  */
+#undef ASM_OUTPUT_BEFORE_CASE_LABEL
+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \
+  fprintf ((FILE), "%s&%d\n", SWBEG_ASM_OP, XVECLEN (PATTERN (TABLE), 1));
+/* end of stuff from m68kv4.h */
+
+#ifndef TARGET_AMIGAOS_VASM
+#undef BSS_SECTION_ASM_OP
+#define BSS_SECTION_ASM_OP    "\t.bss"
+#else
+#define BSS_SECTION_ASM_OP    (!flag_pic?"\tsection\t.bss,bss":"\tsection\t.bss_near,bss")
+#endif
+
+#ifndef TARGET_AMIGAOS_VASM
+#undef DATA_SECTION_ASM_OP
+#define DATA_SECTION_ASM_OP    "\t.data"
+#else
+#define DATA_SECTION_ASM_OP    (!flag_pic?"\tsection\t.data,data":"\tsection\t.data_near,data")
+#endif
+
+#ifndef ASM_OUTPUT_ALIGNED_BSS
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+#endif
+
+
+/* Specs, switches.  */
+
+/* amiga/amigaos are the new "standard" defines for the Amiga.
+   MCH_AMIGA, AMIGA, __chip etc. are used in other compilers and are
+   provided for compatibility reasons.
+   When creating shared libraries, use different 'errno'.  */
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS() \
+  do \
+    { \
+      builtin_define ("__entrypoint=__attribute__((__entrypoint__))"); \
+      builtin_define ("__saveallregs=__attribute__((__saveallregs__))");\
+      builtin_define ("__chip=__attribute__((__chip__))"); \
+      builtin_define ("__fast=__attribute__((__fast__))"); \
+      builtin_define ("__far=__attribute__((__far__))"); \
+      builtin_define ("__saveds=__attribute__((__saveds__))"); \
+      builtin_define ("__interrupt=__attribute__((__interrupt__))"); \
+      builtin_define ("__stackext=__attribute__((__stackext__))"); \
+      builtin_define ("__regargs=__attribute__((__regparm__(2)))"); \
+      builtin_define ("__stdargs=__attribute__((__stkparm__))"); \
+      builtin_define ("__aligned=__attribute__((__aligned__(4)))"); \
+      builtin_define_std ("amiga"); \
+      builtin_define_std ("amigaos"); \
+      builtin_define_std ("AMIGA"); \
+      builtin_define_std ("MCH_AMIGA"); \
+      builtin_assert ("system=amigaos"); \
+      if (flag_pic > 2) \
+    { \
+      builtin_define ("__baserel__"); \
+      if (flag_pic > 3) \
+        builtin_define ("__baserel32__"); \
+    } \
+      if (flag_resident) \
+    builtin_define ("__resident__"); \
+    } \
+  while (0)
+
+#if 0
+if (target_flags & (MASK_RESTORE_A4|MASK_ALWAYS_RESTORE_A4)) \
+  builtin_define ("errno=(*ixemul_errno)"); \
+
+#endif
+
+/* put return values in FPU build in FP0 Reg */
+#undef FUNCTION_VALUE_REGNO_P
+#define FUNCTION_VALUE_REGNO_P(N) \
+  ((N) == D0_REG || (TARGET_68881 && (N) == FP0_REG))
+
+// see 930623-1.c
+//  ((N) == D0_REG || (N) == A0_REG || (TARGET_68881 && (N) == FP0_REG))
+
+
+/* When creating shared libraries, use different 'errno'. */
+#define CPP_IXEMUL_SPEC \
+  "%{!ansi:-Dixemul} -D__ixemul__ -D__ixemul " \
+  "%{malways-restore-a4:-Derrno=(*ixemul_errno)} " \
+  "%{mrestore-a4:-Derrno=(*ixemul_errno)}"
+#define CPP_LIBNIX_SPEC \
+  "-isystem %:sdk_root(libnix/include) " \
+  "%{!ansi:-Dlibnix} -D__libnix__ -D__libnix " \
+  "%{mcrt=nix13:-D__KICK13__}"
+#define CPP_CLIB2_SPEC \
+  "-isystem %:sdk_root(clib2/include) " \
+  "%{!ansi:-DCLIB2} -D__CLIB2__ -D__CLIB2"
+
+/* Define __HAVE_68881__ in preprocessor according to the -m flags.
+   This will control the use of inline 68881 insns in certain macros.
+   Note: it should be set in TARGET_CPU_CPP_BUILTINS but TARGET_68881
+         isn't the same -m68881 since its also true for -m680[46]0 ...
+   Differentiate between libnix and ixemul.  */
+
+#define CPP_SPEC \
+  "%{m68881:-D__HAVE_68881__} " \
+  "%{!ansi:" \
+    "%{m68020:-Dmc68020} " \
+    "%{mc68020:-Dmc68020} " \
+    "%{m68020-40:-Dmc68020} " \
+    "%{m68020-60:-Dmc68020} " \
+    "%{m68030:-Dmc68030} " \
+    "%{m68040:-Dmc68040} " \
+    "%{m68060:-Dmc68060}} " \
+  "%{m68020:-D__mc68020__ -D__mc68020} " \
+  "%{mc68020:-D__mc68020__ -D__mc68020} " \
+  "%{m68020-40:-D__mc68020__ -D__mc68020} " \
+  "%{m68020-60:-D__mc68020__ -D__mc68020} " \
+  "%{m68030:-D__mc68030__ -D__mc68030} " \
+  "%{m68040:-D__mc68040__ -D__mc68040} " \
+  "%{m68060:-D__mc68060__ -D__mc68060} " \
+  "-isystem %:sdk_root(../include) " \
+  "%{mcrt=nix13:-isystem %:sdk_root(ndk13-include)} " \
+  "%{noixemul:%(cpp_libnix)} " \
+  "%{mcrt=nix*:%(cpp_libnix)} " \
+  "%{mcrt=ixemul:%(cpp_ixemul)} " \
+  "%{mcrt=clib2:%(cpp_clib2)}"
+
+/* Various -m flags require special flags to the assembler.  */
+
+#undef ASM_SPEC
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_SPEC \
+   "%(asm_cpu) %(asm_cpu_default) %{msmall-code:-sc} "
+#else
+#define ASM_SPEC \
+   "-gas -esc -ldots -Fhunk -quiet %(asm_cpu) %(asm_cpu_default) %{msmall-code:-sc}"
+#endif
+
+#undef ASM_CPU_SPEC
+#define ASM_CPU_SPEC \
+  "%{mcpu=*:-m%*} " \
+  "%{m68000|mc68000:-m68010} " \
+  "%{m6802*|mc68020:-m68020} " \
+  "%{m68030} " \
+  "%{m68040} " \
+  "%{m68060}"
+
+#ifndef TARGET_AMIGAOS_VASM
+#define ASM_CPU_DEFAULT_SPEC \
+   "%{!m680*:%{!mc680*:%{!mcpu=*:-m68000}}}"
+#else
+#define ASM_CPU_DEFAULT_SPEC \
+   "%{!m680*:%{!mc680*:-m68000}}"
+#endif
+
+/* Choose the right startup file, depending on whether we use base relative
+   code, base relative code with automatic relocation (-resident), their
+   32-bit versions, libnix, profiling or plain crt0.o.  */
+
+#define STARTFILE_IXEMUL_SPEC \
+  "%{fbaserel:%{!resident:bcrt0.o%s}}" \
+  "%{resident:rcrt0.o%s}" \
+  "%{fbaserel32:%{!resident32:lcrt0.o%s}}" \
+  "%{resident32:scrt0.o%s}" \
+  "%{!resident:%{!fbaserel:%{!resident32:%{!fbaserel32:" \
+    "%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}}}"
+
+#define STARTFILE_LIBNIX_SPEC \
+  "%{ramiga-*:" \
+    "%{ramiga-lib:libinit.o%s}" \
+    "%{ramiga-libr:libinitr.o%s}" \
+    "%{ramiga-dev:devinit.o%s}}" \
+  "%{!ramiga-*:" \
+    "%{resident:nrcrt0.o%s}" \
+    "%{!resident:" \
+      "%{fbaserel:nbcrt0.o%s}" \
+      "%{!fbaserel:" \
+    "%{fbaserel32:nlbcrt0.o%s}" \
+    "%{!fbaserel32:ncrt0.o%s}}}}"
+
+#define STARTFILE_CLIB2_SPEC \
+  "%{resident32:nr32crt0.o%s}" \
+  "%{!resident32:" \
+    "%{fbaserel32:nb32crt0.o%s}" \
+    "%{!fbaserel32:" \
+      "%{resident:nrcrt0.o%s}" \
+      "%{!resident:" \
+        "%{fbaserel:nbcrt0.o%s}" \
+        "%{!fbaserel:ncrt0.o%s}}}}"
+
+#define STARTFILE_NEWLIB_SPEC \
+    "%{m6802*|mc6802*|m6803*|m6804*|m6806*|m6808*|mcpu=6802*|mcpu=6803*|mcpu=6804*|mcpu=6806*|mcpu=6808*:" \
+        "%{fbaserel32:libm020/libb32/crt0.o%s}" \
+      "%{!fbaserel32:" \
+              "%{fbaserel:libm020/libb/crt0.o%s}" \
+            "%{!fbaserel:libm020/crt0.o%s}}" \
+      "}" \
+    "%{m6800*|mc6800*|m6801*|mcpu=6800*|mcpu=6801*:" \
+          "%{fbaserel:libb/crt0.o%s}" \
+          "%{!fbaserel:crt0.o%s}" \
+    "}"
+
+#define SELF_SPEC \
+ "%{noixemul:-B %:sdk_root(libnix/lib/)} " \
+ "%{mcrt=nix*:-B %:sdk_root(libnix/lib/)} " \
+ "%{mcrt=clib2:-B %:sdk_root(clib2/lib/)} "
+
+#undef    STARTFILE_SPEC
+#ifdef TARGET_AMIGAOS_VASM
+#define STARTFILE_SPEC \
+   "startup%O%s"
+#else
+#define STARTFILE_SPEC \
+  "%{noixemul:%(startfile_libnix)} " \
+  "%{mcrt=nix*:%(startfile_libnix)} " \
+  "%{mcrt=ixemul:%(startfile_ixemul)} " \
+  "%{mcrt=clib2:%(startfile_clib2)} " \
+  "%{!mcrt=*:%{!noixemul:%(startfile_newlib)}} "
+#endif
+
+#define ENDFILE_IXEMUL_SPEC ""
+#define ENDFILE_LIBNIX_SPEC "-lstubs"
+#define ENDFILE_CLIB2_SPEC ""
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{noixemul:%(endfile_libnix)} " \
+  "%{mcrt=nix*:%(endfile_libnix)} " \
+  "%{mcrt=ixemul:%(endfile_ixemul)} " \
+  "%{mcrt=clib2:%(endfile_clib2)}"
+
+
+/* Automatically search libamiga.a for AmigaOS specific functions.  Note
+   that we first search the standard C library to resolve as much as
+   possible from there, since it has names that are duplicated in libamiga.a
+   which we *don't* want from there.  Then search libamiga.a for any calls
+   that were not generated inline, and finally search the standard C library
+   again to resolve any references that libamiga.a might have generated.
+   This may only be a temporary solution since it might be better to simply
+   remove the things from libamiga.a that should be pulled in from libc.a
+   instead, which would eliminate the first reference to libc.a.  Note that
+   if we don't search it automatically, it is very easy for the user to try
+   to put in a -lamiga himself and get it in the wrong place, so that (for
+   example) calls like sprintf come from -lamiga rather than -lc. */
+
+#define LIB_IXEMUL_SPEC \
+  "%{!p:%{!pg:-lc -lamiga -lc}} " \
+  "%{p:-lc_p} %{pg:-lc_p}"
+#define LIB_LIBNIX_SPEC \
+  "%{mcrt=*:-l%*} " \
+  "-lnixmain " \
+  "%{!mcrt=*:-lnix20 -lnix} " \
+  "%{mstackcheck:-lstack} " \
+  "%{mstackextend:-lstack}"
+#define LIB_CLIB2_SPEC \
+  "-lc -lamiga -ldebug " \
+  "%{mstackcheck:-lstack} " \
+  "%{mstackextend:-lstack}"
+
+#define LIB_NEWLIB_SPEC \
+  "-lc -lamiga"
+
+#ifdef TARGET_AMIGAOS_VASM
+#define LIB_SPEC \
+  "-lvc -lamiga "
+#else
+#define LIB_SPEC \
+  "%{noixemul:%(lib_libnix)} " \
+  "%{mcrt=nix*:%(lib_libnix)} " \
+  "%{mcrt=ixemul:%(lib_ixemul)} " \
+  "%{mcrt=clib2:%(lib_clib2)} " \
+  "%{!mcrt=*:%{!noixemul:%(lib_newlib)}} "
+#endif
+
+#define LIBGCC_IXEMUL_SPEC ""
+#define LIBGCC_LIBNIX_SPEC \
+  "-lstubs " \
+  "-lamiga " \
+  "%{mcrt=*:-l%*}" \
+  "%{!mcrt=*:-lnix20} " \
+   "-lnix " \
+  "%{mcrt=nix20:-lnix20 -lstubs} " \
+  "%{!mcrt=*:-lnix20 -lstubs} "
+
+#define LIBGCC_CLIB2_SPEC "-lc"
+#define LIBGCC_SPEC "-lgcc " \
+  "%{noixemul:%(libgcc_libnix)} " \
+  "%{mcrt=nix*:%(libgcc_libnix)} " \
+  "%{mcrt=ixemul:%(libgcc_ixemul)} " \
+  "%{mcrt=clib2:%(libgcc_clib2)} " \
+  "%{!mcrt=*:%{!noixemul:-lc -lstubs}} " \
+  "%{lm:-lm} "
+
+/* If debugging, tell the linker to output amiga-hunk symbols *and* a BSD
+   compatible debug hunk.
+   Also, pass appropriate linker flavours depending on user-supplied
+   commandline options.  */
+
+#define LINK_IXEMUL_SPEC ""
+#define LINK_LIBNIX_SPEC "-L%:sdk_root(libnix/lib)"
+#define LINK_CLIB2_SPEC "-L%:sdk_root(clib2/lib)"
+
+/* If debugging, tell the linker to output amiga-hunk symbols *and* a BSD
+   compatible debug hunk.
+   Also, pass appropriate linker flavours depending on user-supplied
+   commandline options.  */
+
+#ifdef TARGET_AMIGAOS_VASM
+#define LINK_SPEC \
+  "%{mcpu=68020:-fl libm020} " \
+  "%{m68020:-fl libm020} " \
+  "%{mc68020:-fl libm020} " \
+  "%{m68030:-fl libm020} " \
+  "%{m68040:-fl libm020} " \
+  "%{m68060:-fl libm020} " \
+  "%{m68020-40:-fl libm020} " \
+  "%{m68020-60:-fl libm020} " \
+  "%{noixemul:%(link_libnix)} " \
+  "%{mcrt=nix*:%(link_libnix)} " \
+  "%{mcrt=ixemul:%(link_ixemul)} " \
+  "%{mcrt=clib2:%(link_clib2)} " \
+  "%{fbaserel:%{!resident:-m amiga_bss -fl libb}} " \
+  "%{resident:-m amiga_bss -amiga-datadata-reloc -fl libb} " \
+  "%{fbaserel32:%{!resident32:-m amiga_bss -fl libb32}} " \
+  "%{resident32:-m amiga_bss -amiga-datadata-reloc -fl libb32} " \
+  "%{m68881:-fl libm881}"
+#else
+#define LINK_SPEC \
+  "-L%:sdk_root(../lib) " \
+  "%(link_cpu) " \
+  "%{noixemul:%(link_libnix)} " \
+  "%{mcrt=nix*:%(link_libnix)} " \
+  "%{mcrt=ixemul:%(link_ixemul)} " \
+  "%{mcrt=clib2:%(link_clib2)} " \
+  "%{fbaserel:%{!resident:-m amiga_bss -fl libb}} " \
+  "%{resident:-m amiga_bss -amiga-datadata-reloc -fl libb} " \
+  "%{fbaserel32:%{!resident32:-m amiga_bss -fl libb32}} " \
+  "%{resident32:-m amiga_bss -amiga-datadata-reloc -fl libb32} " \
+  "%{g:-amiga-debug-hunk} " \
+  "%{m68881:-fl libm881}"
+#endif
+
+/* Translate '-resident' to '-fbaserel' (they differ in linking stage only).
+   Don't put function addresses in registers for PC-relative code.  */
+
+#define CC1_SPEC \
+  "%{resident:-fbaserel} " \
+  "%{resident32:-fbaserel32} " \
+  "%{msmall-code:-fno-function-cse}"
+
+#define LINK_CPU_SPEC \
+  "%{m6802*|mc6802*|m6803*|m6804*|m6806*|m6808*|mcpu=6802*|mcpu=6803*|mcpu=6804*|mcpu=6806*|mcpu=6808*:-fl libm020} " \
+  "%{m68881:-fl libm881}"
+
+/* [cahirwpz] A modified copy of LINK_COMMAND_SPEC from gcc/gcc.c file.
+   Don't prepend libgcc.a to link libraries and make sure the options is
+   at the end of command line. Otherwise linker chooses generic functions
+   from libgcc.a instead AmigaOS-specific counterparts from libnix.a. */
+
+#ifdef TARGET_AMIGAOS_VASM
+#define LINK_COMMAND_SPEC \
+  "%{!fsyntax-only:" \
+    "%{!c:" \
+      "%{!M:" \
+    "%{!MM:" \
+      "%{!E:" \
+        "%{!S:" \
+          "%(linker) -Cvbcc %l %X %{o*} %{A} %{d} %{e*} %{m} " \
+          "%{N} %{n} %{r} %{s} %{t} %{u*} %{x} %{z} %{Z} " \
+          "%{!A:%{!nostdlib:%{!nostartfiles:%S}}} " \
+          "%{static:} %{L*} %D %o " \
+          "%{!nostdlib:%{!nodefaultlibs:%L}} " \
+          "%{!A:%{!nostdlib:%{!nostartfiles:%E}}} " \
+          "%{!nostdlib:%{!nodefaultlibs:%G}} " \
+          "%{flto} " \
+          "%{T*} }}}}}} "
+#else
+#define LINK_COMMAND_SPEC \
+  "%{!fsyntax-only:" \
+    "%{!c:" \
+      "%{!M:" \
+    "%{!MM:" \
+      "%{!E:" \
+        "%{!S:" \
+          "%(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} " \
+          "%{N} %{n} %{r} %{s} %{t} %{u*} %{x} %{z} %{Z} " \
+          "%{!A:%{!nostdlib:%{!nostartfiles:%S}}} " \
+          "%{static:} %{L*} %D %o " \
+          "%{!nostdlib:%{!nodefaultlibs:%L}} " \
+          "%{!A:%{!nostdlib:%{!nostartfiles:%E}}} " \
+          "%{!nostdlib:%{!nodefaultlibs:%G}} " \
+              "%{flto} " \
+          "%{T*} }}}}}} "
+#endif
+
+extern const char * amiga_m68k_prefix_func(int, const char **);
+
+#define EXTRA_SPEC_FUNCTIONS \
+  { "sdk_root", amiga_m68k_prefix_func },
+
+/* This macro defines names of additional specifications to put in the specs
+   that can be used in various specifications like CC1_SPEC.  Its definition
+   is an initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   specification name, and a string constant that used by the GCC driver
+   program.
+
+   Do not define this macro if it does not need to do anything.  */
+#undef EXTRA_SPECS
+#define EXTRA_SPECS \
+  {"asm_cpu", ASM_CPU_SPEC }, \
+  {"asm_cpu_default", ASM_CPU_DEFAULT_SPEC }, \
+  {"link_cpu", LINK_CPU_SPEC }, \
+  {"cpp_ixemul", CPP_IXEMUL_SPEC}, \
+  {"cpp_libnix", CPP_LIBNIX_SPEC}, \
+  {"cpp_clib2", CPP_CLIB2_SPEC}, \
+  {"lib_ixemul", LIB_IXEMUL_SPEC}, \
+  {"lib_newlib", LIB_NEWLIB_SPEC}, \
+  {"lib_libnix", LIB_LIBNIX_SPEC}, \
+  {"lib_clib2", LIB_CLIB2_SPEC}, \
+  {"link_ixemul", LINK_IXEMUL_SPEC}, \
+  {"link_libnix", LINK_LIBNIX_SPEC}, \
+  {"link_clib2", LINK_CLIB2_SPEC}, \
+  {"startfile_ixemul", STARTFILE_IXEMUL_SPEC}, \
+  {"startfile_libnix", STARTFILE_LIBNIX_SPEC}, \
+  {"startfile_clib2", STARTFILE_CLIB2_SPEC}, \
+  {"startfile_newlib", STARTFILE_NEWLIB_SPEC}, \
+  {"endfile_ixemul", ENDFILE_IXEMUL_SPEC}, \
+  {"endfile_libnix", ENDFILE_LIBNIX_SPEC}, \
+  {"endfile_clib2", ENDFILE_CLIB2_SPEC}, \
+  {"libgcc_ixemul", LIBGCC_IXEMUL_SPEC}, \
+  {"libgcc_libnix", LIBGCC_LIBNIX_SPEC}, \
+  {"libgcc_clib2", LIBGCC_CLIB2_SPEC}
+
+/* begin-GG-local: dynamic libraries */
+
+extern int amigaos_do_collecting (void);
+extern void amigaos_gccopts_hook (const char *);
+extern void amigaos_libname_hook (const char* arg);
+extern void amigaos_collect2_cleanup (void);
+extern void amigaos_prelink_hook (const char **, int *);
+extern void amigaos_postlink_hook (const char *);
+
+/* This macro is used to check if all collect2 facilities should be used.
+   We need a few special ones, like stripping after linking.  */
+
+#define DO_COLLECTING (do_collecting || amigaos_do_collecting())
+
+/* This macro is called in collect2 for every GCC argument name.
+   ARG is a part of commandline (without '\0' at the end).  */
+
+#define COLLECT2_GCC_OPTIONS_HOOK(ARG) amigaos_gccopts_hook(ARG)
+
+/* This macro is called in collect2 for every ld's "-l" or "*.o" or "*.a"
+   argument.  ARG is a complete argument, with '\0' at the end.  */
+
+#define COLLECT2_LIBNAME_HOOK(ARG) amigaos_libname_hook(ARG)
+
+/* This macro is called at collect2 exit, to clean everything up.  */
+
+#define COLLECT2_EXTRA_CLEANUP amigaos_collect2_cleanup
+
+/* This macro is called just before the first linker invocation.
+   LD1_ARGV is "char** argv", which will be passed to "ld".  STRIP is an
+   *address* of "strip_flag" variable.  */
+
+#define COLLECT2_PRELINK_HOOK(LD1_ARGV, STRIP) \
+amigaos_prelink_hook((const char **)(LD1_ARGV), (STRIP))
+
+/* This macro is called just after the first linker invocation, in place of
+   "nm" and "ldd".  OUTPUT_FILE is the executable's filename.  */
+
+#define COLLECT2_POSTLINK_HOOK(OUTPUT_FILE) amigaos_postlink_hook(OUTPUT_FILE)
+/* end-GG-local */
+
+#define USE_COLLECT2
+
+#undef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT ((1 << 15)*BITS_PER_UNIT)
+
+#undef FIXED_INCLUDE_DIR
+#define FIXED_INCLUDE_DIR CROSS_INCLUDE_DIR "/../ndk-include"
+
+// this disables tree_loop_distribute_patterns
+#define C_COMMON_OVERRIDE_OPTIONS  flag_no_builtin = 1
+/* Baserel support.  */
+
+extern int amiga_is_const_pic_ref(const_rtx x);
+
+#undef CONSTANT_ADDRESS_P
+#define CONSTANT_ADDRESS_P(X) \
+((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF \
+ || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST \
+ || GET_CODE (X) == HIGH \
+ ))
+
+
+
+/* Given that symbolic_operand(X), return TRUE if no special
+   base relative relocation is necessary */
+
+#undef LEGITIMATE_PIC_OPERAND_P
+#define LEGITIMATE_PIC_OPERAND_P(X) ( \
+    (! symbolic_operand (X, VOIDmode) && \
+    ! amiga_is_const_pic_ref(X))) \
+    || amiga_is_far_symbol(X)
+
+extern int amiga_is_far_symbol(const_rtx x);
+
+// (GET_CODE(X) == CONST && (GET_CODE(XEXP(X, 0)) == SYMBOL_REF || GET_CODE(XEXP(X, 0)) == LABEL_REF) && !CONSTANT_POOL_ADDRESS_P (XEXP(X, 0))) ||
+
+#undef TARGET_GCC_EXCEPT_TABLE
+#define TARGET_GCC_EXCEPT_TABLE ".text"
+
+#undef TARGET_GCC_EXCEPT_TABLE_S
+#define TARGET_GCC_EXCEPT_TABLE_S ".text"
+
+#define EH_TABLES_CAN_BE_READ_ONLY 1
+
+
+/* Max. number of data, address and float registers to be used for passing
+   integer, pointer and float arguments when TARGET_REGPARM.
+   It's 4, so d0-d3, a0-a3 and fp0-fp3 can be used.  */
+#undef AMIGAOS_MAX_REGPARM
+#define AMIGAOS_MAX_REGPARM 4
+
+/* The default number of data, address and float registers to use when
+   user specified '-mregparm' switch, not '-mregparm=<value>' option.  */
+#undef AMIGAOS_DEFAULT_REGPARM
+#define AMIGAOS_DEFAULT_REGPARM 2
+
+/* 1 if N is a possible register number for function argument passing.  */
+#undef FUNCTION_ARG_REGNO_P
+#define FUNCTION_ARG_REGNO_P(N)    amigaos_function_arg_reg(N)
+
+extern int
+amigaos_function_arg_reg(unsigned regno);
+
+//extern bool debug_recog(char const * txt, int which_alternative, int n, rtx * operands);
+
+/* SBF: modified RATIOs there 3 operand pushes, the call and the sp correction -> 5 insns.
+ *
+ * Plus the compare is a '<' => use 6 to create up to 5 clr/move insns.
+ */
+#undef MOVE_RATIO
+#undef CLEAR_RATIO
+//#define MOVE_RATIO(speed) ((speed) ? 15 : 3)
+//#define CLEAR_RATIO(speed) ((speed) ? 15 :3)
+#define MOVE_RATIO(speed) ((speed) ? 15 : 6)
+#define CLEAR_RATIO(speed) ((speed) ? 15 : 6)
+
+/* Compile with a4 restoring in public functions.  */
+
+#define MASK_RESTORE_A4 0x10000000 /* 1 << 28 */
+#define TARGET_RESTORE_A4 \
+  ((target_flags & MASK_RESTORE_A4) && TREE_PUBLIC (current_function_decl))
+
+/* Compile with a4 restoring in all functions.  */
+
+#define MASK_ALWAYS_RESTORE_A4 0x8000000 /* 1 << 27 */
+#define TARGET_ALWAYS_RESTORE_A4 (target_flags & MASK_ALWAYS_RESTORE_A4)
+
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+#undef STDINT_LONG32
+#define STDINT_LONG32 0
+
+#undef HAVE_GAS_CFI_DIRECTIVE
+#define HAVE_GAS_CFI_DIRECTIVE 0
+
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO) \
+  asm_fprintf (FILE, "\tjsr _mcount\n")
diff --git a/gcc/config/m68k/m68kemb.h b/gcc/config/m68k/m68kemb.h
index 0d8d88c74ea..29b3e194f12 100644
--- a/gcc/config/m68k/m68kemb.h
+++ b/gcc/config/m68k/m68kemb.h
@@ -32,12 +32,14 @@
 #define NEEDS_UNTYPED_CALL 1
 
 /* Target OS builtins.  */
+#ifndef TARGET_OS_CPP_BUILTINS
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
       builtin_define ("__embedded__");		\
     }						\
   while (0)
+#endif
 
 /* Override the default LIB_SPEC from gcc.c.  We don't currently support
    profiling, or libg.a.  */
diff --git a/gcc/config/m68k/math-68881.h b/gcc/config/m68k/math-68881.h
index 6d9f8b2d4a1..20a5037cc52 100644
--- a/gcc/config/m68k/math-68881.h
+++ b/gcc/config/m68k/math-68881.h
@@ -37,7 +37,7 @@
    September 1993, Use #undef before HUGE_VAL instead of #ifdef/#endif.  */
 
 /* Changed by Ian Lance Taylor:
-   September 1994, use extern inline instead of static inline.  */
+   September 1994, use inline instead of static inline.  */
 
 #ifndef __math_68881
 #define __math_68881
@@ -64,7 +64,7 @@
 })
 #endif
 
-__inline extern double
+__inline double
 sin (double x)
 {
   double value;
@@ -75,7 +75,7 @@ sin (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 cos (double x)
 {
   double value;
@@ -86,7 +86,7 @@ cos (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 tan (double x)
 {
   double value;
@@ -97,7 +97,7 @@ tan (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 asin (double x)
 {
   double value;
@@ -108,7 +108,7 @@ asin (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 acos (double x)
 {
   double value;
@@ -119,7 +119,7 @@ acos (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 atan (double x)
 {
   double value;
@@ -130,7 +130,7 @@ atan (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 atan2 (double y, double x)
 {
   double pi, pi_over_2;
@@ -187,7 +187,7 @@ atan2 (double y, double x)
     }
 }
 
-__inline extern double
+__inline double
 sinh (double x)
 {
   double value;
@@ -198,7 +198,7 @@ sinh (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 cosh (double x)
 {
   double value;
@@ -209,7 +209,7 @@ cosh (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 tanh (double x)
 {
   double value;
@@ -220,7 +220,7 @@ tanh (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 atanh (double x)
 {
   double value;
@@ -231,7 +231,7 @@ atanh (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 exp (double x)
 {
   double value;
@@ -242,7 +242,7 @@ exp (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 expm1 (double x)
 {
   double value;
@@ -253,7 +253,7 @@ expm1 (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 log (double x)
 {
   double value;
@@ -264,7 +264,7 @@ log (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 log1p (double x)
 {
   double value;
@@ -275,7 +275,7 @@ log1p (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 log10 (double x)
 {
   double value;
@@ -286,7 +286,7 @@ log10 (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 sqrt (double x)
 {
   double value;
@@ -297,13 +297,13 @@ sqrt (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 hypot (double x, double y)
 {
   return sqrt (x*x + y*y);
 }
 
-__inline extern double
+__inline double
 pow (double x, double y)
 {
   if (x > 0)
@@ -352,7 +352,7 @@ pow (double x, double y)
     }
 }
 
-__inline extern double
+__inline double
 fabs (double x)
 {
   double value;
@@ -363,7 +363,7 @@ fabs (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 ceil (double x)
 {
   int rounding_mode, round_up;
@@ -385,7 +385,7 @@ ceil (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 floor (double x)
 {
   int rounding_mode, round_down;
@@ -408,7 +408,7 @@ floor (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 rint (double x)
 {
   int rounding_mode, round_nearest;
@@ -430,7 +430,7 @@ rint (double x)
   return value;
 }
 
-__inline extern double
+__inline double
 fmod (double x, double y)
 {
   double value;
@@ -442,7 +442,7 @@ fmod (double x, double y)
   return value;
 }
 
-__inline extern double
+__inline double
 drem (double x, double y)
 {
   double value;
@@ -454,7 +454,7 @@ drem (double x, double y)
   return value;
 }
 
-__inline extern double
+__inline double
 scalb (double x, int n)
 {
   double value;
@@ -466,7 +466,7 @@ scalb (double x, int n)
   return value;
 }
 
-__inline extern double
+__inline double
 logb (double x)
 {
   double exponent;
@@ -477,7 +477,7 @@ logb (double x)
   return exponent;
 }
 
-__inline extern double
+__inline double
 ldexp (double x, int n)
 {
   double value;
@@ -489,7 +489,7 @@ ldexp (double x, int n)
   return value;
 }
 
-__inline extern double
+__inline double
 frexp (double x, int *exp)
 {
   double float_exponent;
@@ -514,7 +514,7 @@ frexp (double x, int *exp)
   return mantissa;
 }
 
-__inline extern double
+__inline double
 modf (double x, double *ip)
 {
   double temp;
diff --git a/gcc/config/m68k/predicates.md b/gcc/config/m68k/predicates.md
index 186436c42b7..9533e65ceaa 100644
--- a/gcc/config/m68k/predicates.md
+++ b/gcc/config/m68k/predicates.md
@@ -30,6 +30,10 @@
 	  || GET_CODE (XEXP (op, 0)) == LABEL_REF
 	  || GET_CODE (XEXP (op, 0)) == CONST))
     return 1;
+#ifdef TARGET_AMIGA
+  if (flag_pic >= 3 && amiga_is_const_pic_ref(op))
+    return 0;
+#endif
   return general_operand (op, mode);
 })
 
diff --git a/gcc/config/m68k/t-amigaos b/gcc/config/m68k/t-amigaos
new file mode 100755
index 00000000000..14e671c0d93
--- /dev/null
+++ b/gcc/config/m68k/t-amigaos
@@ -0,0 +1,43 @@
+# Makefile fragment for AmigaOS target.
+
+EXTRA_OBJS += amigaos.o m68k_68000_10_costs.o m68k_68020_costs.o m68k_68030_costs.o m68k_68040_costs.o
+#EXTRA_OPTIONS += m68k/amigaos.opt
+
+# Extra object file linked to the cc1* executables.
+amigaos.o: $(srcdir)/config/m68k/amigaos.c $(CONFIG_H)
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+m68k_68000_10_costs.o: $(srcdir)/config/m68k/m68k_68000_10_costs.c $(CONFIG_H)
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+m68k_68020_costs.o: $(srcdir)/config/m68k/m68k_68020_costs.c $(CONFIG_H)
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+m68k_68030_costs.o: $(srcdir)/config/m68k/m68k_68030_costs.c $(CONFIG_H)
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+m68k_68040_costs.o: $(srcdir)/config/m68k/m68k_68040_costs.c $(CONFIG_H)
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
+
+# Additional target dependent options for compiling libgcc.a.  This just
+# ensures that we don't compile libgcc* with anything other than a
+# fixed stack.
+
+#TARGET_LIBGCC2_CFLAGS = -mfixedstack
+
+### begin-GG-local: dynamic libraries
+# Extra objects that get compiled and linked to collect2
+
+EXTRA_COLLECT2_OBJS = amigacollect2.o
+
+# Build supplimentary AmigaOS target support file for collect2
+amigacollect2.o: amigacollect2.c
+	$(CXX) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+	-DA2IXDIR_PREFIX=\"$(prefix)/share/a2ixlibrary\" $< $(OUTPUT_OPTION)
+### end-GG-local
+
+# Support for building multiple version of libgcc, libquadmath, libobjc and libstdc++-v3
+MULTILIB_OPTIONS    = mcpu=68020 fbaserel/fbaserel32
+MULTILIB_DIRNAMES   = libm020 libb libb32
+MULTILIB_EXTRA_OPTS = 
+MULTILIB_EXCEPTIONS = fbaserel32 
\ No newline at end of file
diff --git a/gcc/config/m68k/x-amigaos b/gcc/config/m68k/x-amigaos
new file mode 100755
index 00000000000..a8f60b80f9f
--- /dev/null
+++ b/gcc/config/m68k/x-amigaos
@@ -0,0 +1,104 @@
+# Makefile fragment for AmigaOS host
+
+# Each compilation environment (Manx, Dice, GCC, SAS/C, etc) provides its
+# own equivalent of the UNIX /usr/include tree.  For gcc, the standard headers
+# are in /gg/include and system specific headers are in /gg/os-include.
+# Use these paths for fixincludes.
+
+SYSTEM_HEADER_DIR = $(prefix)/include
+
+# Uncomment the following macro to get a resident GCC. We don't do it
+# by default, since we want to support users with mc68000.
+# WARNING!  If you uncomment this, you MUST add the same flags to the
+# libiberty's Makefile (libiberty is now linked into GCC executables).
+
+#RESIDENT = -m68020 -resident32
+
+# Additional host flags that are not used when compiling with GCC_FOR_TARGET,
+# such as when compiling the libgcc* runtime archives. GCC uses stack
+# a lot, and since AmigaOS provides processes with a small, fixed size
+# stack, we have to generate code that will extend it whenever necessary.
+
+XCFLAGS = -mstackextend $(RESIDENT)
+
+# AmigaOS supports "AmigaGuide(R)" hypertext files. For GCC, these are
+# build with a custom "makeinfo".
+
+# Arrange for guides to be build with GCC, in the build directory.
+
+### begin-GG-local: gcc-amigaos
+#EXTRA_DOC_TARGETS = guide gcc-amigaos-doc
+### end-GG-local
+
+# Actually build guides
+
+guide:: doc/cpp.guide doc/gcc.guide doc/gccint.guide \
+	 doc/gccinstall.guide doc/cppinternals.guide
+
+doc/cpp.guide: $(TEXI_CPP_FILES)
+doc/gcc.guide: $(TEXI_GCC_FILES)
+doc/gccint.guide: $(TEXI_GCCINT_FILES)
+doc/cppinternals.guide: $(TEXI_CPPINT_FILES)
+
+doc/%.guide: %.texi
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) --amiga $(MAKEINFOFLAGS) -I $(docdir) \
+			-I $(docdir)/include -o $@ $<; \
+	fi
+
+# Duplicate entry to handle renaming of gccinstall.guide
+doc/gccinstall.guide: $(TEXI_GCCINSTALL_FILES)
+	if [ x$(BUILD_INFO) = xinfo ]; then \
+		$(MAKEINFO) --amiga $(MAKEINFOFLAGS) -I $(docdir) \
+			-I $(docdir)/include -o $@ install.texi; \
+	fi
+
+# Arrange for guides to be installed with GCC.
+
+### begin-GG-local: gcc-amigaos
+#EXTRA_INSTALL_TARGETS = install-guide install-gcc-amigaos-doc
+### end-GG-local
+
+# Where the guide files go
+
+guidedir = $(prefix)/guide
+
+# Actually install guides.
+
+installdirs-guide:
+	$(SHELL) ${srcdir}/mkinstalldirs $(DESTDIR)$(guidedir)
+
+install-guide: doc installdirs-guide \
+	$(DESTDIR)$(guidedir)/cpp.guide \
+	$(DESTDIR)$(guidedir)/gcc.guide \
+	$(DESTDIR)$(guidedir)/cppinternals.guide \
+	$(DESTDIR)$(guidedir)/gccinstall.guide \
+	$(DESTDIR)$(guidedir)/gccint.guide
+
+$(DESTDIR)$(guidedir)/%.guide: doc/%.guide installdirs-guide
+	rm -f $@
+	if [ -f $< ]; then \
+	  for f in $(<)*; do \
+	    realfile=`echo $$f | sed -e 's|.*/\([^/]*\)$$|\1|'`; \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(guidedir)/$$realfile; \
+	    chmod a-x $(DESTDIR)$(guidedir)/$$realfile; \
+	  done; \
+	else true; fi
+
+### begin-GG-local: gcc-amigaos
+# Build and install gcc-amigaos.guide - documentation specific to the
+# AmigaOS port of GCC.
+
+gcc-amigaos-doc:: doc/gcc-amigaos.info doc/gcc-amigaos.guide
+
+doc/gcc-amigaos.info doc/gcc-amigaos.guide: gcc-amigaos.texi
+
+install-gcc-amigaos-doc: doc installdirs installdirs-guide \
+	$(DESTDIR)$(infodir)/gcc-amigaos.info \
+	$(DESTDIR)$(guidedir)/gcc-amigaos.guide
+### end-GG-local
+
+host-amigaos.o : $(srcdir)/config/m68k/host-amigaos.c $(CONFIG_H) $(SYSTEM_H) \
+  coretypes.h hosthooks.h hosthooks-def.h toplev.h diagnostic.h
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/m68k/host-amigaos.c 
diff --git a/gcc/config/m68k/xm-amigaos.h b/gcc/config/m68k/xm-amigaos.h
new file mode 100755
index 00000000000..bb571ba040b
--- /dev/null
+++ b/gcc/config/m68k/xm-amigaos.h
@@ -0,0 +1,64 @@
+/* Configuration for GNU C-compiler for m68k Amiga, running AmigaOS.
+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2003
+   Free Software Foundation, Inc.  
+   Contributed by Markus M. Wild (wild@amiga.physik.unizh.ch).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#ifndef _FCNTL_H_
+#include <fcntl.h>
+#endif
+
+/* AmigaOS specific headers, such as from the Native Developer Update kits,
+   go in SYSTEM_INCLUDE_DIR.  STANDARD_INCLUDE_DIR is the equivalent of
+   Unix "/usr/include".  All other include paths are set in Makefile.  */
+
+#define SYSTEM_INCLUDE_DIR	"/gg/os-include"
+#define STANDARD_INCLUDE_DIR	"/gg/include"
+
+#define STANDARD_EXEC_PREFIX_1	"/gg/libexec/gcc/"
+#define STANDARD_EXEC_PREFIX_2	"/gg/lib/gcc/"
+#define STANDARD_STARTFILE_PREFIX_1 "/gg/lib/"
+#define STANDARD_STARTFILE_PREFIX_2 "/gg/lib/"
+
+/* The AmigaOS stores file names with regard to upper/lower case, but actions
+   on existing files are case independent on the standard filesystems.
+
+   A good example of where this causes problems is the conflict between the C
+   include file <string.h> and the C++ include file <String.h>, where the C++
+   include file dir is searched first and thus causes includes of <string.h>
+   to include <String.h> instead.
+
+   In order to solve this problem we define the macro OPEN_CASE_SENSITIVE as
+   the name of the function that takes the same args as open() and does case
+   dependent opens.  */
+
+#define OPEN_CASE_SENSITIVE(NAME, FLAGS, MODE) open ((NAME), (FLAGS) | O_CASE, (MODE))
+
+/* On the AmigaOS, there are two pathname separators, '/' (DIR_SEPARATOR)
+   and ':' (VOL_SEPARATOR).  DIR_SEPARATOR defaults to the correct
+   character, so we don't have to explicitly set it.  */
+
+#define DIR_SEPARATOR '/'
+#define VOL_SEPARATOR ':'
+#define DIR_SEPARATOR_2 VOL_SEPARATOR
+
+/* Zap PREFIX_INCLUDE_DIR, since with the AmigaOS port it is the same as
+   STANDARD_INCLUDE_DIR.  */
+
+#undef PREFIX_INCLUDE_DIR 
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index 12067fdf534..f0f069f6afa 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -52,9 +52,9 @@ typedef const struct bitmap_head *const_bitmap;
 struct simple_bitmap_def;
 typedef struct simple_bitmap_def *sbitmap;
 typedef const struct simple_bitmap_def *const_sbitmap;
-struct rtx_def;
-typedef struct rtx_def *rtx;
-typedef const struct rtx_def *const_rtx;
+class rtx_def;
+typedef class rtx_def *rtx;
+typedef const class rtx_def *const_rtx;
 
 /* Subclasses of rtx_def, using indentation to show the class
    hierarchy, along with the relevant invariant.
diff --git a/gcc/cp/g++spec.c b/gcc/cp/g++spec.c
index 03cbde090cb..3d1e4ae807f 100644
--- a/gcc/cp/g++spec.c
+++ b/gcc/cp/g++spec.c
@@ -262,7 +262,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,
 #endif
 
   /* Add one for shared_libgcc or extra static library.  */
-  num_args = argc + added + need_math + (library > 0) * 4 + 1;
+  num_args = argc + added + need_math + (library > 0) * 5 + 1;
   new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);
 
   i = 0;
@@ -342,11 +342,36 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,
 	  j++;
 	}
 #endif
+
+#ifdef TARGET_AMIGA
+	{
+	  bool add_new_op = false;
+	  /* do not add glue if exceptions are disabled. */
+	  for (int ii = 0; ii < argc; ++ii)
+	    {
+	      if (decoded_options[ii].opt_index == OPT_fexceptions)
+		add_new_op = !decoded_options[ii].value;
+	    }
+	  if (add_new_op)
+	    {
+	      extern const char *
+	      amiga_m68k_prefix_func (int argc, const char ** argv);
+	      char const * new_op = "../lib/gcc/m68k-amigaos/"
+	      DEFAULT_TARGET_VERSION
+	      "/new_op.o";
+	      char const * p = amiga_m68k_prefix_func (1, &new_op);
+	      generate_option_input_file (p, &new_decoded_options[j]);
+	      ++j;
+	    }
+	}
+#endif
+
       generate_option (OPT_l,
 		       saw_profile_flag ? LIBSTDCXX_PROFILE : LIBSTDCXX, 1,
 		       CL_DRIVER, &new_decoded_options[j]);
       added_libraries++;
       j++;
+
       /* Add target-dependent static library, if necessary.  */
       if ((static_link || library > 1) && LIBSTDCXX_STATIC != NULL)
 	{
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index 23fd4efe12d..995c8083d44 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -3655,8 +3655,14 @@ mangle_decl (const tree decl)
     id = get_identifier ("<anon>");
   else
     {
+      if (!(TREE_CODE (decl) != TYPE_DECL
+		  || !no_linkage_check (TREE_TYPE (decl), true)))
+	no_linkage_check (TREE_TYPE (decl), true);
+
       gcc_assert (TREE_CODE (decl) != TYPE_DECL
-		  || !no_linkage_check (TREE_TYPE (decl), true));
+		  || !no_linkage_check (TREE_TYPE (decl), true)
+		  || (TYPE_STUB_DECL (TREE_TYPE (decl))
+		      && TREE_PUBLIC (TYPE_STUB_DECL (TREE_TYPE (decl)))));
       if (abi_version_at_least (10))
 	if (tree fn = decl_function_context (decl))
 	  maybe_check_abi_tags (fn, decl);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 48e921adfdf..f3bcd78b4f6 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -20570,6 +20570,13 @@ cp_parser_parameter_declaration (cp_parser *parser,
 	}
     }
 
+  /**
+   * SBF: Add support for __asm("xy") register spec.
+   */
+#ifdef TARGET_AMIGAOS
+    tree pasmspec = cp_parser_asm_specification_opt (parser);
+#endif
+
   /* If the next token is an ellipsis, and we have not seen a declarator
      name, and if either the type of the declarator contains parameter
      packs but it is not a TYPE_PACK_EXPANSION or is null (this happens
@@ -20674,6 +20681,41 @@ cp_parser_parameter_declaration (cp_parser *parser,
   else
     default_argument = NULL_TREE;
 
+#ifdef TARGET_AMIGA
+  if (pasmspec)
+    {
+      const char *asmspec = TREE_STRING_POINTER(pasmspec);
+      if (*asmspec == '%')
+        ++asmspec;
+      int offset = 1;
+      int reg_number = -1;
+      if (asmspec[0] == 'd')
+        reg_number = 0;
+      else if (asmspec[0] == 'a')
+        reg_number = 8;
+      else if (asmspec[0] == 'f' && asmspec[1] == 'p')
+        {
+          reg_number = 16;
+          offset = 2;
+        }
+      unsigned add = asmspec[offset] - '0';
+      if (reg_number < 0 || add > 7)
+	    error("invalid register specified %s", asmspec);
+      reg_number += add;
+
+  /* Build tree for __attribute__ ((asmreg(regnum))). */
+      tree ttasm = get_identifier("asmreg");
+      tree value = tree_cons(ttasm, build_int_cst(NULL, reg_number), NULL_TREE);
+      tree attrs = tree_cons(ttasm, value, NULL_TREE);
+
+      /* search outmost declarator, e.g. int * needs the attribute at the pointer not the int. */
+      cp_declarator * d = declarator;
+      while (d->kind != cdk_id && d->declarator)
+	d = d->declarator;
+      d->attributes = chainon(attrs, d->attributes);
+    }
+#endif
+
   return make_parameter_declarator (&decl_specifiers,
 				    declarator,
 				    default_argument,
diff --git a/gcc/df-scan.c b/gcc/df-scan.c
index 98de8440542..1f23452afe1 100644
--- a/gcc/df-scan.c
+++ b/gcc/df-scan.c
@@ -1807,6 +1807,12 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,
 	  df_ref *ref_ptr;
 	  struct df_insn_info *insn_info = DF_REF_INSN_INFO (the_ref);
 
+	  if (DF_REF_FLAGS_IS_SET(the_ref, DF_HARD_REG_LIVE))
+	    {
+	      --df->hard_regs_live_count[DF_REF_REGNO(the_ref)];
+	      ++df->hard_regs_live_count[new_regno];
+	    }
+
 	  DF_REF_REGNO (the_ref) = new_regno;
 	  DF_REF_REG (the_ref) = regno_reg_rtx[new_regno];
 
diff --git a/gcc/dllyang.c b/gcc/dllyang.c
new file mode 100644
index 00000000000..0d8bf8be6bf
--- /dev/null
+++ b/gcc/dllyang.c
@@ -0,0 +1,128 @@
+
+#define __MAKE_MSYS2__
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "target.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "diagnostic-core.h"
+#include "attribs.h"
+#include "stor-layout.h"
+#include "langhooks.h"
+#include "plugin.h"
+
+struct lang_hooks lang_hooks;
+
+struct ggc_root_tab;
+ggc_root_tab ** gt_pch_scalar_rtab;
+ggc_root_tab ** gt_ggc_rtab;
+ggc_root_tab ** gt_ggc_deletable_rtab;
+
+static void (* __apply_tm_attr) (tree, tree);
+void apply_tm_attr (tree a, tree b)
+{
+  __apply_tm_attr(a, b);
+}
+
+static tree (* __decl_attributes) (tree *, tree, int);
+tree decl_attributes (tree *a, tree b, int c)
+{
+  return __decl_attributes(a, b, c);
+}
+
+static tree (* __make_attribute) (const char *, const char *, tree);
+tree make_attribute (const char *a, const char *b, tree c) {
+  return __make_attribute(a, b, c);
+}
+
+static const struct attribute_spec * (*__lookup_attribute_spec) (const_tree);
+const struct attribute_spec *lookup_attribute_spec (const_tree a)
+{
+  return __lookup_attribute_spec(a);
+}
+
+static tree (*__get_attribute_name) (const_tree);
+tree get_attribute_name (const_tree a)
+{
+  return __get_attribute_name(a);
+}
+
+static tree (*__convert) (tree, tree);
+tree convert (tree a, tree b)
+{
+  return __convert(a, b);
+}
+
+static void (*__gt_pch_nx_language_function) (void *);
+void
+gt_pch_nx_language_function (void *x_p)
+{
+  __gt_pch_nx_language_function(x_p);
+}
+
+static void (* __gt_ggc_mx_language_function) (void *);
+void
+gt_ggc_mx_language_function (void *x_p)
+{
+  __gt_ggc_mx_language_function(x_p);
+}
+
+static void (*__gt_ggc_mx_lang_tree_node) (void *);
+void
+gt_ggc_mx_lang_tree_node (void *x_p)
+{
+  __gt_ggc_mx_lang_tree_node(x_p);
+}
+
+static void (*__gt_pch_nx_lang_tree_node) (void *);
+void
+gt_pch_nx_lang_tree_node (void *x_p)
+{
+  __gt_pch_nx_lang_tree_node(x_p);
+}
+
+
+static void (*__gt_clear_caches) ();
+void
+gt_clear_caches ()
+{
+  __gt_clear_caches();
+}
+
+
+void __set__pointers(struct lang_hooks *p__lang_hooks,
+		    ggc_root_tab ** p__gt_pch_scalar_rtab,
+		    ggc_root_tab ** p__gt_ggc_rtab,
+		    ggc_root_tab ** p__gt_ggc_deletable_rtab,
+		     void (*p__apply_tm_attr) (tree, tree),
+		     tree (*p__decl_attributes) (tree *, tree, int),
+		     tree (*p__make_attribute) (const char *, const char *, tree),
+		     const struct attribute_spec * (*p__lookup_attribute_spec) (const_tree),
+		     tree (*p__get_attribute_name) (const_tree),
+		     tree (*p__convert) (tree, tree),
+		     void (*p__gt_pch_nx_language_function) (void *),
+		     void (*p__gt_ggc_mx_language_function) (void *),
+		     void (*p__gt_ggc_mx_lang_tree_node) (void *),
+		     void (*p__gt_pch_nx_lang_tree_node) (void *),
+		     void (*p__gt_clear_caches) ()
+) {
+  memcpy(&lang_hooks, p__lang_hooks, sizeof(struct lang_hooks));
+
+  gt_pch_scalar_rtab = p__gt_pch_scalar_rtab;
+  gt_ggc_rtab = p__gt_ggc_rtab;
+  gt_ggc_deletable_rtab = p__gt_ggc_deletable_rtab;
+
+  __apply_tm_attr = p__apply_tm_attr;
+  __decl_attributes = p__decl_attributes;
+  __make_attribute = p__make_attribute;
+  __lookup_attribute_spec = p__lookup_attribute_spec;
+  __get_attribute_name = p__get_attribute_name;
+  __convert = p__convert;
+  __gt_pch_nx_language_function = p__gt_pch_nx_language_function;
+  __gt_ggc_mx_language_function = p__gt_ggc_mx_language_function;
+  __gt_ggc_mx_lang_tree_node = p__gt_ggc_mx_lang_tree_node;
+  __gt_pch_nx_lang_tree_node = p__gt_pch_nx_lang_tree_node;
+  __gt_clear_caches = p__gt_clear_caches;
+}
diff --git a/gcc/dllying.c b/gcc/dllying.c
new file mode 100644
index 00000000000..0a32040f918
--- /dev/null
+++ b/gcc/dllying.c
@@ -0,0 +1,47 @@
+
+#define __MAKE_MSYS2__
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "target.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "diagnostic-core.h"
+#include "attribs.h"
+#include "stor-layout.h"
+#include "langhooks.h"
+#include "plugin.h"
+
+extern struct lang_hooks lang_hooks;
+
+struct ggc_root_tab;
+extern ggc_root_tab ** gt_pch_scalar_rtab;
+extern ggc_root_tab ** gt_ggc_rtab;
+extern ggc_root_tab ** gt_ggc_deletable_rtab;
+
+extern void __set__pointers(struct lang_hooks *p__lang_hooks,
+			    ggc_root_tab ** p__gt_pch_scalar_rtab,
+			    ggc_root_tab ** gt_ggc_rtab,
+			    ggc_root_tab ** gt_ggc_deletable_rtab,
+		     void (*p__apply_tm_attr) (tree, tree),
+		     tree (*p__decl_attributes) (tree *, tree, int),
+		     tree (*p__make_attribute) (const char *, const char *, tree),
+		     const struct attribute_spec * (*p__lookup_attribute_spec) (const_tree),
+		     tree (*p__get_attribute_name) (const_tree),
+		     tree (*p__convert) (tree, tree),
+		     void (*p__gt_pch_nx_language_function) (void *),
+		     void (*p__gt_ggc_mx_language_function) (void *),
+		     void (*p__gt_ggc_mx_lang_tree_node) (void *),
+		     void (*p__gt_pch_nx_lang_tree_node) (void *),
+		     void (*p__gt_clear_caches) ()
+);
+
+static struct __0 {
+  __0() {
+    __set__pointers(&lang_hooks, gt_pch_scalar_rtab, gt_ggc_rtab, gt_ggc_deletable_rtab,
+		    apply_tm_attr, decl_attributes, make_attribute, lookup_attribute_spec,
+		    get_attribute_name, convert, gt_pch_nx_language_function, gt_ggc_mx_language_function,
+		    gt_ggc_mx_lang_tree_node, gt_pch_nx_lang_tree_node, gt_clear_caches);
+  }
+} ___1;
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 809da745b21..c5994f48b45 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -451,7 +451,7 @@ switch_to_eh_frame_section (bool back ATTRIBUTE_UNUSED)
 						       /*global=*/1);
 	  lsda_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0,
 							/*global=*/0);
-	  flags = ((! flag_pic
+	  flags = (( (!flag_pic || flag_pic > 2)
 		    || ((fde_encoding & 0x70) != DW_EH_PE_absptr
 			&& (fde_encoding & 0x70) != DW_EH_PE_aligned
 			&& (per_encoding & 0x70) != DW_EH_PE_absptr
@@ -469,6 +469,24 @@ switch_to_eh_frame_section (bool back ATTRIBUTE_UNUSED)
       eh_frame_section = ((flags == SECTION_WRITE)
 			  ? data_section : readonly_data_section);
 #endif /* EH_FRAME_SECTION_NAME */
+
+#ifdef TARGET_AMIGA
+      switch_to_section (data_section);
+      {
+	static int init;
+	if (!init)
+	  {
+	    fputs("\t.long ___init_eh\n", asm_out_file);
+	    init = 1;
+	  };
+      }
+      fputs("\t__EH_FRAME_OBJECT__:\n\t.long 0\n\t.long 0\n\t.long 0\n\t.long 0\n\t.long 0\n\t.long 0\n", asm_out_file);
+      fputs("\t.stabs \"__EH_FRAME_OBJECTS__\",24,0,0,__EH_FRAME_OBJECT__\n", asm_out_file);
+
+      switch_to_section (eh_frame_section);
+      ASM_OUTPUT_LABEL (asm_out_file, "_EH_FRAME_BEGIN__");
+      fputs("\t.stabs \"__EH_FRAME_BEGINS__\",22,0,0,__EH_FRAME_BEGIN__\n", asm_out_file);
+#endif
     }
 
   switch_to_section (eh_frame_section);
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 527665be972..572e0e35310 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -2123,7 +2123,11 @@ change_address_1 (rtx memref, machine_mode mode, rtx addr, int validate,
   if (validate && !lra_in_progress)
     {
       if (reload_in_progress || reload_completed)
-	gcc_assert (memory_address_addr_space_p (mode, addr, as));
+	{
+	  bool r = memory_address_addr_space_p (mode, addr, as);
+	  if (!r) debug_rtx(addr);
+	  gcc_assert (r);
+	}
       else
 	addr = memory_address_addr_space (mode, addr, as);
     }
diff --git a/gcc/except.c b/gcc/except.c
index 2a1073f80cc..194478f8454 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -142,6 +142,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "cfgloop.h"
 #include "builtins.h"
 #include "tree-hash-traits.h"
+#include "target-def.h"
 
 static GTY(()) int call_site_base;
 
@@ -2850,14 +2851,14 @@ switch_to_exception_section (const char * ARG_UNUSED (fnname))
 		 it linkonce if we have COMDAT groups to tie them together.  */
 	      if (DECL_COMDAT_GROUP (current_function_decl) && HAVE_COMDAT_GROUP)
 		flags |= SECTION_LINKONCE;
-	      sprintf (section_name, ".gcc_except_table.%s", fnname);
+	      sprintf (section_name, TARGET_GCC_EXCEPT_TABLE_S, fnname);
 	      s = get_section (section_name, flags, current_function_decl);
 	      free (section_name);
 	    }
 	  else
 #endif
 	    exception_section
-	      = s = get_section (".gcc_except_table", flags, NULL);
+	      = s = get_section (TARGET_GCC_EXCEPT_TABLE, flags, NULL);
 	}
       else
 	exception_section
diff --git a/gcc/expmed.c b/gcc/expmed.c
index 2b42deedb65..66c0f27d6f7 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -570,7 +570,12 @@ simple_mem_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,
 	  && bitsize == GET_MODE_BITSIZE (mode)
 	  && (!SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (op0))
 	      || (bitnum % GET_MODE_ALIGNMENT (mode) == 0
-		  && MEM_ALIGN (op0) >= GET_MODE_ALIGNMENT (mode))));
+		  && (
+				  MEM_ALIGN (op0) >= GET_MODE_ALIGNMENT (mode)
+#ifdef TARGET_AMIGA
+  ||(!TUNE_68000 && !TUNE_68010)
+#endif
+				  ))));
 }
 
 /* Try to use instruction INSV to store VALUE into a field of OP0.
diff --git a/gcc/final.c b/gcc/final.c
index c07764e02e2..5e4d2eef81c 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -2151,6 +2151,7 @@ call_from_call_insn (rtx_call_insn *insn)
    SEEN is used to track the end of the prologue, for emitting
    debug information.  We force the emission of a line note after
    both NOTE_INSN_PROLOGUE_END and NOTE_INSN_FUNCTION_BEG.  */
+rtx_insn * current_insn;
 
 rtx_insn *
 final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
@@ -2160,6 +2161,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
   rtx set;
 #endif
   rtx_insn *next;
+  current_insn = insn;
 
   insn_counter++;
 
@@ -3622,6 +3624,13 @@ do_assembler_dialects (const char *p, int *dialect)
 void
 output_asm_insn (const char *templ, rtx *operands)
 {
+  extern bool be_very_verbose;
+  extern bool dump_cycles;
+  extern void append_reg_usage(FILE *, rtx_insn *);
+
+  extern bool dump_reg_track;
+  void append_reg_cache (FILE * f, rtx_insn * insn);
+
   const char *p;
   int c;
 #ifdef ASSEMBLER_DIALECT
@@ -3778,6 +3787,11 @@ output_asm_insn (const char *templ, rtx *operands)
 	putc (c, asm_out_file);
       }
 
+  if (be_very_verbose || dump_cycles)
+    append_reg_usage(asm_out_file, current_insn);
+  if (dump_reg_track)
+    append_reg_cache(asm_out_file, current_insn);
+
   /* Write out the variable names for operands, if we know them.  */
   if (flag_verbose_asm)
     output_asm_operand_names (operands, oporder, ops);
@@ -3995,6 +4009,7 @@ output_addr_const (FILE *file, rtx x)
       if (targetm.asm_out.output_addr_const_extra (file, x))
 	break;
 
+      debug_rtx(current_output_insn);
       output_operand_lossage ("invalid expression as operand");
     }
 }
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 94b9a21bd30..b0492543cce 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -3860,7 +3860,7 @@ make_bit_field_ref (location_t loc, tree inner, tree orig_inner, tree type,
   bftype = type;
   if (TYPE_PRECISION (bftype) != bitsize
       || TYPE_UNSIGNED (bftype) == !unsignedp)
-    bftype = build_nonstandard_integer_type (bitsize, 0);
+    bftype = build_nonstandard_integer_type (bitsize, TYPE_UNSIGNED (bftype)); // SBF: keep the signedness
 
   result = build3_loc (loc, BIT_FIELD_REF, bftype, inner,
 		       size_int (bitsize), bitsize_int (bitpos));
@@ -3964,6 +3964,9 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,
      won't optimize anything, so return zero.  */
   nbitsize = GET_MODE_BITSIZE (nmode);
   nbitpos = lbitpos & ~ (nbitsize - 1);
+#ifdef TARGET_AMIGA
+  unsigned obitpos = lbitpos;
+#endif
   lbitpos -= nbitpos;
   if (nbitsize == lbitsize)
     return 0;
@@ -3982,6 +3985,19 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,
       if (nbitpos < 0)
 	return 0;
 
+#ifdef TARGET_AMIGA
+      /* use the real bit pattern without and mask, to use bfexts/bfextu */
+      lhs = make_bit_field_ref (loc, linner, lhs, unsigned_type,
+				    lbitsize, obitpos, 1, lreversep);
+
+      if (TREE_CODE(lhs) == NOP_EXPR)
+        TREE_TYPE(TREE_OPERAND(lhs, 0)) = lang_hooks.types.type_for_mode (SImode, lunsignedp);
+      else
+        TREE_TYPE(lhs) = lang_hooks.types.type_for_mode (SImode, lunsignedp);
+
+      return fold_build2_loc (loc, code, compare_type, lhs, rhs);
+
+#else
       /* If not comparing with constant, just rework the comparison
 	 and return.  */
       tree t1 = make_bit_field_ref (loc, linner, lhs, unsigned_type,
@@ -3991,6 +4007,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,
 				    nbitsize, nbitpos, 1, rreversep);
       t2 = fold_build2_loc (loc, BIT_AND_EXPR, unsigned_type, t2, mask);
       return fold_build2_loc (loc, code, compare_type, t1, t2);
+#endif
     }
 
   /* Otherwise, we are handling the constant case.  See if the constant is too
@@ -4032,6 +4049,18 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,
       rhs = build_int_cst (type, 0);
     }
 
+#ifdef TARGET_AMIGA
+  /* use the real bit pattern without and mask, to use bfexts/bfextu */
+  lhs = make_bit_field_ref (loc, linner, lhs, unsigned_type,
+				lbitsize, obitpos, 1, lreversep);
+
+  if (TREE_CODE(lhs) == NOP_EXPR)
+    TREE_TYPE(TREE_OPERAND(lhs, 0)) = lang_hooks.types.type_for_mode (SImode, lunsignedp);
+  else
+    TREE_TYPE(lhs) = lang_hooks.types.type_for_mode (SImode, lunsignedp);
+
+  return build2_loc (loc, code, compare_type, lhs, rhs);
+#else
   /* Make a new bitfield reference, shift the constant over the
      appropriate number of bits and mask it with the computed mask
      (in case this was a signed field).  If we changed it, make a new one.  */
@@ -4043,9 +4072,10 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,
 				  fold_convert_loc (loc, unsigned_type, rhs),
 				  size_int (lbitpos)),
 		     mask);
-
   lhs = build2_loc (loc, code, compare_type,
 		    build2 (BIT_AND_EXPR, unsigned_type, lhs, mask), rhs);
+#endif
+
   return lhs;
 }
 
diff --git a/gcc/function.c b/gcc/function.c
index fe140042d78..5f7312c3676 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -39,9 +39,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl.h"
 #include "tree.h"
 #include "gimple-expr.h"
+#include "tm_p.h"
 #include "cfghooks.h"
 #include "df.h"
-#include "tm_p.h"
 #include "stringpool.h"
 #include "expmed.h"
 #include "optabs.h"
diff --git a/gcc/gcc.c b/gcc/gcc.c
index d47108852e2..4b3ec6d0077 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -1042,6 +1042,10 @@ proper position among the other output files.  */
 # define SYSROOT_SPEC "--sysroot=%R"
 #endif
 
+#ifndef SELF_SPEC
+# define SELF_SPEC ""
+#endif
+
 #ifndef SYSROOT_SUFFIX_SPEC
 # define SYSROOT_SUFFIX_SPEC ""
 #endif
@@ -1075,7 +1079,7 @@ static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;
 static const char *sysroot_spec = SYSROOT_SPEC;
 static const char *sysroot_suffix_spec = SYSROOT_SUFFIX_SPEC;
 static const char *sysroot_hdrs_suffix_spec = SYSROOT_HEADERS_SUFFIX_SPEC;
-static const char *self_spec = "";
+static const char *self_spec = SELF_SPEC;
 
 /* Standard options to cpp, cc1, and as, to reduce duplication in specs.
    There should be no need to override these in target dependent files,
@@ -2232,8 +2236,8 @@ read_specs (const char *filename, bool main_p, bool user_p)
       /* The colon shouldn't be missing.  */
       if (*p1 != ':')
 	fatal_error (input_location,
-		     "specs file malformed after %ld characters",
-		     (long) (p1 - buffer));
+		     "specs file malformed after %ld characters: %s",
+		     (long) (p1 - buffer), p1);
 
       /* Skip back over trailing whitespace.  */
       p2 = p1;
@@ -2246,8 +2250,8 @@ read_specs (const char *filename, bool main_p, bool user_p)
       p = skip_whitespace (p1 + 1);
       if (p[1] == 0)
 	fatal_error (input_location,
-		     "specs file malformed after %ld characters",
-		     (long) (p - buffer));
+		     "specs file malformed after %ld characters: %s",
+		     (long) (p - buffer), p);
 
       p1 = p;
       /* Find next blank line or end of string.  */
@@ -6126,6 +6130,10 @@ switch_matches (const char *atom, const char *end_atom, int starred)
   int len = end_atom - atom;
   int plen = starred ? len : -1;
 
+  // allow -l switch
+  if (*atom == 'l')
+	  return true;
+
   for (i = 0; i < n_switches; i++)
     if (!strncmp (switches[i].part1, atom, len)
 	&& (starred || switches[i].part1[len] == '\0')
@@ -10107,3 +10115,33 @@ driver_get_configure_time_options (void (*cb) (const char *option,
   obstack_free (&obstack, NULL);
   n_switches = 0;
 }
+
+#ifdef TARGET_AMIGA
+const char * amiga_m68k_prefix_func(int argc, const char ** argv) {
+  char * p;
+  if (standard_libexec_prefix)
+      p = make_relative_prefix(standard_libexec_prefix, "", "m68k-amigaos/");
+  else
+    p = concat("../../../../", "", NULL);
+
+  for (int i = 0; i < argc; ++i) {
+      char * q = concat(p, argv[i], NULL);
+      free(p);
+      p = q;
+  }
+
+  char * q;
+  while ((q = strstr(p, "/../")))
+    {
+      char * r = q - 1;
+      while (r >= p && *r != '/')
+	--r;
+      if (r < p)
+	break;
+      memmove(r, q + 3, strlen(q + 3) + 1);
+    }
+
+//  printf("amiga_m68k_prefix_func='%s'\n", p);
+  return p;
+}
+#endif
diff --git a/gcc/gcov.c b/gcc/gcov.c
old mode 100644
new mode 100755
diff --git a/gcc/gcse.c b/gcc/gcse.c
index 5b2c96ecb5a..f74e733f933 100644
--- a/gcc/gcse.c
+++ b/gcc/gcse.c
@@ -4075,7 +4075,9 @@ pass_rtl_pre::gate (function *fun)
 {
   return optimize > 0 && flag_gcse
     && !fun->calls_setjmp
+#ifndef TARGET_AMIGA
     && optimize_function_for_speed_p (fun)
+#endif
     && dbg_cnt (pre);
 }
 
@@ -4118,6 +4120,9 @@ public:
 bool
 pass_rtl_hoist::gate (function *)
 {
+#ifdef TARGET_AMIGA
+  return false;
+#else
   return optimize > 0 && flag_gcse
     && !cfun->calls_setjmp
     /* It does not make sense to run code hoisting unless we are optimizing
@@ -4125,6 +4130,7 @@ pass_rtl_hoist::gate (function *)
        bigger if we did PRE (when optimizing for space, we don't run PRE).  */
     && optimize_function_for_size_p (cfun)
     && dbg_cnt (hoist);
+#endif
 }
 
 } // anon namespace
diff --git a/gcc/gengtype.c b/gcc/gengtype.c
index be496609dba..987069ae7f7 100644
--- a/gcc/gengtype.c
+++ b/gcc/gengtype.c
@@ -5032,6 +5032,14 @@ parse_program_options (int argc, char **argv)
 	    srcdir = optarg;
 	  else
 	    fatal ("missing source directory");
+#ifdef __CYGWIN__
+	  if (0 == strncmp("/cygdrive/", srcdir, 10))
+	    {
+	      9[(char *)srcdir] = srcdir[10];
+	      10[(char *)srcdir] = ':';
+	      srcdir += 9;
+	    }
+#endif
 	  srcdir_len = strlen (srcdir);
 	  break;
 	case 'B':		/* --backupdir */
@@ -5104,6 +5112,18 @@ input_file_by_name (const char* name)
   f->inpoutf = NULL;
   f->inpisplugin = false;
   strcpy (f->inpname, name);
+
+#ifdef __CYGWIN__
+    if (strstr(f->inpname, "/cygdrive/") == f->inpname)
+      {
+	int l = strlen(&f->inpname[11]) + 1;
+	char * p = f->inpname;
+	p[0] = p[10];
+	p[1] = ':';
+	memmove(&p[2], &p[11], l);
+      }
+#endif
+
   slot = htab_find_slot (input_file_htab, f, INSERT);
   gcc_assert (slot != NULL);
   if (*slot)
diff --git a/gcc/ggc.h b/gcc/ggc.h
index 32e0f41d7a5..1ee2bbf3d33 100644
--- a/gcc/ggc.h
+++ b/gcc/ggc.h
@@ -70,9 +70,11 @@ struct ggc_root_tab {
 };
 #define LAST_GGC_ROOT_TAB { NULL, 0, 0, NULL, NULL }
 /* Pointers to arrays of ggc_root_tab, terminated by NULL.  */
+#ifndef __MAKE_MSYS2__
 extern const struct ggc_root_tab * const gt_ggc_rtab[];
 extern const struct ggc_root_tab * const gt_ggc_deletable_rtab[];
 extern const struct ggc_root_tab * const gt_pch_scalar_rtab[];
+#endif
 
 /* If EXPR is not NULL and previously unmarked, mark it and evaluate
    to true.  Otherwise evaluate to false.  */
diff --git a/gcc/ginclude/stddef.h b/gcc/ginclude/stddef.h
index d711530d053..4f08f81a3ae 100644
--- a/gcc/ginclude/stddef.h
+++ b/gcc/ginclude/stddef.h
@@ -325,6 +325,7 @@ typedef __rune_t        rune_t;
 #define __WCHAR_TYPE__ int
 #endif
 #ifndef __cplusplus
+#define _WCHAR_T_ int
 typedef __WCHAR_TYPE__ wchar_t;
 #endif
 #endif
diff --git a/gcc/hwint.h b/gcc/hwint.h
index 4dd255d486c..d5296a81d08 100644
--- a/gcc/hwint.h
+++ b/gcc/hwint.h
@@ -295,7 +295,7 @@ abs_hwi (HOST_WIDE_INT x)
 inline unsigned HOST_WIDE_INT
 absu_hwi (HOST_WIDE_INT x)
 {
-  return x >= 0 ? (unsigned HOST_WIDE_INT)x : -(unsigned HOST_WIDE_INT)x;
+  return x >= 0 ? (unsigned HOST_WIDE_INT)x : -(signed HOST_WIDE_INT)x;
 }
 
 #endif /* ! GCC_HWINT_H */
diff --git a/gcc/incpath.c b/gcc/incpath.c
index 952d5c4727d..dc7e44d416c 100644
--- a/gcc/incpath.c
+++ b/gcc/incpath.c
@@ -421,6 +421,23 @@ void
 add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)
 {
   cpp_dir *p;
+  char * q;
+  size_t l = strlen(path);
+  if (l > 1 && (path[0] == '"' || path[0] == '\'') && path[l - 1] == path[0])
+    {
+      l -= 2;
+      memmove(path, path + 1, l);
+      path[l] = 0;
+    }
+  while ((q = strstr(path, "/../")))
+    {
+      char * r = q - 1;
+      while (r >= path && *r != '/')
+	--r;
+      if (r < path)
+	break;
+      memmove(r, q + 3, strlen(q + 3) + 1);
+    }
 
 #if defined (HAVE_DOS_BASED_FILE_SYSTEM)
   /* Remove unnecessary trailing slashes.  On some versions of MS
@@ -449,7 +466,6 @@ add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)
     p->sysp = 0;
   p->construct = 0;
   p->user_supplied_p = user_supplied_p;
-
   add_cpp_dir_path (p, chain);
 }
 
diff --git a/gcc/ipa-chkp.c b/gcc/ipa-chkp.c
index 86c48f14f64..dc72a5f2102 100644
--- a/gcc/ipa-chkp.c
+++ b/gcc/ipa-chkp.c
@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "backend.h"
+#include "tm_p.h"
+#include "target.h"
 #include "tree.h"
 #include "gimple.h"
 #include "tree-pass.h"
diff --git a/gcc/ira-build.c b/gcc/ira-build.c
index caa770e849f..a233dbf8e17 100644
--- a/gcc/ira-build.c
+++ b/gcc/ira-build.c
@@ -2897,6 +2897,8 @@ setup_min_max_conflict_allocno_ids (void)
 	 (the reason for this is the allocnos with bigger conflict id
 	 have their range starts not smaller than allocnos with
 	 smaller ids.  */
+      if (filled_area_start > ira_max_point)
+	filled_area_start = ira_max_point;
       for (j = min; j < filled_area_start; j++)
 	last_lived[j] = i;
       filled_area_start = min;
diff --git a/gcc/lto-compress.c b/gcc/lto-compress.c
index 93b7b8f588f..6af4ed90741 100644
--- a/gcc/lto-compress.c
+++ b/gcc/lto-compress.c
@@ -266,7 +266,11 @@ lto_end_uncompression (struct lto_compression_stream *stream)
   gcc_assert (!stream->is_compression);
   timevar_push (TV_IPA_LTO_DECOMPRESS);
 
+#ifdef TARGET_AMIGA
+  while (remaining > 3)
+#else
   while (remaining > 0)
+#endif
     {
       z_stream in_stream;
       size_t out_bytes;
diff --git a/gcc/opts.c b/gcc/opts.c
index 1467782bc3a..c74ca71fd25 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -381,8 +381,8 @@ maybe_default_option (struct gcc_options *opts,
       enabled = (level >= 3);
       break;
 
-    case OPT_LEVELS_3_PLUS_AND_SIZE:
-      enabled = (level >= 3 || size);
+    case OPT_LEVELS_3_PLUS_AND_SPEED_ONLY:
+      enabled = (level >= 3 && !size && !debug);
       break;
 
     case OPT_LEVELS_SIZE:
@@ -524,14 +524,16 @@ static const struct default_options default_options_table[] =
     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_fpredictive_commoning, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_fsplit_paths, NULL, 1 },
-    /* Inlining of functions reducing size is a good idea with -Os
+    /* Inlining of functions is ALWAYS a good idea with -O3
        regardless of them being declared inline.  */
-    { OPT_LEVELS_3_PLUS_AND_SIZE, OPT_finline_functions, NULL, 1 },
+    { OPT_LEVELS_3_PLUS_AND_SPEED_ONLY, OPT_finline_functions, NULL, 1 },
     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_finline_functions_called_once, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_funswitch_loops, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },
+#ifndef TARGET_AMIGA    
     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_vectorize, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_ftree_slp_vectorize, NULL, 1 },
+#endif
     { OPT_LEVELS_3_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_DYNAMIC },
     { OPT_LEVELS_3_PLUS, OPT_fipa_cp_clone, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_ftree_partial_pre, NULL, 1 },
@@ -1024,6 +1026,11 @@ wrap_help (const char *help,
 	    {
 	      if (i >= room && len != remaining)
 		break;
+	      if (help[i] == '\n')
+		{
+		  len = i;
+		  break;
+		}
 	      if (help[i] == ' ')
 		len = i;
 	      else if ((help[i] == '-' || help[i] == '/')
@@ -1035,7 +1042,7 @@ wrap_help (const char *help,
 
       printf ("  %-*.*s %.*s\n", col_width, item_width, item, len, help);
       item_width = 0;
-      while (help[len] == ' ')
+      while (help[len] == ' ' || help[len] == '\n')
 	len++;
       help += len;
       remaining -= len;
diff --git a/gcc/passes.c b/gcc/passes.c
index e8961811124..1d53bb23b1b 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -2269,6 +2269,29 @@ override_gate_status (opt_pass *pass, tree func, bool gate_status)
 }
 
 
+void dump_insns(char const * name)
+{
+  rtx_insn *insn, *next;
+  fprintf(stderr, "====================================\npass: %s\n", name);
+  for (insn = get_insns(); insn; insn = next)
+    {
+      next = NEXT_INSN(insn);
+	    debug_rtx(insn);
+#if 0
+      if (NONJUMP_INSN_P (insn))
+	{
+	  rtx set= single_set (insn);
+	  if (!set)
+	    continue;
+
+	  if (amiga_is_const_pic_ref(SET_SRC(set)) && MEM_P(SET_DEST(set)))
+	    debug_rtx(insn);
+	}
+#endif
+    }
+}
+
+
 /* Execute PASS. */
 
 bool
@@ -2278,6 +2301,9 @@ execute_one_pass (opt_pass *pass)
 
   bool gate_status;
 
+  if (string_bbb_opts && strchr (string_bbb_opts, 'Y'))
+    dump_insns(pass->name);
+
   /* IPA passes are executed on whole program, so cfun should be NULL.
      Other passes need function context set.  */
   if (pass->type == SIMPLE_IPA_PASS || pass->type == IPA_PASS)
diff --git a/gcc/passes.def b/gcc/passes.def
index 7db9c9577cf..61d0e4d4737 100644
--- a/gcc/passes.def
+++ b/gcc/passes.def
@@ -386,6 +386,7 @@ along with GCC; see the file COPYING3.  If not see
   NEXT_PASS (pass_gen_hsail);
 
   NEXT_PASS (pass_expand);
+  NEXT_PASS (pass_bbb_baserel);
 
   NEXT_PASS (pass_rest_of_compilation);
   PUSH_INSERT_PASSES_WITHIN (pass_rest_of_compilation)
@@ -458,6 +459,7 @@ along with GCC; see the file COPYING3.  If not see
 	  NEXT_PASS (pass_cprop_hardreg);
 	  NEXT_PASS (pass_fast_rtl_dce);
 	  NEXT_PASS (pass_reorder_blocks);
+	  NEXT_PASS (pass_bbb_optimizations);
 	  NEXT_PASS (pass_branch_target_load_optimize2);
 	  NEXT_PASS (pass_leaf_regs);
 	  NEXT_PASS (pass_split_before_sched2);
diff --git a/gcc/recog.c b/gcc/recog.c
index 92b2aa31a77..7faa617fe04 100644
--- a/gcc/recog.c
+++ b/gcc/recog.c
@@ -1356,6 +1356,12 @@ memory_operand (rtx op, machine_mode mode)
   if (mode != VOIDmode && GET_MODE (op) != mode)
     return 0;
 
+#ifdef TARGET_AMIGA
+  /* SBF: allow direct mem ref to a4. */
+  if (MEM_P(op) && amiga_is_const_pic_ref(XEXP(op, 0)))
+    return true;
+#endif
+
   inner = op;
   if (GET_CODE (inner) == SUBREG)
     inner = SUBREG_REG (inner);
@@ -3252,6 +3258,7 @@ peep2_attempt (basic_block bb, rtx_insn *insn, int match_len, rtx_insn *attempt)
   /* If we are splitting an RTX_FRAME_RELATED_P insn, do not allow it to
      match more than one insn, or to be split into more than one insn.  */
   old_insn = peep2_insn_data[peep2_current].insn;
+
   if (RTX_FRAME_RELATED_P (old_insn))
     {
       bool any_note = false;
diff --git a/gcc/regrename.c b/gcc/regrename.c
old mode 100644
new mode 100755
index 9643f328ea3..1ed6557ee71
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -374,44 +374,45 @@ find_rename_reg (du_head_p this_head, enum reg_class super_class,
     = (enum reg_class) targetm.preferred_rename_class (super_class);
 
   /* Pick and check the register from the tied chain iff the tied chain
-     is not renamed.  */
+   is not renamed.  */
   if (this_head->tied_chain && !this_head->tied_chain->renamed
       && check_new_reg_p (old_reg, this_head->tied_chain->regno,
 			  this_head, *unavailable))
     return this_head->tied_chain->regno;
 
   /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass
-     over registers that belong to PREFERRED_CLASS and try to find the
-     best register within the class.  If that failed, we iterate in
-     the second pass over registers that don't belong to the class.
-     If PREFERRED_CLASS is NO_REGS, we iterate over all registers in
-     ascending order without any preference.  */
+   over registers that belong to PREFERRED_CLASS and try to find the
+   best register within the class.  If that failed, we iterate in
+   the second pass over registers that don't belong to the class.
+   If PREFERRED_CLASS is NO_REGS, we iterate over all registers in
+   ascending order without any preference.  */
   has_preferred_class = (preferred_class != NO_REGS);
   for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)
     {
       int new_reg;
-      for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)
-	{
-	  if (has_preferred_class
+  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)
+    {
+      if (has_preferred_class
 	      && (pass == 0)
 	      != TEST_HARD_REG_BIT (reg_class_contents[preferred_class],
-				    new_reg))
-	    continue;
+				   new_reg))
+	continue;
 
-	  if (!check_new_reg_p (old_reg, new_reg, this_head, *unavailable))
-	    continue;
+      if (!check_new_reg_p (old_reg, new_reg, this_head, *unavailable))
+	continue;
 
-	  if (!best_rename)
-	    return new_reg;
+      if (!best_rename)
+	return new_reg;
 
-	  /* In the first pass, we force the renaming of registers that
-	     don't belong to PREFERRED_CLASS to registers that do, even
-	     though the latters were used not very long ago.  */
-	  if ((pass == 0
+      /* In the first pass, we force the renaming of registers that
+       don't belong to PREFERRED_CLASS to registers that do, even
+       though the latters were used not very long ago.
+       Also use a register if no best_new_reg was found till now  */
+	  if (((pass == 0 || !has_preferred_class)
 	      && !TEST_HARD_REG_BIT (reg_class_contents[preferred_class],
 				     best_new_reg))
 	      || tick[best_new_reg] > tick[new_reg])
-	    best_new_reg = new_reg;
+	  best_new_reg = new_reg;
 	}
       if (pass == 0 && best_new_reg != old_reg)
 	break;
@@ -897,7 +898,7 @@ regrename_analyze (bitmap bb_mask)
 	      if (!range_overlaps_hard_reg_set_p (live, chain->regno,
 						  chain->nregs))
 		continue;
-	      
+
 	      n_succs_used++;
 
 	      dest_ri = (struct bb_rename_info *)e->dest->aux;
@@ -921,7 +922,7 @@ regrename_analyze (bitmap bb_mask)
 			  printed = true;
 			  fprintf (dump_file,
 				   "  merging chains %d (->%d) and %d (->%d) [%s]\n",
-				   k, incoming_chain->id, j, chain->id, 
+				   k, incoming_chain->id, j, chain->id,
 				   reg_names[incoming_chain->regno]);
 			}
 
@@ -954,7 +955,7 @@ regrename_analyze (bitmap bb_mask)
    numbering in its subpatterns.  */
 
 bool
-regrename_do_replace (struct du_head *head, int reg)
+regrename_do_replace (struct du_head *head, int regno)
 {
   struct du_chain *chain;
   unsigned int base_regno = head->regno;
@@ -962,19 +963,20 @@ regrename_do_replace (struct du_head *head, int reg)
 
   for (chain = head->first; chain; chain = chain->next_use)
     {
-      unsigned int regno = ORIGINAL_REGNO (*chain->loc);
-      struct reg_attrs *attr = REG_ATTRS (*chain->loc);
-      int reg_ptr = REG_POINTER (*chain->loc);
+      unsigned int orig_regno = ORIGINAL_REGNO(*chain->loc);
+      struct reg_attrs *attr = REG_ATTRS(*chain->loc);
+      int reg_ptr = REG_POINTER(*chain->loc);
 
       if (DEBUG_INSN_P (chain->insn) && REGNO (*chain->loc) != base_regno)
-	validate_change (chain->insn, &(INSN_VAR_LOCATION_LOC (chain->insn)),
-			 gen_rtx_UNKNOWN_VAR_LOC (), true);
+	validate_change (chain->insn, &(INSN_VAR_LOCATION_LOC(chain->insn)),
+	gen_rtx_UNKNOWN_VAR_LOC (),
+			 true);
       else
 	{
-	  validate_change (chain->insn, chain->loc, 
-			   gen_raw_REG (GET_MODE (*chain->loc), reg), true);
-	  if (regno >= FIRST_PSEUDO_REGISTER)
-	    ORIGINAL_REGNO (*chain->loc) = regno;
+	  validate_change (chain->insn, chain->loc,
+			   gen_raw_REG (GET_MODE(*chain->loc), regno), true);
+	  if (orig_regno >= FIRST_PSEUDO_REGISTER)
+	    ORIGINAL_REGNO (*chain->loc) = orig_regno;
 	  REG_ATTRS (*chain->loc) = attr;
 	  REG_POINTER (*chain->loc) = reg_ptr;
 	}
@@ -983,10 +985,29 @@ regrename_do_replace (struct du_head *head, int reg)
   if (!apply_change_group ())
     return false;
 
-  mode = GET_MODE (*head->first->loc);
+  mode = GET_MODE(*head->first->loc);
   head->renamed = 1;
-  head->regno = reg;
-  head->nregs = hard_regno_nregs[reg][mode];
+  head->regno = regno;
+  head->nregs = hard_regno_nregs[regno][mode];
+
+  /* SBF: also update the current df info, move from base_regno -> regno. */
+  if (base_regno < FIRST_PSEUDO_REGISTER && regno < FIRST_PSEUDO_REGISTER)
+    for (chain = head->first; chain; chain = chain->next_use)
+      {
+	if (DEBUG_INSN_P (chain->insn) && VAR_LOC_UNKNOWN_P(INSN_VAR_LOCATION_LOC(chain->insn)))
+	  continue;
+	/* undo regno patch - will be patched again */
+	if (REGNO (*chain->loc) == regno)
+	  SET_REGNO(*chain->loc, base_regno);
+	df_ref_change_reg_with_loc (*chain->loc, regno);
+
+	SET_REGNO(*chain->loc, regno);
+      }
+
+  /* Mark the old regno as no longer used. */
+  if (!df->hard_regs_live_count[base_regno])
+    df_set_regs_ever_live (base_regno, false);
+
   return true;
 }
 
@@ -1912,7 +1933,6 @@ const pass_data pass_data_regrename =
   0, /* todo_flags_start */
   TODO_df_finish, /* todo_flags_finish */
 };
-
 class pass_regrename : public rtl_opt_pass
 {
 public:
@@ -1923,7 +1943,7 @@ public:
   /* opt_pass methods: */
   virtual bool gate (function *)
     {
-      return (optimize > 0 && (flag_rename_registers));
+      return (optimize > 0 && (flag_rename_registers) && !TARGET_AMIGA);
     }
 
   virtual unsigned int execute (function *) { return regrename_optimize (); }
diff --git a/gcc/reload.c b/gcc/reload.c
index 06426d92332..8b82d6e1895 100644
--- a/gcc/reload.c
+++ b/gcc/reload.c
@@ -6248,6 +6248,40 @@ subst_reloads (rtx_insn *insn)
     {
       struct replacement *r = &replacements[i];
       rtx reloadreg = rld[r->what].reg_rtx;
+
+#ifdef TARGET_AMIGA
+      if (!reloadreg && !rld[r->what].optional && rld[r->what].rclass == ADDR_REGS)
+      {
+    	  rtx a = *r->where;
+    	  const char *fmt = GET_RTX_FORMAT(GET_CODE(a));
+
+    	  while (!REG_P(a) && *fmt == 'e') {
+    		  a = XEXP(a, 0);
+    		  fmt = GET_RTX_FORMAT(GET_CODE(a));
+    	  }
+
+    	  if (REG_P(a) && REGNO(a) < FIRST_PSEUDO_REGISTER) {
+    		  extern rtx_insn *old_prev;
+    		  unsigned regno = REGNO(a);
+    		  unsigned swapregno = CALL_P(insn) ? 13 : 15;
+    		  machine_mode m = GET_MODE(a);
+    		  rtx from = gen_rtx_REG(m, regno);
+    		  rtx to   = gen_rtx_REG(m, swapregno);
+
+    		  rld[r->what].optional = 1;
+
+    		  emit_insn_after (gen_swapsi(from, to), old_prev);
+
+    		  debug_rtx(insn);
+		      validate_replace_rtx_group (from, to, insn);
+    		  debug_rtx(insn);
+
+    		  emit_insn_after  (gen_swapsi(from, to), insn);
+    	  }
+      }
+#endif
+
+
       if (reloadreg)
 	{
 #ifdef DEBUG_RELOAD
@@ -6300,7 +6334,13 @@ subst_reloads (rtx_insn *insn)
 	}
       /* If reload got no reg and isn't optional, something's wrong.  */
       else
-	gcc_assert (rld[r->what].optional);
+      {
+    	  if (!rld[r->what].optional) {
+    		  debug_rtx(insn);
+    		  fprintf(stderr, "no free registers left\n");
+		  gcc_assert (rld[r->what].optional);
+    	  }
+      }
     }
 }
 
diff --git a/gcc/reload1.c b/gcc/reload1.c
index c2800f8cb79..f270ca19ea0 100644
--- a/gcc/reload1.c
+++ b/gcc/reload1.c
@@ -2012,9 +2012,14 @@ find_reload_regs (struct insn_chain *chain)
 	  {
 	    if (dump_file)
 	      fprintf (dump_file, "reload failure for reload %d\n", r);
+
+#ifdef TARGET_AMIGA
+	    rld[r].in = 0; // mark as optional - bbb pass will fix this later
+#else
 	    spill_failure (chain->insn, rld[r].rclass);
 	    failure = 1;
 	    return;
+#endif
 	  }
     }
 
@@ -4546,6 +4551,10 @@ fixup_eh_region_note (rtx_insn *insn, rtx_insn *prev, rtx_insn *next)
    We update these for the reloads that we perform,
    as the insns are scanned.  */
 
+#if AUTO_INC_DEC
+rtx_insn *old_prev;
+#endif
+
 static void
 reload_as_needed (int live_known)
 {
@@ -4574,7 +4583,7 @@ reload_as_needed (int live_known)
       rtx_insn *insn = chain->insn;
       rtx_insn *old_next = NEXT_INSN (insn);
 #if AUTO_INC_DEC
-      rtx_insn *old_prev = PREV_INSN (insn);
+      old_prev = PREV_INSN (insn);
 #endif
 
       if (will_delete_init_insn_p (insn))
diff --git a/gcc/system.h b/gcc/system.h
old mode 100644
new mode 100755
index 984f302fbc9..f7d9277d9a8
--- a/gcc/system.h
+++ b/gcc/system.h
@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see
    redefs are pointless here so we can override them.  */
 
 #undef fopen 
+#undef fdopen
 #undef freopen 
 
 #define fopen(PATH, MODE) fopen_unlocked (PATH, MODE)
diff --git a/gcc/target-def.h b/gcc/target-def.h
index ec5e09e568e..d4f586f589e 100644
--- a/gcc/target-def.h
+++ b/gcc/target-def.h
@@ -47,7 +47,7 @@
 #define TARGET_ASM_UNALIGNED_TI_OP NULL
 #endif /* OBJECT_FORMAT_ELF */
 
-#if !defined(TARGET_ASM_CONSTRUCTOR) && !defined(USE_COLLECT2)
+#if !defined(TARGET_ASM_CONSTRUCTOR) && (!defined(USE_COLLECT2) || defined(TARGET_AMIGA))
 # ifdef CTORS_SECTION_ASM_OP
 #  define TARGET_ASM_CONSTRUCTOR default_ctor_section_asm_out_constructor
 # else
@@ -59,7 +59,7 @@
 # endif
 #endif
 
-#if !defined(TARGET_ASM_DESTRUCTOR) && !defined(USE_COLLECT2)
+#if !defined(TARGET_ASM_DESTRUCTOR) && (!defined(USE_COLLECT2) || defined(TARGET_AMIGA))
 # ifdef DTORS_SECTION_ASM_OP
 #  define TARGET_ASM_DESTRUCTOR default_dtor_section_asm_out_destructor
 # else
@@ -108,3 +108,11 @@
 #include "hooks.h"
 #include "targhooks.h"
 #include "insn-target-def.h"
+
+#ifndef TARGET_GCC_EXCEPT_TABLE
+#define TARGET_GCC_EXCEPT_TABLE ".gcc_except_table"
+#endif
+
+#ifndef TARGET_GCC_EXCEPT_TABLE_S
+#define TARGET_GCC_EXCEPT_TABLE_S ".gcc_except_table.%s"
+#endif
diff --git a/gcc/toplev.c b/gcc/toplev.c
index d6f6c74ffbc..1c1b1f4b029 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -207,6 +207,19 @@ get_src_pwd (void)
       src_pwd = getpwd ();
       if (!src_pwd)
 	src_pwd = ".";
+#ifdef __CYGWIN__
+      else
+	  if (strstr(src_pwd, "/cygdrive/") == src_pwd)
+	    {
+	      int l = strlen(&src_pwd[11]) + 1;
+	      char * p = concat(src_pwd, "", NULL);
+	      p[0] = src_pwd[10];
+	      p[1] = ':';
+	      memcpy(&p[2], &src_pwd[11], l);
+	      src_pwd = p;
+	    }
+#endif
+
     }
 
    return src_pwd;
diff --git a/gcc/tree-chkp.c b/gcc/tree-chkp.c
index 28dac22add6..16aa71ca4ee 100644
--- a/gcc/tree-chkp.c
+++ b/gcc/tree-chkp.c
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "backend.h"
+#include "tm_p.h"
 #include "target.h"
 #include "rtl.h"
 #include "tree.h"
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 5f5055d3a6c..76c0996850f 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -590,6 +590,8 @@ extern rtl_opt_pass *make_pass_branch_target_load_optimize2 (gcc::context
 							     *ctxt);
 extern rtl_opt_pass *make_pass_leaf_regs (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_split_before_sched2 (gcc::context *ctxt);
+extern rtl_opt_pass *make_pass_bbb_optimizations (gcc::context *ctxt);
+extern rtl_opt_pass *make_pass_bbb_baserel (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_compare_elim_after_reload (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_sched2 (gcc::context *ctxt);
 extern rtl_opt_pass *make_pass_stack_regs (gcc::context *ctxt);
diff --git a/gcc/tree-ssa-loop-ch.c b/gcc/tree-ssa-loop-ch.c
index 907525627d0..cdf2cb77266 100644
--- a/gcc/tree-ssa-loop-ch.c
+++ b/gcc/tree-ssa-loop-ch.c
@@ -59,7 +59,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,
      be true, since quite often it is possible to verify that the condition is
      satisfied in the first iteration and therefore to eliminate it.  Jump
      threading handles these cases now.  */
-  if (optimize_loop_for_size_p (loop))
+  if (flag_loop_size_optimize == 1 || (flag_loop_size_optimize && optimize_loop_for_size_p (loop)))
     return false;
 
   gcc_assert (EDGE_COUNT (header->succs) > 0);
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 559e8df7c95..8ebe505c269 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -4028,6 +4028,9 @@ eliminate_dom_walker::before_dom_children (basic_block b)
       tree sprime = NULL_TREE;
       gimple *stmt = gsi_stmt (gsi);
       tree lhs = gimple_get_lhs (stmt);
+
+      tree rhs = gimple_assign_rhs1 (stmt);
+
       if (lhs && TREE_CODE (lhs) == SSA_NAME
 	  && !gimple_has_volatile_ops (stmt)
 	  /* See PR43491.  Do not replace a global register variable when
@@ -4038,9 +4041,12 @@ eliminate_dom_walker::before_dom_children (basic_block b)
 	     be ensured by not value-numbering them the same but treating
 	     them like volatiles?  */
 	  && !(gimple_assign_single_p (stmt)
-	       && (TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL
-		   && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt))
-		   && is_global_var (gimple_assign_rhs1 (stmt)))))
+	       && (TREE_CODE (rhs) == VAR_DECL
+		   && DECL_HARD_REGISTER (rhs)
+		   && is_global_var (rhs)))
+	  // SBF: BIT_FIELD_REFs are sometimes mistreaded
+	  && !(rhs && TREE_CODE (rhs) == BIT_FIELD_REF)
+	  )
 	{
 	  sprime = eliminate_avail (lhs);
 	  if (!sprime)
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
index d7997688ec0..4117b4bc37f 100644
--- a/gcc/tree-tailcall.c
+++ b/gcc/tree-tailcall.c
@@ -387,6 +387,42 @@ propagate_through_phis (tree var, edge e)
   return var;
 }
 
+/**
+ * Return true if register params are used.
+ *
+ * The Amiga implementation is also checking if only scratch regs d0/d1/a0/a1 are used.
+ */
+static
+bool func_is_using_regparms(const_tree func)
+{
+#ifdef TARGET_AMIGA
+  tree attrs = TYPE_ATTRIBUTES(TREE_TYPE(func));
+  if (attrs)
+    {
+      tree attr;
+      if (0 != (attr = lookup_attribute ("asmregs", attrs)))
+	{
+	  // this is a string containing all register names like "d0a2d3a4"
+	  char const * p = IDENTIFIER_POINTER(TREE_VALUE(attr));
+	  while (*p)
+	    {
+	      if (*p >= '2' && *p <= '7')
+		return true;
+	      ++p;
+	    }
+	}
+      if (0 != (attr = lookup_attribute ("regparm", attrs)))
+	return TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(attr))) > 2;
+      if (amigaos_regparm > 2 && !lookup_attribute ("stkparm", attrs))
+	return true;
+    }
+  else if (amigaos_regparm > 2)
+    return true;
+#endif
+  return false;
+}
+
+
 /* Finds tailcalls falling into basic block BB. The list of found tailcalls is
    added to the start of RET.  */
 
@@ -461,6 +497,10 @@ find_tail_calls (basic_block bb, struct tailcall **ret)
   /* We found the call, check whether it is suitable.  */
   tail_recursion = false;
   func = gimple_call_fndecl (call);
+
+  if (func && func_is_using_regparms(func))
+    return;
+
   if (func
       && !DECL_BUILT_IN (func)
       && recursive_call_p (current_function_decl, func))
diff --git a/gcc/tree.c b/gcc/tree.c
index e25cbb700c2..42c34e2349c 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -4803,6 +4803,29 @@ build_decl_attribute_variant (tree ddecl, tree attribute)
   return ddecl;
 }
 
+#ifdef TARGET_AMIGA
+/**
+ * Filter __chip__ and __fast__ storage attributes from type's attributes.
+ */
+tree strip_amiga_storage_attrs(tree t1)
+{
+	tree filtered = NULL;
+
+    for (;t1; t1 = TREE_CHAIN (t1))
+	{
+    	  char const * name = IDENTIFIER_POINTER(TREE_PURPOSE (t1));
+    	  if (0 == strcmp("__chip__", name) || 0 == strcmp("__far__", name))
+    	    continue;
+
+	  tree a1 = copy_node (t1);
+	  TREE_CHAIN (a1) = filtered;
+	  filtered = a1;
+	}
+
+	return filtered;
+}
+#endif
+
 /* Return a type like TTYPE except that its TYPE_ATTRIBUTE
    is ATTRIBUTE and its qualifiers are QUALS.
 
@@ -4811,7 +4834,11 @@ build_decl_attribute_variant (tree ddecl, tree attribute)
 tree
 build_type_attribute_qual_variant (tree ttype, tree attribute, int quals)
 {
-  if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))
+  if (! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute)
+#ifdef TARGET_AMIGA
+  && ! attribute_list_equal (TYPE_ATTRIBUTES (ttype), strip_amiga_storage_attrs(attribute))
+#endif
+  )
     {
       inchash::hash hstate;
       tree ntype;
diff --git a/gcc/var-tracking.c b/gcc/var-tracking.c
index 9f09d30b1f9..ab9c0117b07 100644
--- a/gcc/var-tracking.c
+++ b/gcc/var-tracking.c
@@ -92,10 +92,10 @@
 #include "target.h"
 #include "rtl.h"
 #include "tree.h"
+#include "tm_p.h"
 #include "cfghooks.h"
 #include "alloc-pool.h"
 #include "tree-pass.h"
-#include "tm_p.h"
 #include "insn-config.h"
 #include "regs.h"
 #include "emit-rtl.h"
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 2e88e71c25d..2410650689e 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -252,7 +252,6 @@ get_unnamed_section (unsigned int flags, void (*callback) (const void *),
   sect->unnamed.callback = callback;
   sect->unnamed.data = data;
   sect->unnamed.next = unnamed_sections;
-
   unnamed_sections = sect;
   return sect;
 }
@@ -1805,7 +1804,18 @@ assemble_start_function (tree decl, const char *fnname)
 
       maybe_assemble_visibility (decl);
     }
-
+#ifdef TARGET_AMIGA
+  else if (profile_flag)
+    {
+      char *p;
+      char * sfnname = concat("__static__", fnname, "__", DECL_SOURCE_FILE (decl), "__", dump_base_name, NULL);
+      for (p = sfnname; *p; ++p)
+        if (*p < '0' || (*p > '9' && *p < '@') || (*p > 'Z' && *p != '_' && *p < 'a') || *p > 'z')
+          *p = '.';
+      default_globalize_label(asm_out_file, sfnname);
+      ASM_OUTPUT_FUNCTION_LABEL (asm_out_file, sfnname, current_function_decl);
+    }
+#endif
   if (DECL_PRESERVE_P (decl))
     targetm.asm_out.mark_decl_preserved (fnname);
 
@@ -2228,11 +2238,17 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,
   else
     {
       /* Special-case handling of vtv comdat sections.  */
-      if (sect->named.name
+      if ((sect->common.flags & SECTION_STYLE_MASK) == SECTION_NAMED && sect->named.name
 	  && (strcmp (sect->named.name, ".vtable_map_vars") == 0))
 	handle_vtv_comdat_section (sect, decl);
       else
-	switch_to_section (sect);
+	{
+#ifdef TARGET_AMIGA
+	  if ((sect->common.flags & SECTION_STYLE_MASK) == SECTION_NAMED)
+	    sect->named.decl = decl;
+#endif
+	  switch_to_section (sect);
+	}
       if (align > BITS_PER_UNIT)
 	ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));
       assemble_variable_contents (decl, name, dont_output_data);
@@ -4963,7 +4979,7 @@ output_constructor_regular_field (oc_local_state *local)
      if each element has the proper size.  */
   if (local->field != NULL_TREE || local->index != NULL_TREE)
     {
-      if (fieldpos > local->total_bytes)
+      if (fieldpos >= local->total_bytes)
 	{
 	  assemble_zeros (fieldpos - local->total_bytes);
 	  local->total_bytes = fieldpos;
@@ -6356,8 +6372,11 @@ default_select_section (tree decl, int reloc,
     }
   else if (TREE_CODE (decl) == CONSTRUCTOR)
     {
-      if (! ((flag_pic && reloc)
-	     || !TREE_READONLY (decl)
+      if (! (
+#ifndef TARGET_AMIGA
+	  (flag_pic && reloc) ||
+#endif
+	     !TREE_READONLY (decl)
 	     || TREE_SIDE_EFFECTS (decl)
 	     || !TREE_CONSTANT (decl)))
 	return readonly_data_section;
diff --git a/gcc/varpool.c b/gcc/varpool.c
index cbbdda41369..7f5385057b9 100644
--- a/gcc/varpool.c
+++ b/gcc/varpool.c
@@ -298,6 +298,9 @@ varpool_node::get_constructor (void)
   struct lto_in_decl_state *decl_state
 	 = lto_get_function_in_decl_state (file_data, decl);
 
+  if (!decl_state)
+    return NULL;
+
   data = lto_get_section_data (file_data, LTO_section_function_body,
 			       name, &len, decl_state->compressed);
   if (!data)
diff --git a/include/libiberty.h b/include/libiberty.h
old mode 100644
new mode 100755
index a9c885fc670..1ca90f65a82
--- a/include/libiberty.h
+++ b/include/libiberty.h
@@ -705,7 +705,9 @@ extern void stack_limit_increase (unsigned long);
    USE_C_ALLOCA yourself.  The canonical autoconf macro C_ALLOCA is
    also set/unset as it is often used to indicate whether code needs
    to call alloca(0).  */
+#ifndef _MSC_VER
 extern void *C_alloca (size_t) ATTRIBUTE_MALLOC;
+#endif
 #undef alloca
 #if GCC_VERSION >= 2000 && !defined USE_C_ALLOCA
 # define alloca(x) __builtin_alloca(x)
@@ -716,6 +718,8 @@ extern void *C_alloca (size_t) ATTRIBUTE_MALLOC;
    char *const libiberty_nptr = (char *const) alloca (libiberty_len); \
    (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len); }))
 #else
+void * C_alloca(unsigned int size);
+
 # define alloca(x) C_alloca(x)
 # undef USE_C_ALLOCA
 # define USE_C_ALLOCA 1
diff --git a/intl/localcharset.c b/intl/localcharset.c
index 8ece6e39f69..990ce27bc46 100644
--- a/intl/localcharset.c
+++ b/intl/localcharset.c
@@ -265,7 +265,7 @@ get_charset_aliases ()
    name.  */
 
 #ifdef STATIC
-STATIC
+//STATIC
 #endif
 const char *
 locale_charset ()
diff --git a/libatomic/config/amigaos/lock/host-config.h b/libatomic/config/amigaos/lock/host-config.h
new file mode 100755
index 00000000000..f1d7f6a58ca
--- /dev/null
+++ b/libatomic/config/amigaos/lock/host-config.h
@@ -0,0 +1,58 @@
+/* Copyright (C) 2014-2016 Free Software Foundation, Inc.
+   Contributed by Kai Tietz <ktietz@redhat.com>.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Included after all more target-specific host-config.h.  */
+
+#ifndef protect_start_end
+# ifdef HAVE_ATTRIBUTE_VISIBILITY
+#  pragma GCC visibility push(hidden)
+# endif
+
+static inline void libat_lock_1 (void *ptr) {
+  libat_lock_n(ptr, 1);
+}
+static inline void libat_unlock_1 (void *ptr) {
+  libat_unlock_n(ptr, 1);
+}
+
+static inline UWORD
+protect_start (void *ptr)
+{
+  libat_lock_1 (ptr);
+  return 0;
+}
+
+static inline void
+protect_end (void *ptr, UWORD dummy UNUSED)
+{
+  libat_unlock_1 (ptr);
+}
+
+# define protect_start_end 1
+# ifdef HAVE_ATTRIBUTE_VISIBILITY
+#  pragma GCC visibility pop
+# endif
+#endif /* protect_start_end */
+
+#include_next <host-config.h>
diff --git a/libatomic/config/amigaos/lock/lock.c b/libatomic/config/amigaos/lock/lock.c
new file mode 100755
index 00000000000..9245429d640
--- /dev/null
+++ b/libatomic/config/amigaos/lock/lock.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2016 Free Software Foundation, Inc.
+   Contributed by Stefan Bebbo Franke <stefan@franke.ms>.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <exec/execbase.h>
+#include <inline/exec.h>
+#include <sys/types.h>
+
+extern struct ExecBase * SysBase;
+
+void
+libat_lock_n (void *ptr, size_t n)
+{
+  Forbid();
+}
+
+void
+libat_unlock_n (void *ptr, size_t n)
+{
+  Permit();
+}
diff --git a/libatomic/configure.tgt b/libatomic/configure.tgt
index eab2765d7fd..20c928161f6 100644
--- a/libatomic/configure.tgt
+++ b/libatomic/configure.tgt
@@ -113,6 +113,10 @@ case "${target}" in
 	config_path="${config_path} linux/arm posix"
 	;;
 
+  *-*-amiga*)
+	config_path="${config_path} amigaos/loadstore amigaos/lock"
+  	;;
+
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly* \
   | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \
diff --git a/libbacktrace/Makefile.in b/libbacktrace/Makefile.in
index 586b6a6eaa1..4f91b312595 100644
--- a/libbacktrace/Makefile.in
+++ b/libbacktrace/Makefile.in
@@ -411,6 +411,9 @@ clean-noinstLTLIBRARIES:
 libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES) 
 	$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)
 
+libbacktrace.dll: libbacktrace.la
+	$(CC) $(patsubst %.lo,%.o,$(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD)) -shared -o $@
+
 clean-checkPROGRAMS:
 	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
 	echo " rm -f" $$list; \
diff --git a/libcpp/Makefile.in b/libcpp/Makefile.in
index a7d782803f7..7aa547724ef 100644
--- a/libcpp/Makefile.in
+++ b/libcpp/Makefile.in
@@ -101,6 +101,10 @@ libcpp.a: $(libcpp_a_OBJS)
 	$(AR) $(ARFLAGS) libcpp.a $(libcpp_a_OBJS)
 	$(RANLIB) libcpp.a
 
+libcpp.dll: $(libcpp_a_OBJS)
+	rm -rf $@
+	$(CXX) -o $@ -shared $(libcpp_a_OBJS) ../libiberty/libiberty.dll ../gcc/libcommon.dll -liconv
+
 # Rules to rebuild the configuration
 
 Makefile: $(srcdir)/Makefile.in config.status
diff --git a/libcpp/lex.c b/libcpp/lex.c
index b789686f1c4..809aa6ef42d 100644
--- a/libcpp/lex.c
+++ b/libcpp/lex.c
@@ -64,6 +64,10 @@ static tokenrun *next_tokenrun (tokenrun *);
 
 static _cpp_buff *new_buff (size_t);
 
+/*
+ * SBF: This flag is set if an asm statement is parsed, to support multiline strings in __asm()
+ */
+int in_assembler_directive;
 
 /* Utility routine:
 
@@ -1063,7 +1067,10 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)
       else if (note->type == 0)
 	/* Already processed in lex_raw_string.  */;
       else
-	abort ();
+	{
+//	  abort ();
+	  printf("ups: note type=%d\n", note->type);
+	}
     }
 }
 
@@ -1875,6 +1882,20 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)
 	break;
       else if (c == '\n')
 	{
+	  /*
+	   *  SBF: allow multi-line strings
+	   *  Ignore the line end and move to next line.
+	   *  Only fail, if there is no next line
+	   */
+	  if (in_assembler_directive)
+	    {
+	      cpp_buffer *buffer = pfile->buffer;
+	      if (buffer->cur < buffer->rlimit)
+		CPP_INCREMENT_LINE (pfile, 0);
+	      buffer->need_line = true;
+	      if (_cpp_get_fresh_line (pfile))
+		  continue;
+	    }
 	  cur--;
 	  /* Unmatched quotes always yield undefined behavior, but
 	     greedy lexing means that what appears to be an unterminated
diff --git a/libdecnumber/Makefile.in b/libdecnumber/Makefile.in
index 75c2c0424e3..da28b72c316 100644
--- a/libdecnumber/Makefile.in
+++ b/libdecnumber/Makefile.in
@@ -87,6 +87,10 @@ libdecnumber.a: $(libdecnumber_a_OBJS)
 	$(AR) $(ARFLAGS) $@ $(libdecnumber_a_OBJS)
 	$(RANLIB) $@
 
+libdecnumber.dll: $(libcpp_a_OBJS)
+	rm -rf $@
+	$(CXX) -o $@ -shared $(libdecnumber_a_OBJS) 
+
 # Rules to rebuild the configuration
 
 Makefile: $(srcdir)/Makefile.in config.status
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index f09b39b0e85..a1cf43a4a68 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -229,8 +229,8 @@ endif
 
 # Options to use when compiling libgcc2.a.
 #
-LIBGCC2_DEBUG_CFLAGS = -g
-LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(HOST_LIBGCC2_CFLAGS) \
+LIBGCC2_DEBUG_CFLAGS = 
+LIBGCC2_CFLAGS = $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(HOST_LIBGCC2_CFLAGS) \
 		 $(LIBGCC2_DEBUG_CFLAGS) -DIN_LIBGCC2 \
 		 -fbuilding-libgcc -fno-stack-protector \
 		 $(INHIBIT_LIBC_CFLAGS)
@@ -284,7 +284,7 @@ INTERNAL_CFLAGS = $(CFLAGS) $(LIBGCC2_CFLAGS) $(HOST_LIBGCC2_CFLAGS) \
 		  $(INCLUDES) @set_have_cc_tls@ @set_use_emutls@
 
 # Options to use when compiling crtbegin/end.
-CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \
+CRTSTUFF_CFLAGS = $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS)  \
   $(NO_PIE_CFLAGS) -finhibit-size-directive -fno-inline -fno-exceptions \
   -fno-zero-initialized-in-bss -fno-toplevel-reorder -fno-tree-vectorize \
   -fbuilding-libgcc -fno-stack-protector $(FORCE_EXPLICIT_EH_REGISTRY) \
diff --git a/libgcc/config.host b/libgcc/config.host
index 6f6810cf0ba..7117e7983b5 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -816,6 +816,11 @@ m32r-*-linux*)
 m32rle-*-linux*)
 	tmake_file="$tmake_file m32r/t-linux t-fdpbit"
 	;;
+m68k-*-amiga*)
+	tmake_file="$tmake_file m68k/t-glue m68k/t-floatlib soft-fp"
+	CFLAGS="-Os"
+#	tmake_file="$tmake_file m68k/t-glue soft-fp"
+	;;
 m68k-*-elf* | fido-*-elf)
 	tmake_file="$tmake_file m68k/t-floatlib"
 	;;
diff --git a/libgcc/config/m68k/cxxglue.c b/libgcc/config/m68k/cxxglue.c
new file mode 100644
index 00000000000..619750d66d7
--- /dev/null
+++ b/libgcc/config/m68k/cxxglue.c
@@ -0,0 +1,22 @@
+#include "stabs.h"
+
+extern void __register_frame_info(void *, void *);
+extern void * _EH_FRAME_OBJECTS__[];
+extern void * _EH_FRAME_BEGINS__[];
+
+void __init_eh() {
+    void ** frame = _EH_FRAME_BEGINS__;
+    void ** object = _EH_FRAME_OBJECTS__;
+    
+    int n = *(int *)frame++;
+    int m = *(int *)object++;
+    if (n != m)
+	    return;
+    
+    while (n--) {
+	    __register_frame_info(*frame++, *object++);
+    }
+}
+
+ADD2INIT(__init_eh,-5);
+
diff --git a/libgcc/config/m68k/fpgnulib.c b/libgcc/config/m68k/fpgnulib.c
index fe41edf26aa..bd42ffb6616 100644
--- a/libgcc/config/m68k/fpgnulib.c
+++ b/libgcc/config/m68k/fpgnulib.c
@@ -49,6 +49,15 @@
 ** in with -msoft-float.
 */
 
+/* Prototypes for the above in case we use them.  */
+double __floatunsidf (unsigned long);
+double __floatsidf (long);
+float __floatsisf (long);
+double __extendsfdf2 (float);
+float __truncdfsf2 (double);
+long __fixdfsi (double);
+long __fixsfsi (float);
+
 /* the following deal with IEEE single-precision numbers */
 #define EXCESS		126L
 #define SIGNBIT		0x80000000L
@@ -105,6 +114,7 @@ union long_double_long
 
 #ifndef EXTFLOAT
 
+#ifdef __UNORDSF2
 int
 __unordsf2(float a, float b)
 {
@@ -118,7 +128,9 @@ __unordsf2(float a, float b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef __UNORDDF2
 int
 __unorddf2(double a, double b)
 {
@@ -134,7 +146,9 @@ __unorddf2(double a, double b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef __FLOATUNSIDF
 /* convert unsigned int to double */
 double
 __floatunsidf (unsigned long a1)
@@ -167,7 +181,9 @@ __floatunsidf (unsigned long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef __FLOATSIDF
 /* convert int to double */
 double
 __floatsidf (long a1)
@@ -213,7 +229,9 @@ __floatsidf (long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef __FLOATUNSISF
 /* convert unsigned int to float */
 float
 __floatunsisf (unsigned long l)
@@ -221,7 +239,10 @@ __floatunsisf (unsigned long l)
   double foo = __floatunsidf (l);
   return foo;
 }
+#endif
 
+
+#ifdef __FLOATSISF
 /* convert int to float */
 float
 __floatsisf (long l)
@@ -229,7 +250,10 @@ __floatsisf (long l)
   double foo = __floatsidf (l);
   return foo;
 }
+#endif
+
 
+#ifdef __EXTENDSFDF2
 /* convert float to double */
 double
 __extendsfdf2 (float a1)
@@ -268,7 +292,9 @@ __extendsfdf2 (float a1)
 	
   return dl.d;
 }
+#endif
 
+#ifdef __TRUNCDFSF2
 /* convert double to float */
 float
 __truncdfsf2 (double a1)
@@ -336,7 +362,9 @@ __truncdfsf2 (double a1)
   fl.l = PACK (SIGND (dl1), exp, mant);
   return (fl.f);
 }
+#endif
 
+#ifdef __FIXDFSI
 /* convert double to int */
 long
 __fixdfsi (double a1)
@@ -368,7 +396,9 @@ __fixdfsi (double a1)
 
   return (SIGND (dl1) ? -l : l);
 }
+#endif
 
+#ifdef __FIXSFSI
 /* convert float to int */
 long
 __fixsfsi (float a1)
@@ -376,6 +406,7 @@ __fixsfsi (float a1)
   double foo = a1;
   return __fixdfsi (foo);
 }
+#endif
 
 #else /* EXTFLOAT */
 
@@ -387,14 +418,7 @@ __fixsfsi (float a1)
 
    We assume all numbers are normalized, don't do any rounding, etc.  */
 
-/* Prototypes for the above in case we use them.  */
-double __floatunsidf (unsigned long);
-double __floatsidf (long);
-float __floatsisf (long);
-double __extendsfdf2 (float);
-float __truncdfsf2 (double);
-long __fixdfsi (double);
-long __fixsfsi (float);
+#if !defined(EXTFLOATCMP)
 
 int
 __unordxf2(long double a, long double b)
@@ -445,38 +469,6 @@ __extenddfxf2 (double d)
   return ldl.ld;
 }
 
-/* convert long double to double */
-double
-__truncxfdf2 (long double ld)
-{
-  register long exp;
-  register union double_long dl;
-  register union long_double_long ldl;
-
-  ldl.ld = ld;
-  /*printf ("xfdf in: %s\n", dumpxf (ld));*/
-
-  dl.l.upper = SIGNX (ldl);
-  if ((ldl.l.upper & ~SIGNBIT) == 0 && !ldl.l.middle && !ldl.l.lower)
-    {
-      dl.l.lower = 0;
-      return dl.d;
-    }
-
-  exp = EXPX (ldl) - EXCESSX + EXCESSD;
-  /* ??? quick and dirty: keep `exp' sane */
-  if (exp >= EXPDMASK)
-    exp = EXPDMASK - 1;
-  dl.l.upper |= exp << (32 - (EXPDBITS + 1));
-  /* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
-  dl.l.upper |= (ldl.l.middle & MANTXMASK) >> (EXPDBITS + 1 - 1);
-  dl.l.lower = (ldl.l.middle & MANTXMASK) << (32 - (EXPDBITS + 1 - 1));
-  dl.l.lower |= ldl.l.lower >> (EXPDBITS + 1 - 1);
-
-  /*printf ("xfdf out: %g\n", dl.d);*/
-  return dl.d;
-}
-
 /* convert a float to a long double */
 long double
 __extendsfxf2 (float f)
@@ -549,6 +541,8 @@ __negxf2 (long double x1)
   return - (double) x1;
 }
 
+#else
+
 long
 __cmpxf2 (long double x1, long double x2)
 {
@@ -591,5 +585,38 @@ __gexf2 (long double x1, long double x2)
   return __cmpdf2 ((double) x1, (double) x2);
 }
 
+/* convert long double to double */
+double
+__truncxfdf2 (long double ld)
+{
+  register long exp;
+  register union double_long dl;
+  register union long_double_long ldl;
+
+  ldl.ld = ld;
+  /*printf ("xfdf in: %s\n", dumpxf (ld));*/
+
+  dl.l.upper = SIGNX (ldl);
+  if ((ldl.l.upper & ~SIGNBIT) == 0 && !ldl.l.middle && !ldl.l.lower)
+    {
+      dl.l.lower = 0;
+      return dl.d;
+    }
+
+  exp = EXPX (ldl) - EXCESSX + EXCESSD;
+  /* ??? quick and dirty: keep `exp' sane */
+  if (exp >= EXPDMASK)
+    exp = EXPDMASK - 1;
+  dl.l.upper |= exp << (32 - (EXPDBITS + 1));
+  /* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
+  dl.l.upper |= (ldl.l.middle & MANTXMASK) >> (EXPDBITS + 1 - 1);
+  dl.l.lower = (ldl.l.middle & MANTXMASK) << (32 - (EXPDBITS + 1 - 1));
+  dl.l.lower |= ldl.l.lower >> (EXPDBITS + 1 - 1);
+
+  /*printf ("xfdf out: %g\n", dl.d);*/
+  return dl.d;
+}
+#endif /* EXTFLOATCMP */
+
 #endif /* !__mcoldfire__ */
 #endif /* EXTFLOAT */
diff --git a/libgcc/config/m68k/gmon.c b/libgcc/config/m68k/gmon.c
new file mode 100755
index 00000000000..22bf62451da
--- /dev/null
+++ b/libgcc/config/m68k/gmon.c
@@ -0,0 +1,432 @@
+/*-
+ * Copyright (c) 1991 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#pragma GCC push_options
+#pragma GCC optimize ("-O2")
+
+#include <unistd.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/fcntl.h>
+
+#include "gmon.h"
+
+#include "stabs.h"
+
+#include <exec/memory.h>
+#include <exec/interrupts.h>
+#include <dos/dos.h>
+#include <hardware/custom.h>
+#include <hardware/intbits.h>
+#include <proto/exec.h>
+#include <stdio.h>
+
+void _monstartup(void);
+void _moncleanup(void);
+__saveallregs void mcount(void);
+int profil(char *buf, size_t bufsiz,
+                  size_t offset, unsigned int scale);
+
+struct profile_data {
+  unsigned short *data;
+  size_t count;
+  size_t offset;
+};
+int VertBServer(struct profile_data * p __asm("a1"));
+
+
+extern const char const _stext;
+extern const char const _etext;
+
+#if 0
+asm ("
+	.globl	mcount
+mcount:	movel	a1,-(sp)	| Save A1 as it might be used to store the
+	bsr	__mcount	| address of a structure
+	movel	(sp)+,a1
+	rts
+");
+#endif
+
+void moncontrol(int mode);
+
+static unsigned int	*store_last_pc;
+static unsigned int	dummy;
+    /*
+     *	froms is actually a bunch of unsigned shorts indexing tos
+     */
+static int		profiling = 3;
+static unsigned short	*froms;
+static struct tostruct	*tos = 0;
+static long		tolimit = 0;
+static char		*s_lowpc = 0;
+static char		*s_highpc = 0;
+static unsigned long	s_textsize = 0;
+
+static int	ssiz;
+static char	*sbuf;
+static int	s_scale;
+    /* see profil(2) where this is describe (incorrectly) */
+#define		SCALE_1_TO_1	0x10000L
+
+#define	MSG "No space for profiling buffer(s)\n"
+
+static inline void *
+alloc(int s)
+{
+  void *res = malloc (s);
+  if (res)
+    bzero (res, s);
+  return res;
+}
+
+void _monstartup(void)
+{
+    int			monsize;
+    char		*buffer;
+    register int	o;
+
+    char *lowpc;
+    char *highpc;
+
+	/*
+	 *	round lowpc and highpc to multiples of the density we're using
+	 *	so the rest of the scaling (here and in gprof) stays in ints.
+	 */
+    lowpc = (char *)
+	    ROUNDDOWN((unsigned)&_stext, HISTFRACTION*sizeof(HISTCOUNTER));
+    s_lowpc = lowpc;
+    highpc = (char *)
+	    ROUNDUP((unsigned)&_etext, HISTFRACTION*sizeof(HISTCOUNTER));
+    s_highpc = highpc;
+    s_textsize = highpc - lowpc;
+    monsize = (s_textsize / HISTFRACTION)*sizeof(short) + sizeof(struct phdr);
+    buffer = alloc( monsize );
+    if ( buffer == 0 ) {
+	write( 2 , MSG , sizeof(MSG) );
+	return;
+    }
+    froms = (unsigned short *) alloc ( s_textsize / HASHFRACTION );
+    if ( froms == 0 ) {
+	write( 2 , MSG , sizeof(MSG) );
+	froms = 0;
+	return;
+    }
+    tolimit = s_textsize * ARCDENSITY / 100;
+    if ( tolimit < MINARCS ) {
+	tolimit = MINARCS;
+    } else if ( tolimit > 65534 ) {
+	tolimit = 65534;
+    }
+    tos = (struct tostruct *) alloc( tolimit * sizeof( struct tostruct ) );
+    if ( tos == 0 ) {
+	write( 2 , MSG , sizeof(MSG) );
+	froms = 0;
+	tos = 0;
+	return;
+    }
+    tos[0].link = 0;
+    sbuf = buffer;
+    ssiz = monsize;
+    ( (struct phdr *) buffer ) -> lpc = (void *)(lowpc - (&_stext - 0)); // was - 4 - why?
+    ( (struct phdr *) buffer ) -> hpc = (void *)(highpc - (&_stext - 0));// was - 4 - why?
+    ( (struct phdr *) buffer ) -> ncnt = ssiz;
+    monsize -= sizeof(struct phdr);
+    if ( monsize <= 0 )
+	return;
+    o = highpc - lowpc;
+    if( monsize < o )
+    {
+	int quot = o / monsize;
+
+	if (quot >= 0x10000)
+		s_scale = 1;
+	else if (quot >= 0x100)
+		s_scale = 0x10000 / quot;
+	else if (o >= 0x800000)
+		s_scale = 0x1000000 / (o / (monsize >> 8));
+	else
+		s_scale = 0x1000000 / ((o << 8) / monsize);
+    }
+    else
+	s_scale = SCALE_1_TO_1;
+    moncontrol(1);
+}
+
+void _moncleanup(void)
+{
+    FILE *		f;
+    int			fromindex;
+    int			endfrom;
+    char		*frompc;
+    int			toindex;
+    struct rawarc	rawarc;
+
+    moncontrol(0);
+    f = fopen( "gmon.out" , "w");
+    if ( !f) {
+	perror( "mcount: gmon.out" );
+	return;
+    }
+#ifdef DEBUG_VERSION
+	fprintf( stderr , "[mcleanup] sbuf 0x%x ssiz %d\n" , sbuf , ssiz );
+#endif
+    fwrite(sbuf , ssiz, 1 , f);
+    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));
+    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {
+	if ( froms[fromindex] == 0 ) {
+	    continue;
+	}
+	frompc = (void *)(s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms)) - (&_stext - 0));
+	for (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {
+#ifdef DEBUG_VERSION
+		fprintf( stderr ,
+			"[mcleanup] frompc 0x%x selfpc 0x%x count %d\n" ,
+			frompc , tos[toindex].selfpc , tos[toindex].count );
+#endif
+	    rawarc.raw_frompc = (unsigned long) frompc;
+	    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;
+	    rawarc.raw_count = tos[toindex].count;
+	    fwrite(&rawarc , sizeof rawarc, 1, f);
+	}
+    }
+    fclose( f );
+}
+
+__saveallregs void mcount(void)
+{
+	register char			*selfpc;
+	register unsigned short		*frompcindex;
+	register struct tostruct	*top;
+	register struct tostruct	*prevtop;
+	register long			toindex;
+
+	/*
+	 *	find the return address for mcount,
+	 *	and the return address for mcount's caller.
+	 */
+
+	/* selfpc = pc pushed by mcount call.
+	   This identifies the function that was just entered.  */
+	selfpc = (char *) __builtin_return_address (0);
+	/* frompcindex = pc in preceding frame.
+	   This identifies the caller of the function just entered.  */
+	frompcindex = (void *) __builtin_return_address (1);
+	/*
+	 *	check that we are profiling
+	 *	and that we aren't recursively invoked.
+	 */
+	if (profiling) {
+		goto out;
+	}
+	profiling++;
+	*store_last_pc = (unsigned)selfpc;
+	selfpc = selfpc - (int)(&_stext - 0);
+	/*
+	 *	check that frompcindex is a reasonable pc value.
+	 *	for example:	signal catchers get called from the stack,
+	 *			not from text space.  too bad.
+	 */
+#ifdef DEBUG_VERSION
+		fprintf (stderr, "from $%x, self $%x (low = $%x)\n",
+			 frompcindex, selfpc, s_lowpc);
+#endif
+	frompcindex = (unsigned short *)((long)frompcindex - (long)s_lowpc);
+	if ((unsigned long)frompcindex > s_textsize) {
+
+		goto done;
+	}
+	frompcindex =
+	    &froms[((long)frompcindex) / (HASHFRACTION * sizeof(*froms))];
+	toindex = *frompcindex;
+#ifdef DEBUG_VERSION
+		fprintf (stderr, "frompcindex $%x, froms $%x, toindex = $%x\n",
+			 frompcindex, froms, toindex);
+#endif
+	if (toindex == 0) {
+		/*
+		 *	first time traversing this arc
+		 */
+		toindex = ++tos[0].link;
+		if (toindex >= tolimit) {
+			goto overflow;
+		}
+		*frompcindex = toindex;
+		top = &tos[toindex];
+		top->selfpc = selfpc;
+		top->count = 1;
+		top->link = 0;
+		goto done;
+	}
+	top = &tos[toindex];
+	if (top->selfpc == selfpc) {
+		/*
+		 *	arc at front of chain; usual case.
+		 */
+		top->count++;
+		goto done;
+	}
+	/*
+	 *	have to go looking down chain for it.
+	 *	top points to what we are looking at,
+	 *	prevtop points to previous top.
+	 *	we know it is not at the head of the chain.
+	 */
+	for (; /* goto done */; ) {
+		if (top->link == 0) {
+			/*
+			 *	top is end of the chain and none of the chain
+			 *	had top->selfpc == selfpc.
+			 *	so we allocate a new tostruct
+			 *	and link it to the head of the chain.
+			 */
+			toindex = ++tos[0].link;
+			if (toindex >= tolimit) {
+				goto overflow;
+			}
+			top = &tos[toindex];
+			top->selfpc = selfpc;
+			top->count = 1;
+			top->link = *frompcindex;
+			*frompcindex = toindex;
+			goto done;
+		}
+		/*
+		 *	otherwise, check the next arc on the chain.
+		 */
+		prevtop = top;
+		top = &tos[top->link];
+		if (top->selfpc == selfpc) {
+			/*
+			 *	there it is.
+			 *	increment its count
+			 *	move it to the head of the chain.
+			 */
+			top->count++;
+			toindex = prevtop->link;
+			prevtop->link = top->link;
+			top->link = *frompcindex;
+			*frompcindex = toindex;
+			goto done;
+		}
+
+	}
+done:
+	profiling--;
+	/* and fall through */
+out:
+	return;		/* normal return restores saved registers */
+
+overflow:
+	profiling++; /* halt further profiling */
+#   define	TOLIMIT	"mcount: tos overflow\n"
+	write(2, TOLIMIT, sizeof(TOLIMIT));
+	goto out;
+}
+
+
+
+/*
+ * Control profiling
+ *	profiling is what mcount checks to see if
+ *	all the data structures are ready.
+ */
+void moncontrol(int mode)
+{
+    if (mode) {
+	/* start */
+	store_last_pc = (unsigned *)profil(sbuf + sizeof(struct phdr),
+			       ssiz - sizeof(struct phdr), (int)s_lowpc, s_scale);
+        if (store_last_pc == NULL)
+            store_last_pc = &dummy;
+	profiling = 0;
+    } else {
+	/* stop */
+	profil((char *)0, 0, 0, 0);
+	profiling = 3;
+    }
+}
+
+ADD2INIT(_monstartup,-4);
+ADD2EXIT(_moncleanup,-4);
+
+struct profile_data vbdata;
+
+struct Interrupt vbint;
+
+int VertBServer(struct profile_data * p __asm("a1")) {
+  asm("move.l a0,-(sp)");
+  register char * usp __asm("a0");
+  asm("move.l sp,a0");
+
+  size_t index = (*((size_t *)(usp + 0x32)) - p->offset) >> 1;
+  if (index < p->count)
+    ++p->data[index];
+  asm("move.l (sp)+,a0");
+  return 0;
+}
+
+int profil(char *buf, size_t bufsiz,
+                  size_t offset, unsigned int scale) {
+  if (buf) {
+      // install interrupt if not running
+      if (vbdata.data)
+	return -1;
+
+      vbdata.data = (unsigned short *)buf;
+      vbdata.count = bufsiz>>1;
+      vbdata.offset = offset;
+
+      vbint.is_Node.ln_Type = NT_INTERRUPT;         /* Initialize the node. */
+      vbint.is_Node.ln_Pri = 20;
+      vbint.is_Node.ln_Name = "gcc profiler";
+      vbint.is_Data = (APTR)&vbdata;
+      vbint.is_Code = VertBServer;
+
+      AddIntServer(INTB_VERTB, &vbint); /* Kick this interrupt server to life. */
+
+      return 0;
+  }
+
+  if (!vbdata.data)
+    return -1;
+
+  vbdata.count = 0;
+  RemIntServer(INTB_VERTB, &vbint);
+  vbdata.data = 0;
+  return 0;
+}
+
+#pragma GCC pop_options
diff --git a/libgcc/config/m68k/gmon.h b/libgcc/config/m68k/gmon.h
new file mode 100755
index 00000000000..98351823ab4
--- /dev/null
+++ b/libgcc/config/m68k/gmon.h
@@ -0,0 +1,105 @@
+/*-
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)gmon.h	5.3 (Berkeley) 5/6/91
+ */
+
+struct phdr {
+    char	*lpc;
+    char	*hpc;
+    int		ncnt;
+};
+
+    /*
+     *	histogram counters are unsigned shorts (according to the kernel).
+     */
+#define	HISTCOUNTER	unsigned short
+
+    /*
+     *	fraction of text space to allocate for histogram counters
+     *	here, 1/2
+     */
+#define	HISTFRACTION	2
+
+    /*
+     *	Fraction of text space to allocate for from hash buckets.
+     *	The value of HASHFRACTION is based on the minimum number of bytes
+     *	of separation between two subroutine call points in the object code.
+     *	Given MIN_SUBR_SEPARATION bytes of separation the value of
+     *	HASHFRACTION is calculated as:
+     *
+     *		HASHFRACTION = MIN_SUBR_SEPARATION / (2 * sizeof(short) - 1);
+     *
+     *	For the VAX, the shortest two call sequence is:
+     *
+     *		calls	$0,(r0)
+     *		calls	$0,(r0)
+     *
+     *	which is separated by only three bytes, thus HASHFRACTION is 
+     *	calculated as:
+     *
+     *		HASHFRACTION = 3 / (2 * 2 - 1) = 1
+     *
+     *	Note that the division above rounds down, thus if MIN_SUBR_FRACTION
+     *	is less than three, this algorithm will not work!
+     */
+#define	HASHFRACTION	1
+
+    /*
+     *	percent of text space to allocate for tostructs
+     *	with a minimum.
+     */
+#define ARCDENSITY	2
+#define MINARCS		50
+
+struct tostruct {
+    char		*selfpc;
+    long		count;
+    unsigned short	link;
+};
+
+    /*
+     *	a raw arc,
+     *	    with pointers to the calling site and the called site
+     *	    and a count.
+     */
+struct rawarc {
+    unsigned long	raw_frompc;
+    unsigned long	raw_selfpc;
+    long		raw_count;
+};
+
+    /*
+     *	general rounding functions.
+     */
+#define ROUNDDOWN(x,y)	(((x)/(y))*(y))
+#define ROUNDUP(x,y)	((((x)+(y)-1)/(y))*(y))
diff --git a/libgcc/config/m68k/new_op.c b/libgcc/config/m68k/new_op.c
new file mode 100644
index 00000000000..15ae6f39c37
--- /dev/null
+++ b/libgcc/config/m68k/new_op.c
@@ -0,0 +1,11 @@
+#include <stdlib.h>
+#include <stdio.h>
+extern void * malloc(unsigned);
+void * _Znwj (unsigned sz)
+{
+  void *p = malloc(sz);
+  if (p)
+    return p;
+  perror("std::bad_alloc");
+  abort();
+}
diff --git a/libgcc/config/m68k/t-floatlib b/libgcc/config/m68k/t-floatlib
index 1ee8782d9fd..919e573c1ad 100644
--- a/libgcc/config/m68k/t-floatlib
+++ b/libgcc/config/m68k/t-floatlib
@@ -1,11 +1,62 @@
-LIB1ASMSRC = m68k/lb1sf68.S
-LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \
-   _double _float _floatex \
-   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \
-   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2
+#
+#LIB1ASMSRC = m68k/lb1sf68.S
+#LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \
+#   _double _float _floatex \
+#   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \
+#   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2
+#
 
-LIB2ADD = $(srcdir)/config/m68k/fpgnulib.c xfgnulib.c
+LIB2ADD +=  xfpgnulib.c xfpgnulib__unordsf2.c xfpgnulib__unorddf2.c \
+	xfpgnulib__floatunsidf.c xfpgnulib__floatsidf.c xfpgnulib__floatunsisf.c \
+	xfpgnulib__floatsisf.c xfpgnulib__extendsfdf2.c xfpgnulib__truncdfsf2.c \
+	xfpgnulib__fixdfsi.c xfpgnulib__fixsfsi.c xfpgnulib__cmpxf2.c
 
-xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c
-	echo '#define EXTFLOAT' > xfgnulib.c
-	cat $< >> xfgnulib.c
+xfpgnulib__unordsf2.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __UNORDSF2' > xfpgnulib__unordsf2.c
+	cat $< >> xfpgnulib__unordsf2.c
+
+xfpgnulib__unorddf2.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __UNORDDF2' > xfpgnulib__unorddf2.c
+	cat $< >> xfpgnulib__unorddf2.c
+
+xfpgnulib__floatunsidf.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FLOATUNSIDF' > xfpgnulib__floatunsidf.c
+	cat $< >> xfpgnulib__floatunsidf.c
+
+xfpgnulib__floatsidf.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FLOATSIDF' > xfpgnulib__floatsidf.c
+	cat $< >> xfpgnulib__floatsidf.c
+
+xfpgnulib__floatunsisf.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FLOATUNSISF' > xfpgnulib__floatunsisf.c
+	cat $< >> xfpgnulib__floatunsisf.c
+
+xfpgnulib__floatsisf.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FLOATSISF' > xfpgnulib__floatsisf.c
+	cat $< >> xfpgnulib__floatsisf.c
+
+xfpgnulib__extendsfdf2.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __EXTENDSFDF2' > xfpgnulib__extendsfdf2.c
+	cat $< >> xfpgnulib__extendsfdf2.c
+
+xfpgnulib__truncdfsf2.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __TRUNCDFSF2' > xfpgnulib__truncdfsf2.c
+	cat $< >> xfpgnulib__truncdfsf2.c
+
+xfpgnulib__fixdfsi.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FIXDFSI' > xfpgnulib__fixdfsi.c
+	cat $< >> xfpgnulib__fixdfsi.c
+
+xfpgnulib__fixsfsi.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define __FIXSFSI' > xfpgnulib__fixsfsi.c
+	cat $< >> xfpgnulib__fixsfsi.c
+
+xfpgnulib.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define EXTFLOAT' > xfpgnulib.c
+	cat $< >> xfpgnulib.c
+
+xfpgnulib__cmpxf2.c: $(srcdir)/config/m68k/fpgnulib.c
+	echo '#define EXTFLOAT' > xfpgnulib__cmpxf2.c
+	echo '#define EXTFLOATCMP' >> xfpgnulib__cmpxf2.c
+	cat $< >> xfpgnulib__cmpxf2.c
+	
\ No newline at end of file
diff --git a/libgcc/config/m68k/t-glue b/libgcc/config/m68k/t-glue
new file mode 100644
index 00000000000..c44f798af48
--- /dev/null
+++ b/libgcc/config/m68k/t-glue
@@ -0,0 +1,7 @@
+LIB2ADD += $(srcdir)/config/m68k/cxxglue.c 
+LIB2ADD += $(srcdir)/config/m68k/gmon.c 
+
+new_op.o: $(srcdir)/config/m68k/new_op.c
+	$(CC) $(CFLAGS) -c $< 
+
+EXTRA_PARTS=new_op.o
diff --git a/libgcc/unwind-dw2.c b/libgcc/unwind-dw2.c
index 1fb6026d123..31cfdcc43dd 100644
--- a/libgcc/unwind-dw2.c
+++ b/libgcc/unwind-dw2.c
@@ -22,6 +22,9 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+#pragma GCC push_options
+#pragma GCC optimize ("-O2")
+
 #include "tconfig.h"
 #include "tsystem.h"
 #include "coretypes.h"
@@ -260,6 +263,9 @@ _Unwind_GetCFA (struct _Unwind_Context *context)
 }
 
 /* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */
+#ifdef TARGET_AMIGA
+static int overregs[16];
+#endif
 
 inline void
 _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)
@@ -271,6 +277,9 @@ _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)
   gcc_assert (index < (int) sizeof(dwarf_reg_size_table));
   size = dwarf_reg_size_table[index];
 
+#ifdef TARGET_AMIGA
+  overregs[index] = val;
+#endif
   if (_Unwind_IsExtendedContext (context) && context->by_value[index])
     {
       context->reg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);
@@ -279,6 +288,9 @@ _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)
 
   ptr = (void *) (_Unwind_Internal_Ptr) context->reg[index];
 
+  if (!ptr)
+    return;
+
   if (size == sizeof(_Unwind_Ptr))
     * (_Unwind_Ptr *) ptr = val;
   else
@@ -1612,10 +1624,10 @@ _Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),
    macro because __builtin_eh_return must be invoked in the context of
    our caller.  */
 
-#define uw_install_context(CURRENT, TARGET)				\
+#define uw_install_context(CURRENT, TARGET, INDEX)				\
   do									\
     {									\
-      long offset = uw_install_context_1 ((CURRENT), (TARGET));		\
+      long offset = uw_install_context_1 ((CURRENT), (TARGET), (INDEX));		\
       void *handler = __builtin_frob_return_addr ((TARGET)->ra);	\
       _Unwind_DebugHook ((TARGET)->cfa, handler);			\
       __builtin_eh_return (offset, handler);				\
@@ -1624,7 +1636,8 @@ _Unwind_DebugHook (void *cfa __attribute__ ((__unused__)),
 
 static long
 uw_install_context_1 (struct _Unwind_Context *current,
-		      struct _Unwind_Context *target)
+		      struct _Unwind_Context *target,
+		      int index ATTRIBUTE_UNUSED)
 {
   long i;
   _Unwind_SpTmp sp_slot;
@@ -1659,7 +1672,75 @@ uw_install_context_1 (struct _Unwind_Context *current,
       else if (t && c && t != c)
 	memcpy (c, t, dwarf_reg_size_table[i]);
     }
+#ifdef TARGET_AMIGA
+  /* SBF: evil hack to patch the values for d0/d1 into the stack location.
+   * search the movem insn and count the saved regs.
+   * Now patch the values into location.
+   * Always patch d0/d1 since override is always invoked for d0/d1.
+   * Then patch all other regs which the above code omitted.
+   */
+  /* uw_install_context_1 is called from 4 different locations - each uses an unique index.
+   * So initialization is only done once.
+   */
+  static unsigned short counts[4];
+  static unsigned short masks[4];
+
+  unsigned short count = 0;
+  unsigned short reg_mask = masks[index];
+  /* init each index once. */
+  if (!reg_mask)
+    {
+      /* get the return address.*/
+      unsigned short * sp = *(((unsigned short **)&current) - 1);
+      /* search the movem -x(a5),regs insn.*/
+      for (;;)
+	{
+	  unsigned short s = *sp++;
+//      printf("%04x ", s);
+	  gcc_assert(s != (unsigned short)0x4e75);// hit return? ouch!
+	  if (s == (unsigned short)0x4ced)
+	    break;
+	}
+      reg_mask = *sp;
+      /* count saved regs */
+      for (unsigned short i = 0, m = reg_mask; i < 16; ++i)
+	{
+	  if (m & 1)
+	  ++count;
+	  m >>= 1;
+	}
+      masks[index] = reg_mask;
+      counts[index] = count;
+    }
+  else
+    count = counts[index];
 
+  /* regs are saved below local vars -> start at current */
+  int * p = ((int *)current) - count;
+
+  for (unsigned short i = 0, m = reg_mask; i < 16; ++i)
+    {
+      if (m & 1)
+	{
+	  if (i <= 1 || (!current->reg[i] && (target->reg[i] || target->by_value[i])))
+	    {
+	      int old = *p;
+	      /* not set by the code above - set it here */
+	      if (i <= 1) // use the override values for d0/d1
+	        *p = overregs[i];
+	      else
+	      if (target->by_value[i])
+	        *p = (int)target->reg[i];
+	      else
+	        *p = *(int*)target->reg[i];
+//	      printf("patch reg %d from %08lx to %08lx\n", i, old, *p);
+	    }
+	  ++p;
+	}
+      m >>= 1;
+    }
+
+#endif
   /* If the current frame doesn't have a saved stack pointer, then we
      need to rely on EH_RETURN_STACKADJ_RTX to get our target stack
      pointer value reloaded.  */
@@ -1713,3 +1794,5 @@ alias (_Unwind_SetIP);
 #endif
 
 #endif /* !USING_SJLJ_EXCEPTIONS */
+
+#pragma GCC pop_options
diff --git a/libgcc/unwind.inc b/libgcc/unwind.inc
index 7413b55e3fa..8b524b4d6d8 100644
--- a/libgcc/unwind.inc
+++ b/libgcc/unwind.inc
@@ -100,12 +100,12 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
 
       if (code == _URC_END_OF_STACK)
 	/* Hit end of stack with no handler found.  */
-	return _URC_END_OF_STACK;
+	{ code = _URC_END_OF_STACK; goto KOT; }
 
       if (code != _URC_NO_REASON)
 	/* Some error encountered.  Usually the unwinder doesn't
 	   diagnose these and merely crashes.  */
-	return _URC_FATAL_PHASE1_ERROR;
+  	{ code = _URC_FATAL_PHASE1_ERROR; goto KOT; }
 
       /* Unwind successful.  Run the personality routine, if any.  */
       if (fs.personality)
@@ -115,7 +115,7 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
 	  if (code == _URC_HANDLER_FOUND)
 	    break;
 	  else if (code != _URC_CONTINUE_UNWIND)
-	    return _URC_FATAL_PHASE1_ERROR;
+	  	{ code = _URC_FATAL_PHASE1_ERROR; goto KOT; }
 	}
 
       /* Update cur_context to describe the same frame as fs.  */
@@ -129,10 +129,15 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)
 
   cur_context = this_context;
   code = _Unwind_RaiseException_Phase2 (exc, &cur_context);
-  if (code != _URC_INSTALL_CONTEXT)
+KOT:
+  if (code != _URC_INSTALL_CONTEXT) {
+#ifdef TARGET_AMIGA
+	  asm ("move.l %0, (sp)" :: "r"(code));
+#endif
     return code;
+  }
 
-  uw_install_context (&this_context, &cur_context);
+  uw_install_context (&this_context, &cur_context, 0);
 }
 
 
@@ -208,7 +213,7 @@ _Unwind_ForcedUnwind (struct _Unwind_Exception *exc,
   if (code != _URC_INSTALL_CONTEXT)
     return code;
 
-  uw_install_context (&this_context, &cur_context);
+  uw_install_context (&this_context, &cur_context, 1);
 }
 
 
@@ -233,7 +238,7 @@ _Unwind_Resume (struct _Unwind_Exception *exc)
 
   gcc_assert (code == _URC_INSTALL_CONTEXT);
 
-  uw_install_context (&this_context, &cur_context);
+  uw_install_context (&this_context, &cur_context, 2);
 }
 
 
@@ -258,7 +263,7 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)
 
   gcc_assert (code == _URC_INSTALL_CONTEXT);
 
-  uw_install_context (&this_context, &cur_context);
+  uw_install_context (&this_context, &cur_context, 3);
 }
 
 
diff --git a/libiberty/Makefile.in b/libiberty/Makefile.in
index c7a45680917..7f9229ff23f 100644
--- a/libiberty/Makefile.in
+++ b/libiberty/Makefile.in
@@ -148,7 +148,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	random.c regex.c rename.c rindex.c				\
 	safe-ctype.c setenv.c setproctitle.c sha1.c sigsetmask.c        \
 	 simple-object.c simple-object-coff.c simple-object-elf.c	\
-	 simple-object-mach-o.c simple-object-xcoff.c			\
+	 simple-object-mach-o.c simple-object-xcoff.c	simple-object-amigahunk.c		\
          snprintf.c sort.c						\
 	 spaces.c splay-tree.c stack-limit.c stpcpy.c stpncpy.c		\
 	 strcasecmp.c strchr.c strdup.c strerror.c strncasecmp.c	\
@@ -186,7 +186,7 @@ REQUIRED_OFILES =							\
 	./safe-ctype.$(objext)						\
 	./simple-object.$(objext) ./simple-object-coff.$(objext)	\
 	./simple-object-elf.$(objext) ./simple-object-mach-o.$(objext)	\
-	./simple-object-xcoff.$(objext)					\
+	./simple-object-xcoff.$(objext)	./simple-object-amigahunk.$(objext)				\
 	./sort.$(objext) ./spaces.$(objext)				\
 	./splay-tree.$(objext) ./stack-limit.$(objext)			\
 	./strerror.$(objext) ./strsignal.$(objext)			\
@@ -264,6 +264,10 @@ $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
 	  cd ..; \
 	else true; fi
 
+libiberty.dll: $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
+	rm -rf $@
+	$(CC) -o $@ -shared $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)
+
 $(TESTLIB): $(REQUIRED_OFILES) $(CONFIGURED_OFILES)
 	-rm -f $(TESTLIB)
 	$(AR) $(AR_FLAGS) $(TESTLIB) \
@@ -1278,6 +1282,17 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir
 	else true; fi
 	$(COMPILE.c) $(srcdir)/simple-object-xcoff.c $(OUTPUT_OPTION)
 
+./simple-object-amigahunk.$(objext): $(srcdir)/simple-object-amigahunk.c config.h \
+	$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
+	$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object-amigahunk.c -o pic/$@; \
+	else true; fi
+	if [ x"$(NOASANFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/simple-object-amigahunk.c -o noasan/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/simple-object-amigahunk.c $(OUTPUT_OPTION)
+
 ./simple-object.$(objext): $(srcdir)/simple-object.c config.h \
 	$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \
 	$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h
diff --git a/libiberty/lrealpath.c b/libiberty/lrealpath.c
index b27c8de990e..78c06e46da5 100644
--- a/libiberty/lrealpath.c
+++ b/libiberty/lrealpath.c
@@ -73,7 +73,7 @@ extern char *canonicalize_file_name (const char *);
 #endif
 
 char *
-lrealpath (const char *filename)
+__xlrealpath (const char *filename)
 {
   /* Method 1: The system has a compile time upper bound on a filename
      path.  Use that and realpath() to canonicalize the name.  This is
@@ -155,3 +155,19 @@ lrealpath (const char *filename)
   /* This system is a lost cause, just duplicate the filename.  */
   return strdup (filename);
 }
+
+
+char *
+lrealpath (const char *filename)
+{
+  char * r = __xlrealpath(filename);
+#if defined (_WIN32)
+  if (strncmp(r, "/cygdrive/", 10) == 0)
+    {
+      r[9] = r[10];
+      r[10] = ':';
+      r = strdup(&r[9]);
+    }
+#endif
+  return r;
+}
diff --git a/libiberty/make-relative-prefix.c b/libiberty/make-relative-prefix.c
index fe639d18bd2..e5b044056cb 100644
--- a/libiberty/make-relative-prefix.c
+++ b/libiberty/make-relative-prefix.c
@@ -61,7 +61,8 @@ relative prefix can be found, return @code{NULL}.
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
-
+#include <sys/types.h>
+#include <dirent.h>
 #include <string.h>
 
 #include "ansidecl.h"
@@ -233,170 +234,62 @@ make_relative_prefix_1 (const char *progname, const char *bin_prefix,
   int i, n, common;
   int needed_len;
   char *ret = NULL, *ptr, *full_progname;
+  char buf[1024], *p, *q;
+  DIR * d;
 
   if (progname == NULL || bin_prefix == NULL || prefix == NULL)
     return NULL;
 
-  /* If there is no full pathname, try to find the program by checking in each
-     of the directories specified in the PATH environment variable.  */
-  if (lbasename (progname) == progname)
-    {
-      char *temp;
-
-      temp = getenv ("PATH");
-      if (temp)
-	{
-	  char *startp, *endp, *nstore;
-	  size_t prefixlen = strlen (temp) + 1;
-	  size_t len;
-	  if (prefixlen < 2)
-	    prefixlen = 2;
-
-	  len = prefixlen + strlen (progname) + 1;
-#ifdef HAVE_HOST_EXECUTABLE_SUFFIX
-	  len += strlen (HOST_EXECUTABLE_SUFFIX);
-#endif
-	  nstore = (char *) alloca (len);
-
-	  startp = endp = temp;
-	  while (1)
-	    {
-	      if (*endp == PATH_SEPARATOR || *endp == 0)
-		{
-		  if (endp == startp)
-		    {
-		      nstore[0] = '.';
-		      nstore[1] = DIR_SEPARATOR;
-		      nstore[2] = '\0';
-		    }
-		  else
-		    {
-		      memcpy (nstore, startp, endp - startp);
-		      if (! IS_DIR_SEPARATOR (endp[-1]))
-			{
-			  nstore[endp - startp] = DIR_SEPARATOR;
-			  nstore[endp - startp + 1] = 0;
-			}
-		      else
-			nstore[endp - startp] = 0;
-		    }
-		  strcat (nstore, progname);
-		  if (! access (nstore, X_OK)
-#ifdef HAVE_HOST_EXECUTABLE_SUFFIX
-                      || ! access (strcat (nstore, HOST_EXECUTABLE_SUFFIX), X_OK)
-#endif
-		      )
-		    {
-#if defined (HAVE_SYS_STAT_H) && defined (S_ISREG)
-		      struct stat st;
-		      if (stat (nstore, &st) >= 0 && S_ISREG (st.st_mode))
+  buf[0] = 0;
+#ifdef __MSYS__
+  n = GetModuleFileNameA(0, buf, 1023);
+#elif defined(__MACH__)
+  n = 1022;
+  n |= _NSGetExecutablePath(buf, &n);
+#else
+  n = readlink( "/proc/self/exe", buf, 1023);
 #endif
-			{
-			  progname = nstore;
-			  break;
-			}
-		    }
-
-		  if (*endp == 0)
-		    break;
-		  endp = startp = endp + 1;
-		}
-	      else
-		endp++;
-	    }
-	}
-    }
-
-  if (resolve_links)
-    full_progname = lrealpath (progname);
-  else
-    full_progname = strdup (progname);
-  if (full_progname == NULL)
+  if (n < 0 || n > 1022)
     return NULL;
-
-  prog_dirs = split_directories (full_progname, &prog_num);
-  free (full_progname);
-  if (prog_dirs == NULL)
-    return NULL;
-
-  bin_dirs = split_directories (bin_prefix, &bin_num);
-  if (bin_dirs == NULL)
-    goto bailout;
-
-  /* Remove the program name from comparison of directory names.  */
-  prog_num--;
-
-  /* If we are still installed in the standard location, we don't need to
-     specify relative directories.  Also, if argv[0] still doesn't contain
-     any directory specifiers after the search above, then there is not much
-     we can do.  */
-  if (prog_num == bin_num)
-    {
-      for (i = 0; i < bin_num; i++)
-	{
-	  if (strcmp (prog_dirs[i], bin_dirs[i]) != 0)
+  else if (n)
+    buf[n] = 0;
+
+  //puts(buf);
+
+  buf[1023] = 0;
+  for (p = buf; *p; ++p)
+    if (*p == '\\')
+      *p = '/';
+
+  // remove program and bin folder
+  i = 2;
+  while (p > buf) {
+      if (*--p == '/') {
+	  *p = 0;
+	  if (--i == 0)
 	    break;
-	}
+      }
+  }
 
-      if (prog_num <= 0 || i == bin_num)
-	goto bailout;
-    }
-
-  prefix_dirs = split_directories (prefix, &prefix_num);
-  if (prefix_dirs == NULL)
-    goto bailout;
+  // find common path in bin_prefix and prefix
+  for (p = bin_prefix, q = prefix; *p && *p == *q; ++p, ++q)
+    {}
 
-  /* Find how many directories are in common between bin_prefix & prefix.  */
-  n = (prefix_num < bin_num) ? prefix_num : bin_num;
-  for (common = 0; common < n; common++)
-    {
-      if (strcmp (bin_dirs[common], prefix_dirs[common]) != 0)
-	break;
-    }
+  p = concat(buf, "/", q, 0);
 
-  /* If there are no common directories, there can be no relative prefix.  */
-  if (common == 0)
-    goto bailout;
-
-  /* Two passes: first figure out the size of the result string, and
-     then construct it.  */
-  needed_len = 0;
-  for (i = 0; i < prog_num; i++)
-    needed_len += strlen (prog_dirs[i]);
-  needed_len += sizeof (DIR_UP) * (bin_num - common);
-  for (i = common; i < prefix_num; i++)
-    needed_len += strlen (prefix_dirs[i]);
-  needed_len += 1; /* Trailing NUL.  */
-
-  ret = (char *) malloc (needed_len);
-  if (ret == NULL)
-    goto bailout;
-
-  /* Build up the pathnames in argv[0].  */
-  *ret = '\0';
-  for (i = 0; i < prog_num; i++)
-    strcat (ret, prog_dirs[i]);
-
-  /* Now build up the ..'s.  */
-  ptr = ret + strlen(ret);
-  for (i = common; i < bin_num; i++)
+  d = opendir(p);
+  if (d) closedir(d);
+  else
     {
-      strcpy (ptr, DIR_UP);
-      ptr += sizeof (DIR_UP) - 1;
-      *(ptr++) = DIR_SEPARATOR;
+      free(p);
+      strcpy(buf, prefix);
+      buf[q - prefix] = 0;
+      p = concat(buf, q, 0);
     }
-  *ptr = '\0';
-
-  /* Put in directories to move over to prefix.  */
-  for (i = common; i < prefix_num; i++)
-    strcat (ret, prefix_dirs[i]);
-
- bailout:
-  free_split_directories (prog_dirs);
-  free_split_directories (bin_dirs);
-  free_split_directories (prefix_dirs);
+  
+  //printf("%s %s %s %s ->%s\n", progname, buf, bin_prefix, prefix, p);
 
-  return ret;
+  return p;
 }
 
 
diff --git a/libiberty/simple-object-amigahunk.c b/libiberty/simple-object-amigahunk.c
new file mode 100644
index 00000000000..5808686cc59
--- /dev/null
+++ b/libiberty/simple-object-amigahunk.c
@@ -0,0 +1,574 @@
+/* simple-object-amigahunk.c -- routines to manipulate Amiga hunk object files.
+ Copyright 2010 Free Software Foundation, Inc.
+ Written by Stefan "Bebbo" Franke @ Bebbosoft GbR.
+
+ This program is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License as published by the
+ Free Software Foundation; either version 2, or (at your option) any
+ later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, 51 Franklin Street - Fifth Floor,
+ Boston, MA 02110-1301, USA.  */
+
+#include "config.h"
+#include "libiberty.h"
+#include "simple-object.h"
+
+#include <errno.h>
+#include <stddef.h>
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef HAVE_STDIO_H
+#include <stdio.h>
+#endif
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+
+#include "simple-object-common.h"
+
+/**
+ * all info needed to find hunks aka sections.
+ */
+struct hunk
+{
+  struct hunk * next;
+  char const * name;
+  off_t offset;
+  unsigned length;
+};
+
+/**
+ * Used during initial file read.
+ * Track the hunks plus the name.
+ */
+struct simple_object_amigahunk_read
+{
+  struct hunk * root;
+  char const * name;
+  int deleted;
+};
+
+/**
+ * A copy of simple_object_amigahunk_read atm.
+ * /
+struct simple_object_amigahunk_attributes
+{
+  struct hunk * root;
+  char const * name;
+};
+*/
+#define simple_object_amigahunk_attributes simple_object_amigahunk_read
+
+/**
+ * Read 4 bytes as big endian int and move the file offset.
+ */
+static unsigned
+read4 (int descriptor, off_t * offset)
+{
+  static unsigned char b[4];
+  const char *errmsg;
+  int err;
+
+  if (!simple_object_internal_read (descriptor, *offset, b, 4, &errmsg, &err))
+    return 0xffffffff;
+  *offset += 4;
+  return (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];
+}
+
+// not reentrant atm.
+static unsigned nameLen; // size of current name
+static unsigned char * name;    // some name
+
+/**
+ * Read a name into the shared buffer.
+ */
+static int
+readName (unsigned l, int descriptor, off_t * offset)
+{
+  const char *errmsg;
+  int err;
+  l <<= 2;
+  if (nameLen < l)
+    {
+      XDELETE(name);
+      name = XNEWVEC(unsigned char, l + 1);
+      nameLen = l;
+    }
+  if (!l)
+    {
+      if (!name)
+	name = XNEWVEC(unsigned char, 1);
+      *name = 0;
+      return 1;
+    }
+  int r = simple_object_internal_read (descriptor, *offset, name, l, &errmsg,
+				       &err);
+  name[l] = 0;
+  if (r)
+    *offset += l;
+  return r;
+}
+
+/* See if we have an Amiga file.
+ * Also remember all hunks.
+ */
+
+static void *
+simple_object_amigahunk_match (
+    unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN], int descriptor,
+    off_t offset, const char *segment_name ATTRIBUTE_UNUSED,
+    const char **errmsg, int *err)
+{
+  if (header[0] != 0 || header[1] != 0 || header[2] != 3 || header[3] != 0xe7)
+    return NULL;
+
+//  fprintf (stderr, "simple_object_amigahunk_match\n");
+
+  struct simple_object_amigahunk_read * oar = XNEW(
+      struct simple_object_amigahunk_read);
+  oar->root = NULL;
+  oar->name = NULL;
+  oar->deleted = 0;
+
+  for (;;)
+    {
+      unsigned hid = read4 (descriptor, &offset);
+      if (hid == 0xffffffff)
+	break;
+      if (hid == 0x3f2)
+	continue;
+
+      unsigned sz = read4 (descriptor, &offset);
+      switch (hid & 0x3fffffff)
+	{
+	case 0x3f3: // HEADER
+	  if (sz)
+	    {
+	      readName (sz, descriptor, &offset);
+	    }
+	  // first last + sizes
+	  unsigned nsecs = read4 (descriptor, &offset);
+	  unsigned first = read4 (descriptor, &offset);
+	  unsigned last = read4 (descriptor, &offset);
+	  unsigned i;
+	  for (i = 0; i < nsecs; ++i)
+	    {
+	      sz = read4 (descriptor, &offset);
+	    }
+	  break;
+
+	case 0x3e8: // NAME
+	  readName (sz, descriptor, &offset);
+
+	  struct hunk * h = XNEW(struct hunk);
+	  h->next = oar->root;
+	  h->name = xstrdup ((char const*) name);
+
+	  offset += 4;
+	  h->length = read4 (descriptor, &offset) * 4;
+	  h->offset = offset;
+	  offset -= 8;
+
+	  oar->root = h;
+	  break;
+	case 0x3e7: // UNIT
+	  {
+	      readName (sz, descriptor, &offset);
+	      oar->name = xstrdup ((char const *) name);
+	      break;
+	  }
+	case 0x3e9: // CODE
+	case 0x3ea: // DATA
+	case 0x3f1: // DEBUG
+		    // skip sz long words.
+	  offset += sz * 4;
+	  break;
+
+	case 0x3eb: // BSS
+		    // no more data
+	  break;
+
+	case 0x3ec: // RELOC32
+	case 0x3ed: // RELOC16
+	case 0x3ee: // RELOC8
+	case 0x3f7: // DRELOC32
+	case 0x3f8: // DRELOC16
+	case 0x3f9: // DRELOC8
+	case 0x3f0: // SYMBOL
+	case 0x3fe: // ABSRELOC16
+	  while (sz)
+	    {
+	      unsigned hn = read4 (descriptor, &offset);
+	      offset += sz * 4;
+	      sz = read4 (descriptor, &offset);
+	    }
+	  break;
+
+	case 0x3fc: // RELOC32SHORT
+	  while (sz)
+	    {
+	      unsigned hn = read4 (descriptor, &offset);
+	      offset += sz * 2;
+	      sz = read4 (descriptor, &offset);
+	    }
+	  break;
+
+	case 0x3ef: // EXT
+	  while (sz & 0xff000000)
+	    {
+	      unsigned l = sz & 0xffffff;
+	      unsigned b = sz >> 24;
+	      readName (l, descriptor, &offset);
+	      switch (b)
+		{
+		case 0: // ext_symb
+		case 1: // ext_def
+		case 2: // ext_abs
+		case 3: // ext_res
+		  {
+		    offset += 4;
+		  }
+		  break;
+		case 130: // ext_common EXT_ABSCOMMON
+		case 137: // EXT_RELCOMMON
+		case 208: // EXT_DEXT32COMMON
+		case 209: // EXT_DEXT16COMMON
+		case 210: // EXT_DEXT8COMMON
+		  {
+		    offset += 4;
+		    unsigned blocksize = read4 (descriptor, &offset);
+		    offset += blocksize * 4;
+		  }
+		  break;
+		case 129: // ext_ref32
+		case 131: // ext_ref16
+		case 132: // ext_ref8
+		case 133: // ext_dref32
+		case 134: // ext_dref16
+		case 135: // ext_dref8
+		case 136: // EXT_RELREF32
+		case 138: // EXT_ABSREF16
+		case 139: // EXT_ABSREF8
+		  {
+		    unsigned n = read4 (descriptor, &offset);
+		    offset += n * 4;
+		  }
+		  break;
+		default:
+		  break;
+		}
+
+	      sz = read4 (descriptor, &offset);
+	    }
+	  break;
+	}
+    }
+
+  return (void *) oar;
+}
+
+/* Find all sections in an Amiga file.
+ * invoke the callback pfn if section name matches.
+ */
+
+static const char *
+simple_object_amigahunk_find_sections (simple_object_read *sobj, int
+(*pfn) (void *, const char *, off_t offset, off_t length),
+				       void *data, int *err)
+{
+  struct simple_object_amigahunk_read *eor =
+      (struct simple_object_amigahunk_read *) sobj->data;
+  struct hunk * h = eor->root;
+
+//  fprintf (stderr, "simple_object_amigahunk_find_sections\n");
+
+  while (h)
+    {
+      if (!(*pfn) (data, h->name, h->offset, h->length))
+	{
+//	  fprintf (stderr, "simple_object_amigahunk_find_sections: %s\n", h->name);
+	  break;
+	}
+      h = h->next;
+    }
+
+  return NULL;
+}
+
+/* Fetch the attributes for an simple_object_read.  */
+
+static void *
+simple_object_amigahunk_fetch_attributes (simple_object_read *sobj,
+					  const char **errmsg ATTRIBUTE_UNUSED,
+					  int *err ATTRIBUTE_UNUSED)
+{
+  struct simple_object_amigahunk_read *eor =
+      (struct simple_object_amigahunk_read *) sobj->data;
+  struct simple_object_amigahunk_attributes *ret;
+
+//  fprintf (stderr, "simple_object_amigahunk_fetch_attributes\n");
+
+  ret = XNEW(struct simple_object_amigahunk_attributes);
+
+  *ret = *eor;
+  eor->deleted = 1;
+
+  return ret;
+}
+
+/* Release the privata data for an simple_object_read.  */
+
+static void
+simple_object_amigahunk_release_read (void *data)
+{
+  struct simple_object_amigahunk_read *eor =
+      (struct simple_object_amigahunk_read *) data;
+
+  if (!eor->deleted)
+    {
+      struct hunk * h = eor->root;
+      while (h)
+	{
+	  struct hunk * n = h;
+	  h = h->next;
+	  XDELETE(n);
+	}
+      XDELETE(eor->name);
+    }
+  XDELETE(data);
+}
+
+/* Compare two attributes structures.
+ * Not yet implemented.
+ */
+
+static const char *
+simple_object_amigahunk_attributes_merge (void *todata, void *fromdata,
+					  int *err)
+{
+  struct simple_object_amigahunk_attributes *to =
+      (struct simple_object_amigahunk_attributes *) todata;
+  struct simple_object_amigahunk_attributes *from =
+      (struct simple_object_amigahunk_attributes *) fromdata;
+
+//  fprintf (stderr, "simple_object_amigahunk_attributes_merge\n");
+
+  return NULL;
+}
+
+/* Release the private data for an attributes structure.  */
+
+static void
+simple_object_amigahunk_release_attributes (void *data)
+{
+  simple_object_amigahunk_release_read(data);
+}
+
+/* Prepare to write out a file.  */
+
+static void *
+simple_object_amigahunk_start_write (void *attributes_data,
+				     const char **errmsg ATTRIBUTE_UNUSED,
+				     int *err ATTRIBUTE_UNUSED)
+{
+  struct simple_object_amigahunk_attributes *attrs =
+      (struct simple_object_amigahunk_attributes *) attributes_data;
+  struct simple_object_amigahunk_attributes *ret;
+
+  /* We're just going to record the attributes, but we need to make a
+   copy because the user may delete them.  */
+  ret = XNEW(struct simple_object_amigahunk_attributes);
+
+//  fprintf (stderr, "simple_object_amigahunk_start_write\n");
+
+  *ret = *attrs;
+
+  attrs->deleted = 1;
+
+  return ret;
+}
+
+/**
+ * Write a name in Amiga hunk style.
+ */
+static int
+write_name (int descriptor, off_t * offset, char const * name,
+	    const char **errmsg, int *err)
+{
+  unsigned slen = strlen (name);
+  unsigned len = (slen + 3) >> 2;
+  unsigned char b[4];
+  b[3] = len;
+  b[2] = len >> 8;
+  b[1] = len >> 16;
+  b[0] = 0;
+
+  if (!simple_object_internal_write (descriptor, *offset, b, 4, errmsg, err))
+    return 0;
+
+  *offset += 4;
+
+  if (!simple_object_internal_write (descriptor, *offset,
+				     (unsigned char const *) name, slen, errmsg,
+				     err))
+    return 0;
+
+  *offset += slen;
+
+  slen = (len << 2) - slen;
+  if (slen)
+    {
+      b[1] = 0;
+      b[2] = 0;
+      if (!simple_object_internal_write (descriptor, *offset, b, slen, errmsg,
+					 err))
+	return 0;
+
+      *offset += slen;
+    }
+
+  return 1;
+}
+
+/* Write out a complete Amiga file. */
+
+static const char *
+simple_object_amigahunk_write_to_file (simple_object_write *sobj,
+				       int descriptor, int *err)
+{
+  struct simple_object_amigahunk_attributes *attrs =
+      (struct simple_object_amigahunk_attributes *) sobj->data;
+  const char *errmsg;
+  simple_object_write_section *section;
+  unsigned int shnum;
+  off_t offset = 0;
+  static const unsigned char HUNK_UNIT[] =
+    { 0, 0, 3, 0xe7 };
+  static const unsigned char HUNK_NAME[] =
+    { 0, 0, 3, 0xe8 };
+  static const unsigned char HUNK_DEBUG[] =
+    { 0, 0, 3, 0xf1 };
+  static const unsigned char HUNK_END[] =
+    { 0, 0, 3, 0xf2 };
+
+//  fprintf (stderr, "simple_object_amigahunk_write_to_file\n");
+
+  // write header
+  if (!simple_object_internal_write (descriptor, offset, HUNK_UNIT, 4, &errmsg,
+				     err))
+    return NULL;
+  offset += 4;
+  if (!write_name (descriptor, &offset, attrs->name, &errmsg, err))
+    return NULL;
+
+  shnum = 0;
+  for (section = sobj->sections; section != NULL; section = section->next)
+    {
+//      fprintf (stderr, "%d: %s\n", shnum, section->name);
+
+      if (!simple_object_internal_write (descriptor, offset, HUNK_NAME, 4,
+					 &errmsg, err))
+	return NULL;
+      offset += 4;
+      if (!write_name (descriptor, &offset, section->name, &errmsg, err))
+	return NULL;
+
+      if (!simple_object_internal_write (descriptor, offset, HUNK_DEBUG, 4,
+					 &errmsg, err))
+	return NULL;
+      offset += 4;
+
+      // collect data len
+      struct simple_object_write_section_buffer * sb;
+      size_t slen = 0;
+      for (sb = section->buffers; sb; sb = sb->next)
+	slen += sb->size;
+
+      unsigned len = (slen + 3) >> 2;
+      unsigned char b[4];
+      b[3] = len;
+      b[2] = len >> 8;
+      b[1] = len >> 16;
+      b[0] = 0;
+
+      if (!simple_object_internal_write (descriptor, offset, b, 4, &errmsg,
+					 err))
+	return 0;
+
+      offset += 4;
+
+      // write data
+      for (sb = section->buffers; sb; sb = sb->next)
+	{
+	  if (!simple_object_internal_write (descriptor, offset,
+					     (unsigned char const *) sb->buffer,
+					     sb->size, &errmsg, err))
+	    return 0;
+	  offset += sb->size;
+	}
+
+      // pad
+      slen = (len << 2) - slen;
+      if (slen)
+	{
+	  b[1] = 0;
+	  b[2] = 0;
+	  if (!simple_object_internal_write (descriptor, offset, b, slen,
+					     &errmsg, err))
+	    return 0;
+
+	  offset += slen;
+	}
+
+      if (!simple_object_internal_write (descriptor, offset, HUNK_END, 4, &errmsg,
+					 err))
+	return NULL;
+      offset += 4;
+
+      ++shnum;
+    }
+  if (shnum == 0)
+    return NULL;
+
+  return NULL;
+}
+
+/* Release the private data for an simple_object_write structure.  */
+
+static void
+simple_object_amigahunk_release_write (void *data)
+{
+  simple_object_amigahunk_release_read(data);
+}
+
+/* The Amiga functions.  */
+
+const struct simple_object_functions simple_object_amigahunk_functions =
+  { simple_object_amigahunk_match, simple_object_amigahunk_find_sections,
+      simple_object_amigahunk_fetch_attributes,
+      simple_object_amigahunk_release_read,
+      simple_object_amigahunk_attributes_merge,
+      simple_object_amigahunk_release_attributes,
+      simple_object_amigahunk_start_write,
+      simple_object_amigahunk_write_to_file,
+      simple_object_amigahunk_release_write };
diff --git a/libiberty/simple-object-common.h b/libiberty/simple-object-common.h
index bef9b08cef8..f86663dd4d7 100644
--- a/libiberty/simple-object-common.h
+++ b/libiberty/simple-object-common.h
@@ -149,6 +149,7 @@ extern const struct simple_object_functions simple_object_coff_functions;
 extern const struct simple_object_functions simple_object_elf_functions;
 extern const struct simple_object_functions simple_object_mach_o_functions;
 extern const struct simple_object_functions simple_object_xcoff_functions;
+extern const struct simple_object_functions simple_object_amigahunk_functions;
 
 /* Read SIZE bytes from DESCRIPTOR at file offset OFFSET into BUFFER.
    Return non-zero on success.  On failure return 0 and set *ERRMSG
diff --git a/libiberty/simple-object.c b/libiberty/simple-object.c
index 5d379d053c4..175c5b026eb 100644
--- a/libiberty/simple-object.c
+++ b/libiberty/simple-object.c
@@ -52,7 +52,8 @@ static const struct simple_object_functions * const format_functions[] =
   &simple_object_elf_functions,
   &simple_object_mach_o_functions,
   &simple_object_coff_functions,
-  &simple_object_xcoff_functions
+  &simple_object_xcoff_functions,
+  &simple_object_amigahunk_functions
 };
 
 /* Read data from a file using the simple_object error reporting
diff --git a/libiberty/strsignal.c b/libiberty/strsignal.c
index 666b1b4f15e..2f607023097 100644
--- a/libiberty/strsignal.c
+++ b/libiberty/strsignal.c
@@ -551,7 +551,7 @@ followed by a newline.
 #ifndef HAVE_PSIGNAL
 
 void
-psignal (int signo, char *message)
+psignal (int signo, const char *message)
 {
   if (signal_names == NULL)
     {
diff --git a/libobjc/configure b/libobjc/configure
index 55fcc33dbe2..a60258f422d 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -7637,7 +7637,8 @@ $as_echo_n "checking for $compiler option to produce PIC... " >&6; }
             # FIXME: we need at least 68020 code to build shared libraries, but
             # adding the `-m68020' flag to GCC prevents building anything better,
             # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+            #lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+            enable_shared=no
         ;;
       esac
       ;;
diff --git a/libobjc/objc/objc.h b/libobjc/objc/objc.h
index 37391a446bb..6c73f53290e 100644
--- a/libobjc/objc/objc.h
+++ b/libobjc/objc/objc.h
@@ -52,7 +52,11 @@ extern "C" {
    Important: this could change and we could switch to 'typedef bool
    BOOL' in the future.  Do not depend on the type of BOOL.  */
 #undef BOOL
+#ifdef AMIGA
+typedef short  BOOL;
+#else
 typedef unsigned char  BOOL;
+#endif
 
 #define YES   (BOOL)1
 #define NO    (BOOL)0
diff --git a/libstdc++-v3/config/os/newlib/ctype_configure_char.cc b/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
index 903de5625d7..ed0c757d42f 100644
--- a/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
+++ b/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
@@ -65,6 +65,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     _M_narrow_ok = 0;
   }
 
+#ifdef __AMIGA__
+  ctype<char>::~ctype()
+  {
+    _S_destroy_c_locale(_M_c_locale_ctype);
+    if (_M_del)
+      delete[] this->table();
+  }
+#endif
+
   char
   ctype<char>::do_toupper(char __c) const
   {
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index fe2a7e4b338..6ca2768cb76 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -8638,6 +8638,7 @@ $as_echo_n "checking for $compiler option to produce PIC... " >&6; }
             # adding the `-m68020' flag to GCC prevents building anything better,
             # like `-m68040'.
             lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+            enable_shared=no
         ;;
       esac
       ;;
@@ -28885,6 +28886,10 @@ else
 
 # Base decisions on target environment.
 case "${host}" in
+  m68k-*-*)
+  	# Nothing to do here.
+  	;;
+
   arm*-*-symbianelf*)
     # This is a freestanding configuration; there is nothing to do here.
     ;;
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index 304a7f5aff6..7483c2df5f1 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -226,6 +226,11 @@ case "${host_os}" in
     os_include_dir="os/generic"
     atomicity_dir="cpu/generic"
     ;;
+  amiga*)
+        os_include_dir="os/newlib"
+        CFLAGS="${TARGET_C_FLAGS}"
+        CXXFLAGS="${TARGET_C_FLAGS}"
+        ;;
   bsd*)
     # Plain BSD attempts to share FreeBSD files.
     os_include_dir="os/bsd/freebsd"
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 5a2b1064ce4..bde080792f4 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -5469,9 +5469,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   stod(const string& __str, size_t* __idx = 0)
   { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
 
+#ifdef _HAVE_LONG_DOUBLE
   inline long double
   stold(const string& __str, size_t* __idx = 0)
   { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
+#endif
 #endif // _GLIBCXX_USE_C99_STDLIB
 
 #if _GLIBCXX_USE_C99_STDIO
@@ -5575,9 +5577,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   stod(const wstring& __str, size_t* __idx = 0)
   { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
 
+#ifdef _HAVE_LONG_DOUBLE
   inline long double
   stold(const wstring& __str, size_t* __idx = 0)
   { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
+#endif
 
 #ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
   // DR 1261.
diff --git a/libstdc++-v3/include/bits/codecvt.h b/libstdc++-v3/include/bits/codecvt.h
index 8a335af6cfd..c65b6224c12 100644
--- a/libstdc++-v3/include/bits/codecvt.h
+++ b/libstdc++-v3/include/bits/codecvt.h
@@ -298,7 +298,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     protected:
       virtual
-      ~codecvt() { }
+      ~codecvt();
 
       virtual result
       do_out(state_type& __state, const intern_type* __from,
@@ -478,8 +478,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static locale::id			id;
 
       explicit
-      codecvt(size_t __refs = 0)
-      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }
+      codecvt(size_t __refs = 0);
 
     protected:
       virtual
@@ -535,8 +534,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static locale::id			id;
 
       explicit
-      codecvt(size_t __refs = 0)
-      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }
+      codecvt(size_t __refs = 0);
 
     protected:
       virtual
diff --git a/libstdc++-v3/include/c_global/cstdlib b/libstdc++-v3/include/c_global/cstdlib
index 1ba5fb7f03a..bf9dae90131 100644
--- a/libstdc++-v3/include/c_global/cstdlib
+++ b/libstdc++-v3/include/c_global/cstdlib
@@ -249,8 +249,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   using ::strtoull;
 #endif
   using ::strtof;
+#ifdef _HAVE_LONG_DOUBLE
   using ::strtold;
-
+#endif
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace __gnu_cxx
 
@@ -269,7 +270,9 @@ namespace std
   using ::__gnu_cxx::strtof;
   using ::__gnu_cxx::strtoll;
   using ::__gnu_cxx::strtoull;
+#ifdef _HAVE_LONG_DOUBLE
   using ::__gnu_cxx::strtold;
+#endif
 } // namespace std
 
 #endif // _GLIBCXX_USE_C99_STDLIB
diff --git a/libstdc++-v3/include/std/memory b/libstdc++-v3/include/std/memory
index 4d5a1456e7f..72758b6101f 100644
--- a/libstdc++-v3/include/std/memory
+++ b/libstdc++-v3/include/std/memory
@@ -115,14 +115,14 @@ inline void*
 align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
 {
   const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
-  const auto __aligned = (__intptr - 1u + __align) & -__align;
-  const auto __diff = __aligned - __intptr;
+  const auto __alignedx = (__intptr - 1u + __align) & -__align;
+  const auto __diff = __alignedx - __intptr;
   if ((__size + __diff) > __space)
     return nullptr;
   else
     {
       __space -= __diff;
-      return __ptr = reinterpret_cast<void*>(__aligned);
+      return __ptr = reinterpret_cast<void*>(__alignedx);
     }
 }
 
diff --git a/libstdc++-v3/include/tr1/cstdint b/libstdc++-v3/include/tr1/cstdint
index 7304d900841..7d6ab77ce17 100644
--- a/libstdc++-v3/include/tr1/cstdint
+++ b/libstdc++-v3/include/tr1/cstdint
@@ -30,7 +30,9 @@
 #define _GLIBCXX_TR1_CSTDINT 1
 
 #pragma GCC system_header
-
+#ifdef AMIGA
+#include <stdint.h>
+#endif
 #include <bits/c++config.h>
 
 // For 8.22.1/1 (see C99, Notes 219, 220, 222)
diff --git a/libstdc++-v3/src/c++11/codecvt.cc b/libstdc++-v3/src/c++11/codecvt.cc
index 00ccb6afd4d..49bef2caecb 100644
--- a/libstdc++-v3/src/c++11/codecvt.cc
+++ b/libstdc++-v3/src/c++11/codecvt.cc
@@ -733,6 +733,10 @@ namespace
 
 locale::id codecvt<char16_t, char, mbstate_t>::id;
 
+codecvt<char16_t, char, mbstate_t>::codecvt(size_t __refs)
+      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs)
+{}
+
 codecvt<char16_t, char, mbstate_t>::~codecvt() { }
 
 codecvt_base::result
@@ -810,6 +814,10 @@ codecvt<char16_t, char, mbstate_t>::do_max_length() const throw()
 
 locale::id codecvt<char32_t, char, mbstate_t>::id;
 
+codecvt<char32_t, char, mbstate_t>::codecvt(size_t __refs)
+: __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }
+
+
 codecvt<char32_t, char, mbstate_t>::~codecvt() { }
 
 codecvt_base::result
diff --git a/libstdc++-v3/src/c++11/ctype.cc b/libstdc++-v3/src/c++11/ctype.cc
index fa370681dad..f80e8303425 100644
--- a/libstdc++-v3/src/c++11/ctype.cc
+++ b/libstdc++-v3/src/c++11/ctype.cc
@@ -51,12 +51,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const size_t ctype<char>::table_size;
 
+#ifndef __AMIGA__
+/* moved to ctype_configure_char */
   ctype<char>::~ctype()
   { 
     _S_destroy_c_locale(_M_c_locale_ctype);
     if (_M_del) 
       delete[] this->table(); 
   }
+#endif
 
   // Fill in the narrowing cache and flag whether all values are
   // valid or not.  _M_narrow_ok is set to 2 if memcpy can't
