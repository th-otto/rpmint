diff -rupN SDL-1.2.16-git.orig/configure.ac SDL-1.2.16-git.new/configure.ac
--- SDL-1.2.16-git.orig/configure.ac	2023-12-21 22:11:00.000000000 +0100
+++ SDL-1.2.16-git.new/configure.ac	2023-12-22 05:13:26.213453512 +0100
@@ -1657,7 +1657,6 @@ CheckAtariGemVideo()
             video_gem=yes
             AC_DEFINE(SDL_VIDEO_DRIVER_GEM)
             SOURCES="$SOURCES $srcdir/src/video/gem/*.c"
-            SDL_LIBS="$SDL_LIBS -lgem"
             have_video=yes
         fi
     fi
@@ -2206,7 +2205,7 @@ CheckAtariLdg()
         if test x$have_ldg_hdr = xyes -a x$have_ldg_lib = xyes; then
             AC_DEFINE(SDL_LOADSO_LDG)
             SOURCES="$SOURCES $srcdir/src/loadso/mint/*.c"
-            SDL_LIBS="$SDL_LIBS -lldg -lgem"
+            SDL_LIBS="$SDL_LIBS -lldg"
             have_loadso=yes
         fi
     fi
diff -rupN SDL-1.2.16-git.orig/src/video/gem/SDL_gemglobals.c SDL-1.2.16-git.new/src/video/gem/SDL_gemglobals.c
--- SDL-1.2.16-git.orig/src/video/gem/SDL_gemglobals.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/SDL_gemglobals.c	2023-12-22 05:13:31.823445850 +0100
@@ -0,0 +1,29 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include <gem.h>
+
+/** global aes variable: aes global array, used by all 
+    "old style" aes functions (function without "mt_")
+ */
+short aes_global[AES_GLOBMAX];
diff -rupN SDL-1.2.16-git.orig/src/video/gem/SDL_gemlib.c SDL-1.2.16-git.new/src/video/gem/SDL_gemlib.c
--- SDL-1.2.16-git.orig/src/video/gem/SDL_gemlib.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/SDL_gemlib.c	2023-12-22 05:13:31.823445850 +0100
@@ -0,0 +1,611 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2012 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/*
+ * Replacement of some gemlib functions,
+ * so that SDL does not depend on it
+ *
+ * 2023 Thorsten Otto
+ */
+
+#include <gem.h>
+#include <gemx.h>
+#include "gem_aesP.h"
+#include "gem_vdiP.h"
+
+
+/*
+ * only the ones used by SDL are implemented here,
+ * if that list ever changes, copy them from gemlib
+ */
+
+/*
+ * AES bindings
+ */
+
+short
+mt_appl_init(short *global_aes)
+{
+	AES_PARAMS(10,0,1,0,0);
+	
+	/* clear some variable that may be used to check if an AES is loaded */
+	global_aes[0] = 0;  /* AES version number */
+	global_aes[2] = -1;  /* AES application ID */
+	aes_intout[0] = -1;  /* AES application ID */
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short
+mt_appl_exit(short *global_aes)
+{
+	AES_PARAMS(19,0,1,0,0);
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short
+mt_appl_getinfo (short type, short *out1, short *out2, short *out3, short *out4, short *global_aes)
+{
+	static int has_agi = -1; /* do the check only once */
+
+	AES_PARAMS(130,1,5,0,0);
+
+	if (has_agi < 0) {
+		has_agi = global_aes[0] >= 0x400 ||
+		          mt_appl_find("?AGI\0\0\0\0",global_aes) >= 0;
+	}
+	if (!has_agi) {
+		return 0;
+	}
+
+	aes_intin[0] = type;
+
+	AES_TRAP(aes_params);
+
+#if CHECK_NULLPTR
+	if (out1)
+#endif
+	*out1 = aes_intout[1];
+#if CHECK_NULLPTR
+	if (out2)
+#endif
+	*out2 = aes_intout[2];
+#if CHECK_NULLPTR
+	if (out3)
+#endif
+	*out3 = aes_intout[3];
+#if CHECK_NULLPTR
+	if (out4)
+#endif
+	*out4 = aes_intout[4];
+
+	return (aes_intout[0]);
+}
+
+short
+mt_appl_write(short ap_id, short length, void *ap_pbuff, short *global_aes)
+{
+	AES_PARAMS(12,2,1,1,0);
+
+	aes_intin[0]  = ap_id;
+	aes_intin[1]  = length;
+	aes_addrin[0] = (long)ap_pbuff;
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short
+mt_appl_find(const char *name, short *global_aes)
+{
+	AES_PARAMS(13,0,1,1,0);
+
+	aes_addrin[0] = (long)name;
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short
+mt_evnt_multi_fast (const EVMULT_IN * em_in, short msg[], EVMULT_OUT * em_out, short *global_aes)
+{
+	AES_PARAMS(25,16,7,1,0);
+
+	aes_params.intin = (const short*)em_in;				/* input integer array */
+	aes_params.intout = (short*)em_out;					/* output integer array */
+
+	aes_addrin[0] = (long)msg;
+
+	AES_TRAP(aes_params);
+
+	return em_out->emo_events;
+}
+
+short
+mt_form_dial(short mode,
+			 short x1, short y1, short w1, short h1,
+			 short x2, short y2, short w2, short h2, short *global_aes)
+{
+	AES_PARAMS(51,9,1,0,0);
+
+	aes_intin[0] = mode;
+	aes_intin[1] = x1;
+	aes_intin[2] = y1;
+	aes_intin[3] = w1;
+	aes_intin[4] = h1;
+	aes_intin[5] = x2;
+	aes_intin[6] = y2;
+	aes_intin[7] = w2;
+	aes_intin[8] = h2;
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short
+mt_graf_handle (short *wcell, short *hcell, short *wbox, short *hbox, short *global_aes)
+{
+#if !(CHECK_NULLPTR)
+	short *ptr;
+#endif
+
+	AES_PARAMS(77,0,5,0,0);
+
+	AES_TRAP(aes_params);
+
+#if CHECK_NULLPTR
+	if (wcell) *wcell = aes_intout[1];
+	if (hcell) *hcell = aes_intout[2];
+	if (wbox)  *wbox  = aes_intout[3];
+	if (hbox)  *hbox  = aes_intout[4];
+#else
+	ptr = &aes_intout[1];
+	*wcell = *(ptr ++);									/* [1] */
+	*hcell = *(ptr ++);									/* [2] */
+	*wbox  = *(ptr ++);									/* [3] */
+	*hbox  = *(ptr);									/* [4] */
+#endif
+
+	return aes_intout[0];
+}
+
+short
+mt_graf_mkstate (short *mx, short *my, short *mbutton, short *kmeta, short *global_aes)
+{
+#if !(CHECK_NULLPTR)
+	short *ptr;
+#endif
+
+	AES_PARAMS(79,0,5,0,0);
+
+	AES_TRAP(aes_params);
+
+#if CHECK_NULLPTR
+	if (mx) 	 *mx	  = aes_intout[1];
+	if (my) 	 *my	  = aes_intout[2];
+	if (mbutton) *mbutton = aes_intout[3];
+	if (kmeta)	 *kmeta   = aes_intout[4];
+#else
+	ptr = &aes_intout[1];
+	*mx = *(ptr ++);									/* [1] */
+	*my = *(ptr ++);									/* [2] */
+	*mbutton = *(ptr ++);							    /* [3] */
+	*kmeta = *(ptr);									/* [4] */
+#endif
+
+	return aes_intout[0];
+}
+
+short
+mt_graf_mouse (short shape, const MFORM *shape_addr, short *global_aes)
+{
+	AES_PARAMS(78,1,1,1,0);
+
+	aes_intin[0] = shape;
+	aes_addrin[0] = (long)shape_addr;
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short 
+mt_wind_calc_grect(short Type, short Parts, const GRECT *In, GRECT *Out, short *global_aes)
+{
+	AES_PARAMS(108,6,5,0,0);
+                    
+	aes_intin[0]		    = Type;
+	aes_intin[1]		    = Parts;
+	*(GRECT*)(aes_intin +2) = *In;
+
+	AES_TRAP(aes_params);
+
+	*Out = *(GRECT*)(aes_intout +1);
+	
+	return aes_intout[0];
+}
+
+short 
+mt_wind_close (short WindowHandle, short *global_aes)
+{
+	AES_PARAMS(102,1,1,0,0);
+
+	aes_intin[0] = WindowHandle;
+
+	AES_TRAP(aes_params);
+
+	return (aes_intout[0]);
+}
+
+short 
+mt_wind_create_grect(short Parts, const GRECT *r, short *global_aes)
+{
+	AES_PARAMS(100,5,1,0,0);
+                    
+	aes_intin[0] = Parts;
+	*(GRECT*)(aes_intin +1) = *r;
+
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short 
+mt_wind_delete (short WindowHandle, short *global_aes)
+{
+	AES_PARAMS(103,1,1,0,0);
+
+	aes_intin[0] = WindowHandle;
+
+	AES_TRAP(aes_params);
+
+	return (aes_intout[0]);
+}
+
+short 
+mt_wind_get_grect(short WindowHandle, short What, GRECT *r, short *global_aes)
+{
+	AES_PARAMS(104,2,5,0,0);
+                    
+	aes_intin[0] = WindowHandle;
+	aes_intin[1] = What;
+	
+	AES_TRAP(aes_params);
+
+	*r = *(GRECT*)(aes_intout +1);
+	
+	return (aes_intout[0]);
+}
+
+short 
+mt_wind_open_grect(short WindowHandle, const GRECT *r, short *global_aes)
+{
+	AES_PARAMS(101,5,1,0,0);
+                    
+	aes_intin[0] = WindowHandle;
+	*(GRECT*)(aes_intin +1) = *r;
+	
+	AES_TRAP(aes_params);
+
+	return aes_intout[0];
+}
+
+short 
+mt_wind_set_grect(short WindowHandle, short What, const GRECT *r, short *global_aes)
+{
+	AES_PARAMS(105,6,1,0,0);
+
+	aes_intin[0]			= WindowHandle;
+	aes_intin[1]			= What;
+	*(GRECT*)(aes_intin +2) = *r;
+	
+	AES_TRAP(aes_params);
+	
+	return (aes_intout[0]);
+
+}
+
+short 
+mt_wind_set_str (short WindowHandle, short What, const char *str, short *global_aes)
+{
+	AES_PARAMS(105,6,1,0,0);
+
+	aes_intin[0]                  = WindowHandle;
+	aes_intin[1]                  = What;
+	*(const char**)(aes_intin +2) = str;
+	*(const char**)(aes_intin +4) = 0;
+	
+	AES_TRAP(aes_params);
+
+	return (aes_intout[0]);
+}
+
+short 
+mt_wind_set_int (short WindowHandle, short What, short W1, short *global_aes)
+{
+	short *ptr;
+
+	AES_PARAMS(105,6,1,0,0);
+
+	ptr = aes_intin;
+	*(ptr ++) = WindowHandle;							/* aes_intin[0] */
+	*(ptr ++) = What;									/* aes_intin[1] */
+	*(ptr ++) = W1; 								    /* aes_intin[2] */
+	*(ptr ++) = 0; 									    /* aes_intin[3] */
+	*(ptr ++) = 0; 									    /* aes_intin[4] */
+	*(ptr ++) = 0; 									    /* aes_intin[5] */
+
+	AES_TRAP(aes_params);
+
+	return (aes_intout[0]);
+}
+
+short 
+mt_wind_update (short Code, short *global_aes)
+{
+	AES_PARAMS(107,1,1,0,0);
+
+	aes_intin[0] = Code;
+
+	AES_TRAP(aes_params);
+
+	return (aes_intout[0]);
+}
+
+/*
+ * VDI bindings
+ */
+
+void
+v_bar (short handle, short pxy[])
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, 0L, pxy, vdi_dummy, vdi_dummy);
+	
+	VDI_TRAP_ESC (vdi_params, handle, 11,1, 2,0);
+}
+
+void
+v_clsvwk (short handle)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, 0L, 0L, vdi_dummy, vdi_dummy );
+	
+	VDI_TRAP_00 (vdi_params, handle, 101);
+}
+
+void
+v_hide_c (short handle)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, 0L, 0L, vdi_dummy, vdi_dummy );
+	
+	VDI_TRAP_00 (vdi_params, handle, 123);
+}
+
+void
+v_opnvwk (short work_in[], short *handle, short work_out[])
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, work_in, 0L, &work_out[0], &work_out[45] );
+	
+	VDI_TRAP (vdi_params, *handle, 100, 0,11);
+
+	*handle = vdi_control[6];
+	
+	/* some VDI doesn't have the same default parameters.
+	   Here is a fix */	
+	
+	if (vdi_control[6]!=0)
+	{ 
+		vsf_perimeter(vdi_control[6],PERIMETER_ON);
+#if 0
+		/* no line/text drawing functions are used in SDL */
+		vsl_ends(vdi_control[6],0,0);
+		vsl_width(vdi_control[6],1);
+		vst_effects(vdi_control[6],0);
+		vsm_height(vdi_control[6],9);
+#endif
+	}
+}
+
+void
+v_show_c (short handle, short reset)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, &reset, 0L, vdi_dummy, vdi_dummy );
+		
+	VDI_TRAP (vdi_params, handle, 122, 0,1);
+}
+
+short
+vq_color (short handle, short index, short flag, short rgb[])
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	short vdi_intin[2];   
+	short vdi_intout[4]; 
+
+	VDI_PARAMS(vdi_control, vdi_intin, 0L, vdi_intout, vdi_dummy );
+	
+	vdi_intin[0] = index;
+	vdi_intin[1] = flag;
+	
+	VDI_TRAP (vdi_params, handle, 26, 0,2);
+	
+	rgb[0] = vdi_intout[1];
+	rgb[1] = vdi_intout[2];
+	rgb[2] = vdi_intout[3];
+	
+	return vdi_intout[0];
+}
+
+void
+vq_extnd (short handle, short flag, short work_out[])
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+
+	VDI_PARAMS(vdi_control, &flag, 0L, &work_out[0], &work_out[45] );
+	
+	VDI_TRAP (vdi_params, handle, 102, 0,1);
+}
+
+void
+vq_scrninfo (short handle, short *work_out)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	static short vdi_intin[1] = {2};   
+
+	VDI_PARAMS(vdi_control, vdi_intin, 0L, work_out, vdi_dummy);
+	
+	VDI_TRAP_ESC (vdi_params, handle, 102,1, 0,1);
+}
+
+void
+vro_cpyfm (short handle, short mode, short pxy[], MFDB *src, MFDB *dst)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	
+	VDI_PARAMS(vdi_control, &mode, pxy, vdi_dummy, vdi_dummy);
+	
+	vdi_control_ptr(0, MFDB *) = src;
+	vdi_control_ptr(1, MFDB *) = dst;
+	
+	VDI_TRAP (vdi_params, handle, 109, 4,1);
+}
+
+void
+vs_clip (short handle, short clip_flag, short pxy[])
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	
+	VDI_PARAMS(vdi_control, &clip_flag, pxy, vdi_dummy, vdi_dummy );
+	
+	VDI_TRAP (vdi_params, handle, 129, 2,1);
+}
+
+void
+vs_color (short handle, short index, const short rgb[])
+{
+	short *ptr;
+	short vdi_control[VDI_CNTRLMAX]; 
+	short vdi_intin[4];   
+	
+	VDI_PARAMS(vdi_control, vdi_intin, 0L, vdi_dummy, vdi_dummy );
+	
+	ptr = vdi_intin;
+	*(ptr ++) = index;		       /* vdi_intin[0] = index */
+	*(ptr ++) = *(rgb ++);	       /* vdi_intin[1] = rgb[0] */
+	*(ptr ++) = *(rgb ++);	       /* vdi_intin[2] = rgb[1] */
+	*(ptr   ) = *(rgb   );	       /* vdi_intin[3] = rgb[2] */
+
+	VDI_TRAP (vdi_params, handle, 14, 0,4);
+}
+
+short
+vsf_color (short handle, short index)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	short vdi_intout[1]; 
+	
+	VDI_PARAMS(vdi_control, &index, 0L, vdi_intout, vdi_dummy );
+	
+	VDI_TRAP (vdi_params, handle, 25, 0,1);
+
+	return vdi_intout[0];
+}
+
+short
+vsf_interior (short handle, short style)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	short vdi_intout[1]; 
+	
+	VDI_PARAMS(vdi_control, &style, 0L, vdi_intout, vdi_dummy );
+	
+	VDI_TRAP (vdi_params, handle, 23, 0,1);
+
+	return vdi_intout[0];
+}
+
+short
+vsf_perimeter (short handle, short vis)
+{
+	short vdi_control[VDI_CNTRLMAX]; 
+	short vdi_intout[1]; 
+	
+	VDI_PARAMS(vdi_control, &vis, 0L, vdi_intout, vdi_dummy );
+
+	VDI_TRAP (vdi_params, handle, 104, 0,1);
+
+	return vdi_intout[0];
+}
+ 
+/*
+ * Utilities
+ */
+
+#undef min
+#undef max
+#define max(x,y)   	(((x)>(y))?(x):(y))
+#define	min(x,y)   	(((x)<(y))?(x):(y))
+
+short
+rc_intersect (const GRECT * r1, GRECT * r2)
+{
+	short tx, ty, tw, th, ret;
+
+	tx = max (r2->g_x, r1->g_x);
+	tw = min (r2->g_x + r2->g_w, r1->g_x + r1->g_w) - tx;
+	
+	ret = (0 < tw);
+	if (ret)
+	{
+		ty = max (r2->g_y, r1->g_y);
+		th = min (r2->g_y + r2->g_h, r1->g_y + r1->g_h) - ty;
+		
+		ret = (0 < th);
+		if (ret)
+		{
+			r2->g_x = tx;
+			r2->g_y = ty;
+			r2->g_w = tw;
+			r2->g_h = th;
+		}
+	}
+	
+	return ret;
+}
+
diff -rupN SDL-1.2.16-git.orig/src/video/gem/SDL_gemvideo.c SDL-1.2.16-git.new/src/video/gem/SDL_gemvideo.c
--- SDL-1.2.16-git.orig/src/video/gem/SDL_gemvideo.c	2023-12-21 22:11:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/SDL_gemvideo.c	2023-12-22 05:16:08.349898715 +0100
@@ -112,7 +112,7 @@ static void GEM_GL_SwapBuffers(_THIS);
 static int GEM_Available(void)
 {
 	/* Test if AES available */
-	internal_ap_id = appl_init();
+	internal_ap_id = mt_appl_init(aes_global);
 	if (internal_ap_id == -1)
 		return 0;
 
diff -rupN SDL-1.2.16-git.orig/src/video/gem/SDL_gemwm.c SDL-1.2.16-git.new/src/video/gem/SDL_gemwm.c
--- SDL-1.2.16-git.orig/src/video/gem/SDL_gemwm.c	2023-12-21 22:11:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/SDL_gemwm.c	2023-12-22 05:20:35.789533416 +0100
@@ -93,7 +93,7 @@ int GEM_IconifyWindow(_THIS)
 		return 0;
 
 	GEM_message[0] = WM_ICONIFY;
-	GEM_message[1] = gl_apid;
+	GEM_message[1] = GEM_ap_id;
 	GEM_message[2] = 0;
 	GEM_message[3] = GEM_handle;
 	GEM_message[4] = 0;
@@ -101,7 +101,7 @@ int GEM_IconifyWindow(_THIS)
 	GEM_message[6] = ICONWIDTH;
 	GEM_message[7] = ICONHEIGHT;
 
-	appl_write(gl_apid, sizeof(GEM_message), GEM_message);
+	appl_write(GEM_ap_id, sizeof(GEM_message), GEM_message);
 
 	return 1;
 }
diff -rupN SDL-1.2.16-git.orig/src/video/gem/gem_aesP.h SDL-1.2.16-git.new/src/video/gem/gem_aesP.h
--- SDL-1.2.16-git.orig/src/video/gem/gem_aesP.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/gem_aesP.h	2023-12-22 05:13:34.720108560 +0100
@@ -0,0 +1,67 @@
+#ifndef __GNUC__
+ #error "you loose"
+#endif
+
+/*
+ * Macros to set up the AES parameter block
+ */
+static inline void _aes_trap (AESPB * aespb)
+{
+	__asm__ volatile (
+		"move.l	%0,%%d1\n\t"	/* &aespb */
+		"move.w	#200,%%d0\n\t"
+		"trap	#2"
+		:
+		: "g"(aespb)
+		: "d0","d1","d2","a0","a1","a2","memory","cc"
+	);
+}
+#define AES_TRAP(aespb) _aes_trap(&aespb)
+
+#define AES_PARAMS(opcode,num_intin,num_intout,num_addrin,num_addrout) \
+	static short	aes_control[AES_CTRLMAX]={opcode,num_intin,num_intout,num_addrin,num_addrout}; \
+	short			aes_intin[__builtin_constant_p(num_intin) ? num_intin : -1];			  \
+	/* some bindings use #num_intout == 0, but AES writes to the array anyway */ \
+	short			aes_intout[__builtin_constant_p(num_intout) ? (num_intout == 0 ? 1 : num_intout) : -1]; 		  \
+	long			aes_addrin[__builtin_constant_p(num_addrin) ? num_addrin : -1]; 		  \
+	long			aes_addrout[__builtin_constant_p(num_addrout) ? num_addrout : -1];		  \
+														  \
+	AESPB aes_params;									  \
+	aes_params.control = &aes_control[0];				  \
+	aes_params.global  = &global_aes[0];				  \
+	aes_params.intin   = aes_intin; 				  \
+	aes_params.intout  = aes_intout;				  \
+	aes_params.addrin  = aes_addrin;				  \
+	aes_params.addrout = aes_addrout
+
+/* to avoid "dereferencing type-punned pointer" */
+static __inline long *__aes_intout_long(short n, short *aes_intout)
+{
+	return ((long *)(aes_intout   +n));
+}
+#define aes_intout_long(n)  *__aes_intout_long(n, aes_intout)
+
+static __inline long *__aes_intin_long(short n, short *aes_intin)
+{
+	return ((long *)(aes_intin   +n));
+}
+#define aes_intin_long(n)  *__aes_intin_long(n, aes_intin)
+
+static __inline void **__aes_intout_ptr(short n, short *aes_intout)
+{
+	return ((void **)(aes_intout   +n));
+}
+#define aes_intout_ptr(n, t)  *((t *)__aes_intout_ptr(n, aes_intout))
+
+static __inline void **__aes_intin_ptr(short n, short *aes_intin)
+{
+	return ((void **)(aes_intin   +n));
+}
+#define aes_intin_ptr(n, t)  *((t *)__aes_intin_ptr(n, aes_intin))
+
+/* special feature for AES bindings: pointer in parameters (for return values)
+ * could be NULL (nice idea by Martin Elsasser against dummy variables) 
+ */
+#define CHECK_NULLPTR 0
+
+
diff -rupN SDL-1.2.16-git.orig/src/video/gem/gem_vdiP.h SDL-1.2.16-git.new/src/video/gem/gem_vdiP.h
--- SDL-1.2.16-git.orig/src/video/gem/gem_vdiP.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/gem_vdiP.h	2023-12-22 05:13:34.720108560 +0100
@@ -0,0 +1,106 @@
+/*
+ * Macros to set up the VDI parameter block
+ */
+
+static inline void
+_vdi_trap_esc (VDIPB * vdipb,
+               long cntrl_0_1, long cntrl_3, long cntrl_5, short handle)
+{
+	__asm__ volatile (
+		"movea.l	%0,%%a0\n\t"	/* &vdipb */
+		"move.l	%%a0,%%d1\n\t"
+		"move.l	(%%a0),%%a0\n\t"	/* vdipb->control */
+		"move.l	%1,(%%a0)+\n\t"	/* cntrl_0, cntrl_1 */
+		"move.l	%2,(%%a0)+\n\t"	/* cntrl_2, cntrl_3 */
+		"move.l	%3,(%%a0)+\n\t"	/* cntrl_4, cntrl_5 */
+		"move.w	%4,(%%a0)\n\t"	/* handle */
+		"move.w	#115,%%d0\n\t"	/* 0x0073 */
+		"trap	#2"
+		:
+		: "g"(vdipb), "g"(cntrl_0_1), "g"(cntrl_3), "g"(cntrl_5), "g"(handle)
+		: "d0", "d1", "d2", "a0", "a1", "a2", "memory", "cc"
+	);
+}
+#define VDI_TRAP_ESC(vdipb, handle, opcode, subop, cntrl_1, cntrl_3) \
+	_vdi_trap_esc (&vdipb, (opcode##uL<<16)|cntrl_1, cntrl_3, subop, handle)
+
+static inline void
+_vdi_trap_00 (VDIPB * vdipb, long cntrl_0_1, short handle)
+{
+	__asm__ volatile (
+		"movea.l %0,%%a0\n\t"	/* &vdipb */
+		"move.l  %%a0,%%d1\n\t"
+		"move.l  (%%a0),%%a0\n\t"	/* vdipb->control */
+		"move.l  %1,(%%a0)+\n\t"	/* cntrl_0, cntrl_1 */
+		"moveq   #0,%%d0\n\t"
+		"move.l  %%d0,(%%a0)+\n\t"	/* cntrl_2, cntrl_3 */
+		"move.l  %%d0,(%%a0)+\n\t"	/* cntrl_4, cntrl_5 */
+		"move.w  %2,(%%a0)\n\t"	/* handle */
+		"move.w  #115,%%d0\n\t"	/* 0x0073 */
+		"trap    #2"
+		:
+		: "g"(vdipb), "g"(cntrl_0_1), "g"(handle)
+		: "d0", "d1", "d2", "a0", "a1", "a2", "memory", "cc"
+	);
+}
+#define VDI_TRAP_00(vdipb, handle, opcode) \
+	_vdi_trap_00 (&vdipb, (opcode##uL<<16), handle)
+
+#define VDI_TRAP(vdipb, handle, opcode, cntrl_1, cntrl_3) \
+	VDI_TRAP_ESC(vdipb, handle, opcode, 0, cntrl_1, cntrl_3)
+
+#define VDI_PARAMS(a,b,c,d,e) \
+	VDIPB vdi_params;         \
+	vdi_params.control = a;   \
+	vdi_params.intin   = b;   \
+	vdi_params.ptsin   = c;   \
+	vdi_params.intout  = d;   \
+	vdi_params.ptsout  = e;
+
+/* special feature for VDI bindings: set VDIPB::intout and VDIPB::ptsout to
+ * vdi_dummy array intead of NULL against crashes if some crazy VDI drivers
+ * tries to write something in ptsout/intout.
+ */ 
+#define USE_VDI_DUMMY 1
+
+#if USE_VDI_DUMMY
+	/* use dummy array vdi_dummy[] from vdi_dummy.c */
+extern short vdi_dummy[];
+#else
+	/* replace vdi_dummy in VDIPB by NULL pointer */
+	#define vdi_dummy 0L
+#endif
+
+#define N_PTRINTS (sizeof(void *) / sizeof(short))
+
+#ifdef __GNUC__
+
+/* to avoid "dereferencing type-punned pointer" */
+static __inline long *__vdi_array_long(short n, short *array)
+{
+	return ((long *)(array   +n));
+}
+
+static __inline void **__vdi_array_ptr(short n, short *array)
+{
+	return ((void**)(array + n));
+}
+
+#else
+
+#define __vdi_array_ptr(n, array)   ((void **)(array + (n)))
+#define __vdi_array_long(n, array)   ((long *)(array + (n)))
+
+#endif
+
+#define vdi_intin_long(n)  *__vdi_array_long(n, vdi_intin)
+#define vdi_intout_long(n)  *__vdi_array_long(n, vdi_intout)
+#define vdi_ptsin_long(n)  *__vdi_array_long(n, vdi_ptsin)
+#define vdi_ptsout_long(n)  *__vdi_array_long(n, vdi_ptsout)
+
+#define vdi_control_ptr(n, t)  *((t *)__vdi_array_ptr(7 + (n) * N_PTRINTS, vdi_control))
+#define vdi_intin_ptr(n, t)  *((t *)__vdi_array_ptr(n, vdi_intin))
+#define vdi_intout_ptr(n, t)  *((t *)__vdi_array_ptr(n, vdi_intout))
+#define vdi_ptsin_ptr(n, t)  *((t *)__vdi_array_ptr(n, vdi_ptsin))
+#define vdi_ptsout_ptr(n, t)  *((t *)__vdi_array_ptr(n, vdi_ptsout))
+
diff -rupN SDL-1.2.16-git.orig/src/video/gem/vdi_dummy.c SDL-1.2.16-git.new/src/video/gem/vdi_dummy.c
--- SDL-1.2.16-git.orig/src/video/gem/vdi_dummy.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/gem/vdi_dummy.c	2023-12-22 05:13:34.720108560 +0100
@@ -0,0 +1,7 @@
+#include <gem.h>
+#include "gem_vdiP.h"
+
+#if USE_VDI_DUMMY
+short vdi_dummy[1024];
+#endif
+
diff -rupN SDL-1.2.16-git.orig/src/video/xbios/SDL_xbios_ctpci.c SDL-1.2.16-git.new/src/video/xbios/SDL_xbios_ctpci.c
--- SDL-1.2.16-git.orig/src/video/xbios/SDL_xbios_ctpci.c	2023-12-21 22:11:00.000000000 +0100
+++ SDL-1.2.16-git.new/src/video/xbios/SDL_xbios_ctpci.c	2023-12-22 05:47:20.667321796 +0100
@@ -157,13 +157,13 @@ static void saveMode(_THIS, SDL_PixelFor
 {
 	SCREENINFO si = { 0 };
 
-	if (appl_init() >= 0) {
+	if (mt_appl_init(aes_global) >= 0) {
 		wind_update(BEG_UPDATE);
 		wind_update(BEG_MCTRL);
 
 		graf_mouse(M_OFF, NULL);
 
-		wind_get(0, WF_WORKXYWH, &desktop.g_x, &desktop.g_y, &desktop.g_w, &desktop.g_h);
+		wind_get_grect(0, WF_WORKXYWH, &desktop);
 
 		aes_present = SDL_TRUE;
 	}
