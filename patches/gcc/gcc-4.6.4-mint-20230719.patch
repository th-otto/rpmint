diff --git a/Makefile.def b/Makefile.def
index 95c77ab179c..eb906eff8ae 100644
--- a/Makefile.def
+++ b/Makefile.def
@@ -69,10 +69,10 @@ host_modules= { module= gmp; lib_path=.libs; bootstrap=true;
 		// gmp's configure will complain if given anything
 		// different from host for target.
 	        target="none-${host_vendor}-${host_os}"; };
-host_modules= { module= mpfr; lib_path=.libs; bootstrap=true;
+host_modules= { module= mpfr; lib_path=src/.libs; bootstrap=true;
 		extra_configure_flags='--disable-shared @extra_mpfr_configure_flags@';
 		no_install= true; };
-host_modules= { module= mpc; lib_path=.libs; bootstrap=true;
+host_modules= { module= mpc; lib_path=src/.libs; bootstrap=true;
 		extra_configure_flags='--disable-shared @extra_mpc_gmp_configure_flags@ @extra_mpc_mpfr_configure_flags@';
 		no_install= true; };
 host_modules= { module= ppl; lib_path=src/.libs; bootstrap=true;
diff --git a/Makefile.in b/Makefile.in
index 51edbdf0268..753130ef248 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -616,12 +616,12 @@ HOST_LIB_PATH_gmp = \
 
 @if mpfr
 HOST_LIB_PATH_mpfr = \
-  $$r/$(HOST_SUBDIR)/mpfr/.libs:$$r/$(HOST_SUBDIR)/prev-mpfr/.libs:
+  $$r/$(HOST_SUBDIR)/mpfr/src/.libs:$$r/$(HOST_SUBDIR)/prev-mpfr/src/.libs:
 @endif mpfr
 
 @if mpc
 HOST_LIB_PATH_mpc = \
-  $$r/$(HOST_SUBDIR)/mpc/.libs:$$r/$(HOST_SUBDIR)/prev-mpc/.libs:
+  $$r/$(HOST_SUBDIR)/mpc/src/.libs:$$r/$(HOST_SUBDIR)/prev-mpc/src/.libs:
 @endif mpc
 
 @if ppl
@@ -16833,14 +16833,14 @@ configure-gmp: stage_current
 maybe-configure-gmp: configure-gmp
 configure-gmp: 
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	$(HOST_EXPORTS)  \
 	echo Configuring in $(HOST_SUBDIR)/gmp; \
 	cd "$(HOST_SUBDIR)/gmp" || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -16862,7 +16862,7 @@ configure-stage1-gmp:
 	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE1_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -16873,7 +16873,7 @@ configure-stage1-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -16894,7 +16894,7 @@ configure-stage2-gmp:
 	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE2_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -16906,7 +16906,7 @@ configure-stage2-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -16928,7 +16928,7 @@ configure-stage3-gmp:
 	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE3_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -16940,7 +16940,7 @@ configure-stage3-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -16962,7 +16962,7 @@ configure-stage4-gmp:
 	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE4_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -16974,7 +16974,7 @@ configure-stage4-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -16996,7 +16996,7 @@ configure-stageprofile-gmp:
 	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEprofile_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -17008,7 +17008,7 @@ configure-stageprofile-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -17030,7 +17030,7 @@ configure-stagefeedback-gmp:
 	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
 	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
 	test ! -f $(HOST_SUBDIR)/gmp/Makefile || exit 0; \
 	$(HOST_EXPORTS) \
@@ -17042,7 +17042,7 @@ configure-stagefeedback-gmp:
 	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/gmp ; \
 	cd $(HOST_SUBDIR)/gmp || exit 1; \
 	case $(srcdir) in \
-	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  /* | [A-Za-z]:[\\/]*) topdir=$$s ;; \
 	  *) topdir=`echo $(HOST_SUBDIR)/gmp/ | \
 		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
 	esac; \
@@ -17303,7 +17303,7 @@ TARGET-stagefeedback-gmp = $(TARGET-gmp)
 all-stagefeedback-gmp: configure-stagefeedback-gmp
 	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -17346,7 +17346,7 @@ maybe-check-gmp: check-gmp
 check-gmp:
 	@: $(MAKE); $(unstage)
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	(cd $(HOST_SUBDIR)/gmp && \
 	  $(MAKE) $(FLAGS_TO_PASS)  check)
@@ -17945,7 +17945,7 @@ TARGET-mpfr=all
 maybe-all-mpfr: all-mpfr
 all-mpfr: configure-mpfr
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS)  \
 	(cd $(HOST_SUBDIR)/mpfr && \
 	  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS)  \
@@ -17965,7 +17965,7 @@ TARGET-stage1-mpfr = $(TARGET-mpfr)
 all-stage1-mpfr: configure-stage1-mpfr
 	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE1_TFLAGS)"; \
 	$(HOST_EXPORTS)  \
 	cd $(HOST_SUBDIR)/mpfr && \
@@ -18006,7 +18006,7 @@ TARGET-stage2-mpfr = $(TARGET-mpfr)
 all-stage2-mpfr: configure-stage2-mpfr
 	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE2_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -18049,7 +18049,7 @@ TARGET-stage3-mpfr = $(TARGET-mpfr)
 all-stage3-mpfr: configure-stage3-mpfr
 	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE3_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -18092,7 +18092,7 @@ TARGET-stage4-mpfr = $(TARGET-mpfr)
 all-stage4-mpfr: configure-stage4-mpfr
 	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGE4_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -18135,7 +18135,7 @@ TARGET-stageprofile-mpfr = $(TARGET-mpfr)
 all-stageprofile-mpfr: configure-stageprofile-mpfr
 	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEprofile_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -18178,7 +18178,7 @@ TARGET-stagefeedback-mpfr = $(TARGET-mpfr)
 all-stagefeedback-mpfr: configure-stagefeedback-mpfr
 	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
 	@r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
 	$(HOST_EXPORTS) \
 	$(POSTSTAGE1_HOST_EXPORTS)  \
@@ -18332,7 +18332,7 @@ html-mpfr: \
     configure-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18357,7 +18357,7 @@ TAGS-mpfr: \
     configure-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18383,7 +18383,7 @@ install-info-mpfr: \
     info-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18409,7 +18409,7 @@ install-pdf-mpfr: \
     pdf-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18435,7 +18435,7 @@ install-html-mpfr: \
     html-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18460,7 +18460,7 @@ installcheck-mpfr: \
     configure-mpfr 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18484,7 +18484,7 @@ maybe-mostlyclean-mpfr: mostlyclean-mpfr
 mostlyclean-mpfr: 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18508,7 +18508,7 @@ maybe-clean-mpfr: clean-mpfr
 clean-mpfr: 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
@@ -18532,7 +18532,7 @@ maybe-distclean-mpfr: distclean-mpfr
 distclean-mpfr: 
 	@[ -f ./mpfr/Makefile ] || exit 0; \
 	r=`${PWD_COMMAND}`; export r; \
-	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	s=`cd $(srcdir); ${PWD_COMMAND} | sed -e 's@^/\(.\)/\(.*\)@\1:/\2@'`; export s; \
 	$(HOST_EXPORTS) \
 	for flag in $(EXTRA_HOST_FLAGS) ; do \
 	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
diff --git a/README.md b/README.md
new file mode 100644
index 00000000000..fb7bce189b7
--- /dev/null
+++ b/README.md
@@ -0,0 +1,46 @@
+gcc-4.6.4
+=========
+
+Patch to gcc for supporting "fastcall" on m68k target.
+
+By default gcc pass all arguments on the stack for the m68k target, 
+this is not always optimal when memory access is slow. This default
+abi is from now an named the `cdecl` abi.
+
+A new abi named `fastcall` has been added, where registers d0-d2, 
+a0-a1 and fp0-fp2 are used to pass registers to functions when possible.
+A third option is to use the `regparm` option to specify the number
+of registers of each class to use.
+
+At a minimum d0-d1, a0-a1, fp0-fp1 are clobbered by function calls.
+Any further register potentially used for the arguments for the
+functions abi is also clobbered, that is that d2 is also 
+concidered clobbered for `fastcall`.
+
+32 bit float are passed in registers when 68881 is not enabled, when
+enabled fp0-fp2 are used for all floating point types.
+
+All build-in libgcc functions use the `fastcall` abi, this means that
+any library being used must also be rebuilt. This is most useful on
+plain 68000 where short helper functions for 32bit int are frequently
+called.
+
+Only named arguments for variadic functions can use registers, all
+unnamed arguments are always passed on the stack.
+
+Examples
+--------
+
+    // a passed in d0
+    // b passed in d1
+    __attribute__((fastcall)) int foo(int a, int b);
+    
+    // a passed in d0
+    // b passed in a0
+    // c passed in d1
+    __attribute__((fastcall)) int foo(float a, int *b, char c);
+
+    // s passed in a0
+    // rest on stack
+    __attribute__((fastcall)) void printf(char *s, ...);
+
diff --git a/boehm-gc/configure b/boehm-gc/configure
index 019054da22a..fc3118cbfc6 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -5655,6 +5655,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9287,6 +9293,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/config-ml.in b/config-ml.in
index 2dd0d5181f2..ca30eb9984b 100644
--- a/config-ml.in
+++ b/config-ml.in
@@ -351,6 +351,24 @@ m68*-*-*)
 	    esac
 	  done
 	fi
+	case "${host}" in
+	  *-*-mint*)
+	    case "${srcdir}" in
+	      */libgcc ) : ;;
+	      *)
+	        old_multidirs="${multidirs}"
+	        multidirs=""
+	        for x in ${old_multidirs}; do
+		  case "$x" in
+		    *mshort ) : ;;
+		    *mfastcall ) : ;;
+		    *) multidirs="${multidirs} ${x}" ;;
+		  esac
+		done
+		;;
+	    esac
+	    ;;
+	esac
 	;;
 mips*-*-*)
 	if [ x$enable_single_float = xno ]
diff --git a/config.guess b/config.guess
index 6eeea023eb9..4e19ae06ba5 100755
--- a/config.guess
+++ b/config.guess
@@ -395,22 +395,22 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+        echo m68k-atari-mint
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint
         exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+        echo m68k-atari-mint
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
+        echo m68k-milan-mint
         exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
+        echo m68k-hades-mint
         exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
+        echo m68k-unknown-mint
         exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten${UNAME_RELEASE}
diff --git a/configure b/configure
index 6be5e9d2b60..3b281204fdd 100755
--- a/configure
+++ b/configure
@@ -3077,6 +3077,9 @@ if test x$enable_libmudflap = x ; then
     *-*-freebsd*)
         # Enable libmudflap by default in FreeBSD.
 	;;
+    *-*-mint*)
+        # Enable libmudflap by default in MiNT.
+	;;
     *)
         # Disable it by default everywhere else.
 	noconfigdirs="$noconfigdirs target-libmudflap"
@@ -3449,6 +3452,9 @@ case "${target}" in
   m68k-*-coff*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
@@ -5279,9 +5285,13 @@ if test "x$with_mpfr_lib" != x; then
   gmplibs="-L$with_mpfr_lib $gmplibs"
 fi
 if test "x$with_mpfr$with_mpfr_include$with_mpfr_lib" = x && test -d ${srcdir}/mpfr; then
-  gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir $gmplibs"
-  gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr -I$$s/mpfr '"$gmpinc"
-  extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir"
+  # MPFR v3.1.0 moved the sources into a src sub-directory.
+  if ! test -d ${srcdir}/mpfr/src; then
+    as_fn_error "Building GCC with MPFR in the source tree is only handled for MPFR 3.1.0+." "$LINENO" 5
+  fi
+  gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir $gmplibs"
+  gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr/src -I$$s/mpfr/src '"$gmpinc"
+  extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr/src --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir"
   # Do not test the mpfr version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
diff --git a/configure.ac b/configure.ac
index ba6d84da43b..875bca42544 100644
--- a/configure.ac
+++ b/configure.ac
@@ -523,6 +523,9 @@ if test x$enable_libmudflap = x ; then
     *-*-freebsd*)
         # Enable libmudflap by default in FreeBSD.
 	;;
+    *-*-mint*)
+        # Enable libmudflap by default in MiNT.
+	;;
     *)
         # Disable it by default everywhere else.
 	noconfigdirs="$noconfigdirs target-libmudflap"
@@ -895,6 +898,9 @@ case "${target}" in
   m68k-*-coff*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
@@ -1393,9 +1399,14 @@ if test "x$with_mpfr_lib" != x; then
   gmplibs="-L$with_mpfr_lib $gmplibs"
 fi
 if test "x$with_mpfr$with_mpfr_include$with_mpfr_lib" = x && test -d ${srcdir}/mpfr; then
-  gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir $gmplibs"
-  gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr -I$$s/mpfr '"$gmpinc"
-  extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/'"$lt_cv_objdir"
+  # MPFR v3.1.0 moved the sources into a src sub-directory.
+  if ! test -d ${srcdir}/mpfr/src; then
+    AC_MSG_ERROR([dnl
+Building GCC with MPFR in the source tree is only handled for MPFR 3.1.0+.])
+  fi
+  gmplibs='-L$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir $gmplibs"
+  gmpinc='-I$$r/$(HOST_SUBDIR)/mpfr/src -I$$s/mpfr/src '"$gmpinc"
+  extra_mpc_mpfr_configure_flags='--with-mpfr-include=$$s/mpfr/src --with-mpfr-lib=$$r/$(HOST_SUBDIR)/mpfr/src/'"$lt_cv_objdir"
   # Do not test the mpfr version.  Assume that it is sufficient, since
   # it is in the source tree, and the library has not been built yet
   # but it would be included on the link line in the version check below
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index e0b952ffd99..ae3c83930b7 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -618,6 +618,9 @@ man7ext = .7
 objext = .o
 exeext = @host_exeext@
 build_exeext = @build_exeext@
+EVAL_MINGW := case `uname -s` in MINGW*) echo yes;; *) echo no;; esac
+MINGW := $(shell $(EVAL_MINGW))
+mingw_srcdir := $(shell if test "${MINGW}" = yes; then cmd //c echo ${srcdir}; else echo ${srcdir}; fi)
 
 # Directory in which to put man pages.
 mandir = @mandir@
@@ -915,7 +918,7 @@ GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \
 	tree-ssa-alias.h vecir.h
 GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h
 COVERAGE_H = coverage.h $(GCOV_IO_H)
-DEMANGLE_H = $(srcdir)/../include/demangle.h
+DEMANGLE_H = $(mingw_srcdir)/../include/demangle.h
 RECOG_H = recog.h
 ALIAS_H = alias.h coretypes.h
 EMIT_RTL_H = emit-rtl.h
@@ -948,25 +951,25 @@ GGC_H = ggc.h gtype-desc.h statistics.h
 GGC_INTERNAL_H = ggc-internal.h $(GGC_H)
 TIMEVAR_H = timevar.h timevar.def
 INSN_ATTR_H = insn-attr.h $(INSN_ADDR_H)
-INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h
+INSN_ADDR_H = $(mingw_srcdir)/insn-addr.h vecprim.h
 C_COMMON_H = c-family/c-common.h c-family/c-common.def \
 	$(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H) $(DIAGNOSTIC_CORE_H)
 C_PRAGMA_H = c-family/c-pragma.h $(CPPLIB_H)
 C_TREE_H = c-tree.h $(C_COMMON_H) $(DIAGNOSTIC_H)
-SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h \
-	$(srcdir)/../include/safe-ctype.h $(srcdir)/../include/filenames.h
+SYSTEM_H = system.h hwint.h $(mingw_srcdir)/../include/libiberty.h \
+	$(mingw_srcdir)/../include/safe-ctype.h $(mingw_srcdir)/../include/filenames.h
 PREDICT_H = predict.h predict.def
-CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \
-	$(srcdir)/../libcpp/include/cpplib.h
-INPUT_H = $(srcdir)/../libcpp/include/line-map.h input.h
+CPPLIB_H = $(mingw_srcdir)/../libcpp/include/line-map.h \
+	$(mingw_srcdir)/../libcpp/include/cpplib.h
+INPUT_H = $(mingw_srcdir)/../libcpp/include/line-map.h input.h
 OPTS_H = $(INPUT_H) $(VEC_H) opts.h
 DECNUM_H = $(DECNUM)/decContext.h $(DECNUM)/decDPD.h $(DECNUM)/decNumber.h \
 	$(DECNUMFMT)/decimal32.h $(DECNUMFMT)/decimal64.h \
 	$(DECNUMFMT)/decimal128.h $(DECNUMFMT)/decimal128Local.h
-MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h
-SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)
-CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h
-CPP_INTERNAL_H = $(srcdir)/../libcpp/internal.h $(CPP_ID_DATA_H)
+MKDEPS_H = $(mingw_srcdir)/../libcpp/include/mkdeps.h
+SYMTAB_H = $(mingw_srcdir)/../libcpp/include/symtab.h $(OBSTACK_H)
+CPP_ID_DATA_H = $(CPPLIB_H) $(mingw_srcdir)/../libcpp/include/cpp-id-data.h
+CPP_INTERNAL_H = $(mingw_srcdir)/../libcpp/internal.h $(CPP_ID_DATA_H)
 TREE_PASS_H = tree-pass.h $(TIMEVAR_H)
 TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H) $(TREE_PASS_H)
 TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \
@@ -1831,7 +1834,7 @@ libbackend.a: $(OBJS)
 xgcc$(exeext): $(GCC_OBJS) gccspec.o version.o intl.o prefix.o \
    version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
-	  gccspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+	  gccspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS) $(GLIBC_SO)
 
 # cpp is to cpp0 as gcc is to cc1.
 # The only difference from xgcc is that it's linked with cppspec.o
@@ -1839,7 +1842,7 @@ xgcc$(exeext): $(GCC_OBJS) gccspec.o version.o intl.o prefix.o \
 cpp$(exeext): $(GCC_OBJS) cppspec.o version.o intl.o prefix.o \
    version.o $(LIBDEPS) $(EXTRA_GCC_OBJS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \
-	  cppspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS)
+	  cppspec.o intl.o prefix.o version.o $(EXTRA_GCC_OBJS) $(LIBS) $(GLIBC_SO)
 
 # Dump a specs file to make -B./ read these specs over installed ones.
 $(SPECS): xgcc$(exeext)
@@ -1867,7 +1870,7 @@ cc1-checksum.o : cc1-checksum.c $(CONFIG_H) $(SYSTEM_H)
 
 cc1$(exeext): $(C_OBJS) cc1-checksum.o $(BACKEND) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) \
-	  cc1-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+	  cc1-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 
 #
 # Build libgcc.a.
@@ -2082,7 +2085,7 @@ COLLECT2_LIBS = @COLLECT2_LIBS@
 collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
 # Don't try modifying collect2 (aka ld) in place--it might be linking this.
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o T$@ \
-		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS)
+		$(COLLECT2_OBJS) $(LIBS) $(COLLECT2_LIBS) $(GLIBC_SO)
 	mv -f T$@ $@
 
 collect2.o : collect2.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h \
@@ -2098,7 +2101,7 @@ tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h
     $(OBSTACK_H) collect2.h intl.h
 
 lto-wrapper$(exeext): lto-wrapper.o intl.o $(LIBDEPS)
-	+$(COMPILER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ lto-wrapper.o intl.o $(LIBS)
+	+$(COMPILER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ lto-wrapper.o intl.o $(LIBS) $(GLIBC_SO)
 	mv -f T$@ $@
 
 lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h \
@@ -3502,14 +3505,14 @@ $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \
 # Build auxiliary files that support ecoff format.
 mips-tfile: mips-tfile.o version.o $(LIBDEPS)
 	$(LINKER) $(LINKERFLAGS) $(LDFLAGS) -o $@ \
-		mips-tfile.o version.o $(LIBS)
+		mips-tfile.o version.o $(LIBS) $(GLIBC_SO)
 
 mips-tfile.o : mips-tfile.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) version.h $(srcdir)/../include/getopt.h $(GSTAB_H) intl.h
 
 mips-tdump: mips-tdump.o version.o $(LIBDEPS)
 	$(LINKER) $(LINKERFLAGS) $(LDFLAGS) -o $@ \
-		mips-tdump.o version.o $(LIBS)
+		mips-tdump.o version.o $(LIBS) $(GLIBC_SO)
 
 mips-tdump.o : mips-tdump.c $(CONFIG_H) $(RTL_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) version.h $(srcdir)/../include/getopt.h stab.def
@@ -3794,7 +3797,7 @@ GENGTYPE_FLAGS=
 
 gtyp-input.list: s-gtyp-input ; @true
 s-gtyp-input: Makefile
-	@: $(call write_entries_to_file,$(GTFILES),tmp-gi.list)
+	@: $(call write_entries_to_file,$(patsubst $(srcdir)/%, $(mingw_srcdir)/%, $(GTFILES)),tmp-gi.list)
 	$(SHELL) $(srcdir)/../move-if-change tmp-gi.list gtyp-input.list
 	$(STAMP) s-gtyp-input
 
@@ -3802,7 +3805,7 @@ s-gtype: build/gengtype$(build_exeext) $(filter-out [%], $(GTFILES)) \
 	 gtyp-input.list
 # First, parse all files and save a state file.
 	$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \
-                    -S $(srcdir) -I gtyp-input.list -w gtype.state
+                    -S $(mingw_srcdir) -I gtyp-input.list -w gtype.state
 # Second, read the state file and generate all files.  This ensure that
 # gtype.state is correctly read:
 	$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \
@@ -4026,11 +4029,11 @@ gcov-dump.o: gcov-dump.c gcov-io.c $(GCOV_IO_H) $(SYSTEM_H) coretypes.h \
 
 GCOV_OBJS = gcov.o intl.o version.o errors.o
 gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
-	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@
+	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) $(GLIBC_SO) -o $@
 GCOV_DUMP_OBJS = gcov-dump.o version.o errors.o
 gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \
-		$(LIBS) -o $@
+		$(LIBS) $(GLIBC_SO) -o $@
 #
 # Build the include directories.  The stamp files are stmp-* rather than
 # s-* so that mostlyclean does not force the include directory to
diff --git a/gcc/collect2.c b/gcc/collect2.c
index 42e35b607ff..62a8d1d6a54 100644
--- a/gcc/collect2.c
+++ b/gcc/collect2.c
@@ -1072,6 +1072,8 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,
 
 /* Main program.  */
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 6dc2427bc7c..6df36803d99 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -1809,6 +1809,15 @@ m68k-*-linux*)		# Motorola m68k's running GNU/Linux
 	    tmake_file="$tmake_file m68k/t-slibgcc-elf-ver"
 	fi
 	;;
+m68k-*-mint*)
+	default_m68k_cpu=68000
+	default_cf_cpu=5475
+	tm_file="${tm_file} m68k/mint.h"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-mint"
+	gas=yes
+	gnu_ld=yes
+	;;
 m68k-*-rtems*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5206
diff --git a/gcc/config/host-darwin.c b/gcc/config/host-darwin.c
index 4d5a5512e9f..ba62c1d91a4 100644
--- a/gcc/config/host-darwin.c
+++ b/gcc/config/host-darwin.c
@@ -24,7 +24,10 @@
 #include "config/host-darwin.h"
 
 /* Yes, this is really supposed to work.  */
-static char pch_address_space[1024*1024*1024] __attribute__((aligned (4096)));
+/* This allows for a pagesize of 16384, which we have on Darwin20, but should
+   continue to work OK for pagesize 4096 which we have on earlier versions.
+   The size is 1 (binary) Gb.  */
+static char pch_address_space[65536*16384] __attribute__((aligned (16384)));
 
 /* Return the address of the PCH address space, if the PCH will fit in it.  */
 
diff --git a/gcc/config/m68k/addxf3.c b/gcc/config/m68k/addxf3.c
new file mode 100644
index 00000000000..fb780ed6ec4
--- /dev/null
+++ b/gcc/config/m68k/addxf3.c
@@ -0,0 +1,5 @@
+#ifndef __mcoldfire__
+
+#include "../soft-fp/addxf3.c"
+
+#endif
diff --git a/gcc/config/m68k/divxf3.c b/gcc/config/m68k/divxf3.c
new file mode 100644
index 00000000000..72b1d51b91c
--- /dev/null
+++ b/gcc/config/m68k/divxf3.c
@@ -0,0 +1,5 @@
+#ifndef __mcoldfire__
+
+#include "../soft-fp/divxf3.c"
+
+#endif
diff --git a/gcc/config/m68k/extenddfxf2.c b/gcc/config/m68k/extenddfxf2.c
new file mode 100644
index 00000000000..9480b1d4806
--- /dev/null
+++ b/gcc/config/m68k/extenddfxf2.c
@@ -0,0 +1,2 @@
+#define L_extenddfxf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/extendsfdf2.c b/gcc/config/m68k/extendsfdf2.c
new file mode 100644
index 00000000000..d323cf2fa35
--- /dev/null
+++ b/gcc/config/m68k/extendsfdf2.c
@@ -0,0 +1,2 @@
+#define L_extendsfdf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/extendsfxf2.c b/gcc/config/m68k/extendsfxf2.c
new file mode 100644
index 00000000000..5bd4bea784f
--- /dev/null
+++ b/gcc/config/m68k/extendsfxf2.c
@@ -0,0 +1,2 @@
+#define L_extendsfxf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/fixdfsi.c b/gcc/config/m68k/fixdfsi.c
new file mode 100644
index 00000000000..1d811017e2c
--- /dev/null
+++ b/gcc/config/m68k/fixdfsi.c
@@ -0,0 +1,2 @@
+#define L_fixdfsi
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/fixsfsi.c b/gcc/config/m68k/fixsfsi.c
new file mode 100644
index 00000000000..c76353b3bd6
--- /dev/null
+++ b/gcc/config/m68k/fixsfsi.c
@@ -0,0 +1,2 @@
+#define L_fixsfsi
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/fixxfsi.c b/gcc/config/m68k/fixxfsi.c
new file mode 100644
index 00000000000..ba166b14308
--- /dev/null
+++ b/gcc/config/m68k/fixxfsi.c
@@ -0,0 +1,2 @@
+#define L_fixxfsi
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatsidf.c b/gcc/config/m68k/floatsidf.c
new file mode 100644
index 00000000000..0fe443ca183
--- /dev/null
+++ b/gcc/config/m68k/floatsidf.c
@@ -0,0 +1,2 @@
+#define L_floatsidf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatsisf.c b/gcc/config/m68k/floatsisf.c
new file mode 100644
index 00000000000..7ce07487f40
--- /dev/null
+++ b/gcc/config/m68k/floatsisf.c
@@ -0,0 +1,2 @@
+#define L_floatsisf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatsixf.c b/gcc/config/m68k/floatsixf.c
new file mode 100644
index 00000000000..5c10b8081ed
--- /dev/null
+++ b/gcc/config/m68k/floatsixf.c
@@ -0,0 +1,2 @@
+#define L_floatsixf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatunsidf.c b/gcc/config/m68k/floatunsidf.c
new file mode 100644
index 00000000000..f901056f428
--- /dev/null
+++ b/gcc/config/m68k/floatunsidf.c
@@ -0,0 +1,2 @@
+#define L_floatunsidf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatunsisf.c b/gcc/config/m68k/floatunsisf.c
new file mode 100644
index 00000000000..8a143a26cdc
--- /dev/null
+++ b/gcc/config/m68k/floatunsisf.c
@@ -0,0 +1,2 @@
+#define L_floatunsisf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/floatunsixf.c b/gcc/config/m68k/floatunsixf.c
new file mode 100644
index 00000000000..d67949bd696
--- /dev/null
+++ b/gcc/config/m68k/floatunsixf.c
@@ -0,0 +1,2 @@
+#define L_floatunsixf
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/fpgnulib.c b/gcc/config/m68k/fpgnulib.c
index 2a7f6c75d11..5a6971af38f 100644
--- a/gcc/config/m68k/fpgnulib.c
+++ b/gcc/config/m68k/fpgnulib.c
@@ -1,10 +1,6 @@
 /* This is a stripped down version of floatlib.c.  It supplies only those
    functions which exist in libgcc, but for which there is not assembly
-   language versions in m68k/lb1sf68.asm.
-
-   It also includes simplistic support for extended floats (by working in
-   double precision).  You must compile this file again with -DEXTFLOAT
-   to get this support.  */
+   language versions in m68k/lb1sf68.asm.  */
 
 /*
 ** gnulib support for software floating point.
@@ -53,6 +49,7 @@
 #define EXCESS		126L
 #define SIGNBIT		0x80000000L
 #define HIDDEN		(1L << 23L)
+#define EXPFMASK	0xFFL
 #define SIGN(fp)	((fp) & SIGNBIT)
 #define EXP(fp)		(((fp) >> 23L) & 0xFF)
 #define MANT(fp)	(((fp) & 0x7FFFFFL) | HIDDEN)
@@ -102,23 +99,61 @@ union long_double_long
       unsigned long lower;
     } l;
 };
-
-#ifndef EXTFLOAT
 
+/* Prototypes for functions defined here in case we use them.  */
+int __unordsf2(float a, float b);
+int __unorddf2(double a, double b);
+double __floatunsidf (unsigned long a1);
+double __floatsidf (long a1);
+float __floatunsisf (unsigned long l);
+float __floatsisf (long l);
+double __extendsfdf2 (float a1);
+float __truncdfsf2 (double a1);
+long __fixdfsi (double a1);
+long __fixsfsi (float a1);
+long __cmpdf2 (double x1, double x2);
+
+#if !defined (__mcoldfire__)
+int __unordxf2(long double a, long double b);
+long double __extenddfxf2 (double d);
+double __truncxfdf2 (long double ld);
+long double __extendsfxf2 (float f);
+float __truncxfsf2 (long double ld);
+long double __floatsixf (long l);
+long double __floatunsixf (unsigned long l);
+long __fixxfsi (long double ld);
+long double __addxf3 (long double x1, long double x2);
+long double __subxf3 (long double x1, long double x2);
+long double __mulxf3 (long double x1, long double x2);
+long double __divxf3 (long double x1, long double x2);
+long double __negxf2 (long double x1);
+long __cmpxf2 (long double x1, long double x2);
+long __eqxf2 (long double x1, long double x2);
+long __nexf2 (long double x1, long double x2);
+long __ltxf2 (long double x1, long double x2);
+long __lexf2 (long double x1, long double x2);
+long __gtxf2 (long double x1, long double x2);
+long __gexf2 (long double x1, long double x2);
+#endif
+
+
+#ifdef L_unordsf2
 int
 __unordsf2(float a, float b)
 {
   union float_long fl;
 
   fl.f = a;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   fl.f = b;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_unorddf2
 int
 __unorddf2(double a, double b)
 {
@@ -134,7 +169,9 @@ __unorddf2(double a, double b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_floatunsidf
 /* convert unsigned int to double */
 double
 __floatunsidf (unsigned long a1)
@@ -167,7 +204,9 @@ __floatunsidf (unsigned long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef L_floatsidf
 /* convert int to double */
 double
 __floatsidf (long a1)
@@ -213,7 +252,9 @@ __floatsidf (long a1)
 
   return dl.d;
 }
+#endif
 
+#ifdef L_floatunsisf
 /* convert unsigned int to float */
 float
 __floatunsisf (unsigned long l)
@@ -221,7 +262,9 @@ __floatunsisf (unsigned long l)
   double foo = __floatunsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_floatsisf
 /* convert int to float */
 float
 __floatsisf (long l)
@@ -229,15 +272,17 @@ __floatsisf (long l)
   double foo = __floatsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_extendsfdf2
 /* convert float to double */
 double
 __extendsfdf2 (float a1)
 {
-  register union float_long fl1;
-  register union double_long dl;
-  register long exp;
-  register long mant;
+  union float_long fl1;
+  union double_long dl;
+  long exp;
+  long mant;
 
   fl1.f = a1;
 
@@ -250,7 +295,7 @@ __extendsfdf2 (float a1)
 
   exp = EXP(fl1.l);
   mant = MANT (fl1.l) & ~HIDDEN;
-  if (exp == 0)
+  if (exp == 0) /* case of mant == 0 has already been catched above */
     {
       /* Denormal.  */
       exp = 1;
@@ -261,22 +306,27 @@ __extendsfdf2 (float a1)
 	}
       mant &= ~HIDDEN;
     }
-  exp = exp - EXCESS + EXCESSD;
+  if (exp == EXPFMASK)
+    exp = EXPDMASK;
+  else
+    exp = exp - EXCESS + EXCESSD;
   dl.l.upper |= exp << 20;
   dl.l.upper |= mant >> 3;
   dl.l.lower = mant << 29;
 	
   return dl.d;
 }
+#endif
 
+#ifdef L_truncdfsf2
 /* convert double to float */
 float
 __truncdfsf2 (double a1)
 {
-  register long exp;
-  register long mant;
-  register union float_long fl;
-  register union double_long dl1;
+  long exp;
+  long mant;
+  union float_long fl;
+  union double_long dl1;
   int sticky;
   int shift;
 
@@ -290,7 +340,7 @@ __truncdfsf2 (double a1)
 
   exp = EXPD (dl1) - EXCESSD + EXCESS;
 
-  sticky = dl1.l.lower & ((1 << 22) - 1);
+  sticky = dl1.l.lower & ((1L << 22) - 1);
   mant = MANTD (dl1);
   /* shift double mantissa 6 bits so we can round */
   sticky |= mant & ((1 << 6) - 1);
@@ -311,7 +361,15 @@ __truncdfsf2 (double a1)
 	}
       exp = 0;
     }
-  
+  else if (exp >= EXPFMASK)
+    {
+      if (exp == EXPDMASK - EXCESSD + EXCESS)
+        mant &= ~3; /* was already inf or nan; do not round */
+      else
+        mant = 0; /* just overflowed */
+      exp = EXPFMASK;
+    }
+
   /* now round */
   shift = 1;
   if ((mant & 1) && (sticky || (mant & 2)))
@@ -336,14 +394,16 @@ __truncdfsf2 (double a1)
   fl.l = PACK (SIGND (dl1), exp, mant);
   return (fl.f);
 }
+#endif
 
+#ifdef L_fixdfsi
 /* convert double to int */
 long
 __fixdfsi (double a1)
 {
-  register union double_long dl1;
-  register long exp;
-  register long l;
+  union double_long dl1;
+  long exp;
+  long l;
 
   dl1.d = a1;
 
@@ -368,7 +428,9 @@ __fixdfsi (double a1)
 
   return (SIGND (dl1) ? -l : l);
 }
+#endif
 
+#ifdef L_fixsfsi
 /* convert float to int */
 long
 __fixsfsi (float a1)
@@ -376,8 +438,7 @@ __fixsfsi (float a1)
   double foo = a1;
   return __fixdfsi (foo);
 }
-
-#else /* EXTFLOAT */
+#endif
 
 /* We do not need these routines for coldfire, as it has no extended
    float format. */
@@ -387,15 +448,7 @@ __fixsfsi (float a1)
 
    We assume all numbers are normalized, don't do any rounding, etc.  */
 
-/* Prototypes for the above in case we use them.  */
-double __floatunsidf (unsigned long);
-double __floatsidf (long);
-float __floatsisf (long);
-double __extendsfdf2 (float);
-float __truncdfsf2 (double);
-long __fixdfsi (double);
-long __fixsfsi (float);
-
+#ifdef L_unordxf2
 int
 __unordxf2(long double a, long double b)
 {
@@ -411,14 +464,16 @@ __unordxf2(long double a, long double b)
     return 1;
   return 0;
 }
+#endif
 
+#ifdef L_extenddfxf2
 /* convert double to long double */
 long double
 __extenddfxf2 (double d)
 {
-  register union double_long dl;
-  register union long_double_long ldl;
-  register long exp;
+  union double_long dl;
+  union long_double_long ldl;
+  long exp;
 
   dl.d = d;
   /*printf ("dfxf in: %g\n", d);*/
@@ -431,7 +486,11 @@ __extenddfxf2 (double d)
       return ldl.ld;
     }
 
-  exp = EXPD (dl) - EXCESSD + EXCESSX;
+  exp = EXPD (dl);
+  if (exp == EXPDMASK)
+    exp = EXPXMASK;
+  else
+    exp = exp - EXCESSD + EXCESSX;
   ldl.l.upper |= exp << 16;
   ldl.l.middle = HIDDENX;
   /* 31-20: # mantissa bits in ldl.l.middle - # mantissa bits in dl.l.upper */
@@ -444,39 +503,65 @@ __extenddfxf2 (double d)
   /*printf ("dfxf out: %s\n", dumpxf (ldl.ld));*/
   return ldl.ld;
 }
+#endif
 
+#ifdef L_truncxfdf2
 /* convert long double to double */
 double
 __truncxfdf2 (long double ld)
 {
-  register long exp;
-  register union double_long dl;
-  register union long_double_long ldl;
+  long exp;
+  union double_long dl;
+  union long_double_long ldl;
 
   ldl.ld = ld;
   /*printf ("xfdf in: %s\n", dumpxf (ld));*/
 
+  exp = EXPX (ldl);
   dl.l.upper = SIGNX (ldl);
-  if ((ldl.l.upper & ~SIGNBIT) == 0 && !ldl.l.middle && !ldl.l.lower)
+  if (exp == 0 && (ldl.l.middle & MANTXMASK) == 0 && !ldl.l.lower)
     {
       dl.l.lower = 0;
-      return dl.d;
     }
-
-  exp = EXPX (ldl) - EXCESSX + EXCESSD;
-  /* ??? quick and dirty: keep `exp' sane */
-  if (exp >= EXPDMASK)
-    exp = EXPDMASK - 1;
-  dl.l.upper |= exp << (32 - (EXPDBITS + 1));
-  /* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
-  dl.l.upper |= (ldl.l.middle & MANTXMASK) >> (EXPDBITS + 1 - 1);
-  dl.l.lower = (ldl.l.middle & MANTXMASK) << (32 - (EXPDBITS + 1 - 1));
-  dl.l.lower |= ldl.l.lower >> (EXPDBITS + 1 - 1);
+  else
+    {
+      if (exp == EXPXMASK)
+        {
+          exp = EXPDMASK;
+          ldl.l.middle = 0;
+          ldl.l.lower = 0;
+        }
+      else
+        {
+          exp = exp - EXCESSX + EXCESSD;
+          /* ??? quick and dirty: keep `exp' sane */
+          if (exp >= EXPDMASK)
+          {
+          	/* overflow: return infinity */
+            exp = EXPDMASK;
+            ldl.l.middle = 0;
+            ldl.l.lower = 0;
+          } else if (exp <= 0)
+          {
+          	/* underflow */
+            exp = 0;
+            ldl.l.middle = 0;
+            ldl.l.lower = 0;
+          }
+        }
+      dl.l.upper |= exp << (32 - (EXPDBITS + 1));
+      /* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
+      dl.l.upper |= (ldl.l.middle & MANTXMASK) >> (EXPDBITS + 1 - 1);
+      dl.l.lower = (ldl.l.middle & MANTXMASK) << (32 - (EXPDBITS + 1 - 1));
+      dl.l.lower |= ldl.l.lower >> (EXPDBITS + 1 - 1);
+	}
 
   /*printf ("xfdf out: %g\n", dl.d);*/
   return dl.d;
 }
+#endif
 
+#ifdef L_extendsfxf2
 /* convert a float to a long double */
 long double
 __extendsfxf2 (float f)
@@ -484,7 +569,9 @@ __extendsfxf2 (float f)
   long double foo = __extenddfxf2 (__extendsfdf2 (f));
   return foo;
 }
+#endif
 
+#ifdef L_truncxfsf2
 /* convert a long double to a float */
 float
 __truncxfsf2 (long double ld)
@@ -492,7 +579,9 @@ __truncxfsf2 (long double ld)
   float foo = __truncdfsf2 (__truncxfdf2 (ld));
   return foo;
 }
+#endif
 
+#ifdef L_floatsixf
 /* convert an int to a long double */
 long double
 __floatsixf (long l)
@@ -500,7 +589,9 @@ __floatsixf (long l)
   double foo = __floatsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_floatunsixf
 /* convert an unsigned int to a long double */
 long double
 __floatunsixf (unsigned long l)
@@ -508,7 +599,9 @@ __floatunsixf (unsigned long l)
   double foo = __floatunsidf (l);
   return foo;
 }
+#endif
 
+#ifdef L_fixxfsi
 /* convert a long double to an int */
 long
 __fixxfsi (long double ld)
@@ -516,80 +609,6 @@ __fixxfsi (long double ld)
   long foo = __fixdfsi ((double) ld);
   return foo;
 }
-
-/* The remaining provide crude math support by working in double precision.  */
-
-long double
-__addxf3 (long double x1, long double x2)
-{
-  return (double) x1 + (double) x2;
-}
-
-long double
-__subxf3 (long double x1, long double x2)
-{
-  return (double) x1 - (double) x2;
-}
-
-long double
-__mulxf3 (long double x1, long double x2)
-{
-  return (double) x1 * (double) x2;
-}
-
-long double
-__divxf3 (long double x1, long double x2)
-{
-  return (double) x1 / (double) x2;
-}
-
-long double
-__negxf2 (long double x1)
-{
-  return - (double) x1;
-}
-
-long
-__cmpxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__eqxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__nexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__ltxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__lexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__gtxf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
-
-long
-__gexf2 (long double x1, long double x2)
-{
-  return __cmpdf2 ((double) x1, (double) x2);
-}
+#endif
 
 #endif /* !__mcoldfire__ */
-#endif /* EXTFLOAT */
diff --git a/gcc/config/m68k/lb1sf68-fast.asm b/gcc/config/m68k/lb1sf68-fast.asm
new file mode 100644
index 00000000000..b4745501b79
--- /dev/null
+++ b/gcc/config/m68k/lb1sf68-fast.asm
@@ -0,0 +1,218 @@
+/* libgcc routines for 68000 w/o floating-point hardware.
+   Copyright (C) 1994, 1996, 1997, 1998, 2008, 2009 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3, or (at your option) any
+later version.
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifdef  L_mulsi3
+	.text
+	FUNC(__mulsi3)
+	.globl	SYM (__mulsi3)
+#ifdef __ELF__
+	.hidden	SYM (__mulsi3_internal)
+#endif
+SYM (__mulsi3):
+SYM (__mulsi3_internal):
+	move.l  d2,-(a7)
+	movel   d0, a0          | d0a0 = x0:x1
+	movel   d1, a1		| d1a1 = y0:y1
+	swap	d0              | d0   = x1:x0 
+	muluw   d1, d0          | d0 = y1*x0 
+	swap	d1		| d1 = y1:y0
+	movel   a0, d2		| d2 = x0:x1
+	muluw   d2, d1          | d1 = x1*y0	
+#ifndef __mcoldfire__
+	addw	d1, d0
+#else
+	addl	d1, d0
+#endif
+	swap	d0
+	clrw	d0
+	movel	a1,d1		| d1 = y0:y1
+	muluw	d2, d1		| d1 = x1*y1
+
+	move.l  (a7)+,d2
+	addl	d1, d0
+
+	rts
+#endif /* L_mulsi3 */
+
+#ifdef  L_udivsi3
+	.text
+	FUNC(__udivsi3)
+	.globl	SYM (__udivsi3)
+	.globl	SYM (__udivsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__udivsi3_internal)
+#endif
+SYM (__udivsi3):
+SYM (__udivsi3_internal):
+#ifndef __mcoldfire__
+	move.l  d2,-(a7)
+	movel	d0, a0
+
+	cmpl	IMM (0x10000), d1 /* divisor >= 2 ^ 16 ?   */
+	jcc	udivsi3_fast_L3		/* then try next algorithm */
+	movel	d0, d2
+	clrw	d2
+	swap	d2
+	divu	d1, d2          /* high quotient in lower word */
+	movew	d2, d0		/* save high quotient */
+	swap	d0
+	movew	a0, d2		/* get low dividend + high rest */
+	divu	d1, d2		/* low quotient */
+	movew	d2, d0
+	jra	udivsi3_fast_L6
+
+udivsi3_fast_L3:	movel	d1, d2		/* use d2 as divisor backup */
+udivsi3_fast_L4:	lsrl	IMM (1), d1	/* shift divisor */
+	lsrl	IMM (1), d0	/* shift dividend */
+	cmpl	IMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */
+	jcc	udivsi3_fast_L4
+	divu	d1, d0		/* now we have 16-bit divisor */
+	andl	IMM (0xffff), d0 /* mask out divisor, ignore remainder */
+
+/* Multiply the 16-bit tentative quotient with the 32-bit divisor.  Because of
+   the operand ranges, this might give a 33-bit product.  If this product is
+   greater than the dividend, the tentative quotient was too large. */
+	movel	d2, d1
+	mulu	d0, d1		/* low part, 32 bits */
+	swap	d2
+	mulu	d0, d2		/* high part, at most 17 bits */
+	swap	d2		/* align high part with low part */
+	tstw	d2		/* high part 17 bits? */
+	jne	udivsi3_fast_L5		/* if 17 bits, quotient was too large */
+	addl	d2, d1		/* add parts */
+	jcs	udivsi3_fast_L5		/* if sum is 33 bits, quotient was too large */
+	cmpl	a0, d1		/* compare the sum with the dividend */
+	jls	udivsi3_fast_L6		/* if sum > dividend, quotient was too large */
+udivsi3_fast_L5:	subql	IMM (1), d0	/* adjust quotient */
+
+udivsi3_fast_L6:
+	move.l  (a7)+,d2
+	rts
+
+#else /* __mcoldfire__ */
+
+/* ColdFire implementation of non-restoring division algorithm from
+   Hennessy & Patterson, Appendix A. */
+	moveml	d2-d4,sp@
+	clrl	d2		| clear p
+	moveq	IMM (31),d4
+udivsi3_fast_L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
+	addxl	d2,d2
+	movl	d2,d3		| subtract b from p, store in tmp.
+	subl	d1,d3
+	jcs	udivsi3_fast_L2		| if no carry,
+	bset	IMM (0),d0	| set the low order bit of a to 1,
+	movl	d3,d2		| and store tmp in p.
+udivsi3_fast_L2:	subql	IMM (1),d4
+	jcc	udivsi3_fast_L1
+	moveml	sp@,d2-d4	| restore data registers
+	rts
+#endif /* __mcoldfire__ */
+
+#endif /* L_udivsi3 */
+
+#ifdef  L_divsi3
+	.text
+	FUNC(__divsi3)
+	.globl	SYM (__divsi3)
+	.globl	SYM (__divsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__divsi3_internal)
+#endif
+SYM (__divsi3):
+SYM (__divsi3_internal):
+	move.l  d2,-(a7)
+	moveq	IMM (1), d2	/* sign of result stored in d2 (=1 or =-1) */
+	tstl	d1
+	jpl	divsi3_fast_L1
+	negl	d1
+#ifndef __mcoldfire__
+	negw	d2		/* change sign because divisor <0  */
+#else
+	negl	d2		/* change sign because divisor <0  */
+#endif
+divsi3_fast_L1:	tstl	d0		/* d0 = dividend */
+	jpl	divsi3_fast_L2
+	negl	d0
+#ifndef __mcoldfire__
+	negw	d2
+#else
+	negl	d2
+#endif
+
+divsi3_fast_L2:	movew	d2,a1		/* Called function MUST NOT clobber a1 */
+	PICCALL	SYM (__udivsi3_internal)	/* divide abs(dividend) by abs(divisor) */
+
+	movew	a1,d2
+	jpl	divsi3_fast_L3
+	negl	d0
+
+divsi3_fast_L3:
+	move.l  (a7)+,d2
+	rts
+#endif /* L_divsi3 */
+
+#ifdef  L_umodsi3
+	.text
+	FUNC(__umodsi3)
+	.globl	SYM (__umodsi3)
+SYM (__umodsi3):
+	move.l  d2,-(a7)
+	movel	d0, d2
+	movel	d1, a1		/* a1 MUST NOT be clobbered by calls*/
+	PICCALL	SYM (__udivsi3_internal)
+	movel	a1, d1		/* d1 = divisor */
+#ifndef __mcoldfire__
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+#else
+	mulsl	d1,d0
+#endif
+	movel	d2, d1		/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	move.l  (a7)+,d2
+	rts
+#endif /* L_umodsi3 */
+
+#ifdef  L_modsi3
+	.text
+	FUNC(__modsi3)
+	.globl	SYM (__modsi3)
+SYM (__modsi3):
+	move.l  d2,-(a7)
+	movel	d0, sp@-
+	movel	d1, sp@-
+	PICCALL	SYM (__divsi3_internal)
+	movel	sp@+, d1	/* d1 = divisor */
+#ifndef __mcoldfire__
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
+#else
+	mulsl	d1,d0
+#endif
+	movel	sp@+, d1	/* d1 = dividend */
+	subl	d0, d1		/* d1 = a - (a/b)*b */
+	movel	d1, d0
+	move.l  (a7)+,d2
+	rts
+#endif /* L_modsi3 */
diff --git a/gcc/config/m68k/lb1sf68.asm b/gcc/config/m68k/lb1sf68.asm
index 0339a092c4f..f9eb378f808 100644
--- a/gcc/config/m68k/lb1sf68.asm
+++ b/gcc/config/m68k/lb1sf68.asm
@@ -1,5 +1,5 @@
 /* libgcc routines for 68000 w/o floating-point hardware.
-   Copyright (C) 1994, 1996, 1997, 1998, 2008, 2009 Free Software Foundation, Inc.
+   Copyright (C) 1994-2023 Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -52,17 +52,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
 
 /* Note that X is a function.  */
-	
+
 #ifdef __ELF__
 #define FUNC(x) .type SYM(x),function
 #else
-/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just	
+/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just
    define this to the empty string for non-ELF systems, but defining it
    to .proc means that the information is available to the assembler if
    the need arises.  */
 #define FUNC(x) .proc
 #endif
-		
+
 /* Use the right prefix for registers.  */
 
 #define REG(x) CONCAT1 (__REGISTER_PREFIX__, x)
@@ -223,9 +223,44 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif /* __PIC__ */
 
 
+| The following exception types are supported:
+INEXACT_RESULT 		= 0x0001
+UNDERFLOW 		= 0x0002
+OVERFLOW 		= 0x0004
+DIVIDE_BY_ZERO 		= 0x0008
+INVALID_OPERATION 	= 0x0010
+
+| The allowed rounding modes are:
+UNKNOWN           = -1
+ROUND_TO_NEAREST  = 0 | round result to nearest representable value
+ROUND_TO_ZERO     = 1 | round result towards zero
+ROUND_TO_PLUS     = 2 | round result towards plus infinity
+ROUND_TO_MINUS    = 3 | round result towards minus infinity
+
+| The allowed values of format are:
+NIL          = 0
+SINGLE_FLOAT = 1
+DOUBLE_FLOAT = 2
+LONG_FLOAT   = 3
+
+| The allowed values for the last operation are:
+NOOP         = 0
+ADD          = 1
+MULTIPLY     = 2
+DIVIDE       = 3
+NEGATE       = 4
+COMPARE      = 5
+EXTENDSFDF   = 6
+TRUNCDFSF    = 7
+
+| return values from __cmpdf2/__cmpsf2/__cmpxf2
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
 #ifdef L_floatex
 
-| This is an attempt at a decent floating point (single, double and 
+| This is an attempt at a decent floating point (single, double and
 | extended double) code for the GNU C compiler. It should be easy to
 | adapt to other compilers (but beware of the local labels!).
 
@@ -234,10 +269,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 | It is convenient to introduce the notation (s,e,f) for a floating point
 | number, where s=sign, e=exponent, f=fraction. We will call a floating
 | point number fpn to abbreviate, independently of the precision.
-| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023 
-| for doubles and 16383 for long doubles). We then have the following 
+| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023
+| for doubles and 16383 for long doubles). We then have the following
 | different cases:
-|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to 
+|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to
 |     (-1)^s x 1.f x 2^(e-bias-1).
 |  2. Denormalized fpns have e=0. They correspond to numbers of the form
 |     (-1)^s x 0.f x 2^(-bias).
@@ -252,8 +287,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 | This is the floating point condition code register (_fpCCR):
 |
 | struct {
-|   short _exception_bits;	
-|   short _trap_enable_bits;	
+|   short _exception_bits;
+|   short _trap_enable_bits;
 |   short _sticky_bits;
 |   short _rounding_mode;
 |   short _format;
@@ -261,10 +296,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 |   union {
 |     float sf;
 |     double df;
+|     long double xf;
 |   } _operand1;
 |   union {
 |     float sf;
 |     double df;
+|     long double xf;
 |   } _operand2;
 | } _fpCCR;
 
@@ -272,7 +309,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 	.even
 
 	.globl	SYM (_fpCCR)
-	
+
 SYM (_fpCCR):
 __exception_bits:
 	.word	0
@@ -289,9 +326,11 @@ __last_operation:
 __operand1:
 	.long	0
 	.long	0
+	.long	0
 __operand2:
 	.long 	0
 	.long	0
+	.long	0
 
 | Offsets:
 EBITS  = __exception_bits - SYM (_fpCCR)
@@ -303,42 +342,12 @@ LASTO  = __last_operation - SYM (_fpCCR)
 OPER1  = __operand1 - SYM (_fpCCR)
 OPER2  = __operand2 - SYM (_fpCCR)
 
-| The following exception types are supported:
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-| The allowed rounding modes are:
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
-| The allowed values of format are:
-NIL          = 0
-SINGLE_FLOAT = 1
-DOUBLE_FLOAT = 2
-LONG_FLOAT   = 3
-
-| The allowed values for the last operation are:
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
 |=============================================================================
 |                           __clear_sticky_bits
 |=============================================================================
 
-| The sticky bits are normally not cleared (thus the name), whereas the 
-| exception type and exception value reflect the last computation. 
+| The sticky bits are normally not cleared (thus the name), whereas the
+| exception type and exception value reflect the last computation.
 | This routine is provided to clear them (you can also write to _fpCCR,
 | since it is globally visible).
 
@@ -348,13 +357,9 @@ TRUNCDFSF    = 7
 	.even
 
 | void __clear_sticky_bits(void);
-SYM (__clear_sticky_bit):		
+SYM (__clear_sticky_bit):
 	PICLEA	SYM (_fpCCR),a0
-#ifndef __mcoldfire__
-	movew	IMM (0),a0@(STICK)
-#else
 	clr.w	a0@(STICK)
-#endif
 	rts
 
 |=============================================================================
@@ -370,13 +375,13 @@ SYM (__clear_sticky_bit):
 | NOTE: it is NOT callable from C!
 | It expects the exception type in d7, the format (SINGLE_FLOAT,
 | DOUBLE_FLOAT or LONG_FLOAT) in d6, and the last operation code in d5.
-| It sets the corresponding exception and sticky bits, and the format. 
-| Depending on the format if fills the corresponding slots for the 
+| It sets the corresponding exception and sticky bits, and the format.
+| Depending on the format if fills the corresponding slots for the
 | operands which produced the exception (all this information is provided
 | so if you write your own exception handlers you have enough information
 | to deal with the problem).
-| Then checks to see if the corresponding exception is trap-enabled, 
-| in which case it pushes the address of _fpCCR and traps through 
+| Then checks to see if the corresponding exception is trap-enabled,
+| in which case it pushes the address of _fpCCR and traps through
 | trap FPTRAP (15 for the moment).
 
 FPTRAP = 15
@@ -396,19 +401,33 @@ $_exception_handler:
 
 | Now put the operands in place:
 #ifndef __mcoldfire__
-	cmpw	IMM (SINGLE_FLOAT),d6
+	subqw	IMM (DOUBLE_FLOAT),d6
 #else
-	cmpl	IMM (SINGLE_FLOAT),d6
+	subql	IMM (DOUBLE_FLOAT),d6
 #endif
-	beq	1f
+	beq	2f
+	bmi	3f
+	moveml a6@(8),d0-d5
+	moveml d0-d5,a0@(OPER1)
+	| for cmpxf2, return value is int!
+#ifndef __mcoldfire__
+	subqw	IMM (2),d6
+#else
+	subql	IMM (2),d6
+#endif
+	beq		4f
+	moveml	d0-d2,a1@			| write return value for long double
+	movel	a1,d0
+	bra	4f
+2:
 	movel	a6@(8),a0@(OPER1)
 	movel	a6@(12),a0@(OPER1+4)
 	movel	a6@(16),a0@(OPER2)
 	movel	a6@(20),a0@(OPER2+4)
-	bra	2f
-1:	movel	a6@(8),a0@(OPER1)
+	bra	4f
+3:	movel	a6@(8),a0@(OPER1)
 	movel	a6@(12),a0@(OPER2)
-2:
+4:
 | And check whether the exception is trap-enabled:
 #ifndef __mcoldfire__
 	andw	a0@(TRAPE),d7	| is exception trap-enabled?
@@ -418,24 +437,32 @@ $_exception_handler:
 	andl	d6,d7
 #endif
 	beq	1f		| no, exit
-	PICPEA	SYM (_fpCCR),a1	| yes, push address of _fpCCR
+	pea		(a0)	| yes, push address of _fpCCR
 	trap	IMM (FPTRAP)	| and trap
-#ifndef __mcoldfire__
-1:	moveml	sp@+,d2-d7	| restore data registers
-#else
-1:	moveml	sp@,d2-d7
+1:
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 #endif /* L_floatex */
 
+#ifdef __FASTCALL__
+
+#include "lb1sf68-fast.asm"
+
+#else
+
 #ifdef  L_mulsi3
 	.text
 	FUNC(__mulsi3)
 	.globl	SYM (__mulsi3)
+	.globl	SYM (__mulsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__mulsi3_internal)
+#endif
 SYM (__mulsi3):
+SYM (__mulsi3_internal):
 	movew	sp@(4), d0	/* x0 -> d0 */
 	muluw	sp@(10), d0	/* x0*y1 */
 	movew	sp@(6), d1	/* x1 -> d1 */
@@ -458,7 +485,12 @@ SYM (__mulsi3):
 	.text
 	FUNC(__udivsi3)
 	.globl	SYM (__udivsi3)
+	.globl	SYM (__udivsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__udivsi3_internal)
+#endif
 SYM (__udivsi3):
+SYM (__udivsi3_internal):
 #ifndef __mcoldfire__
 	movel	d2, sp@-
 	movel	sp@(12), d1	/* d1 = divisor */
@@ -516,11 +548,11 @@ L6:	movel	sp@+, d2
 	moveq	IMM (31),d4
 L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
 	addxl	d2,d2
-	movl	d2,d3		| subtract b from p, store in tmp.
+	movel	d2,d3		| subtract b from p, store in tmp.
 	subl	d1,d3
 	jcs	L2		| if no carry,
 	bset	IMM (0),d0	| set the low order bit of a to 1,
-	movl	d3,d2		| and store tmp in p.
+	movel	d3,d2		| and store tmp in p.
 L2:	subql	IMM (1),d4
 	jcc	L1
 	moveml	sp@,d2-d4	| restore data registers
@@ -534,7 +566,12 @@ L2:	subql	IMM (1),d4
 	.text
 	FUNC(__divsi3)
 	.globl	SYM (__divsi3)
+	.globl	SYM (__divsi3_internal)
+#ifdef __ELF__
+	.hidden	SYM (__divsi3_internal)
+#endif
 SYM (__divsi3):
+SYM (__divsi3_internal):
 	movel	d2, sp@-
 
 	moveq	IMM (1), d2	/* sign of result stored in d2 (=1 or =-1) */
@@ -557,7 +594,7 @@ L1:	movel	sp@(8), d0	/* d0 = dividend */
 
 L2:	movel	d1, sp@-
 	movel	d0, sp@-
-	PICCALL	SYM (__udivsi3)	/* divide abs(dividend) by abs(divisor) */
+	PICCALL	SYM (__udivsi3_internal)	/* divide abs(dividend) by abs(divisor) */
 	addql	IMM (8), sp
 
 	tstb	d2
@@ -577,13 +614,13 @@ SYM (__umodsi3):
 	movel	sp@(4), d0	/* d0 = dividend */
 	movel	d1, sp@-
 	movel	d0, sp@-
-	PICCALL	SYM (__udivsi3)
+	PICCALL	SYM (__udivsi3_internal)
 	addql	IMM (8), sp
 	movel	sp@(8), d1	/* d1 = divisor */
 #ifndef __mcoldfire__
 	movel	d1, sp@-
 	movel	d0, sp@-
-	PICCALL	SYM (__mulsi3)	/* d0 = (a/b)*b */
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
 	addql	IMM (8), sp
 #else
 	mulsl	d1,d0
@@ -603,13 +640,13 @@ SYM (__modsi3):
 	movel	sp@(4), d0	/* d0 = dividend */
 	movel	d1, sp@-
 	movel	d0, sp@-
-	PICCALL	SYM (__divsi3)
+	PICCALL	SYM (__divsi3_internal)
 	addql	IMM (8), sp
 	movel	sp@(8), d1	/* d1 = divisor */
 #ifndef __mcoldfire__
 	movel	d1, sp@-
 	movel	d0, sp@-
-	PICCALL	SYM (__mulsi3)	/* d0 = (a/b)*b */
+	PICCALL	SYM (__mulsi3_internal)	/* d0 = (a/b)*b */
 	addql	IMM (8), sp
 #else
 	mulsl	d1,d0
@@ -620,13 +657,35 @@ SYM (__modsi3):
 	rts
 #endif /* L_modsi3 */
 
+#endif /* __FASTCALL__ */
 
 #ifdef  L_double
 
+|=============================================================================
+|=============================================================================
+|                         double precision routines
+|=============================================================================
+|=============================================================================
+
+| A double precision floating point number (double) has the format:
+|
+| struct _double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 11; /* exponent, shifted by 1022 */
+|  unsigned int fraction  : 52; /* fraction */
+| } double;
+|
+| Thus sizeof(double) = 8 (64 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
+
 	.globl	SYM (_fpCCR)
 	.globl  $_exception_handler
 
 QUIET_NaN      = 0xffffffff
+INFINITY       = 0x7ff00000
 
 D_MAX_EXP      = 0x07ff
 D_BIAS         = 1022
@@ -634,29 +693,6 @@ DBL_MAX_EXP    = D_MAX_EXP - D_BIAS
 DBL_MIN_EXP    = 1 - D_BIAS
 DBL_MANT_DIG   = 53
 
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-DOUBLE_FLOAT = 2
-
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
 | Entry points:
 
 	.globl SYM (__adddf3)
@@ -666,12 +702,14 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity
 	.globl SYM (__negdf2)
 	.globl SYM (__cmpdf2)
 	.globl SYM (__cmpdf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpdf2_internal)
+#endif
 
 	.text
 	.even
 
-| These are common routines to return and signal exceptions.	
+| These are common routines to return and signal exceptions.
 
 Ld$den:
 | Return and signal a denormalized number
@@ -682,8 +720,8 @@ Ld$den:
 
 Ld$infty:
 Ld$overflow:
-| Return a properly signed INFINITY and set the exception flags 
-	movel	IMM (0x7ff00000),d0
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
 	movel	IMM (0),d1
 	orl	d7,d0
 	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
@@ -691,7 +729,7 @@ Ld$overflow:
 	PICJUMP	$_exception_handler
 
 Ld$underflow:
-| Return 0 and set the exception flags 
+| Return 0 and set the exception flags
 	movel	IMM (0),d0
 	movel	d0,d1
 	movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
@@ -708,33 +746,13 @@ Ld$inop:
 
 Ld$div$0:
 | Return a properly signed INFINITY and set the exception flags
-	movel	IMM (0x7ff00000),d0
+	movel	IMM (INFINITY),d0
 	movel	IMM (0),d1
 	orl	d7,d0
 	movew	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
 	moveq	IMM (DOUBLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-|=============================================================================
-|=============================================================================
-|                         double precision routines
-|=============================================================================
-|=============================================================================
-
-| A double precision floating point number (double) has the format:
-|
-| struct _double {
-|  unsigned int sign      : 1;  /* sign bit */ 
-|  unsigned int exponent  : 11; /* exponent, shifted by 126 */
-|  unsigned int fraction  : 52; /* fraction */
-| } double;
-| 
-| Thus sizeof(double) = 8 (64 bits). 
-|
-| All the routines are callable from C programs, and return the result 
-| in the register pair d0-d1. They also preserve all registers except 
-| d0-d1 and a0-a1.
-
 |=============================================================================
 |                              __subdf3
 |=============================================================================
@@ -744,6 +762,7 @@ Ld$div$0:
 SYM (__subdf3):
 	bchg	IMM (31),sp@(12) | change sign of second operand
 				| and fall through, so we always add
+
 |=============================================================================
 |                              __adddf3
 |=============================================================================
@@ -751,34 +770,26 @@ SYM (__subdf3):
 | double __adddf3(double, double);
 	FUNC(__adddf3)
 SYM (__adddf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)	| everything will be done in registers
-	moveml	d2-d7,sp@-	| save all data registers and a2 (but d0-d1)
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0	| get first operand
-	movel	a6@(12),d1	| 
-	movel	a6@(16),d2	| get second operand
-	movel	a6@(20),d3	| 
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
 
-	movel	d0,d7		| get d0's sign bit in d7 '
+	movel	d0,d7		| get d0's sign bit in d7
 	addl	d1,d1		| check and clear sign bit of a, and gain one
 	addxl	d0,d0		| bit of extra precision
 	beq	Ladddf$b	| if zero return second operand
 
-	movel	d2,d6		| save sign in d6 
+	movel	d2,d6		| save sign in d6
 	addl	d3,d3		| get rid of sign bit and gain one bit of
 	addxl	d2,d2		| extra precision
 	beq	Ladddf$a	| if zero return first operand
 
-	andl	IMM (0x80000000),d7 | isolate a's sign bit '
-        swap	d6		| and also b's sign bit '
+	andl	IMM (0x80000000),d7 | isolate a's sign bit
+	swap	d6		| and also b's sign bit
 #ifndef __mcoldfire__
 	andw	IMM (0x8000),d6	|
-	orw	d6,d7		| and combine them into d7, so that a's sign '
-				| bit is in the high word and b's is in the '
+	orw	d6,d7		| and combine them into d7, so that a's sign
+				| bit is in the high word and b's is in the
 				| low word, so d6 is free to be used
 #else
 	andl	IMM (0x8000),d6
@@ -792,13 +803,13 @@ SYM (__adddf3):
 	movel	IMM (0x001fffff),d6 | mask for the fraction
 	movel	IMM (0x00200000),d7 | mask to put hidden bit back
 
-	movel	d0,d4		| 
+	movel	d0,d4		|
 	andl	d6,d0		| get fraction in d0
 	notl	d6		| make d6 into mask for the exponent
 	andl	d6,d4		| get exponent in d4
 	beq	Ladddf$a$den	| branch if a is denormalized
 	cmpl	d6,d4		| check for INFINITY or NaN
-	beq	Ladddf$nf       | 
+	beq	Ladddf$nf       |
 	orl	d7,d0		| and put hidden bit back
 Ladddf$1:
 	swap	d4		| shift right exponent so that it starts
@@ -807,7 +818,7 @@ Ladddf$1:
 #else
 	lsrl	IMM (5),d4	| in bit 0 and not bit 20
 #endif
-| Now we have a's exponent in d4 and fraction in d0-d1 '
+| Now we have a's exponent in d4 and fraction in d0-d1
 	movel	d2,d5		| save b to get exponent
 	andl	d6,d5		| get exponent in d5
 	beq	Ladddf$b$den	| branch if b is denormalized
@@ -824,25 +835,17 @@ Ladddf$2:
 	lsrl	IMM (5),d5	| in bit 0 and not bit 20
 #endif
 
-| Now we have b's exponent in d5 and fraction in d2-d3. '
+| Now we have b's exponent in d5 and fraction in d2-d3.
 
-| The situation now is as follows: the signs are combined in a0, the 
+| The situation now is as follows: the signs are combined in a0, the
 | numbers are in d0-d1 (a) and d2-d3 (b), and the exponents in d4 (a)
 | and d5 (b). To do the rounding correctly we need to keep all the
 | bits until the end, so we need to use d0-d1-d2-d3 for the first number
 | and d4-d5-d6-d7 for the second. To do this we store (temporarily) the
 | exponents in a2-a3.
 
-#ifndef __mcoldfire__
-	moveml	a2-a3,sp@-	| save the address registers
-#else
-	movel	a2,sp@-	
-	movel	a3,sp@-	
-	movel	a4,sp@-	
-#endif
-
 	movel	d4,a2		| save the exponents
-	movel	d5,a3		| 
+	movel	d5,a3		|
 
 	movel	IMM (0),d7	| and move the numbers around
 	movel	d7,d6		|
@@ -851,7 +854,7 @@ Ladddf$2:
 	movel	d7,d3		|
 	movel	d7,d2		|
 
-| Here we shift the numbers until the exponents are the same, and put 
+| Here we shift the numbers until the exponents are the same, and put
 | the largest exponent in a2.
 #ifndef __mcoldfire__
 	exg	d4,a2		| get exponents back
@@ -866,10 +869,10 @@ Ladddf$2:
 	movel	a4,a3
 	cmpl	d4,d5		| compare the exponents
 #endif
-	beq	Ladddf$3	| if equal don't shift '
+	beq	Ladddf$3	| if equal don't shift
 	bhi	9f		| branch if second exponent is higher
 
-| Here we have a's exponent larger than b's, so we have to shift b. We do 
+| Here we have a's exponent larger than b's, so we have to shift b. We do
 | this by using as counter d2:
 1:	movew	d4,d2		| move largest exponent to d2
 #ifndef __mcoldfire__
@@ -885,7 +888,7 @@ Ladddf$2:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
 	cmpw	IMM (DBL_MANT_DIG+2),d2
 #else
@@ -900,9 +903,9 @@ Ladddf$2:
 	bge	5f
 2:
 #ifndef __mcoldfire__
-	cmpw	IMM (16),d2	| if difference >= 16, shift by words	
+	cmpw	IMM (16),d2	| if difference >= 16, shift by words
 #else
-	cmpl	IMM (16),d2	| if difference >= 16, shift by words	
+	cmpl	IMM (16),d2	| if difference >= 16, shift by words
 #endif
 	bge	6f
 	bra	3f		| enter dbra loop
@@ -933,10 +936,10 @@ Ladddf$2:
 	dbra	d2,4b
 #else
 	subql	IMM (1),d2
-	bpl	4b	
+	bpl	4b
 #endif
 	movel	IMM (0),d2
-	movel	d2,d3	
+	movel	d2,d3
 	bra	Ladddf$4
 5:
 	movel	d6,d7
@@ -964,7 +967,7 @@ Ladddf$2:
 	subl	IMM (16),d2
 #endif
 	bra	3b
-	
+
 9:
 #ifndef __mcoldfire__
 	exg	d4,d5
@@ -984,7 +987,7 @@ Ladddf$2:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
 	cmpw	IMM (DBL_MANT_DIG+2),d6
 #else
@@ -999,9 +1002,9 @@ Ladddf$2:
 	bge	5f
 2:
 #ifndef __mcoldfire__
-	cmpw	IMM (16),d6	| if difference >= 16, shift by words	
+	cmpw	IMM (16),d6	| if difference >= 16, shift by words
 #else
-	cmpl	IMM (16),d6	| if difference >= 16, shift by words	
+	cmpl	IMM (16),d6	| if difference >= 16, shift by words
 #endif
 	bge	6f
 	bra	3f		| enter dbra loop
@@ -1065,7 +1068,7 @@ Ladddf$2:
 	bra	3b
 Ladddf$3:
 #ifndef __mcoldfire__
-	exg	d4,a2	
+	exg	d4,a2
 	exg	d5,a3
 #else
 	movel	d4,a4
@@ -1075,13 +1078,13 @@ Ladddf$3:
 	movel	a3,d5
 	movel	a4,a3
 #endif
-Ladddf$4:	
+Ladddf$4:
 | Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and
-| the signs in a4.
+| the signs in a0.
 
 | Here we have to decide whether to add or subtract the numbers:
 #ifndef __mcoldfire__
-	exg	d7,a0		| get the signs 
+	exg	d7,a0		| get the signs
 	exg	d6,a3		| a3 is free to be used
 #else
 	movel	d7,a4
@@ -1092,11 +1095,11 @@ Ladddf$4:
 	movel	a4,a3
 #endif
 	movel	d7,d6		|
-	movew	IMM (0),d7	| get a's sign in d7 '
+	movew	IMM (0),d7	| get a's sign in d7
 	swap	d6              |
-	movew	IMM (0),d6	| and b's sign in d6 '
+	movew	IMM (0),d6	| and b's sign in d6
 	eorl	d7,d6		| compare the signs
-	bmi	Lsubdf$0	| if the signs are different we have 
+	bmi	Lsubdf$0	| if the signs are different we have
 				| to subtract
 #ifndef __mcoldfire__
 	exg	d7,a0		| else we add the numbers
@@ -1111,26 +1114,18 @@ Ladddf$4:
 #endif
 	addl	d7,d3		|
 	addxl	d6,d2		|
-	addxl	d5,d1		| 
+	addxl	d5,d1		|
 	addxl	d4,d0           |
 
 	movel	a2,d4		| return exponent to d4
-	movel	a0,d7		| 
+	movel	a0,d7		|
 	andl	IMM (0x80000000),d7 | d7 now has the sign
 
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4	
-	movel	sp@+,a3	
-	movel	sp@+,a2	
-#endif
-
 | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (DBL_MANT_DIG+1),d0	
+	btst	IMM (DBL_MANT_DIG+1-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -1155,12 +1150,12 @@ Ladddf$4:
 	addl	IMM (1),d4
 #endif
 1:
-	lea	pc@(Ladddf$5),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Ladddf$5),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -1173,18 +1168,18 @@ Ladddf$4:
 Ladddf$5:
 | Put back the exponent and check for overflow
 #ifndef __mcoldfire__
-	cmpw	IMM (0x7ff),d4	| is the exponent big?
+	cmpw	IMM (D_MAX_EXP),d4	| is the exponent big?
 #else
-	cmpl	IMM (0x7ff),d4	| is the exponent big?
+	cmpl	IMM (D_MAX_EXP),d4	| is the exponent big?
 #endif
 	bge	1f
-	bclr	IMM (DBL_MANT_DIG-1),d0
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
 #ifndef __mcoldfire__
 	lslw	IMM (4),d4	| put exponent back into position
 #else
 	lsll	IMM (4),d4	| put exponent back into position
 #endif
-	swap	d0		| 
+	swap	d0		|
 #ifndef __mcoldfire__
 	orw	d4,d0		|
 #else
@@ -1222,23 +1217,16 @@ Lsubdf$0:
 	negxl	d2		|
 	negxl	d1              | and negate result
 	negxl	d0              |
-1:	
+1:
 	movel	a2,d4		| return exponent to d4
 	movel	a0,d7
 	andl	IMM (0x80000000),d7 | isolate sign bit
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	|
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
 | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (DBL_MANT_DIG+1),d0	
+	btst	IMM (DBL_MANT_DIG+1-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -1263,12 +1251,12 @@ Lsubdf$0:
 	addl	IMM (1),d4
 #endif
 1:
-	lea	pc@(Lsubdf$1),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubdf$1),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -1279,14 +1267,14 @@ Lsubdf$0:
 	blt	Lround$to$zero
 	bra	Lround$to$plus
 Lsubdf$1:
-| Put back the exponent and sign (we don't have overflow). '
-	bclr	IMM (DBL_MANT_DIG-1),d0	
+| Put back the exponent and sign (we don't have overflow).
+	bclr	IMM (DBL_MANT_DIG-1-32),d0
 #ifndef __mcoldfire__
 	lslw	IMM (4),d4	| put exponent back into position
 #else
 	lsll	IMM (4),d4	| put exponent back into position
 #endif
-	swap	d0		| 
+	swap	d0		|
 #ifndef __mcoldfire__
 	orw	d4,d0		|
 #else
@@ -1295,50 +1283,28 @@ Lsubdf$1:
 	swap	d0		|
 	bra	Ladddf$ret
 
-| If one of the numbers was too small (difference of exponents >= 
-| DBL_MANT_DIG+1) we return the other (and now we don't have to '
+| If one of the numbers was too small (difference of exponents >=
+| DBL_MANT_DIG+1) we return the other (and now we don't have to
 | check for finiteness or zero).
 Ladddf$a$small:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 	movel	a6@(16),d0
 	movel	a6@(20),d1
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 
 Ladddf$b$small:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	
-#else
-	movel	sp@+,a4	
-	movel	sp@+,a3	
-	movel	sp@+,a2	
-#endif
 	movel	a6@(8),d0
 	movel	a6@(12),d1
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6		| and return
 	rts
 
@@ -1372,7 +1338,7 @@ Ladddf$a:
 	bclr	IMM (31),d0		|
 	cmpl	IMM (0x7ff00000),d0	|
 	bge	2f			|
-	movel	d0,d0           	| check for zero, since we don't  '
+	movel	d0,d0           	| check for zero, since we don't
 	bne	Ladddf$ret		| want to return -0 by mistake
 	bclr	IMM (31),d7		|
 	bra	Ladddf$ret		|
@@ -1381,28 +1347,17 @@ Ladddf$a:
 	orl	d1,d0			|
 	bne	Ld$inop         	|
 	bra	Ld$infty		|
-	
+
 Ladddf$ret$1:
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3	| restore regs and exit
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
 Ladddf$ret:
 | Normal exit.
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
+	clrw	a0@
 	orl	d7,d0		| put sign bit back
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -1426,25 +1381,25 @@ Ladddf$nf:
 | executed very often. We sacrifice speed for clarity here.
 	movel	a6@(8),d0	| get the numbers back (remember that we
 	movel	a6@(12),d1	| did some processing already)
-	movel	a6@(16),d2	| 
-	movel	a6@(20),d3	| 
-	movel	IMM (0x7ff00000),d4 | useful constant (INFINITY)
+	movel	a6@(16),d2	|
+	movel	a6@(20),d3	|
+	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
 	movel	d0,d7		| save sign bits
-	movel	d2,d6		| 
+	movel	d2,d6		|
 	bclr	IMM (31),d0	| clear sign bits
-	bclr	IMM (31),d2	| 
+	bclr	IMM (31),d2	|
 | We know that one of them is either NaN of +/-INFINITY
 | Check for NaN (if either one is NaN return NaN)
 	cmpl	d4,d0		| check first a (d0)
 	bhi	Ld$inop		| if d0 > 0x7ff00000 or equal and
 	bne	2f
 	tstl	d1		| d1 > 0, a is NaN
-	bne	Ld$inop		| 
+	bne	Ld$inop		|
 2:	cmpl	d4,d2		| check now b (d1)
-	bhi	Ld$inop		| 
+	bhi	Ld$inop		|
 	bne	3f
-	tstl	d3		| 
-	bne	Ld$inop		| 
+	tstl	d3		|
+	bne	Ld$inop		|
 3:
 | Now comes the check for +/-INFINITY. We know that both are (maybe not
 | finite) numbers, but we have to check if both are infinite whether we
@@ -1461,8 +1416,8 @@ Ladddf$nf:
 	bne	1f		| if d0 <> d2 they are not equal
 	cmpl	d3,d1		| if d0 == d2 test d3 and d1
 	beq	Ld$inop		| if equal return NaN
-1:	
-	andl	IMM (0x80000000),d7 | get a's sign bit '
+1:
+	andl	IMM (0x80000000),d7 | get a's sign bit
 	cmpl	d4,d0		| test now for infinity
 	beq	Ld$infty	| if a is INFINITY return with this sign
 	bchg	IMM (31),d7	| else we know b is INFINITY and has
@@ -1475,34 +1430,26 @@ Ladddf$nf:
 | double __muldf3(double, double);
 	FUNC(__muldf3)
 SYM (__muldf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0		| get a into d0-d1
-	movel	a6@(12),d1		| 
-	movel	a6@(16),d2		| and b into d2-d3
-	movel	a6@(20),d3		|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
 	movel	d0,d7			| d7 will hold the sign of the product
 	eorl	d2,d7			|
 	andl	IMM (0x80000000),d7	|
-	movel	d7,a0			| save sign bit into a0 
-	movel	IMM (0x7ff00000),d7	| useful constant (+INFINITY)
+	movel	d7,a0			| save sign bit into a0
+	movel	IMM (INFINITY),d7	| useful constant (+INFINITY)
 	movel	d7,d6			| another (mask for fraction)
 	notl	d6			|
-	bclr	IMM (31),d0		| get rid of a's sign bit '
-	movel	d0,d4			| 
-	orl	d1,d4			| 
+	bclr	IMM (31),d0		| get rid of a's sign bit
+	movel	d0,d4			|
+	orl	d1,d4			|
 	beq	Lmuldf$a$0		| branch if a is zero
 	movel	d0,d4			|
-	bclr	IMM (31),d2		| get rid of b's sign bit '
+	bclr	IMM (31),d2		| get rid of b's sign bit
 	movel	d2,d5			|
-	orl	d3,d5			| 
+	orl	d3,d5			|
 	beq	Lmuldf$b$0		| branch if b is zero
-	movel	d2,d5			| 
+	movel	d2,d5			|
 	cmpl	d7,d0			| is a big?
 	bhi	Lmuldf$inop		| if a is NaN return NaN
 	beq	Lmuldf$a$nf		| we still have to check d1 and b ...
@@ -1517,11 +1464,11 @@ SYM (__muldf3):
 	orl	IMM (0x00100000),d0	| and put hidden bit back
 	swap	d4			| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (4),d4		| 
+	lsrw	IMM (4),d4		|
 #else
-	lsrl	IMM (4),d4		| 
+	lsrl	IMM (4),d4		|
 #endif
-Lmuldf$1:			
+Lmuldf$1:
 	andl	d7,d5			|
 	beq	Lmuldf$b$den		|
 	andl	d6,d2			|
@@ -1542,8 +1489,8 @@ Lmuldf$2:				|
 #endif
 
 | We are now ready to do the multiplication. The situation is as follows:
-| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were 
-| denormalized to start with!), which means that in the product bit 104 
+| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were
+| denormalized to start with!), which means that in the product bit 104
 | (which will correspond to bit 8 of the fourth long) is set.
 
 | Here we have to do the product.
@@ -1551,13 +1498,6 @@ Lmuldf$2:				|
 | enough to keep everything in them. So we use the address registers to keep
 | some intermediate data.
 
-#ifndef __mcoldfire__
-	moveml	a2-a3,sp@-	| save a2 and a3 for temporary use
-#else
-	movel	a2,sp@-
-	movel	a3,sp@-
-	movel	a4,sp@-
-#endif
 	movel	IMM (0),a2	| a2 is a null register
 	movel	d4,a3		| and a3 will preserve the exponent
 
@@ -1591,8 +1531,8 @@ Lmuldf$2:				|
 	movel	d3,d1           |
 	movel	d3,d0	        |
 
-| We use a1 as counter:	
-	movel	IMM (DBL_MANT_DIG-1),a1		
+| We use a1 as counter:
+	movel	IMM (DBL_MANT_DIG-1),a1
 #ifndef __mcoldfire__
 	exg	d7,a1
 #else
@@ -1628,7 +1568,7 @@ Lmuldf$2:				|
 	addxl	d7,d1		|
 	addxl	d7,d0		|
 #ifndef __mcoldfire__
-	exg	d7,a2		| 
+	exg	d7,a2		|
 #else
 	movel	d7,a4
 	movel	a2,d7
@@ -1647,16 +1587,9 @@ Lmuldf$2:				|
 #endif
 
 	movel	a3,d4		| restore exponent
-#ifndef __mcoldfire__
-	moveml	sp@+,a2-a3
-#else
-	movel	sp@+,a4
-	movel	sp@+,a3
-	movel	sp@+,a2
-#endif
 
-| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The 
-| first thing to do now is to normalize it so bit 8 becomes bit 
+| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The
+| first thing to do now is to normalize it so bit 8 becomes bit
 | DBL_MANT_DIG-32 (to do the rounding); later we will shift right.
 	swap	d0
 	swap	d1
@@ -1695,7 +1628,7 @@ Lmuldf$2:				|
 	orl	d7,d1
 	lsrl	IMM (3),d0
 #endif
-	
+
 | Now round, check for over- and underflow, and exit.
 	movel	a0,d7		| get sign bit back into d7
 	moveq	IMM (MULTIPLY),d5
@@ -1757,18 +1690,14 @@ Lmuldf$a$0:
 1:	cmpl	IMM (0x7ff00000),d2 | check for non-finiteness
 	bge	Ld$inop		| in case NaN or +/-INFINITY return NaN
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | hidden bit back into the fraction; instead we shift left until bit 21
 | (the hidden bit) is set, adjusting the exponent accordingly. We do this
 | to ensure that the product of the fractions is close to 1.
@@ -1808,30 +1737,22 @@ Lmuldf$b$den:
 | double __divdf3(double, double);
 	FUNC(__divdf3)
 SYM (__divdf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	movel	a6@(8),d0	| get a into d0-d1
-	movel	a6@(12),d1	| 
-	movel	a6@(16),d2	| and b into d2-d3
-	movel	a6@(20),d3	|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get a into d0-d1, and b into d2-d3
 	movel	d0,d7		| d7 will hold the sign of the result
 	eorl	d2,d7		|
 	andl	IMM (0x80000000),d7
 	movel	d7,a0		| save sign into a0
-	movel	IMM (0x7ff00000),d7 | useful constant (+INFINITY)
+	movel	IMM (INFINITY),d7 | useful constant (+INFINITY)
 	movel	d7,d6		| another (mask for fraction)
 	notl	d6		|
-	bclr	IMM (31),d0	| get rid of a's sign bit '
+	bclr	IMM (31),d0	| get rid of a's sign bit
 	movel	d0,d4		|
 	orl	d1,d4		|
 	beq	Ldivdf$a$0	| branch if a is zero
 	movel	d0,d4		|
-	bclr	IMM (31),d2	| get rid of b's sign bit '
+	bclr	IMM (31),d2	| get rid of b's sign bit
 	movel	d2,d5		|
 	orl	d3,d5		|
 	beq	Ldivdf$b$0	| branch if b is zero
@@ -1839,7 +1760,7 @@ SYM (__divdf3):
 	cmpl	d7,d0		| is a big?
 	bhi	Ldivdf$inop	| if a is NaN return NaN
 	beq	Ldivdf$a$nf	| if d0 == 0x7ff00000 we check d1
-	cmpl	d7,d2		| now compare b with INFINITY 
+	cmpl	d7,d2		| now compare b with INFINITY
 	bhi	Ldivdf$inop	| if b is NaN return NaN
 	beq	Ldivdf$b$nf	| if d2 == 0x7ff00000 we check d3
 | Here we have both numbers finite and nonzero (and with no sign bit).
@@ -1854,11 +1775,11 @@ SYM (__divdf3):
 	orl	IMM (0x00100000),d0 | and put hidden bit back
 	swap	d4		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (4),d4	| 
+	lsrw	IMM (4),d4	|
 #else
-	lsrl	IMM (4),d4	| 
+	lsrl	IMM (4),d4	|
 #endif
-Ldivdf$1:			| 
+Ldivdf$1:			|
 	andl	d7,d5		|
 	beq	Ldivdf$b$den	|
 	andl	d6,d2		|
@@ -1881,7 +1802,7 @@ Ldivdf$2:			|
 | We are now ready to do the division. We have prepared things in such a way
 | that the ratio of the fractions will be less than 2 but greater than 1/2.
 | At this point the registers in use are:
-| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit 
+| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit
 | DBL_MANT_DIG-1-32=1)
 | d2-d3	hold b (second operand, bit DBL_MANT_DIG-32=1)
 | d4	holds the difference of the exponents, corrected by the bias
@@ -1890,19 +1811,19 @@ Ldivdf$2:			|
 | To do the rounding correctly we need to keep information about the
 | nonsignificant bits. One way to do this would be to do the division
 | using four registers; another is to use two registers (as originally
-| I did), but use a sticky bit to preserve information about the 
+| I did), but use a sticky bit to preserve information about the
 | fractional part. Note that we can keep that info in a1, which is not
 | used.
 	movel	IMM (0),d6	| d6-d7 will hold the result
-	movel	d6,d7		| 
+	movel	d6,d7		|
 	movel	IMM (0),a1	| and a1 will hold the sticky bit
 
-	movel	IMM (DBL_MANT_DIG-32+1),d5	
-	
+	movel	IMM (DBL_MANT_DIG-32+1),d5
+
 1:	cmpl	d0,d2		| is a < b?
 	bhi	3f		| if b > a skip the following
 	beq	4f		| if d0==d2 check d1 and d3
-2:	subl	d3,d1		| 
+2:	subl	d3,d1		|
 	subxl	d2,d0		| a <-- a - b
 	bset	d5,d6		| set the corresponding bit in d6
 3:	addl	d1,d1		| shift a by 1
@@ -1913,7 +1834,7 @@ Ldivdf$2:			|
 	subql	IMM (1), d5
 	bpl	1b
 #endif
-	bra	5f			
+	bra	5f
 4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	3b		| if d1 > d2 skip the subtraction
 	bra	2b		| else go do it
@@ -1924,7 +1845,7 @@ Ldivdf$2:			|
 1:	cmpl	d0,d2		| is a < b?
 	bhi	3f		| if b > a skip the following
 	beq	4f		| if d0==d2 check d1 and d3
-2:	subl	d3,d1		| 
+2:	subl	d3,d1		|
 	subxl	d2,d0		| a <-- a - b
 	bset	d5,d7		| set the corresponding bit in d7
 3:	addl	d1,d1		| shift a by 1
@@ -1935,7 +1856,7 @@ Ldivdf$2:			|
 	subql	IMM (1), d5
 	bpl	1b
 #endif
-	bra	5f			
+	bra	5f
 4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	3b		| if d1 > d2 skip the subtraction
 	bra	2b		| else go do it
@@ -1955,12 +1876,12 @@ Ldivdf$2:			|
 #endif
 	movel	IMM (0),d2	| here no sticky bit was found
 	movel	d2,d3
-	bra	5f			
+	bra	5f
 3:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 	bhi	2b		| if d1 > d2 go back
 4:
 | Here put the sticky bit in d2-d3 (in the position which actually corresponds
-| to it; if you don't do this the algorithm loses in some cases). '
+| to it; if you don't do this the algorithm loses in some cases).
 	movel	IMM (0),d2
 	movel	d2,d3
 #ifndef __mcoldfire__
@@ -2032,38 +1953,34 @@ Ldivdf$a$0:
 | return a properly signed zero.
 	moveq	IMM (DIVIDE),d5
 	bclr	IMM (31),d2	|
-	movel	d2,d4		| 
-	orl	d3,d4		| 
+	movel	d2,d4		|
+	orl	d3,d4		|
 	beq	Ld$inop		| if b is also zero return NaN
-	cmpl	IMM (0x7ff00000),d2 | check for NaN
-	bhi	Ld$inop		| 
+	cmpl	IMM (INFINITY),d2 | check for NaN
+	bhi	Ld$inop		|
 	blt	1f		|
 	tstl	d3		|
 	bne	Ld$inop		|
 1:	movel	a0,d0		| else return signed zero
-	moveq	IMM(0),d1	| 
+	moveq	IMM(0),d1	|
 	PICLEA	SYM (_fpCCR),a0	| clear exception flags
-	movew	IMM (0),a0@	|
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| 
-#else
-	moveml	sp@,d2-d7	| 
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5	|
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| 
-	rts			| 	
+	unlk	a6		|
+	rts			|
 
 Ldivdf$b$0:
 	moveq	IMM (DIVIDE),d5
 | If we got here a is not zero. Check if a is NaN; in that case return NaN,
-| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
 | cleared already.
-	movel	a0,d7		| put a's sign bit back in d7 '
-	cmpl	IMM (0x7ff00000),d0 | compare d0 with INFINITY
+	movel	a0,d7		| put a's sign bit back in d7
+	cmpl	IMM (INFINITY),d0 | compare d0 with INFINITY
 	bhi	Ld$inop		| if larger it is NaN
-	tstl	d1		| 
-	bne	Ld$inop		| 
+	tstl	d1		|
+	bne	Ld$inop		|
 	bra	Ld$div$0	| else signal DIVIDE_BY_ZERO
 
 Ldivdf$b$nf:
@@ -2079,13 +1996,13 @@ Ldivdf$a$nf:
 	tstl	d1		|
 	bne	Ld$inop		| if d1 <> 0, a is NaN
 | If a is INFINITY we have to check b
-	cmpl	d7,d2		| compare b with INFINITY 
+	cmpl	d7,d2		| compare b with INFINITY
 	bge	Ld$inop		| if b is NaN or INFINITY return NaN
 	tstl	d3		|
-	bne	Ld$inop		| 
+	bne	Ld$inop		|
 	bra	Ld$overflow	| else return overflow
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | bit back into the fraction.
 Ldivdf$a$den:
 	movel	IMM (1),d4
@@ -2122,32 +2039,32 @@ Lround$exit:
 
 | First check for underlow in the exponent:
 #ifndef __mcoldfire__
-	cmpw	IMM (-DBL_MANT_DIG-1),d4		
+	cmpw	IMM (-DBL_MANT_DIG-1),d4
 #else
-	cmpl	IMM (-DBL_MANT_DIG-1),d4		
+	cmpl	IMM (-DBL_MANT_DIG-1),d4
 #endif
-	blt	Ld$underflow	
-| It could happen that the exponent is less than 1, in which case the 
-| number is denormalized. In this case we shift right and adjust the 
-| exponent until it becomes 1 or the fraction is zero (in the latter case 
+	blt	Ld$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
 | we signal underflow and return zero).
 	movel	d7,a0		|
 	movel	IMM (0),d6	| use d6-d7 to collect bits flushed right
 	movel	d6,d7		| use d6-d7 to collect bits flushed right
 #ifndef __mcoldfire__
-	cmpw	IMM (1),d4	| if the exponent is less than 1 we 
+	cmpw	IMM (1),d4	| if the exponent is less than 1 we
 #else
-	cmpl	IMM (1),d4	| if the exponent is less than 1 we 
+	cmpl	IMM (1),d4	| if the exponent is less than 1 we
 #endif
 	bge	2f		| have to shift right (denormalize)
 1:
 #ifndef __mcoldfire__
 	addw	IMM (1),d4	| adjust the exponent
-	lsrl	IMM (1),d0	| shift right once 
+	lsrl	IMM (1),d0	| shift right once
 	roxrl	IMM (1),d1	|
 	roxrl	IMM (1),d2	|
 	roxrl	IMM (1),d3	|
-	roxrl	IMM (1),d6	| 
+	roxrl	IMM (1),d6	|
 	roxrl	IMM (1),d7	|
 	cmpw	IMM (1),d4	| is the exponent 1 already?
 #else
@@ -2177,17 +2094,17 @@ Lround$exit:
 #endif
 	beq	2f		| if not loop back
 	bra	1b              |
-	bra	Ld$underflow	| safety check, shouldn't execute '
-2:	orl	d6,d2		| this is a trick so we don't lose  '
+	bra	Ld$underflow	| safety check, shouldn't execute
+2:	orl	d6,d2		| this is a trick so we don't lose
 	orl	d7,d3		| the bits which were flushed right
 	movel	a0,d7		| get back sign bit into d7
 | Now call the rounding routine (which takes care of denormalized numbers):
-	lea	pc@(Lround$0),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -2201,14 +2118,14 @@ Lround$0:
 | Here we have a correctly rounded result (either normalized or denormalized).
 
 | Here we should have either a normalized number or a denormalized one, and
-| the exponent is necessarily larger or equal to 1 (so we don't have to  '
-| check again for underflow!). We have to check for overflow or for a 
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
 | denormalized number (which also signals underflow).
 | Check for overflow (i.e., exponent >= 0x7ff).
 #ifndef __mcoldfire__
-	cmpw	IMM (0x07ff),d4
+	cmpw	IMM (D_MAX_EXP),d4
 #else
-	cmpl	IMM (0x07ff),d4
+	cmpl	IMM (D_MAX_EXP),d4
 #endif
 	bge	Ld$overflow
 | Now check for a denormalized number (exponent==0):
@@ -2224,22 +2141,18 @@ Lround$0:
 	bclr	IMM (DBL_MANT_DIG-32-1),d0
 	swap	d0		| and put back exponent
 #ifndef __mcoldfire__
-	orw	d4,d0		| 
+	orw	d4,d0		|
 #else
-	orl	d4,d0		| 
+	orl	d4,d0		|
 #endif
 	swap	d0		|
 	orl	d7,d0		| and sign also
 
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -2250,13 +2163,8 @@ Lround$0:
 | double __negdf2(double, double);
 	FUNC(__negdf2)
 SYM (__negdf2):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (NEGATE),d5
 	movel	a6@(8),d0	| get number to negate in d0-d1
 	movel	a6@(12),d1	|
@@ -2273,16 +2181,12 @@ SYM (__negdf2):
 	bne	Ld$inop		|
 	movel	d0,d7		| else get sign and return INFINITY
 	andl	IMM (0x80000000),d7
-	bra	Ld$infty		
+	bra	Ld$infty
 1:	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 2:	bclr	IMM (31),d0
@@ -2292,24 +2196,47 @@ SYM (__negdf2):
 |                              __cmpdf2
 |=============================================================================
 
-GREATER =  1
-LESS    = -1
-EQUAL   =  0
+| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
+| __ledf2, __ltdf2 to all return the same value as a direct call to
+| __cmpdf2 would.  In this implementation, each of these routines
+| simply calls __cmpdf2.  It would be more efficient to give the
+| __cmpdf2 routine several names, but separating them out will make it
+| easier to write efficient versions of these routines someday.
+| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
+| The other routines return 1.
+
+	FUNC(__gtdf2)
+	.globl	SYM (__gtdf2)
+SYM (__gtdf2):
+	FUNC(__gedf2)
+	.globl	SYM (__gedf2)
+SYM (__gedf2):
+	lea	LESS,a0
+	jbra SYM(__cmpdf2_internal)
+
+	FUNC(__eqdf2)
+	.globl	SYM (__eqdf2)
+SYM (__eqdf2):
+	FUNC(__nedf2)
+	.globl	SYM (__nedf2)
+SYM (__nedf2):
+	FUNC(__ltdf2)
+	.globl	SYM (__ltdf2)
+SYM (__ltdf2):
+	FUNC(__ledf2)
+	.globl	SYM (__ledf2)
+SYM (__ledf2):
+
+| int __cmpdf2(double, double);
+	FUNC(__cmpdf2)
+SYM (__cmpdf2):
+	lea	GREATER,a0
 
 | int __cmpdf2_internal(double, double, int);
 SYM (__cmpdf2_internal):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@- 	| save registers
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
-	moveq	IMM (COMPARE),d5
-	movel	a6@(8),d0	| get first operand
-	movel	a6@(12),d1	|
-	movel	a6@(16),d2	| get second operand
-	movel	a6@(20),d3	|
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveml	a6@(8),d0-d3	| get first operand into d0-d1, and second operand into d2-d3
 | First check if a and/or b are (+/-) zero and in that case clear
 | the sign bit.
 	movel	d0,d6		| copy signs into d6 (a) and d7(b)
@@ -2317,14 +2244,14 @@ SYM (__cmpdf2_internal):
 	movel	d2,d7		|
 	bclr	IMM (31),d2	|
 	cmpl	IMM (0x7ff00000),d0 | check for a == NaN
-	bhi	Lcmpd$inop		| if d0 > 0x7ff00000, a is NaN
+	bhi	Lcmpdf$inop		| if d0 > 0x7ff00000, a is NaN
 	beq	Lcmpdf$a$nf	| if equal can be INFINITY, so check d1
 	movel	d0,d4		| copy into d4 to test for zero
 	orl	d1,d4		|
 	beq	Lcmpdf$a$0	|
 Lcmpdf$0:
 	cmpl	IMM (0x7ff00000),d2 | check for b == NaN
-	bhi	Lcmpd$inop		| if d2 > 0x7ff00000, b is NaN
+	bhi	Lcmpdf$inop		| if d2 > 0x7ff00000, b is NaN
 	beq	Lcmpdf$b$nf	| if equal can be INFINITY, so check d3
 	movel	d2,d4		|
 	orl	d3,d4		|
@@ -2365,39 +2292,27 @@ Lcmpdf$1:
 	bne	Lcmpdf$a$gt$b	| |b| < |a|
 | If we got here a == b.
 	movel	IMM (EQUAL),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpdf$a$gt$b:
 	movel	IMM (GREATER),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpdf$b$gt$a:
 	movel	IMM (LESS),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-Lcmpdf$a$0:	
+Lcmpdf$a$0:
 	bclr	IMM (31),d6
 	bra	Lcmpdf$0
 Lcmpdf$b$0:
@@ -2406,39 +2321,27 @@ Lcmpdf$b$0:
 
 Lcmpdf$a$nf:
 	tstl	d1
-	bne	Ld$inop
+	bne	Lcmpdf$inop
 	bra	Lcmpdf$0
 
 Lcmpdf$b$nf:
 	tstl	d3
-	bne	Ld$inop
+	bne	Lcmpdf$inop
 	bra	Lcmpdf$1
 
-Lcmpd$inop:
-	movl	a6@(24),d0
+Lcmpdf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
 	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 	moveq	IMM (DOUBLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-| int __cmpdf2(double, double);
-	FUNC(__cmpdf2)
-SYM (__cmpdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-
 |=============================================================================
 |                           rounding routines
 |=============================================================================
 
 | The rounding routines expect the number to be normalized in registers
-| d0-d1-d2-d3, with the exponent in register d4. They assume that the 
+| d0-d1-d2-d3, with the exponent in register d4. They assume that the
 | exponent is larger or equal to 1. They return a properly normalized number
 | if possible, and a denormalized number otherwise. The exponent is returned
 | in d4.
@@ -2451,15 +2354,15 @@ Lround$to$nearest:
 | Check for denormalized numbers:
 1:	btst	IMM (DBL_MANT_DIG-32),d0
 	bne	2f		| if set the number is normalized
-| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent 
-| is one (remember that a denormalized number corresponds to an 
+| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent
+| is one (remember that a denormalized number corresponds to an
 | exponent of -D_BIAS+1).
 #ifndef __mcoldfire__
 	cmpw	IMM (1),d4	| remember that the exponent is at least one
 #else
 	cmpl	IMM (1),d4	| remember that the exponent is at least one
 #endif
- 	beq	2f		| an exponent of one means denormalized
+	beq	2f		| an exponent of one means denormalized
 	addl	d3,d3		| else shift and adjust the exponent
 	addxl	d2,d2		|
 	addxl	d1,d1		|
@@ -2473,20 +2376,20 @@ Lround$to$nearest:
 2:
 | Now round: we do it as follows: after the shifting we can write the
 | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
-| If delta < 1, do nothing. If delta > 1, add 1 to f. 
-| If delta == 1, we make sure the rounded number will be even (odd?) 
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
 | (after shifting).
 	btst	IMM (0),d1	| is delta < 1?
 	beq	2f		| if so, do not do anything
 	orl	d2,d3		| is delta == 1?
 	bne	1f		| if so round to even
-	movel	d1,d3		| 
+	movel	d1,d3		|
 	andl	IMM (2),d3	| bit 1 is the last significant bit
 	movel	IMM (0),d2	|
 	addl	d3,d1		|
 	addxl	d2,d0		|
-	bra	2f		| 
-1:	movel	IMM (1),d3	| else add 1 
+	bra	2f		|
+1:	movel	IMM (1),d3	| else add 1
 	movel	IMM (0),d2	|
 	addl	d3,d1		|
 	addxl	d2,d0
@@ -2494,7 +2397,7 @@ Lround$to$nearest:
 2:
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
-	roxrl	IMM (1),d1		
+	roxrl	IMM (1),d1
 #else
 	lsrl	IMM (1),d1
 	btst	IMM (0),d0
@@ -2505,7 +2408,7 @@ Lround$to$nearest:
 
 | Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a
 | 'fraction overflow' ...).
-	btst	IMM (DBL_MANT_DIG-32),d0	
+	btst	IMM (DBL_MANT_DIG-32),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -2520,7 +2423,7 @@ Lround$to$nearest:
 	addl	IMM (1),d4
 #endif
 1:
-| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we 
+| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we
 | have to put the exponent to zero and return a denormalized number.
 	btst	IMM (DBL_MANT_DIG-32-1),d0
 	beq	1f
@@ -2536,6 +2439,26 @@ Lround$to$minus:
 
 #ifdef  L_float
 
+|=============================================================================
+|=============================================================================
+|                         single precision routines
+|=============================================================================
+|=============================================================================
+
+| A single precision floating point number (float) has the format:
+|
+| struct _float {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
+|  unsigned int fraction  : 23; /* fraction */
+| } float;
+|
+| Thus sizeof(float) = 4 (32 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the single register d0. They also preserve all registers except
+| d0-d1 and a0-a1.
+
 	.globl	SYM (_fpCCR)
 	.globl  $_exception_handler
 
@@ -2549,29 +2472,6 @@ FLT_MAX_EXP    = F_MAX_EXP - F_BIAS
 FLT_MIN_EXP    = 1 - F_BIAS
 FLT_MANT_DIG   = 24
 
-INEXACT_RESULT 		= 0x0001
-UNDERFLOW 		= 0x0002
-OVERFLOW 		= 0x0004
-DIVIDE_BY_ZERO 		= 0x0008
-INVALID_OPERATION 	= 0x0010
-
-SINGLE_FLOAT = 1
-
-NOOP         = 0
-ADD          = 1
-MULTIPLY     = 2
-DIVIDE       = 3
-NEGATE       = 4
-COMPARE      = 5
-EXTENDSFDF   = 6
-TRUNCDFSF    = 7
-
-UNKNOWN           = -1
-ROUND_TO_NEAREST  = 0 | round result to nearest representable value
-ROUND_TO_ZERO     = 1 | round result towards zero
-ROUND_TO_PLUS     = 2 | round result towards plus infinity
-ROUND_TO_MINUS    = 3 | round result towards minus infinity
-
 | Entry points:
 
 	.globl SYM (__addsf3)
@@ -2581,9 +2481,11 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity
 	.globl SYM (__negsf2)
 	.globl SYM (__cmpsf2)
 	.globl SYM (__cmpsf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpsf2_internal)
+#endif
 
-| These are common routines to return and signal exceptions.	
+| These are common routines to return and signal exceptions.
 
 	.text
 	.even
@@ -2597,7 +2499,7 @@ Lf$den:
 
 Lf$infty:
 Lf$overflow:
-| Return a properly signed INFINITY and set the exception flags 
+| Return a properly signed INFINITY and set the exception flags
 	movel	IMM (INFINITY),d0
 	orl	d7,d0
 	moveq	IMM (INEXACT_RESULT+OVERFLOW),d7
@@ -2605,7 +2507,7 @@ Lf$overflow:
 	PICJUMP	$_exception_handler
 
 Lf$underflow:
-| Return 0 and set the exception flags 
+| Return 0 and set the exception flags
 	moveq	IMM (0),d0
 	moveq	IMM (INEXACT_RESULT+UNDERFLOW),d7
 	moveq	IMM (SINGLE_FLOAT),d6
@@ -2626,26 +2528,6 @@ Lf$div$0:
 	moveq	IMM (SINGLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-|=============================================================================
-|=============================================================================
-|                         single precision routines
-|=============================================================================
-|=============================================================================
-
-| A single precision floating point number (float) has the format:
-|
-| struct _float {
-|  unsigned int sign      : 1;  /* sign bit */ 
-|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
-|  unsigned int fraction  : 23; /* fraction */
-| } float;
-| 
-| Thus sizeof(float) = 4 (32 bits). 
-|
-| All the routines are callable from C programs, and return the result 
-| in the single register d0. They also preserve all registers except 
-| d0-d1 and a0-a1.
-
 |=============================================================================
 |                              __subsf3
 |=============================================================================
@@ -2653,8 +2535,14 @@ Lf$div$0:
 | float __subsf3(float, float);
 	FUNC(__subsf3)
 SYM (__subsf3):
+#ifdef __FASTCALL__
+	bchg	IMM (31),d1   	| change sign of second operand
+				| and fall through
+#else
 	bchg	IMM (31),sp@(8)	| change sign of second operand
 				| and fall through
+#endif
+
 |=============================================================================
 |                              __addsf3
 |=============================================================================
@@ -2662,19 +2550,18 @@ SYM (__subsf3):
 | float __addsf3(float, float);
 	FUNC(__addsf3)
 SYM (__addsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)	| everything will be done in registers
-	moveml	d2-d7,sp@-	| save all data registers but d0-d1
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get first operand
 	movel	a6@(12),d1	| get second operand
-	movel	d0,a0		| get d0's sign bit '
+#endif
+	movel	d0,a2		| store first operand
+	movel	d1,a3		| store second operand
+	movel	d0,a0		| get d0's sign bit
 	addl	d0,d0		| check and clear sign bit of a
 	beq	Laddsf$b	| if zero return second operand
-	movel	d1,a1		| save b's sign bit '
+	movel	d1,a1		| save b's sign bit
 	addl	d1,d1		| get rid of sign bit
 	beq	Laddsf$a	| if zero return first operand
 
@@ -2693,9 +2580,9 @@ SYM (__addsf3):
 	swap	d6		| put exponent into first word
 	orl	d5,d0		| and put hidden bit back
 Laddsf$1:
-| Now we have a's exponent in d6 (second byte) and the mantissa in d0. '
+| Now we have a's exponent in d6 (second byte) and the mantissa in d0.
 	movel	d1,d7		| get exponent in d7
-	andl	d4,d7		| 
+	andl	d4,d7		|
 	beq	Laddsf$b$den	| branch if b is denormalized
 	cmpl	d4,d7		| check for INFINITY or NaN
 	beq	Laddsf$nf
@@ -2704,9 +2591,9 @@ Laddsf$1:
 	andl	d4,d1		| get fraction in d1
 	orl	d5,d1		| and put hidden bit back
 Laddsf$2:
-| Now we have b's exponent in d7 (second byte) and the mantissa in d1. '
+| Now we have b's exponent in d7 (second byte) and the mantissa in d1.
 
-| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we 
+| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we
 | shifted right once, so bit #FLT_MANT_DIG is set (so we have one extra
 | bit).
 
@@ -2717,14 +2604,14 @@ Laddsf$2:
 
 | Here we shift the numbers in registers d0 and d1 so the exponents are the
 | same, and put the largest exponent in d6. Note that we are using two
-| registers for each number (see the discussion by D. Knuth in "Seminumerical 
+| registers for each number (see the discussion by D. Knuth in "Seminumerical
 | Algorithms").
 #ifndef __mcoldfire__
 	cmpw	d6,d7		| compare exponents
 #else
 	cmpl	d6,d7		| compare exponents
 #endif
-	beq	Laddsf$3	| if equal don't shift '
+	beq	Laddsf$3	| if equal don't shift
 	bhi	5f		| branch if second exponent largest
 1:
 	subl	d6,d7		| keep the largest exponent
@@ -2734,11 +2621,11 @@ Laddsf$2:
 #else
 	lsrl	IMM (8),d7	| put difference in lower byte
 #endif
-| if difference is too large we don't shift (actually, we can just exit) '
+| if difference is too large we don't shift (actually, we can just exit)
 #ifndef __mcoldfire__
-	cmpw	IMM (FLT_MANT_DIG+2),d7		
+	cmpw	IMM (FLT_MANT_DIG+2),d7
 #else
-	cmpl	IMM (FLT_MANT_DIG+2),d7		
+	cmpl	IMM (FLT_MANT_DIG+2),d7
 #endif
 	bge	Laddsf$b$small
 #ifndef __mcoldfire__
@@ -2795,11 +2682,11 @@ Laddsf$2:
 #else
 	lsrl	IMM (8),d7	| put difference in lower byte
 #endif
-| if difference is too large we don't shift (and exit!) '
+| if difference is too large we don't shift (and exit!)
 #ifndef __mcoldfire__
-	cmpw	IMM (FLT_MANT_DIG+2),d7		
+	cmpw	IMM (FLT_MANT_DIG+2),d7
 #else
-	cmpl	IMM (FLT_MANT_DIG+2),d7		
+	cmpl	IMM (FLT_MANT_DIG+2),d7
 #endif
 	bge	Laddsf$a$small
 #ifndef __mcoldfire__
@@ -2859,7 +2746,7 @@ Laddsf$3:
 	movel	d4,a1
 #endif
 	eorl	d6,d7		| combine sign bits
-	bmi	Lsubsf$0	| if negative a and b have opposite 
+	bmi	Lsubsf$0	| if negative a and b have opposite
 				| sign so we actually subtract the
 				| numbers
 
@@ -2876,7 +2763,7 @@ Laddsf$3:
 | Here we do the addition.
 	addl	d3,d1
 	addxl	d2,d0
-| Note: now we have d2, d3, d4 and d5 to play with! 
+| Note: now we have d2, d3, d4 and d5 to play with!
 
 | Put the exponent, in the first byte, in d2, to use the "standard" rounding
 | routines:
@@ -2889,9 +2776,9 @@ Laddsf$3:
 
 | Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider
 | the case of denormalized numbers in the rounding routine itself).
-| As in the addition (not in the subtraction!) we could have set 
+| As in the addition (not in the subtraction!) we could have set
 | one more bit we check this:
-	btst	IMM (FLT_MANT_DIG+1),d0	
+	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	1f
 #ifndef __mcoldfire__
 	lsrl	IMM (1),d0
@@ -2905,12 +2792,12 @@ Laddsf$3:
 #endif
 	addl	IMM (1),d2
 1:
-	lea	pc@(Laddsf$4),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| ROUND rounding mode in d6
+	lea	pc@(Laddsf$4),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -2923,9 +2810,9 @@ Laddsf$3:
 Laddsf$4:
 | Put back the exponent, but check for overflow.
 #ifndef __mcoldfire__
-	cmpw	IMM (0xff),d2
+	cmpw	IMM (F_MAX_EXP),d2
 #else
-	cmpl	IMM (0xff),d2
+	cmpl	IMM (F_MAX_EXP),d2
 #endif
 	bhi	1f
 	bclr	IMM (FLT_MANT_DIG-1),d0
@@ -2970,12 +2857,12 @@ Lsubsf$0:
 | Note that we do not have to normalize, since in the subtraction bit
 | #FLT_MANT_DIG+1 is never set, and denormalized numbers are handled by
 | the rounding routines themselves.
-	lea	pc@(Lsubsf$1),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lsubsf$1),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -2986,7 +2873,7 @@ Lsubsf$0:
 	blt	Lround$to$zero
 	bra	Lround$to$plus
 Lsubsf$1:
-| Put back the exponent (we can't have overflow!). '
+| Put back the exponent (we can't have overflow!).
 	bclr	IMM (FLT_MANT_DIG-1),d0
 #ifndef __mcoldfire__
 	lslw	IMM (7),d2
@@ -2997,36 +2884,28 @@ Lsubsf$1:
 	orl	d2,d0
 	bra	Laddsf$ret
 
-| If one of the numbers was too small (difference of exponents >= 
-| FLT_MANT_DIG+2) we return the other (and now we don't have to '
+| If one of the numbers was too small (difference of exponents >=
+| FLT_MANT_DIG+2) we return the other (and now we don't have to
 | check for finiteness or zero).
 Laddsf$a$small:
-	movel	a6@(12),d0
+	movel	a3,d0
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 Laddsf$b$small:
-	movel	a6@(8),d0
+	movel	a2,d0
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 | If the numbers are denormalized remember to put exponent equal to 1.
 
@@ -3042,12 +2921,12 @@ Laddsf$b$den:
 				| (this was not executed after the jump)
 	bra	Laddsf$2
 
-| The rest is mainly code for the different results which can be 
+| The rest is mainly code for the different results which can be
 | returned (checking always for +/-INFINITY and NaN).
 
 Laddsf$b:
 | Return b (if a is zero).
-	movel	a6@(12),d0
+	movel	a3,d0
 	cmpl	IMM (0x80000000),d0	| Check if b is -0
 	bne	1f
 	movel	a0,d7
@@ -3056,7 +2935,7 @@ Laddsf$b:
 	bra	Laddsf$ret
 Laddsf$a:
 | Return a (if b is zero).
-	movel	a6@(8),d0
+	movel	a2,d0
 1:
 	moveq	IMM (ADD),d5
 | We have to check for NaN and +/-infty.
@@ -3065,7 +2944,7 @@ Laddsf$a:
 	bclr	IMM (31),d0		| clear sign
 	cmpl	IMM (INFINITY),d0	| check for infty or NaN
 	bge	2f
-	movel	d0,d0		| check for zero (we do this because we don't '
+	movel	d0,d0		| check for zero (we do this because we don't
 	bne	Laddsf$ret	| want to return -0 by mistake
 	bclr	IMM (31),d7	| if zero be sure to clear sign
 	bra	Laddsf$ret	| if everything OK just return
@@ -3079,27 +2958,23 @@ Laddsf$ret:
 | Normal exit (a and b nonzero, result is not NaN nor +/-infty).
 | We have to clear the exception flags (just the exception type).
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
+	clrw	a0@
 	orl	d7,d0		| put sign bit
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| restore data registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5	| restore data registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| and return
-	rts
+	unlk	a6
+	rts		| and return
 
 Laddsf$ret$den:
-| Return a denormalized number (for addition we don't signal underflow) '
+| Return a denormalized number (for addition we don't signal underflow)
 	lsrl	IMM (1),d0	| remember to shift right back once
 	bra	Laddsf$ret	| and return
 
-| Note: when adding two floats of the same sign if either one is 
-| NaN we return NaN without regard to whether the other is finite or 
-| not. When subtracting them (i.e., when adding two numbers of 
-| opposite signs) things are more complicated: if both are INFINITY 
+| Note: when adding two floats of the same sign if either one is
+| NaN we return NaN without regard to whether the other is finite or
+| not. When subtracting them (i.e., when adding two numbers of
+| opposite signs) things are more complicated: if both are INFINITY
 | we return NaN, if only one is INFINITY and the other is NaN we return
 | NaN, but if it is finite we return INFINITY with the corresponding sign.
 
@@ -3107,25 +2982,26 @@ Laddsf$nf:
 	moveq	IMM (ADD),d5
 | This could be faster but it is not worth the effort, since it is not
 | executed very often. We sacrifice speed for clarity here.
-	movel	a6@(8),d0	| get the numbers back (remember that we
-	movel	a6@(12),d1	| did some processing already)
+	movel	a2,d0	| get the numbers back (remember that we
+	movel	a3,d1	| did some processing already)
 	movel	IMM (INFINITY),d4 | useful constant (INFINITY)
 	movel	d0,d2		| save sign bits
+	movel	d0,d7		| into d7 as well as we may need the sign
+				| bit before jumping to Lf$infty
 	movel	d1,d3
 	bclr	IMM (31),d0	| clear sign bits
 	bclr	IMM (31),d1
 | We know that one of them is either NaN of +/-INFINITY
 | Check for NaN (if either one is NaN return NaN)
 	cmpl	d4,d0		| check first a (d0)
-	bhi	Lf$inop		
+	bhi	Lf$inop
 	cmpl	d4,d1		| check now b (d1)
-	bhi	Lf$inop		
+	bhi	Lf$inop
 | Now comes the check for +/-INFINITY. We know that both are (maybe not
 | finite) numbers, but we have to check if both are infinite whether we
 | are adding or subtracting them.
 	eorl	d3,d2		| to check sign bits
 	bmi	1f
-	movel	d0,d7
 	andl	IMM (0x80000000),d7	| get (common) sign bit
 	bra	Lf$infty
 1:
@@ -3135,8 +3011,7 @@ Laddsf$nf:
 	cmpl	d1,d0		| are both infinite?
 	beq	Lf$inop		| if so return NaN
 
-	movel	d0,d7
-	andl	IMM (0x80000000),d7 | get a's sign bit '
+	andl	IMM (0x80000000),d7 | get a's sign bit
 	cmpl	d4,d0		| test now for infinity
 	beq	Lf$infty	| if a is INFINITY return with this sign
 	bchg	IMM (31),d7	| else we know b is INFINITY and has
@@ -3149,15 +3024,14 @@ Laddsf$nf:
 | float __mulsf3(float, float);
 	FUNC(__mulsf3)
 SYM (__mulsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get a into d0
 	movel	a6@(12),d1	| and b into d1
+#endif
+	movel	d0,a2		| store a into a0
+	movel	d1,a3		| store b into a1
 	movel	d0,d7		| d7 will hold the sign of the product
 	eorl	d1,d7		|
 	andl	IMM (0x80000000),d7
@@ -3165,10 +3039,10 @@ SYM (__mulsf3):
 	movel	d6,d5			| another (mask for fraction)
 	notl	d5			|
 	movel	IMM (0x00800000),d4	| this is to put hidden bit back
-	bclr	IMM (31),d0		| get rid of a's sign bit '
+	bclr	IMM (31),d0		| get rid of a's sign bit
 	movel	d0,d2			|
 	beq	Lmulsf$a$0		| branch if a is zero
-	bclr	IMM (31),d1		| get rid of b's sign bit '
+	bclr	IMM (31),d1		| get rid of b's sign bit
 	movel	d1,d3		|
 	beq	Lmulsf$b$0	| branch if b is zero
 	cmpl	d6,d0		| is a big?
@@ -3185,9 +3059,9 @@ SYM (__mulsf3):
 	orl	d4,d0		| and put hidden bit back
 	swap	d2		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (7),d2	| 
+	lsrw	IMM (7),d2	|
 #else
-	lsrl	IMM (7),d2	| 
+	lsrl	IMM (7),d2	|
 #endif
 Lmulsf$1:			| number
 	andl	d6,d3		|
@@ -3210,10 +3084,10 @@ Lmulsf$2:			|
 #endif
 
 | We are now ready to do the multiplication. The situation is as follows:
-| both a and b have bit FLT_MANT_DIG-1 set (even if they were 
-| denormalized to start with!), which means that in the product 
-| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the 
-| high long) is set. 
+| both a and b have bit FLT_MANT_DIG-1 set (even if they were
+| denormalized to start with!), which means that in the product
+| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the
+| high long) is set.
 
 | To do the multiplication let us move the number a little bit around ...
 	movel	d1,d6		| second operand in d6
@@ -3223,11 +3097,11 @@ Lmulsf$2:			|
 	movel	d4,d0
 
 | now bit FLT_MANT_DIG-1 becomes bit 31:
-	lsll	IMM (31-FLT_MANT_DIG+1),d6		
+	lsll	IMM (31-FLT_MANT_DIG+1),d6
 
 | Start the loop (we loop #FLT_MANT_DIG times):
-	moveq	IMM (FLT_MANT_DIG-1),d3	
-1:	addl	d1,d1		| shift sum 
+	moveq	IMM (FLT_MANT_DIG-1),d3
+1:	addl	d1,d1		| shift sum
 	addxl	d0,d0
 	lsll	IMM (1),d6	| get bit bn
 	bcc	2f		| if not set skip sum
@@ -3242,7 +3116,7 @@ Lmulsf$2:			|
 #endif
 
 | Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG
-| (mod 32) of d0 set. The first thing to do now is to normalize it so bit 
+| (mod 32) of d0 set. The first thing to do now is to normalize it so bit
 | FLT_MANT_DIG is set (to do the rounding).
 #ifndef __mcoldfire__
 	rorl	IMM (6),d1
@@ -3270,7 +3144,7 @@ Lmulsf$2:			|
 #endif
 
 	moveq	IMM (MULTIPLY),d5
-	
+
 	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	Lround$exit
 #ifndef __mcoldfire__
@@ -3303,31 +3177,27 @@ Lmulsf$inf:
 	bhi	Lf$inop		| if so return NaN
 	bra	Lf$overflow	| else return +/-INFINITY
 
-| If either number is zero return zero, unless the other is +/-INFINITY, 
+| If either number is zero return zero, unless the other is +/-INFINITY,
 | or NaN, in which case we return NaN.
 Lmulsf$b$0:
 | Here d1 (==b) is zero.
-	movel	a6@(8),d1	| get a again to check for non-finiteness
+	movel	a2,d1		| get a again to check for non-finiteness
 	bra	1f
 Lmulsf$a$0:
-	movel	a6@(12),d1	| get b again to check for non-finiteness
-1:	bclr	IMM (31),d1	| clear sign bit 
+	movel	a3,d1	| get b again to check for non-finiteness
+1:	bclr	IMM (31),d1	| clear sign bit
 	cmpl	IMM (INFINITY),d1 | and check for a large exponent
 	bge	Lf$inop		| if b is +/-INFINITY or NaN return NaN
 	movel	d7,d0		| else return signed zero
 	PICLEA	SYM (_fpCCR),a0	|
-	movew	IMM (0),a0@	| 
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7	| 
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@	|
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6		| 
-	rts			| 
+	unlk	a6		|
+	rts			|
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | hidden bit back into the fraction; instead we shift left until bit 23
 | (the hidden bit) is set, adjusting the exponent accordingly. We do this
 | to ensure that the product of the fractions is close to 1.
@@ -3364,32 +3234,29 @@ Lmulsf$b$den:
 | float __divsf3(float, float);
 	FUNC(__divsf3)
 SYM (__divsf3):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+#ifndef __FASTCALL
 	movel	a6@(8),d0		| get a into d0
 	movel	a6@(12),d1		| and b into d1
+#endif
 	movel	d0,d7			| d7 will hold the sign of the result
 	eorl	d1,d7			|
-	andl	IMM (0x80000000),d7	| 
+	andl	IMM (0x80000000),d7	|
 	movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
 	movel	d6,d5			| another (mask for fraction)
 	notl	d5			|
 	movel	IMM (0x00800000),d4	| this is to put hidden bit back
-	bclr	IMM (31),d0		| get rid of a's sign bit '
+	bclr	IMM (31),d0		| get rid of a's sign bit
 	movel	d0,d2			|
 	beq	Ldivsf$a$0		| branch if a is zero
-	bclr	IMM (31),d1		| get rid of b's sign bit '
+	bclr	IMM (31),d1		| get rid of b's sign bit
 	movel	d1,d3			|
 	beq	Ldivsf$b$0		| branch if b is zero
 	cmpl	d6,d0			| is a big?
 	bhi	Ldivsf$inop		| if a is NaN return NaN
 	beq	Ldivsf$inf		| if a is INFINITY we have to check b
-	cmpl	d6,d1			| now compare b with INFINITY 
+	cmpl	d6,d1			| now compare b with INFINITY
 	bhi	Ldivsf$inop		| if b is NaN return NaN
 	beq	Ldivsf$underflow
 | Here we have both numbers finite and nonzero (and with no sign bit).
@@ -3402,11 +3269,11 @@ SYM (__divsf3):
 	orl	d4,d0		| and put hidden bit back
 	swap	d2		| I like exponents in the first byte
 #ifndef __mcoldfire__
-	lsrw	IMM (7),d2	| 
+	lsrw	IMM (7),d2	|
 #else
-	lsrl	IMM (7),d2	| 
+	lsrl	IMM (7),d2	|
 #endif
-Ldivsf$1:			| 
+Ldivsf$1:			|
 	andl	d6,d3		|
 	beq	Ldivsf$b$den	|
 	andl	d5,d1		|
@@ -3425,7 +3292,7 @@ Ldivsf$2:			|
 	subl	d3,d2		| subtract exponents
  	addl	IMM (F_BIAS),d2	| and add bias
 #endif
- 
+
 | We are now ready to do the division. We have prepared things in such a way
 | that the ratio of the fractions will be less than 2 but greater than 1/2.
 | At this point the registers in use are:
@@ -3435,7 +3302,7 @@ Ldivsf$2:			|
 | d7	holds the sign of the ratio
 | d4, d5, d6 hold some constants
 	movel	d7,a0		| d6-d7 will hold the ratio of the fractions
-	movel	IMM (0),d6	| 
+	movel	IMM (0),d6	|
 	movel	d6,d7
 
 	moveq	IMM (FLT_MANT_DIG+1),d3
@@ -3478,10 +3345,10 @@ Ldivsf$2:			|
 	movel	d6,d0		| put the ratio in d0-d1
 	movel	a0,d7		| get sign back
 
-| Because of the normalization we did before we are guaranteed that 
+| Because of the normalization we did before we are guaranteed that
 | d0 is smaller than 2^26 but larger than 2^24. Thus bit 26 is not set,
 | bit 25 could be set, and if it is not set then bit 24 is necessarily set.
-	btst	IMM (FLT_MANT_DIG+1),d0		
+	btst	IMM (FLT_MANT_DIG+1),d0
 	beq	1f              | if it is not set, then bit 24 is set
 	lsrl	IMM (1),d0	|
 #ifndef __mcoldfire__
@@ -3514,24 +3381,20 @@ Ldivsf$a$0:
 	andl	IMM (0x7fffffff),d1	| clear sign bit and test b
 	beq	Lf$inop			| if b is also zero return NaN
 	cmpl	IMM (INFINITY),d1	| check for NaN
-	bhi	Lf$inop			| 
+	bhi	Lf$inop			|
 	movel	d7,d0			| else return signed zero
 	PICLEA	SYM (_fpCCR),a0		|
-	movew	IMM (0),a0@		|
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7		| 
-#else
-	moveml	sp@,d2-d7		| 
+	clrw	a0@		|
+	moveml	sp@,d2-d7/a2-a5		|
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
-	unlk	a6			| 
-	rts				| 
-	
+	unlk	a6			|
+	rts				|
+
 Ldivsf$b$0:
 	moveq	IMM (DIVIDE),d5
 | If we got here a is not zero. Check if a is NaN; in that case return NaN,
-| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
+| else return +/-INFINITY. Remember that a is in d0 with the sign bit
 | cleared already.
 	cmpl	IMM (INFINITY),d0	| compare d0 with INFINITY
 	bhi	Lf$inop			| if larger it is NaN
@@ -3540,11 +3403,11 @@ Ldivsf$b$0:
 Ldivsf$inf:
 	moveq	IMM (DIVIDE),d5
 | If a is INFINITY we have to check b
-	cmpl	IMM (INFINITY),d1	| compare b with INFINITY 
+	cmpl	IMM (INFINITY),d1	| compare b with INFINITY
 	bge	Lf$inop			| if b is NaN or INFINITY return NaN
 	bra	Lf$overflow		| else return overflow
 
-| If a number is denormalized we put an exponent of 1 but do not put the 
+| If a number is denormalized we put an exponent of 1 but do not put the
 | bit back into the fraction.
 Ldivsf$a$den:
 	movel	IMM (1),d2
@@ -3573,30 +3436,30 @@ Ldivsf$b$den:
 	bra	1b
 
 Lround$exit:
-| This is a common exit point for __mulsf3 and __divsf3. 
+| This is a common exit point for __mulsf3 and __divsf3.
 
 | First check for underlow in the exponent:
 #ifndef __mcoldfire__
-	cmpw	IMM (-FLT_MANT_DIG-1),d2		
+	cmpw	IMM (-FLT_MANT_DIG-1),d2
 #else
-	cmpl	IMM (-FLT_MANT_DIG-1),d2		
+	cmpl	IMM (-FLT_MANT_DIG-1),d2
 #endif
-	blt	Lf$underflow	
-| It could happen that the exponent is less than 1, in which case the 
-| number is denormalized. In this case we shift right and adjust the 
-| exponent until it becomes 1 or the fraction is zero (in the latter case 
+	blt	Lf$underflow
+| It could happen that the exponent is less than 1, in which case the
+| number is denormalized. In this case we shift right and adjust the
+| exponent until it becomes 1 or the fraction is zero (in the latter case
 | we signal underflow and return zero).
 	movel	IMM (0),d6	| d6 is used temporarily
 #ifndef __mcoldfire__
-	cmpw	IMM (1),d2	| if the exponent is less than 1 we 
+	cmpw	IMM (1),d2	| if the exponent is less than 1 we
 #else
-	cmpl	IMM (1),d2	| if the exponent is less than 1 we 
+	cmpl	IMM (1),d2	| if the exponent is less than 1 we
 #endif
 	bge	2f		| have to shift right (denormalize)
 1:
 #ifndef __mcoldfire__
 	addw	IMM (1),d2	| adjust the exponent
-	lsrl	IMM (1),d0	| shift right once 
+	lsrl	IMM (1),d0	| shift right once
 	roxrl	IMM (1),d1	|
 	roxrl	IMM (1),d6	| d6 collect bits we would lose otherwise
 	cmpw	IMM (1),d2	| is the exponent 1 already?
@@ -3615,16 +3478,16 @@ Lround$exit:
 #endif
 	beq	2f		| if not loop back
 	bra	1b              |
-	bra	Lf$underflow	| safety check, shouldn't execute '
-2:	orl	d6,d1		| this is a trick so we don't lose  '
+	bra	Lf$underflow	| safety check, shouldn't execute
+2:	orl	d6,d1		| this is a trick so we don't lose
 				| the extra bits which were flushed right
 | Now call the rounding routine (which takes care of denormalized numbers):
-	lea	pc@(Lround$0),a0 | to return from rounding routine
-	PICLEA	SYM (_fpCCR),a1	| check the rounding mode
+	PICLEA	SYM (_fpCCR),a0	| check the rounding mode
 #ifdef __mcoldfire__
 	clrl	d6
 #endif
-	movew	a1@(6),d6	| rounding mode in d6
+	movew	a0@(6),d6	| rounding mode in d6
+	lea	pc@(Lround$0),a0 | to return from rounding routine
 	beq	Lround$to$nearest
 #ifndef __mcoldfire__
 	cmpw	IMM (ROUND_TO_PLUS),d6
@@ -3638,14 +3501,14 @@ Lround$0:
 | Here we have a correctly rounded result (either normalized or denormalized).
 
 | Here we should have either a normalized number or a denormalized one, and
-| the exponent is necessarily larger or equal to 1 (so we don't have to  '
-| check again for underflow!). We have to check for overflow or for a 
+| the exponent is necessarily larger or equal to 1 (so we don't have to
+| check again for underflow!). We have to check for overflow or for a
 | denormalized number (which also signals underflow).
 | Check for overflow (i.e., exponent >= 255).
 #ifndef __mcoldfire__
-	cmpw	IMM (0x00ff),d2
+	cmpw	IMM (F_MAX_EXP),d2
 #else
-	cmpl	IMM (0x00ff),d2
+	cmpl	IMM (F_MAX_EXP),d2
 #endif
 	bge	Lf$overflow
 | Now check for a denormalized number (exponent==0).
@@ -3661,7 +3524,7 @@ Lround$0:
 	bclr	IMM (FLT_MANT_DIG-1),d0
 	swap	d0		| and put back exponent
 #ifndef __mcoldfire__
-	orw	d2,d0		| 
+	orw	d2,d0		|
 #else
 	orl	d2,d0
 #endif
@@ -3669,14 +3532,10 @@ Lround$0:
 	orl	d7,d0		| and sign also
 
 	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
@@ -3684,21 +3543,18 @@ Lround$0:
 |                             __negsf2
 |=============================================================================
 
-| This is trivial and could be shorter if we didn't bother checking for NaN '
+| This is trivial and could be shorter if we didn't bother checking for NaN
 | and +/-INFINITY.
 
 | float __negsf2(float);
 	FUNC(__negsf2)
 SYM (__negsf2):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@-
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (NEGATE),d5
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get number to negate in d0
+#endif
 	bchg	IMM (31),d0	| negate
 	movel	d0,d1		| make a positive copy
 	bclr	IMM (31),d1	|
@@ -3709,16 +3565,12 @@ SYM (__negsf2):
 	bhi	Lf$inop		| if larger (fraction not zero) is NaN
 	movel	d0,d7		| else get sign and return INFINITY
 	andl	IMM (0x80000000),d7
-	bra	Lf$infty		
+	bra	Lf$infty
 1:	PICLEA	SYM (_fpCCR),a0
-	movew	IMM (0),a0@
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7
-#else
-	moveml	sp@,d2-d7
+	clrw	a0@
+	moveml	sp@,d2-d7/a2-a5
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 2:	bclr	IMM (31),d0
@@ -3728,22 +3580,45 @@ SYM (__negsf2):
 |                             __cmpsf2
 |=============================================================================
 
-GREATER =  1
-LESS    = -1
-EQUAL   =  0
+| The comments above about __eqdf2, et. al., also apply to __eqsf2,
+| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
+
+	FUNC(__gtsf2)
+	.globl	SYM (__gtsf2)
+SYM (__gtsf2):
+	FUNC(__gesf2)
+	.globl	SYM (__gesf2)
+SYM (__gesf2):
+	lea	LESS,a0
+	jbra	SYM (__cmpsf2_internal)
+
+SYM (__cmpsf2):
+	FUNC(__eqsf2)
+	.globl	SYM (__eqsf2)
+SYM (__eqsf2):
+	FUNC(__nesf2)
+	.globl	SYM (__nesf2)
+SYM (__nesf2):
+	FUNC(__ltsf2)
+	.globl	SYM (__ltsf2)
+SYM (__ltsf2):
+	FUNC(__lesf2)
+	.globl	SYM (__lesf2)
+SYM (__lesf2):
+
+| int __cmpsf2(float, float);
+	FUNC(__cmpsf2)
+	lea	GREATER,a0
 
 | int __cmpsf2_internal(float, float, int);
 SYM (__cmpsf2_internal):
-#ifndef __mcoldfire__
-	link	a6,IMM (0)
-	moveml	d2-d7,sp@- 	| save registers
-#else
-	link	a6,IMM (-24)
-	moveml	d2-d7,sp@
-#endif
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
 	moveq	IMM (COMPARE),d5
+#ifndef __FASTCALL__
 	movel	a6@(8),d0	| get first operand
 	movel	a6@(12),d1	| get second operand
+#endif
 | Check if either is NaN, and in that case return garbage and signal
 | INVALID_OPERATION. Check also if either is zero, and clear the signs
 | if necessary.
@@ -3751,13 +3626,13 @@ SYM (__cmpsf2_internal):
 	andl	IMM (0x7fffffff),d0
 	beq	Lcmpsf$a$0
 	cmpl	IMM (0x7f800000),d0
-	bhi	Lcmpf$inop
+	bhi	Lcmpsf$inop
 Lcmpsf$1:
 	movel	d1,d7
 	andl	IMM (0x7fffffff),d1
 	beq	Lcmpsf$b$0
 	cmpl	IMM (0x7f800000),d1
-	bhi	Lcmpf$inop
+	bhi	Lcmpsf$inop
 Lcmpsf$2:
 | Check the signs
 	eorl	d6,d7
@@ -3786,66 +3661,43 @@ Lcmpsf$2:
 	bne	Lcmpsf$a$gt$b	| |b| < |a|
 | If we got here a == b.
 	movel	IMM (EQUAL),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
-#endif
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	unlk	a6
 	rts
 Lcmpsf$a$gt$b:
 	movel	IMM (GREATER),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 Lcmpsf$b$gt$a:
 	movel	IMM (LESS),d0
-#ifndef __mcoldfire__
-	moveml	sp@+,d2-d7 	| put back the registers
-#else
-	moveml	sp@,d2-d7
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
 	| XXX if frame pointer is ever removed, stack pointer must
 	| be adjusted here.
-#endif
 	unlk	a6
 	rts
 
-Lcmpsf$a$0:	
+Lcmpsf$a$0:
 	bclr	IMM (31),d6
 	bra	Lcmpsf$1
 Lcmpsf$b$0:
 	bclr	IMM (31),d7
 	bra	Lcmpsf$2
 
-Lcmpf$inop:
-	movl	a6@(16),d0
+Lcmpsf$inop:
+	movel	a0,d0
 	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 	moveq	IMM (SINGLE_FLOAT),d6
 	PICJUMP	$_exception_handler
 
-| int __cmpsf2(float, float);
-	FUNC(__cmpsf2)
-SYM (__cmpsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-
 |=============================================================================
 |                           rounding routines
 |=============================================================================
 
 | The rounding routines expect the number to be normalized in registers
-| d0-d1, with the exponent in register d2. They assume that the 
+| d0-d1, with the exponent in register d2. They assume that the
 | exponent is larger or equal to 1. They return a properly normalized number
 | if possible, and a denormalized number otherwise. The exponent is returned
 | in d2.
@@ -3858,8 +3710,8 @@ Lround$to$nearest:
 | Check for denormalized numbers:
 1:	btst	IMM (FLT_MANT_DIG),d0
 	bne	2f		| if set the number is normalized
-| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent 
-| is one (remember that a denormalized number corresponds to an 
+| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent
+| is one (remember that a denormalized number corresponds to an
 | exponent of -F_BIAS+1).
 #ifndef __mcoldfire__
 	cmpw	IMM (1),d2	| remember that the exponent is at least one
@@ -3878,24 +3730,24 @@ Lround$to$nearest:
 2:
 | Now round: we do it as follows: after the shifting we can write the
 | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
-| If delta < 1, do nothing. If delta > 1, add 1 to f. 
-| If delta == 1, we make sure the rounded number will be even (odd?) 
+| If delta < 1, do nothing. If delta > 1, add 1 to f.
+| If delta == 1, we make sure the rounded number will be even (odd?)
 | (after shifting).
 	btst	IMM (0),d0	| is delta < 1?
 	beq	2f		| if so, do not do anything
 	tstl	d1		| is delta == 1?
 	bne	1f		| if so round to even
-	movel	d0,d1		| 
+	movel	d0,d1		|
 	andl	IMM (2),d1	| bit 1 is the last significant bit
-	addl	d1,d0		| 
-	bra	2f		| 
-1:	movel	IMM (1),d1	| else add 1 
+	addl	d1,d0		|
+	bra	2f		|
+1:	movel	IMM (1),d1	| else add 1
 	addl	d1,d0		|
 | Shift right once (because we used bit #FLT_MANT_DIG!).
-2:	lsrl	IMM (1),d0		
+2:	lsrl	IMM (1),d0
 | Now check again bit #FLT_MANT_DIG (rounding could have produced a
 | 'fraction overflow' ...).
-	btst	IMM (FLT_MANT_DIG),d0	
+	btst	IMM (FLT_MANT_DIG),d0
 	beq	1f
 	lsrl	IMM (1),d0
 #ifndef __mcoldfire__
@@ -3904,7 +3756,7 @@ Lround$to$nearest:
 	addql	IMM (1),d2
 #endif
 1:
-| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we 
+| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we
 | have to put the exponent to zero and return a denormalized number.
 	btst	IMM (FLT_MANT_DIG-1),d0
 	beq	1f
@@ -3918,197 +3770,268 @@ Lround$to$minus:
 	jmp	a0@
 #endif /* L_float */
 
-| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
-| __ledf2, __ltdf2 to all return the same value as a direct call to
-| __cmpdf2 would.  In this implementation, each of these routines
-| simply calls __cmpdf2.  It would be more efficient to give the
-| __cmpdf2 routine several names, but separating them out will make it
-| easier to write efficient versions of these routines someday.
-| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
-| The other routines return 1.
+/* We do not need these routines for coldfire, as it has no extended
+   float format. */
+#if !defined (__mcoldfire__)
 
-#ifdef  L_eqdf2
-	.text
-	FUNC(__eqdf2)
-	.globl	SYM (__eqdf2)
-SYM (__eqdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_eqdf2 */
+#ifdef  L_long_double
 
-#ifdef  L_nedf2
-	.text
-	FUNC(__nedf2)
-	.globl	SYM (__nedf2)
-SYM (__nedf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_nedf2 */
+| A long double precision floating point number (long double) has the format:
+|
+| struct _long_double {
+|  unsigned int sign      : 1;  /* sign bit */
+|  unsigned int exponent  : 15; /* exponent, shifted by 16383 */
+|  unsigned int empty     : 16;
+|  unsigned int fraction  : 64; /* fraction */
+| } double;
+|
+| Thus sizeof(long double) = 12 (96 bits).
+|
+| All the routines are callable from C programs, and return the result
+| in the register pair d0-d1. They also preserve all registers except
+| d0-d1 and a0-a1.
 
-#ifdef  L_gtdf2
-	.text
-	FUNC(__gtdf2)
-	.globl	SYM (__gtdf2)
-SYM (__gtdf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gtdf2 */
+	.globl	SYM (_fpCCR)
+	.globl  $_exception_handler
 
-#ifdef  L_gedf2
-	.text
-	FUNC(__gedf2)
-	.globl	SYM (__gedf2)
-SYM (__gedf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gedf2 */
+QUIET_NaN      = 0xffffffff
+INFINITY       = 0x7fff0000
 
-#ifdef  L_ltdf2
-	.text
-	FUNC(__ltdf2)
-	.globl	SYM (__ltdf2)
-SYM (__ltdf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_ltdf2 */
+X_MAX_EXP      = 0x7fff
+X_BIAS         = 16383
+LDBL_MAX_EXP   = X_MAX_EXP - X_BIAS
+LDBL_MIN_EXP   = 1 - X_BIAS
+LDBL_MANT_DIG  = 64
 
-#ifdef  L_ledf2
-	.text
-	FUNC(__ledf2)
-	.globl	SYM (__ledf2)
-SYM (__ledf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(20),sp@-
-	movl	a6@(16),sp@-
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpdf2_internal)
-	unlk	a6
-	rts
-#endif /* L_ledf2 */
+| Entry points:
 
-| The comments above about __eqdf2, et. al., also apply to __eqsf2,
-| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
+	.globl SYM (__negxf2)
+	.globl SYM (__cmpxf2)
+| __addxf3, __subxf3, __mulxf3, and __divxf3 are implemented elsewhere
 
-#ifdef  L_eqsf2
 	.text
-	FUNC(__eqsf2)
-	.globl	SYM (__eqsf2)
-SYM (__eqsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_eqsf2 */
+	.even
 
-#ifdef  L_nesf2
-	.text
-	FUNC(__nesf2)
-	.globl	SYM (__nesf2)
-SYM (__nesf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_nesf2 */
+| These are common routines to return and signal exceptions.
 
-#ifdef  L_gtsf2
-	.text
-	FUNC(__gtsf2)
-	.globl	SYM (__gtsf2)
-SYM (__gtsf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gtsf2 */
+Lx$infty:
+Lx$overflow:
+| Return a properly signed INFINITY and set the exception flags
+	movel	IMM (INFINITY),d0
+	movel	IMM (0),d1
+	movel	IMM (0),d2
+	orl	d7,d0
+	movew	IMM (INEXACT_RESULT+OVERFLOW),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
 
-#ifdef  L_gesf2
-	.text
-	FUNC(__gesf2)
-	.globl	SYM (__gesf2)
-SYM (__gesf2):
-	link	a6,IMM (0)
-	pea	-1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
-	unlk	a6
-	rts
-#endif /* L_gesf2 */
+Lx$inop:
+| Return a quiet NaN and set the exception flags
+	movel	IMM (QUIET_NaN),d0
+	movel	d0,d1
+	movel	d0,d2
+	movew	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	moveq	IMM (LONG_FLOAT),d6
+	PICJUMP	$_exception_handler
 
-#ifdef  L_ltsf2
-	.text
-	FUNC(__ltsf2)
-	.globl	SYM (__ltsf2)
-SYM (__ltsf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
+|=============================================================================
+|                              __negxf2
+|=============================================================================
+
+| long double __negxf2(long double, long double);
+	FUNC(__negxf2)
+SYM (__negxf2):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	moveq	IMM (NEGATE),d5
+	moveml	a6@(8),d0-d2	| get number to negate in d0-d2
+	bchg	IMM (31),d0	| negate
+	movel	d0,d6		| make a positive copy (for the tests)
+	andl	IMM(0x7fff0000),d6	|
+	movel	d6,d4		| check for zero
+	orl	d1,d4		|
+	orl	d2,d4		|
+	beq	2f		| if zero (either sign) return +zero
+	cmpl	IMM (0x7fff0000),d6 | compare to +INFINITY
+	blt	1f		| if finite, return
+	tstl	d1		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	tstl	d2		| if fraction not zero is NaN
+	bne	Lx$inop		|
+	movel	d0,d7		| else get sign and return INFINITY
+	andl	IMM (0x80000000),d7
+	bra	Lx$infty
+1:	PICLEA	SYM (_fpCCR),a0
+	clrw	a0@
+	moveml	d0-d2,a1@
+	movel	a1,d0
+	moveml	sp@,d2-d7/a2-a5
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
 	unlk	a6
 	rts
-#endif /* L_ltsf2 */
+2:	bclr	IMM (31),d0
+	bra	1b
 
-#ifdef  L_lesf2
-	.text
-	FUNC(__lesf2)
-	.globl	SYM (__lesf2)
-SYM (__lesf2):
-	link	a6,IMM (0)
-	pea	1
-	movl	a6@(12),sp@-
-	movl	a6@(8),sp@-
-	PICCALL	SYM (__cmpsf2_internal)
+|=============================================================================
+|                              __cmpxf2
+|=============================================================================
+
+GREATER =  1
+LESS    = -1
+EQUAL   =  0
+
+| The comments above about __eqdf2, et. al., also apply to __eqxf2,
+| et. al., except that the latter call __cmpxf2 rather than __cmpdf2.
+
+	FUNC(__gtxf2)
+	.globl	SYM (__gtxf2)
+SYM (__gtxf2):
+	FUNC(__gexf2)
+	.globl	SYM (__gexf2)
+SYM (__gexf2):
+	lea LESS,a0
+	jbra SYM(__cmpxf2_internal)
+
+	FUNC(__eqxf2)
+	.globl	SYM (__eqxf2)
+SYM (__eqxf2):
+	FUNC(__nexf2)
+	.globl	SYM (__nexf2)
+SYM (__nexf2):
+	FUNC(__ltxf2)
+	.globl	SYM (__ltxf2)
+SYM (__ltxf2):
+	FUNC(__lexf2)
+	.globl	SYM (__lexf2)
+SYM (__lexf2):
+
+| int __cmpxf2(long double, long double);
+	FUNC(__cmpxf2)
+SYM (__cmpxf2):
+	lea	GREATER,a0
+
+| int __cmpxf2_internal(long double, long double, int);
+SYM (__cmpxf2_internal):
+	link	a6,IMM (-40)	| everything will be done in registers
+	moveml	d2-d7/a2-a5,sp@	| save all data registers and a2-a5 (but d0-d1)
+	movel	a6@(8),d0	| get first operand
+	movel	a6@(12),d1	|
+	movel	a6@(16),a2
+	movel	a6@(20),d2	| get second operand
+	movel	a6@(24),d3	|
+	movel	a6@(28),a3
+| First check if a and/or b are (+/-) zero and in that case clear
+| the sign bit.
+	movel	d0,d6		| copy signs into d6 (a) and d7(b)
+	andl	IMM (0x7fff0000),d0	| and clear signs in d0 and d2
+	movel	d2,d7		|
+	andl	IMM (0x7fff0000),d2
+	cmpl	IMM (0x7fff0000),d0 | check for a == NaN
+	beq	Lcmpxf$a$nf	| if equal can be INFINITY, so check d1
+	movel	a2,d4		| copy into d4 to test for zero
+	orl	d0,d4		|
+	orl	d1,d4		|
+	beq	Lcmpxf$a$0	|
+Lcmpxf$0:
+	cmpl	IMM (0x7fff0000),d2 | check for b == NaN
+	bhi	Lcmpxf$inop		| if d2 > 0x7ff00000, b is NaN
+	beq	Lcmpxf$b$nf	| if equal can be INFINITY, so check d3
+	movel	a3,d4		|
+	orl	d2,d4		|
+	orl	d3,d4		|
+	beq	Lcmpxf$b$0	|
+Lcmpxf$1:
+| Check the signs
+	eorl	d6,d7
+	bpl	1f
+| If the signs are not equal check if a >= 0
+	tstl	d6
+	bpl	Lcmpxf$a$gt$b	| if (a >= 0 && b < 0) => a > b
+	bmi	Lcmpxf$b$gt$a	| if (a < 0 && b >= 0) => a < b
+1:
+| If the signs are equal check for < 0
+	tstl	d6
+	bpl	1f
+| If both are negative exchange them
+#ifndef __mcoldfire__
+	exg	d0,d2
+	exg	d1,d3
+	exg	a2,a3
+#else
+	movel	d0,d7
+	movel	d2,d0
+	movel	d7,d2
+	movel	d1,d7
+	movel	d3,d1
+	movel	d7,d3
+	movel	a2,d7
+	movel	a3,a2
+	movel	d7,a3
+#endif
+1:
+| Now that they are positive we just compare them as longs (does this also
+| work for denormalized numbers?).
+	cmpl	d0,d2
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d0 == d2, so we compare d1 and d3.
+	cmpl	d1,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here d1 == d3, so we compare a2 and a3.
+	movel	a3,d3
+	cmpl	a2,d3
+	bhi	Lcmpxf$b$gt$a	| |b| > |a|
+	bne	Lcmpxf$a$gt$b	| |b| < |a|
+| If we got here a == b.
+	movel	IMM (EQUAL),d0
+	bra 1f
+Lcmpxf$a$gt$b:
+	movel	IMM (GREATER),d0
+	bra 1f
+Lcmpxf$b$gt$a:
+	movel	IMM (LESS),d0
+1:
+	moveml	sp@,d2-d7/a2-a5 	| put back the registers
+	| XXX if frame pointer is ever removed, stack pointer must
+	| be adjusted here.
 	unlk	a6
 	rts
-#endif /* L_lesf2 */
+
+Lcmpxf$a$0:
+	bclr	IMM (31),d6
+	bra	Lcmpxf$0
+Lcmpxf$b$0:
+	bclr	IMM (31),d7
+	bra	Lcmpxf$1
+
+Lcmpxf$a$nf:
+	tstl	d1
+	bne	Lcmpxf$inop
+	movel a2,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$0
+
+Lcmpxf$b$nf:
+	tstl	d3
+	bne	Lcmpxf$inop
+	movel a3,d4
+	bne	Lcmpxf$inop
+	bra	Lcmpxf$1
+
+Lcmpxf$inop:
+	movel	a0,d0
+	moveq	IMM (COMPARE),d5
+	moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
+	| this functions returns an int, not a long double
+	moveq	IMM (LONG_FLOAT+1),d6
+	PICJUMP	$_exception_handler
+
+#endif /* _long_double */
+
+#endif /* __mcoldfire__ */
+
 
 #if defined (__ELF__) && defined (__linux__)
 	/* Make stack non-executable for ELF linux targets.  */
diff --git a/gcc/config/m68k/linux.h b/gcc/config/m68k/linux.h
index 82417b477bd..672a194b033 100644
--- a/gcc/config/m68k/linux.h
+++ b/gcc/config/m68k/linux.h
@@ -171,7 +171,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)					\
-  m68k_function_value (VALTYPE, FUNC)
+  m68k_function_value (VALTYPE, FUNC, true)
 
 /* Define how to find the value returned by a library function
    assuming the value has mode MODE.
diff --git a/gcc/config/m68k/m68k-protos.h b/gcc/config/m68k/m68k-protos.h
index ad02026309a..033bf7ea08e 100644
--- a/gcc/config/m68k/m68k-protos.h
+++ b/gcc/config/m68k/m68k-protos.h
@@ -63,7 +63,7 @@ extern rtx m68k_legitimize_tls_address (rtx);
 extern bool m68k_tls_reference_p (rtx, bool);
 extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);
 extern rtx m68k_libcall_value (enum machine_mode);
-extern rtx m68k_function_value (const_tree, const_tree);
+extern rtx m68k_function_value (const_tree, const_tree, bool);
 extern int emit_move_sequence (rtx *, enum machine_mode, rtx);
 extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);
 extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);
@@ -100,3 +100,15 @@ extern void init_68881_table (void);
 extern rtx m68k_legitimize_call_address (rtx);
 extern rtx m68k_legitimize_sibcall_address (rtx);
 extern int m68k_hard_regno_rename_ok(unsigned int, unsigned int);
+
+#ifdef RTX_CODE
+#ifdef TREE_CODE
+void m68k_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);
+void m68k_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);
+rtx m68k_function_arg (CUMULATIVE_ARGS *, enum machine_mode, const_tree, bool);
+#endif
+#endif
+void m68k_order_regs_for_local_alloc(void);
+void m68k_call_abi_override (const_tree);
+enum calling_abi m68k_function_type_abi (const_tree);
+enum calling_abi m68k_cfun_abi (void);
diff --git a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
index e5bd0119a02..35641ab9a23 100644
--- a/gcc/config/m68k/m68k.c
+++ b/gcc/config/m68k/m68k.c
@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "recog.h"
 #include "diagnostic-core.h"
 #include "expr.h"
+#include "toplev.h"
 #include "reload.h"
 #include "tm_p.h"
 #include "target.h"
@@ -132,6 +133,7 @@ static void m68k_sched_dfa_post_advance_cycle (void);
 static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);
 
 static bool m68k_can_eliminate (const int, const int);
+static void m68k_set_current_function (tree);
 static void m68k_conditional_register_usage (void);
 static bool m68k_legitimate_address_p (enum machine_mode, rtx, bool);
 static bool m68k_handle_option (size_t, const char *, int);
@@ -145,6 +147,8 @@ static rtx m68k_struct_value_rtx (tree, int);
 static tree m68k_handle_fndecl_attribute (tree *node, tree name,
 					  tree args, int flags,
 					  bool *no_add_attrs);
+static tree m68k_handle_type_attribute (tree *, tree, tree, int, bool *);
+static int m68k_comp_type_attributes (const_tree, const_tree);
 static void m68k_compute_frame_layout (void);
 static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);
 static bool m68k_ok_for_sibcall_p (tree, tree);
@@ -158,10 +162,7 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static void m68k_trampoline_init (rtx, tree, rtx);
 static int m68k_return_pops_args (tree, tree, int);
 static rtx m68k_delegitimize_address (rtx);
-static void m68k_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,
-				       const_tree, bool);
-static rtx m68k_function_arg (CUMULATIVE_ARGS *, enum machine_mode,
-			      const_tree, bool);
+static void m68k_maybe_switch_abi (void);
 
 
 /* Specify the identification number of the library being built */
@@ -282,6 +283,12 @@ const char *m68k_library_id_string = "_current_shared_library_a5_offset_";
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE m68k_can_eliminate
 
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION m68k_set_current_function
+
+#undef TARGET_EXPAND_TO_RTL_HOOK
+#define TARGET_EXPAND_TO_RTL_HOOK m68k_maybe_switch_abi
+
 #undef TARGET_CONDITIONAL_REGISTER_USAGE
 #define TARGET_CONDITIONAL_REGISTER_USAGE m68k_conditional_register_usage
 
@@ -306,9 +313,21 @@ static const struct attribute_spec m68k_attribute_table[] =
   { "interrupt", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },
   { "interrupt_handler", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },
   { "interrupt_thread", 0, 0, true,  false, false, m68k_handle_fndecl_attribute },
+
+ /* cdecl attribute specifies to pass arguments on the stack */
+  { "cdecl",             0, 0, false, true,  true,  m68k_handle_type_attribute },
+  /* Regparm attribute specifies how many integer arguments are to be
+     passed in registers.  */
+  { "regparm",           0, 1, false, true,  true,  m68k_handle_type_attribute },
+  /* Fastcall attribute says callee is responsible for popping arguments
+   if they are not variable.  */
+  { "fastcall",          0, 0, false, true,  true,  m68k_handle_type_attribute },
   { NULL,                0, 0, false, false, false, NULL }
 };
 
+#undef TARGET_COMP_TYPE_ATTRIBUTES
+#define TARGET_COMP_TYPE_ATTRIBUTES m68k_comp_type_attributes
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Base flags for 68k ISAs.  */
@@ -442,6 +461,9 @@ unsigned int m68k_cpu_flags;
 /* The set of FL_* flags that apply to the processor to be tuned for.  */
 unsigned int m68k_tune_flags;
 
+/* The abi used by target.  */
+enum calling_abi m68k_abi;
+
 /* Asm templates for calling or jumping to an arbitrary symbolic address,
    or NULL if such calls or jumps are not supported.  The address is held
    in operand 0.  */
@@ -560,10 +582,27 @@ m68k_handle_option (size_t code, const char *arg, int value)
     }
 }
 
-/* Implement TARGET_OPTION_OVERRIDE.  */
+/* Clear stack slot assignments remembered from previous functions.
+   This is called from INIT_EXPANDERS once before RTL is emitted for each
+   function.  */
+
+static struct machine_function *
+m68k_init_machine_status (void)
+{
+  struct machine_function *f;
+
+  f = ggc_alloc_cleared_machine_function ();
+  f->call_abi = m68k_abi;
+
+  return f;
+}
+
+/* Override various settings based on options.  If MAIN_ARGS_P, the
+   options are from the command line, otherwise they are from
+   attributes.  */
 
 static void
-m68k_option_override (void)
+m68k_option_override_internal (bool main_args_p)
 {
   const struct m68k_target_selection *entry;
   unsigned long target_mask;
@@ -599,7 +638,8 @@ m68k_option_override (void)
     entry = all_devices + TARGET_CPU_DEFAULT;
 
   m68k_cpu_flags = entry->flags;
-
+  m68k_abi = TARGET_FASTCALL ? FASTCALL_ABI : STD_ABI;
+  
   /* Use the architecture setting to derive default values for
      certain flags.  */
   target_mask = 0;
@@ -628,7 +668,7 @@ m68k_option_override (void)
     {
       enum target_device dev;
       dev = all_microarchs[M68K_DEFAULT_TUNE].device;
-      m68k_tune_flags = all_devices[dev]->flags;
+      m68k_tune_flags = all_devices[dev].flags;
     }
 #endif
   else
@@ -758,8 +798,27 @@ m68k_option_override (void)
       else
 	m68k_sched_mac = MAC_NO;
     }
+
+  if (optimize >= 1 && !global_options_set.x_flag_omit_frame_pointer)
+    flag_omit_frame_pointer = optimize_size;
+
+  init_machine_status = m68k_init_machine_status;
+
+  /* Save the initial options in case the user does function specific options */
+  if (main_args_p)
+    target_option_default_node = target_option_current_node
+      = build_target_option_node ();
+}
+
+/* Implement the TARGET_OPTION_OVERRIDE hook.  */
+
+static void
+m68k_option_override (void)
+{
+  m68k_option_override_internal (true);
 }
 
+
 /* Implement TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE.  */
 
 static void
@@ -855,6 +914,280 @@ m68k_handle_fndecl_attribute (tree *node, tree name,
   return NULL_TREE;
 }
 
+/* Handle a "regparm" or "cdecl" attribute;
+   arguments as in struct attribute_spec.handler.  */
+
+static void
+m68k_validate_mutually_exclusive_attribute (const char *attr1, const char *attr2, tree *node, tree name ATTRIBUTE_UNUSED)
+{
+  if (lookup_attribute (attr2, TYPE_ATTRIBUTES(*node)))
+    error ("%s and %s attributes are mutually exclusive", attr1, attr2);
+}
+
+static tree
+m68k_handle_type_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,
+        		    int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_TYPE ||
+      TREE_CODE (*node) == METHOD_TYPE ||
+      TREE_CODE (*node) == FIELD_DECL ||
+      TREE_CODE (*node) == TYPE_DECL)
+    {
+      if (is_attribute_p ("cdecl", name))
+        {
+          m68k_validate_mutually_exclusive_attribute ("cdecl", "fastcall", node, name);
+          m68k_validate_mutually_exclusive_attribute ("cdecl", "regparm", node, name);
+        }
+      else if (is_attribute_p ("fastcall", name))
+        {
+          m68k_validate_mutually_exclusive_attribute ("fastcall", "cdecl", node, name);
+          m68k_validate_mutually_exclusive_attribute ("fastcall", "regparm", node, name);
+        }
+      else if (is_attribute_p ("regparm", name))
+        {
+          m68k_validate_mutually_exclusive_attribute ("regparm", "cdecl", node, name);
+          m68k_validate_mutually_exclusive_attribute ("regparm", "fastcall", node, name);
+        }
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+               name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,
+   one if they are compatible, and two if they are nearly compatible
+   (which causes a warning to be generated). */
+
+static int
+m68k_comp_exclusive_type_attributes(const char *name1, const char *name2, const_tree type1, const_tree type2)
+{
+	return (!! lookup_attribute (name1, TYPE_ATTRIBUTES (type1)) !=
+            !! lookup_attribute (name1, TYPE_ATTRIBUTES (type2))
+         || !! lookup_attribute (name2, TYPE_ATTRIBUTES (type1)) !=
+            !! lookup_attribute (name2, TYPE_ATTRIBUTES (type2)));
+}
+
+static int
+m68k_comp_type_attributes (const_tree type1, const_tree type2)
+{
+  /* Functions or methods are incompatible if they specify mutually
+     exclusive ways of passing arguments.  */
+  if (TREE_CODE (type1) == FUNCTION_TYPE || TREE_CODE (type1) == METHOD_TYPE)
+    {
+      tree arg1, arg2;
+      if (m68k_comp_exclusive_type_attributes ("cdecl", "regparm", type1, type2)
+	   || m68k_comp_exclusive_type_attributes ("cdecl", "fastcall", type1, type2)
+	   || m68k_comp_exclusive_type_attributes ("regparm", "fastcall", type1, type2))
+        return 0; /* 'regparm' and 'cdecl' are mutually exclusive.  */
+
+      arg1 = lookup_attribute ("regparm", TYPE_ATTRIBUTES (type1));
+      arg2 = lookup_attribute ("regparm", TYPE_ATTRIBUTES (type2));
+      if (arg1 && arg2)
+        {
+          int num1 = 0, num2 = 0;
+          if (TREE_VALUE (arg1) && TREE_CODE (TREE_VALUE (arg1)) == TREE_LIST)
+            {
+              tree numofregs = TREE_VALUE (TREE_VALUE (arg1));
+              if (numofregs)
+        	num1 = TREE_INT_CST_LOW (numofregs);
+            }
+          if (TREE_VALUE (arg2) && TREE_CODE (TREE_VALUE (arg2)) == TREE_LIST)
+            {
+              tree numofregs = TREE_VALUE (TREE_VALUE (arg2));
+              if (numofregs)
+        	num2 = TREE_INT_CST_LOW (numofregs);
+            }
+          if (num1 != num2)
+            return 0; /* Different numbers, or no number in one type.  */
+        }
+    }
+  return 1;
+}
+
+
+/* Implementation of call abi switching target hook. Specific to FNDECL
+   the specific call register sets are set.  See also
+   ix86_conditional_register_usage for more details.  */
+void
+m68k_call_abi_override (const_tree fndecl)
+{
+  if (fndecl == NULL_TREE)
+    cfun->machine->call_abi = m68k_abi;
+  else
+    cfun->machine->call_abi = m68k_function_type_abi (TREE_TYPE (fndecl));
+}
+
+static enum calling_abi
+m68k_function_abi (const_tree fndecl)
+{
+  if (! fndecl)
+    return m68k_abi;
+  return m68k_function_type_abi (TREE_TYPE (fndecl));
+}
+
+/* Returns value STD_ABI, FASTCALL_ABI dependent on cfun, specifying the
+   call abi used.  */
+enum calling_abi
+m68k_cfun_abi (void)
+{
+  if (! cfun)
+    return m68k_abi;
+  return cfun->machine->call_abi;
+}
+
+/* Returns value STD_ABI, FASTCALL_ABI dependent on fntype, specifying the
+   call abi used.  */
+enum calling_abi
+m68k_function_type_abi (const_tree fntype)
+{
+  if (fntype != NULL)
+    {
+      enum calling_abi abi = m68k_abi;
+      if (abi == STD_ABI)
+	{
+	  if (lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fntype)))
+	    abi = FASTCALL_ABI;
+	}
+      else if (lookup_attribute ("cdecl", TYPE_ATTRIBUTES (fntype)))
+	abi = STD_ABI;
+      return abi;
+    }
+  return m68k_abi;
+}
+
+/* STD and FASTCALL ABI have different set of call used registers.  Avoid expensive
+   re-initialization of init_regs each time we switch function context since
+   this is needed only during RTL expansion.  */
+static void
+m68k_maybe_switch_abi (void)
+{
+  if ((call_used_regs[D2_REG] != 0) == (cfun->machine->call_abi == STD_ABI))
+    reinit_regs ();
+}
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+void
+m68k_init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */
+		      tree fntype,	/* tree ptr for function decl */
+		      rtx libname,	/* SYMBOL_REF of library name or 0 */
+		      tree fndecl,
+		      int caller ATTRIBUTE_UNUSED)
+{
+  cum->last_arg_reg = -1;
+  cum->last_arg_len = 0;
+  CLEAR_HARD_REG_SET(cum->regs_already_used);
+  
+  if (libname)
+    {
+      cum->call_abi = m68k_abi;
+    }
+  else if (fndecl)
+    {
+      cum->call_abi = m68k_function_abi (fndecl);
+    }
+  else
+    {
+      cum->call_abi = m68k_function_type_abi (fntype);
+    }
+
+#if ! defined (PCC_STATIC_STRUCT_RETURN) && defined (M68K_STRUCT_VALUE_REGNUM)
+  /* If return value is a structure, and we pass the buffer address in a
+     register, we can't use this register for our own purposes.
+     FIXME: Something similar would be useful for static chain.  */
+  if (fntype && aggregate_value_p (TREE_TYPE (fntype), fntype))
+    SET_HARD_REG_BIT(cum->regs_already_used, M68K_STRUCT_VALUE_REGNUM);
+#endif
+}
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.  */
+
+rtx m68k_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,
+                              const_tree type, bool named)
+{
+  if (cum->call_abi == FASTCALL_ABI)
+    {
+      int regbegin = -1, regend, len;
+      
+      /* FIXME: The last condition below is a workaround for a bug.  */
+      if (!TARGET_68881 && FLOAT_MODE_P (mode) && GET_MODE_UNIT_SIZE (mode) <= 4 &&
+          (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+        {
+            regbegin = D0_REG; /* Dx */
+            regend = regbegin + M68K_FASTCALL_DATA_PARM;
+            len = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
+        }
+      else if (TARGET_68881 && FLOAT_MODE_P (mode) &&
+          GET_MODE_UNIT_SIZE (mode) <= 12 &&
+          (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+        {
+          regbegin = FP0_REG; /* FPx */
+          regend = regbegin + M68K_FASTCALL_DATA_PARM;
+          len = GET_MODE_NUNITS (mode);
+        }
+      /* FIXME: Two last conditions below are workarounds for bugs.  */
+      else if (INTEGRAL_MODE_P (mode) && mode != CQImode && mode != CHImode)
+        {
+          len = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
+          if (len == 1)
+            {
+              if (type && POINTER_TYPE_P (type))  /* THIS */
+                {
+                  regbegin = A0_REG; /* Ax */
+                  regend = regbegin + M68K_FASTCALL_ADDR_PARM;
+                }
+              else
+                {
+                  regbegin = D0_REG; /* Dx */
+                  regend = regbegin + M68K_FASTCALL_DATA_PARM;
+                }
+            }
+        }
+
+      if (regbegin != -1)
+        {
+          int reg;
+          for (reg = regbegin; reg < regend; reg++)
+            {
+              if (!TEST_HARD_REG_BIT(cum->regs_already_used, reg) &&
+                  (reg + len <= regend))
+                {
+                  cum->last_arg_reg = reg;
+                  cum->last_arg_len = len;
+                  break;
+                }
+             }
+         }
+        
+      if (!named)
+        SET_HARD_REG_SET(cum->regs_already_used);
+
+      if (cum->last_arg_reg != -1)
+        {
+          return gen_rtx_REG (mode, cum->last_arg_reg);
+        }
+    }
+  return NULL_RTX;
+}
+
+
+
 static void
 m68k_compute_frame_layout (void)
 {
@@ -1464,12 +1797,27 @@ static bool
 m68k_ok_for_sibcall_p (tree decl, tree exp)
 {
   enum m68k_function_kind kind;
+  tree type, decl_or_type;
   
   /* We cannot use sibcalls for nested functions because we use the
      static chain register for indirect calls.  */
   if (CALL_EXPR_STATIC_CHAIN (exp))
     return false;
 
+  if (decl)
+    {
+      decl_or_type = decl;
+      type = TREE_TYPE (decl);
+    }
+  else
+    {
+      /* We're looking at the CALL_EXPR, we need the type of the function.  */
+      type = CALL_EXPR_FN (exp);		/* pointer expression */
+      type = TREE_TYPE (type);			/* pointer type */
+      type = TREE_TYPE (type);			/* function type */
+      decl_or_type = type;
+    }
+
   if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))
     {
       /* Check that the return value locations are the same.  For
@@ -1490,6 +1838,18 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
 	return false;
     }
 
+  /* The FASTCALL ABI has more call-clobbered registers;
+      disallow sibcalls from FASTCALL to STD.  */
+  if (cfun->machine->call_abi == FASTCALL_ABI
+      && m68k_function_type_abi (type) == STD_ABI)
+      return false;
+
+  /* FIXME: currently does not work at all for FASTCALL, because the
+     A2 register for the call will be restored in the epilogue
+     befor being used */
+  if (cfun->machine->call_abi == FASTCALL_ABI)
+      return false;
+
   kind = m68k_get_function_kind (current_function_decl);
   if (kind == m68k_fk_normal_function)
     /* We can always sibcall from a normal function, because it's
@@ -1504,24 +1864,19 @@ m68k_ok_for_sibcall_p (tree decl, tree exp)
   return false;
 }
 
-/* On the m68k all args are always pushed.  */
-
-static rtx
-m68k_function_arg (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,
-		   enum machine_mode mode ATTRIBUTE_UNUSED,
-		   const_tree type ATTRIBUTE_UNUSED,
-		   bool named ATTRIBUTE_UNUSED)
-{
-  return NULL_RTX;
-}
-
-static void
-m68k_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,
-			   const_tree type, bool named ATTRIBUTE_UNUSED)
+void
+m68k_function_arg_advance (CUMULATIVE_ARGS *cum,
+    enum machine_mode mode ATTRIBUTE_UNUSED,
+    const_tree type ATTRIBUTE_UNUSED,
+    bool named ATTRIBUTE_UNUSED)
 {
-  *cum += (mode != BLKmode
-	   ? (GET_MODE_SIZE (mode) + 3) & ~3
-	   : (int_size_in_bytes (type) + 3) & ~3);
+    if (cum->last_arg_reg != -1)
+      {
+	int count;
+	for (count = 0; count < cum->last_arg_len; count++)
+	    SET_HARD_REG_BIT(cum->regs_already_used, cum->last_arg_reg + count);
+	cum->last_arg_reg = -1;
+      }
 }
 
 /* Convert X to a legitimate function call memory reference and return the
@@ -5095,7 +5450,7 @@ output_call (rtx x)
   if (symbolic_operand (x, VOIDmode))
     return m68k_symbolic_call;
   else
-    return "jsr %a0";
+    return "jsr %a0"; /* note: will be replaced by STATIC_CHAIN_REGNUM in m68k_legitimize_sibcall_address */
 }
 
 /* Likewise sibling calls.  */
@@ -5106,7 +5461,7 @@ output_sibcall (rtx x)
   if (symbolic_operand (x, VOIDmode))
     return m68k_symbolic_jump;
   else
-    return "jmp %a0";
+    return "jmp %a0"; /* note: will be replaced by STATIC_CHAIN_REGNUM in m68k_legitimize_sibcall_address */
 }
 
 static void
@@ -5344,11 +5699,22 @@ m68k_libcall_value (enum machine_mode mode)
    NOTE: Due to differences in ABIs, don't call this function directly,
    use FUNCTION_VALUE instead.  */
 rtx
-m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
+m68k_function_value (const_tree valtype, const_tree fntype_or_decl, bool regs)
 {
-  enum machine_mode mode;
+  enum machine_mode mode = TYPE_MODE (valtype);
+  const_tree fn, fntype;
+  bool func_fastcall;
+  
+  fn = NULL_TREE;
+  if (fntype_or_decl && DECL_P (fntype_or_decl))
+    fn = fntype_or_decl;
+  fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;
+
+  func_fastcall = m68k_function_type_abi(fntype) == FASTCALL_ABI;
+
+  if (! regs && !func_fastcall)
+    return gen_rtx_REG (mode, D0_REG);
 
-  mode = TYPE_MODE (valtype);
   switch (mode) {
   case SFmode:
   case DFmode:
@@ -5361,7 +5727,7 @@ m68k_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)
   }
 
   /* If the function returns a pointer, push that into %a0.  */
-  if (func && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (func))))
+  if (regs && fntype && POINTER_TYPE_P (TREE_TYPE (fntype)) && !func_fastcall)
     /* For compatibility with the large body of existing code which
        does not always properly declare external functions returning
        pointer types, the m68k/SVR4 convention is to copy the value
@@ -6591,6 +6957,66 @@ m68k_return_pops_args (tree fundecl, tree funtype, int size)
 	  ? size : 0);
 }
 
+/* Remember the last target of m68k_set_current_function.  */
+static GTY(()) tree m68k_previous_fndecl;
+
+/* Establish appropriate back-end context for processing the function
+   FNDECL.  The argument might be NULL to indicate processing at top
+   level, outside of any function scope.  */
+static void
+m68k_set_current_function (tree fndecl)
+{
+  /* Only change the context if the function changes.  This hook is called
+     several times in the course of compiling a function, and we don't want to
+     slow things down too much or call target_reinit when it isn't safe.  */
+  if (fndecl && fndecl != m68k_previous_fndecl)
+    {
+      tree old_tree = (m68k_previous_fndecl
+		       ? DECL_FUNCTION_SPECIFIC_TARGET (m68k_previous_fndecl)
+		       : NULL_TREE);
+
+      tree new_tree = (fndecl
+		       ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
+		       : NULL_TREE);
+
+      m68k_previous_fndecl = fndecl;
+      if (old_tree == new_tree)
+	;
+
+      else if (new_tree)
+	{
+	  cl_target_option_restore (&global_options,
+				    TREE_TARGET_OPTION (new_tree));
+	  target_reinit ();
+	}
+
+      else if (old_tree)
+	{
+	  struct cl_target_option *def
+	    = TREE_TARGET_OPTION (target_option_current_node);
+
+	  cl_target_option_restore (&global_options, def);
+	  target_reinit ();
+	}
+    }
+}
+
+void
+m68k_order_regs_for_local_alloc (void)
+{
+  int i;
+  int pos = 0;
+  for (i = 0; i < 16; i ++)
+    if (call_used_regs [i] && !fixed_regs[i])
+      reg_alloc_order[pos++] = i;
+  for (i = 0; i < 16; i ++)
+    if (!(call_used_regs [i] && !fixed_regs[i]))
+      reg_alloc_order[pos++] = i;
+  reg_alloc_order[pos++] = 24;
+  for (i = 16; i < 24; i++)
+    reg_alloc_order[pos++] = i;
+}
+
 /* Make sure everything's fine if we *don't* have a given processor.
    This assumes that putting a register in fixed_regs will keep the
    compiler's mitts completely off it.  We don't bother to zero it out
@@ -6601,6 +7027,22 @@ m68k_conditional_register_usage (void)
 {
   int i;
   HARD_REG_SET x;
+  
+  int num_of_dregs = m68k_cfun_abi() == FASTCALL_ABI ? M68K_FASTCALL_USED_DATA_REGS : M68K_STD_USED_REGS;
+  int num_of_aregs = m68k_cfun_abi() == FASTCALL_ABI ? M68K_FASTCALL_USED_ADDR_REGS : M68K_STD_USED_REGS;
+  for (i = 0; i < 8; i++)
+    {
+      call_used_regs[i] = (i < num_of_dregs) | fixed_regs[i];
+      call_used_regs[i + 8] = (i < num_of_aregs) | fixed_regs[i + 8];
+      call_used_regs[i + 16] = (i < num_of_dregs) | fixed_regs[i + 16];
+    }
+  if (flag_pic)
+    fixed_regs[PIC_REG] = 1;
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    {
+       call_used_regs[i] |= fixed_regs[i];
+       call_really_used_regs[i] = call_used_regs[i];
+    }
   if (!TARGET_HARD_FLOAT)
     {
       COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);
@@ -6608,8 +7050,6 @@ m68k_conditional_register_usage (void)
         if (TEST_HARD_REG_BIT (x, i))
 	  fixed_regs[i] = call_used_regs[i] = 1;
     }
-  if (flag_pic)
-    fixed_regs[PIC_REG] = call_used_regs[PIC_REG] = 1;
 }
 
 #include "gt-m68k.h"
diff --git a/gcc/config/m68k/m68k.h b/gcc/config/m68k/m68k.h
index 71b7c4f273f..877e3335583 100644
--- a/gcc/config/m68k/m68k.h
+++ b/gcc/config/m68k/m68k.h
@@ -30,6 +30,19 @@ along with GCC; see the file COPYING3.  If not see
 # define TARGET_VERSION fprintf (stderr, " (68k, MIT syntax)")
 #endif
 
+/* Available call abi.  */
+enum calling_abi
+{
+  STD_ABI = 0,
+  FASTCALL_ABI = 1
+};
+
+/* The abi used by target.  */
+extern enum calling_abi m68k_abi;
+
+/* The default abi used by target.  */
+#define DEFAULT_ABI STD_ABI
+
 /* Handle --with-cpu default option from configure script.  */
 #define OPTION_DEFAULT_SPECS						\
   { "cpu",   "%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:\
@@ -138,8 +151,16 @@ along with GCC; see the file COPYING3.  If not see
 	}								\
 									\
       if (TARGET_68881)							\
-	builtin_define ("__HAVE_68881__");				\
+	{								\
+	  builtin_define ("__HAVE_68881__");				\
+	  builtin_define ("__M68881__"); /* Non-standard */		\
+	}								\
 									\
+      if (TARGET_FASTCALL)                                              \
+        {                                                               \
+      	  builtin_define ("__FASTCALL__"); /* Non-standard */		\
+        }                                                               \
+                                                                        \
       if (TARGET_COLDFIRE)						\
 	{								\
 	  const char *tmp;						\
@@ -304,7 +325,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #define UNITS_PER_WORD 4
 
-#define PARM_BOUNDARY (TARGET_SHORT ? 16 : 32)
+#define PARM_BOUNDARY ((TARGET_SHORT || (TARGET_FASTCALL && TUNE_68000_10)) ? 16 : 32)
 #define STACK_BOUNDARY 16
 #define FUNCTION_BOUNDARY 16
 #define EMPTY_FIELD_BOUNDARY 16
@@ -440,7 +461,7 @@ along with GCC; see the file COPYING3.  If not see
  */
 #define ARG_POINTER_REGNUM 24
 
-#define STATIC_CHAIN_REGNUM A0_REG
+#define STATIC_CHAIN_REGNUM (TARGET_FASTCALL ? A2_REG : A0_REG)
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a0"
 
 /* Register in which address to store a structure value
@@ -489,7 +510,7 @@ extern enum reg_class regno_reg_class[];
 /* On the m68k, this is the size of MODE in words,
    except in the FP regs, where a single reg is always enough.  */
 #define CLASS_MAX_NREGS(CLASS, MODE)	\
- ((CLASS) == FP_REGS ? 1 \
+ ((CLASS) == FP_REGS ? GET_MODE_NUNITS (MODE) \
   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
 
 /* Moves between fp regs and other regs are two insns.  */
@@ -514,30 +535,77 @@ extern enum reg_class regno_reg_class[];
 #define FIRST_PARM_OFFSET(FNDECL) 8
 
 /* On the m68k the return value defaults to D0.  */
+#undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)  \
-  gen_rtx_REG (TYPE_MODE (VALTYPE), D0_REG)
+  m68k_function_value (VALTYPE, FUNC, false)
 
 /* On the m68k the return value defaults to D0.  */
-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, D0_REG)
+#define LIBCALL_VALUE(MODE)  m68k_libcall_value (MODE)
 
 /* On the m68k, D0 is usually the only register used.  */
-#define FUNCTION_VALUE_REGNO_P(N) ((N) == D0_REG)
+#define FUNCTION_VALUE_REGNO_P(N) ((N) == D0_REG || (N) == A0_REG || (TARGET_68881 && (N) == FP0_REG))
 
 /* Define this to be true when FUNCTION_VALUE_REGNO_P is true for
    more than one register.
    XXX This macro is m68k specific and used only for m68kemb.h.  */
-#define NEEDS_UNTYPED_CALL 0
+#define NEEDS_UNTYPED_CALL 1
 
 /* On the m68k, all arguments are usually pushed on the stack.  */
-#define FUNCTION_ARG_REGNO_P(N) 0
+/* 1 if N is a possible register number for function argument passing.  */
+#define FUNCTION_ARG_REGNO_P(N)			\
+  ((((int)N) >= 0 && (N) < M68K_FASTCALL_DATA_PARM)		\
+   || ((N) >= 8 && (N) < 8 + M68K_FASTCALL_ADDR_PARM)	\
+   || (TARGET_68881 && (N) >= 16 && (N) < 16 + M68K_FASTCALL_DATA_PARM))
 
-/* On the m68k, this is a single integer, which is a number of bytes
-   of arguments scanned so far.  */
-#define CUMULATIVE_ARGS int
+   
+/* The number of data/float registers and address registers to use for
+   fast calls. */
+#define M68K_FASTCALL_DATA_PARM 3
+#define M68K_FASTCALL_ADDR_PARM 2
+
+/* Call clobbered regs. */
+#define M68K_STD_USED_REGS 2
+#define M68K_FASTCALL_USED_DATA_REGS 2
+#define M68K_FASTCALL_USED_ADDR_REGS 2
+
+/* On the m68k, this is a structure:
+   regs_already_used: bitmask of the already used registers.
+   last_arg_reg - register number of the most recently passed argument.
+     -1 if passed on stack.
+   last_arg_len - number of registers used by the most recently passed
+     argument.
+*/
+
+struct m68k_args
+{
+  unsigned long /* HARD_REG_SET */ regs_already_used;
+  int last_arg_reg;
+  int last_arg_len;
+  enum calling_abi call_abi;
+};
 
-/* On the m68k, the offset starts at 0.  */
-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
- ((CUM) = 0)
+#define CUMULATIVE_ARGS struct m68k_args
+
+/* The default number of data, address and float registers to use when
+   user specified '-mregparm' switch, not '-mregparm=<value>' option.  */
+
+#define ADJUST_REG_ALLOC_ORDER m68k_order_regs_for_local_alloc ()
+
+#define OVERRIDE_ABI_FORMAT(FNDECL) m68k_call_abi_override (FNDECL)
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  m68k_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL), (N_NAMED_ARGS) != -1)
+
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
+  (m68k_function_arg_advance (&(CUM), MODE, TYPE, NAMED))
+
+/* On m68k all args are pushed, except if -mfastcall then d0-2, a0-1 and
+   fp0-2 are used for passing the first arguments.
+   Note: by default, the static-chain is passed in a0. Targets that want
+   to make full use of '-mfastcall' are advised to pass the static-chain
+   somewhere else.  */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  (m68k_function_arg (&(CUM), (MODE), (TYPE), (NAMED)))
 
 #define FUNCTION_PROFILER(FILE, LABELNO)  \
   asm_fprintf (FILE, "\tlea %LLP%d,%Ra0\n\tjsr mcount\n", (LABELNO))
@@ -1032,3 +1100,11 @@ extern int m68k_sched_address_bypass_p (rtx, rtx);
 extern int m68k_sched_indexed_address_bypass_p (rtx, rtx);
 
 #define CPU_UNITS_QUERY 1
+
+#ifndef USED_FOR_TARGET
+struct GTY(()) machine_function {
+  /* This value is used for amd64 targets and specifies the current abi
+     to be used. STD_ABI means cdecl abi. Otherwise FASTCALL_ABI means fastcall abi.  */
+  ENUM_BITFIELD(calling_abi) call_abi : 8;
+};
+#endif
diff --git a/gcc/config/m68k/m68k.md b/gcc/config/m68k/m68k.md
index f89037f2e96..3118c1d01a1 100644
--- a/gcc/config/m68k/m68k.md
+++ b/gcc/config/m68k/m68k.md
@@ -129,8 +129,11 @@
 ;; Registers by name.
 (define_constants
   [(D0_REG		0)
+   (D1_REG		1)
+   (D2_REG		2)
    (A0_REG		8)
    (A1_REG		9)
+   (A2_REG		10)
    (PIC_REG		13)
    (A6_REG		14)
    (SP_REG		15)
@@ -1070,7 +1073,10 @@
 (define_insn ""
   [(set (match_operand:QI 0 "nonimmediate_operand" "=d,*a,m")
 	(match_operand:QI 1 "general_src_operand" "dmSi*a,di*a,dmSi"))]
-  "!TARGET_COLDFIRE"
+  "!TARGET_COLDFIRE
+   && (!MEM_P (operands[0])
+       || GET_CODE (XEXP (operands[0], 0)) != PRE_DEC
+       || XEXP (XEXP (operands[0], 0), 0) != stack_pointer_rtx)"
   "* return output_move_qimode (operands);")
 
 (define_insn ""
diff --git a/gcc/config/m68k/m68k.opt b/gcc/config/m68k/m68k.opt
index d5aa9fa7698..c04afa3c9a7 100644
--- a/gcc/config/m68k/m68k.opt
+++ b/gcc/config/m68k/m68k.opt
@@ -147,6 +147,10 @@ mnoshort
 Target RejectNegative InverseMask(SHORT)
 Consider type 'int' to be 32 bits wide
 
+mnofastcall
+Target RejectNegative InverseMask(FASTCALL)
+Use standard calling conventions. 
+
 mpcrel
 Target Report Mask(PCREL)
 Generate pc-relative code
@@ -167,6 +171,10 @@ mshort
 Target Report Mask(SHORT)
 Consider type 'int' to be 16 bits wide
 
+mfastcall
+Target Report Mask(FASTCALL)
+Use calling convention passing arguments in registers.
+
 msoft-float
 Target RejectNegative InverseMask(HARD_FLOAT)
 Generate code with library calls for floating point
diff --git a/gcc/config/m68k/m68kelf.h b/gcc/config/m68k/m68kelf.h
index d3fc41a4e49..9c76eeb57db 100644
--- a/gcc/config/m68k/m68kelf.h
+++ b/gcc/config/m68k/m68kelf.h
@@ -86,7 +86,7 @@ do {								\
    structure return, so have to use a1 for the static chain.  */
 
 #undef STATIC_CHAIN_REGNUM
-#define STATIC_CHAIN_REGNUM A1_REG
+#define STATIC_CHAIN_REGNUM (TARGET_FASTCALL ? A2_REG : A1_REG)
 #undef M68K_STATIC_CHAIN_REG_NAME
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a1"
 
diff --git a/gcc/config/m68k/math-68881.h b/gcc/config/m68k/math-68881.h
index 6d9f8b2d4a1..9fad2950508 100644
--- a/gcc/config/m68k/math-68881.h
+++ b/gcc/config/m68k/math-68881.h
@@ -44,6 +44,16 @@
 
 #include <errno.h>
 
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+#ifdef __cplusplus
+# define __MATH_68881_INLINE inline
+#elif defined __GNUC_STDC_INLINE__
+# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
+#else
+# define __MATH_68881_INLINE extern __inline
+#endif
+
 #undef HUGE_VAL
 #ifdef __sun__
 /* The Sun assembler fails to handle the hex constant in the usual defn.  */
@@ -64,7 +74,7 @@
 })
 #endif
 
-__inline extern double
+__MATH_68881_INLINE double
 sin (double x)
 {
   double value;
@@ -75,7 +85,7 @@ sin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cos (double x)
 {
   double value;
@@ -86,7 +96,7 @@ cos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tan (double x)
 {
   double value;
@@ -97,7 +107,7 @@ tan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 asin (double x)
 {
   double value;
@@ -108,7 +118,7 @@ asin (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 acos (double x)
 {
   double value;
@@ -119,7 +129,7 @@ acos (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan (double x)
 {
   double value;
@@ -130,7 +140,7 @@ atan (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan2 (double y, double x)
 {
   double pi, pi_over_2;
@@ -187,7 +197,7 @@ atan2 (double y, double x)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sinh (double x)
 {
   double value;
@@ -198,7 +208,7 @@ sinh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cosh (double x)
 {
   double value;
@@ -209,7 +219,7 @@ cosh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tanh (double x)
 {
   double value;
@@ -220,7 +230,7 @@ tanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atanh (double x)
 {
   double value;
@@ -231,7 +241,7 @@ atanh (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 exp (double x)
 {
   double value;
@@ -242,7 +252,7 @@ exp (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 expm1 (double x)
 {
   double value;
@@ -253,7 +263,7 @@ expm1 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log (double x)
 {
   double value;
@@ -264,7 +274,7 @@ log (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log1p (double x)
 {
   double value;
@@ -275,7 +285,7 @@ log1p (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log10 (double x)
 {
   double value;
@@ -286,7 +296,7 @@ log10 (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sqrt (double x)
 {
   double value;
@@ -297,13 +307,13 @@ sqrt (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 hypot (double x, double y)
 {
   return sqrt (x*x + y*y);
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 pow (double x, double y)
 {
   if (x > 0)
@@ -352,7 +362,7 @@ pow (double x, double y)
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fabs (double x)
 {
   double value;
@@ -363,7 +373,7 @@ fabs (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ceil (double x)
 {
   int rounding_mode, round_up;
@@ -385,7 +395,7 @@ ceil (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 floor (double x)
 {
   int rounding_mode, round_down;
@@ -408,7 +418,7 @@ floor (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 rint (double x)
 {
   int rounding_mode, round_nearest;
@@ -430,7 +440,7 @@ rint (double x)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fmod (double x, double y)
 {
   double value;
@@ -442,7 +452,7 @@ fmod (double x, double y)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 drem (double x, double y)
 {
   double value;
@@ -454,19 +464,20 @@ drem (double x, double y)
   return value;
 }
 
-__inline extern double
-scalb (double x, int n)
+__MATH_68881_INLINE double
+scalb (double x, double n)
 {
   double value;
+  int exp = (int)(n);
 
   __asm ("fscale%.l %2,%0"
 	 : "=f" (value)
 	 : "0" (x),
-	   "dmi" (n));
+	   "dmi" (exp));
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 logb (double x)
 {
   double exponent;
@@ -477,7 +488,7 @@ logb (double x)
   return exponent;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ldexp (double x, int n)
 {
   double value;
@@ -489,7 +500,7 @@ ldexp (double x, int n)
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 frexp (double x, int *exp)
 {
   double float_exponent;
@@ -514,7 +525,7 @@ frexp (double x, int *exp)
   return mantissa;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 modf (double x, double *ip)
 {
   double temp;
diff --git a/gcc/config/m68k/mint.h b/gcc/config/m68k/mint.h
new file mode 100644
index 00000000000..6d9844ba645
--- /dev/null
+++ b/gcc/config/m68k/mint.h
@@ -0,0 +1,177 @@
+/* Definitions of target machine for GNU compiler.
+   Atari ST TOS/MiNT.
+   Copyright (C) 1994, 1995, 2007, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Here are four prefixes that are used by asm_fprintf to
+   facilitate customization for alternate assembler syntaxes.
+   Machines with no likelihood of an alternate syntax need not
+   define these and need not use asm_fprintf.  */
+
+/* The prefix for register names.  Note that REGISTER_NAMES
+   is supposed to include this prefix. Also note that this is NOT an
+   fprintf format string, it is a literal string */
+
+#undef REGISTER_PREFIX
+#define REGISTER_PREFIX "%"
+
+/* The prefix for local (compiler generated) labels.
+   These labels will not appear in the symbol table.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "|"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE SHORT_TYPE_SIZE
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__MINT__");		\
+      builtin_define_std ("atarist");		\
+      builtin_assert ("machine=atari");		\
+      builtin_assert ("system=mint");		\
+    }						\
+  while (0)
+
+/* The following defines are nonstandard
+   and are kept only for compatibility
+   with older versions of GCC for MiNT.  */
+
+#undef CPP_SPEC
+#define CPP_SPEC			\
+  "%{m68000:-D__M68000__} "		\
+  "%{mc68020:-D__M68020__} "		\
+  "%{m68020:-D__M68020__} "		\
+  "%{m68030:-D__M68020__} "		\
+  "%{m68040:-D__M68020__} "		\
+  "%{m68060:-D__M68020__} "		\
+  "%{m68020-40:-D__M68020__} "		\
+  "%{m68020-60:-D__M68020__} "		\
+  "%{!m680*:%{!mc680*:-D__M68000__}} "	\
+  "%{mshort:-D__MSHORT__}"
+
+#define STARTFILE_SPEC	"%{pg|p|profile:gcrt0.o%s;:crt0.o%s}"
+#define LIB_SPEC	"-lc"
+#define LINKER_NAME	"collect2 %{v:-v}"
+
+/* Every structure or union's size must be a multiple of 2 bytes.  */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+/* The -g option generates stabs debug information.  */
+#define DBX_DEBUGGING_INFO 1
+
+/* This is the assembler directive to equate two values.  */
+#undef SET_ASM_OP
+#define SET_ASM_OP		"\t.set\t"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+#undef ASM_WEAKEN_LABEL
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* The system headers are C++-aware.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* By default, the vtable entries are void pointers, the so the alignment
+   is the same as pointer alignment.  The value of this macro specifies
+   the alignment of the vtable entry in bits.  It should be defined only
+   when special alignment is necessary.
+
+   MiNT: The default value of 32 is too much and unsupported by a.out-mintprg.
+*/
+#define TARGET_VTABLE_ENTRY_ALIGN 16
+
+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that
+   the rest of the DWARF 2 frame unwind support is also provided.
+   
+   MiNT: DWARF 2 frame unwind is not supported by a.out-mint.
+*/
+#define DWARF2_UNWIND_INFO 0
+
+/* config/m68k.md has an explicit reference to the program counter,
+   prefix this by the register prefix.  */
+
+#define ASM_RETURN_CASE_JUMP				\
+  do {							\
+    if (TARGET_COLDFIRE)				\
+      {							\
+	if (ADDRESS_REG_P (operands[0]))		\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else						\
+	  return "ext%.l %0\n\tjmp %%pc@(2,%0:l)";	\
+      }							\
+    else						\
+      return "jmp %%pc@(2,%0:w)";			\
+  } while (0)
+
+/* The ADDR_DIFF_VEC must exactly follow the previous instruction.  */
+
+#undef ADDR_VEC_ALIGN
+#define ADDR_VEC_ALIGN(ADDR_VEC) 0
+
+/* If defined, a C expression whose value is a string containing the
+   assembler operation to identify the following data as uninitialized global
+   data.  */
+
+#define BSS_SECTION_ASM_OP "\t.bss"
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* Disable -fpic and -fPIC since bsr.l _label@PLTPC
+   is unsupported by the assembler.  */
+
+#undef  SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (flag_pic && !TARGET_PCREL)					\
+      error ("-f%s is not supported on this target",			\
+	       (flag_pic > 1) ? "PIC" : "pic");				\
+} while (0)
+
+
+/* Workaround for GCC bug #35067 about multiple thunks.  */
+
+#undef MAKE_DECL_ONE_ONLY
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+/* Avoid requiring -static with -fmudflap like in config/bfin/uclinux.h */
+#define MFWRAP_SPEC " %{fmudflap|fmudflapth: \
+ --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\
+ --wrap=mmap --wrap=munmap --wrap=alloca\
+ %{fmudflapth: --wrap=pthread_create\
+}} %{fmudflap|fmudflapth: --wrap=main}"
diff --git a/gcc/config/m68k/mulxf3.c b/gcc/config/m68k/mulxf3.c
new file mode 100644
index 00000000000..4ca28c3a013
--- /dev/null
+++ b/gcc/config/m68k/mulxf3.c
@@ -0,0 +1,5 @@
+#ifndef __mcoldfire__
+
+#include "../soft-fp/mulxf3.c"
+
+#endif
diff --git a/gcc/config/m68k/netbsd-elf.h b/gcc/config/m68k/netbsd-elf.h
index 1238d26e766..356684d42fd 100644
--- a/gcc/config/m68k/netbsd-elf.h
+++ b/gcc/config/m68k/netbsd-elf.h
@@ -230,7 +230,7 @@ while (0)
    regnum.  Make it a1 instead.  */
 
 #undef STATIC_CHAIN_REGNUM
-#define STATIC_CHAIN_REGNUM A1_REG
+#define STATIC_CHAIN_REGNUM (TARGET_FASTCALL ? A2_REG : A1_REG)
 #undef M68K_STATIC_CHAIN_REG_NAME
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a1"
 
@@ -270,7 +270,7 @@ while (0)
 
 #undef FUNCTION_VALUE
 #define FUNCTION_VALUE(VALTYPE, FUNC)					\
-  m68k_function_value (VALTYPE, FUNC)
+  m68k_function_value (VALTYPE, FUNC, true)
 
 
 /* Define how to find the value returned by a library function
diff --git a/gcc/config/m68k/sfp-exceptions.c b/gcc/config/m68k/sfp-exceptions.c
new file mode 100644
index 00000000000..3bd77a70b7c
--- /dev/null
+++ b/gcc/config/m68k/sfp-exceptions.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2012-2023 Free Software Foundation, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 3, or (at your option) any
+ * later version.
+ * 
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * Under Section 7 of GPL version 3, you are granted additional
+ * permissions described in the GCC Runtime Library Exception, version
+ * 3.1, as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License and
+ * a copy of the GCC Runtime Library Exception along with this program;
+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _SOFT_FLOAT
+#include "sfp-machine.h"
+
+void
+__sfp_handle_exceptions (int _fex __attribute__ ((unused)))
+{
+  /* does nothing currently. The DFmode functions eventually do a trap #15 */
+}
+#endif
diff --git a/gcc/config/m68k/sfp-machine.h b/gcc/config/m68k/sfp-machine.h
new file mode 100644
index 00000000000..9376f62c74f
--- /dev/null
+++ b/gcc/config/m68k/sfp-machine.h
@@ -0,0 +1,193 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+/* The type of the result of a floating point comparison.  This must
+   match `__libgcc_cmp_return__' in GCC for the target.  */
+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));
+#define CMPtype __gcc_CMPtype
+
+#if 0 /* does not work, because all inputs/outputs must be in data registers */
+
+#define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\
+  __asm__ ("addl %11,%3\n\t"				\
+	   "addxl %9,%2\n\t"				\
+	   "addxl %7,%1\n\t"				\
+	   "addxl %5,%0"				\
+	   : "=d" ((USItype) (r3)),				\
+	     "=&d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "%0" ((USItype) (x3)),				\
+	     "g" ((USItype) (y3)),				\
+	     "%1" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "%2" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "%3" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_ADD_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\
+  __asm__ ("addl %8,%2\n\t"				\
+	   "addxl %6,%1\n\t"				\
+	   "addxl %4,%0"				\
+	   : "=d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "%0" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "%1" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "%2" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_SUB_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)	\
+  __asm__ ("subl %11,%3\n\t"				\
+	   "subxl %9,%2\n\t"				\
+	   "subxl %7,%1\n\t"				\
+	   "subxl %5,%0"				\
+	   : "=d" ((USItype) (r3)),				\
+	     "=&d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "0" ((USItype) (x3)),				\
+	     "g" ((USItype) (y3)),				\
+	     "1" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "2" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "3" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#define __FP_FRAC_SUB_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)		\
+  __asm__ ("subl %8,%2\n\t"				\
+	   "subxl %6,%1\n\t"				\
+	   "subxl %4,%0"				\
+	   : "=d" ((USItype) (r2)),				\
+	     "=&d" ((USItype) (r1)),				\
+	     "=&d" ((USItype) (r0))				\
+	   : "0" ((USItype) (x2)),				\
+	     "g" ((USItype) (y2)),				\
+	     "1" ((USItype) (x1)),				\
+	     "g" ((USItype) (y1)),				\
+	     "2" ((USItype) (x0)),				\
+	     "g" ((USItype) (y0)))
+#endif
+#define __FP_FRAC_ADDI_4(x3,x2,x1,x0,i)				\
+  do { \
+    long zero; \
+  	__asm__ ("moveq #0,%4\n\t" \
+       "addl %5,%3\n\t"				\
+	   "addxl %4,%2\n\t"				\
+	   "addxl %4,%1\n\t"				\
+	   "addxl %4,%0"				\
+	   : "+d" ((USItype) (x3)),				\
+	     "+&d" ((USItype) (x2)),				\
+	     "+&d" ((USItype) (x1)),				\
+	     "+&d" ((USItype) (x0)),				\
+	     "=d"(zero) \
+	   : "g" ((USItype) (i))); \
+	} while(0)
+
+#define _FP_MUL_MEAT_S(R,X,Y)	_FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)	_FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_E(R,X,Y)	_FP_MUL_MEAT_4_wide(_FP_WFRACBITS_E,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)	_FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_E(R,X,Y)   _FP_DIV_MEAT_4_udiv(E,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_H		_FP_QNANBIT_H
+#define _FP_NANFRAC_B		_FP_QNANBIT_B
+#define _FP_NANFRAC_S		_FP_QNANBIT_S
+#define _FP_NANFRAC_D		_FP_QNANBIT_D, 0
+/* Even if XFmode is 12byte,  we have to pad it to
+   16byte since soft-fp emulation is done in 16byte.  */
+#define _FP_NANFRAC_E		_FP_QNANBIT_E, 0, 0, 0
+#define _FP_NANFRAC_Q		_FP_QNANBIT_Q, 0, 0, 0
+
+#ifndef _SOFT_FLOAT
+#define FP_EX_SHIFT 0
+
+#define _FP_DECL_EX \
+  unsigned short _fcw __attribute__ ((unused)) = FP_RND_NEAREST;
+
+#define FP_RND_NEAREST		0
+#define FP_RND_ZERO		0x010
+#define FP_RND_PINF		0x020
+#define FP_RND_MINF		0x030
+
+#define FP_RND_MASK		0x030
+
+#define FP_INIT_ROUNDMODE
+
+#endif
+
+#define _FP_KEEPNANFRACP	1
+#define _FP_QNANNEGATEDP 0
+
+#define _FP_NANSIGN_H		0
+#define _FP_NANSIGN_B		0
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_E		0
+#define _FP_NANSIGN_Q		0
+
+/* Here is something Intel misdesigned: the specs don't define
+   the case where we have two NaNs with same mantissas, but
+   different sign. Different operations pick up different NaNs.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if (_FP_FRAC_GT_##wc(X, Y)					\
+	|| (_FP_FRAC_EQ_##wc(X,Y) && (OP == '+' || OP == '*')))	\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    else							\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#ifndef _SOFT_FLOAT
+/*
+ * these are arbitrary, but we choose
+ * the same values as co-processor would use
+ */
+#define FP_EX_INVALID		0x4000
+#define FP_EX_OVERFLOW		0x1000
+#define FP_EX_DIVZERO		0x0400
+#define FP_EX_UNDERFLOW		0x0800
+#define FP_EX_INEXACT		0x0200
+#define FP_EX_ALL \
+	(FP_EX_INVALID | FP_EX_DENORM | FP_EX_DIVZERO | FP_EX_OVERFLOW \
+	 | FP_EX_UNDERFLOW | FP_EX_INEXACT)
+
+void __sfp_handle_exceptions (int);
+
+#define FP_HANDLE_EXCEPTIONS			\
+  do {						\
+    if (__builtin_expect (_fex, 0))		\
+      __sfp_handle_exceptions (_fex);		\
+  } while (0)
+
+#define FP_TRAPPING_EXCEPTIONS ((_fcw >> FP_EX_SHIFT) & FP_EX_ALL)
+
+#define FP_ROUNDMODE		(_fcw & FP_RND_MASK)
+#endif
+
+#define _FP_TININESS_AFTER_ROUNDING 1
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+
+#define __BYTE_ORDER __BIG_ENDIAN
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
diff --git a/gcc/config/m68k/subxf3.c b/gcc/config/m68k/subxf3.c
new file mode 100644
index 00000000000..9e893287beb
--- /dev/null
+++ b/gcc/config/m68k/subxf3.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation.
+   Return a - b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+long double __subxf3 (long double x1, long double x2);
+long double __addxf3 (long double x1, long double x2);
+
+long double
+__subxf3 (long double a, long double b)
+{
+	(void)a;
+	__asm__ __volatile__(
+		"bchg #7,%0\n\t"
+		"jmp (%1)"
+	:
+	: "m"(b), "a"(__addxf3)
+	: "cc", "memory");
+	__builtin_unreachable();
+}
diff --git a/gcc/config/m68k/t-floatlib b/gcc/config/m68k/t-floatlib
index 2039d1d0dc4..03a16e7bd9f 100644
--- a/gcc/config/m68k/t-floatlib
+++ b/gcc/config/m68k/t-floatlib
@@ -18,14 +18,37 @@
 
 LIB1ASMSRC = m68k/lb1sf68.asm
 LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \
-   _double _float _floatex \
-   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \
-   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2
+	_double _long_double _float _floatex
 
-LIB2FUNCS_EXTRA = fpgnulib.c xfgnulib.c
+LIB2FUNCS_EXTRA = \
+	$(srcdir)/config/m68k/unordsf2.c \
+	$(srcdir)/config/m68k/unorddf2.c \
+	$(srcdir)/config/m68k/floatunsidf.c \
+	$(srcdir)/config/m68k/floatsidf.c \
+	$(srcdir)/config/m68k/floatunsisf.c \
+	$(srcdir)/config/m68k/floatsisf.c \
+	$(srcdir)/config/m68k/extendsfdf2.c \
+	$(srcdir)/config/m68k/truncdfsf2.c \
+	$(srcdir)/config/m68k/fixdfsi.c \
+	$(srcdir)/config/m68k/fixsfsi.c \
+	\
+	$(srcdir)/config/m68k/unordxf2.c \
+	$(srcdir)/config/m68k/extenddfxf2.c \
+	$(srcdir)/config/m68k/extendsfxf2.c \
+	$(srcdir)/config/m68k/truncxfdf2.c \
+	$(srcdir)/config/m68k/truncxfsf2.c \
+	$(srcdir)/config/m68k/floatsixf.c \
+	$(srcdir)/config/m68k/floatunsixf.c \
+	$(srcdir)/config/m68k/fixxfsi.c \
+	\
+	$(srcdir)/config/m68k/addxf3.c \
+	$(srcdir)/config/m68k/subxf3.c \
+	$(srcdir)/config/m68k/mulxf3.c \
+	$(srcdir)/config/m68k/divxf3.c \
+	$(srcdir)/config/m68k/sfp-exceptions.c \
+	$(empty)
 
-fpgnulib.c: $(srcdir)/config/m68k/fpgnulib.c
-	cp $(srcdir)/config/m68k/fpgnulib.c fpgnulib.c
-xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c
-	echo '#define EXTFLOAT' > xfgnulib.c
-	cat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c
+SFP_MACHINE := sfp-machine.h
+
+$(SFP_MACHINE): $(srcdir)/config/m68k/$(SFP_MACHINE)
+	cp $< $@
diff --git a/gcc/config/m68k/t-mint b/gcc/config/m68k/t-mint
new file mode 100644
index 00000000000..faac34970ba
--- /dev/null
+++ b/gcc/config/m68k/t-mint
@@ -0,0 +1,41 @@
+# 
+# Use multiple libraries
+# 
+
+MULTILIB_OPTIONS = m68020-60/mcpu=5475 mshort mfastcall
+
+MULTILIB_DIRNAMES = m68020-60 m5475 mshort mfastcall
+
+MULTILIB_MATCHES = \
+	m68020-60=m68881 \
+	m68020-60=m68020 \
+	m68020-60=m68020-40 \
+	m68020-60=mc68020 \
+	m68020-60=m68030 \
+	m68020-60=m68040 \
+	m68020-60=m68060 \
+	m68020-60=mcpu?68020 \
+	m68020-60=mcpu?68030 \
+	m68020-60=mcpu?68040 \
+	m68020-60=mcpu?68060 \
+	m68020-60=march?68020 \
+	m68020-60=march?68030 \
+	m68020-60=march?68040 \
+	m68020-60=march?68060 \
+	mcpu?5475=mcfv4e \
+	mcpu?5475=mcpu?5470 \
+	mcpu?5475=mcpu?5471 \
+	mcpu?5475=mcpu?5472 \
+	mcpu?5475=mcpu?5473 \
+	mcpu?5475=mcpu?5474 \
+	mcpu?5475=mcpu?547x \
+	mcpu?5475=mcpu?5480 \
+	mcpu?5475=mcpu?5481 \
+	mcpu?5475=mcpu?5482 \
+	mcpu?5475=mcpu?5483 \
+	mcpu?5475=mcpu?5484 \
+	mcpu?5475=mcpu?5485 \
+	mcpu?5475=mcpu?548x
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff --git a/gcc/config/m68k/truncdfsf2.c b/gcc/config/m68k/truncdfsf2.c
new file mode 100644
index 00000000000..75017b4f0a8
--- /dev/null
+++ b/gcc/config/m68k/truncdfsf2.c
@@ -0,0 +1,2 @@
+#define L_truncdfsf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/truncxfdf2.c b/gcc/config/m68k/truncxfdf2.c
new file mode 100644
index 00000000000..67db750e2d0
--- /dev/null
+++ b/gcc/config/m68k/truncxfdf2.c
@@ -0,0 +1,2 @@
+#define L_truncxfdf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/truncxfsf2.c b/gcc/config/m68k/truncxfsf2.c
new file mode 100644
index 00000000000..1320019a454
--- /dev/null
+++ b/gcc/config/m68k/truncxfsf2.c
@@ -0,0 +1,2 @@
+#define L_truncxfsf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/unorddf2.c b/gcc/config/m68k/unorddf2.c
new file mode 100644
index 00000000000..32f668b2aa7
--- /dev/null
+++ b/gcc/config/m68k/unorddf2.c
@@ -0,0 +1,2 @@
+#define L_unorddf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/unordsf2.c b/gcc/config/m68k/unordsf2.c
new file mode 100644
index 00000000000..0471d9a121e
--- /dev/null
+++ b/gcc/config/m68k/unordsf2.c
@@ -0,0 +1,2 @@
+#define L_unordsf2
+#include "fpgnulib.c"
diff --git a/gcc/config/m68k/unordxf2.c b/gcc/config/m68k/unordxf2.c
new file mode 100644
index 00000000000..a1c11bee483
--- /dev/null
+++ b/gcc/config/m68k/unordxf2.c
@@ -0,0 +1,2 @@
+#define L_unordxf2
+#include "fpgnulib.c"
diff --git a/gcc/config/soft-fp/addxf3.c b/gcc/config/soft-fp/addxf3.c
new file mode 100644
index 00000000000..b379dbe9392
--- /dev/null
+++ b/gcc/config/soft-fp/addxf3.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return a + b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__addxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+  FP_UNPACK_SEMIRAW_E (B, b);
+  FP_ADD_E (R, A, B);
+  FP_PACK_SEMIRAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/divxf3.c b/gcc/config/soft-fp/divxf3.c
new file mode 100644
index 00000000000..d698492c844
--- /dev/null
+++ b/gcc/config/soft-fp/divxf3.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return a / b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__divxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_E (A, a);
+  FP_UNPACK_E (B, b);
+  FP_DIV_E (R, A, B);
+  FP_PACK_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/double.h b/gcc/config/soft-fp/double.h
index 1cde3308bac..c6c768d7d8a 100644
--- a/gcc/config/soft-fp/double.h
+++ b/gcc/config/soft-fp/double.h
@@ -160,6 +160,7 @@ union _FP_UNION_D
 #define FP_FROM_INT_D(X,r,rs,rt)	_FP_FROM_INT(D,2,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_D(X)	_FP_FRAC_HIGH_2(X)
+#define _FP_FRAC_ZEROHIGH_D(X)
 #define _FP_FRAC_HIGH_RAW_D(X)	_FP_FRAC_HIGH_2(X)
 
 #else
@@ -260,6 +261,9 @@ union _FP_UNION_D
 #define FP_FROM_INT_D(X,r,rs,rt)	_FP_FROM_INT(D,1,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_D(X)	_FP_FRAC_HIGH_1(X)
+#define _FP_FRAC_ZEROHIGH_D(X)
 #define _FP_FRAC_HIGH_RAW_D(X)	_FP_FRAC_HIGH_1(X)
 
 #endif /* W_TYPE_SIZE < 64 */
+
+#include "softfp-protos.h"
diff --git a/gcc/config/soft-fp/eqxf2.c b/gcc/config/soft-fp/eqxf2.c
new file mode 100644
index 00000000000..f5d86407a6d
--- /dev/null
+++ b/gcc/config/soft-fp/eqxf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 otherwise
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__eqxf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_EQ_E (r, A, B, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__eqxf2, __nexf2);
diff --git a/gcc/config/soft-fp/extenddfxf2.c b/gcc/config/soft-fp/extenddfxf2.c
new file mode 100644
index 00000000000..053ee08a8ca
--- /dev/null
+++ b/gcc/config/soft-fp/extenddfxf2.c
@@ -0,0 +1,53 @@
+/* Software floating-point emulation.
+   Return a converted to IEEE quad
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXACT_UNDERFLOW
+#include "soft-fp.h"
+#include "double.h"
+#include "extended.h"
+
+XFtype
+__extenddfxf2 (DFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_D (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_TRAPPING_EXCEPTIONS;
+  FP_UNPACK_RAW_D (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_EXTEND (E, D, 4, 2, R, A);
+#else
+  FP_EXTEND (E, D, 2, 1, R, A);
+#endif
+  FP_PACK_RAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/extended.h b/gcc/config/soft-fp/extended.h
index e5f16debecb..8906a84e089 100644
--- a/gcc/config/soft-fp/extended.h
+++ b/gcc/config/soft-fp/extended.h
@@ -67,10 +67,9 @@ union _FP_UNION_E
    struct 
    {
 #if __BYTE_ORDER == __BIG_ENDIAN
-      unsigned long pad1 : _FP_W_TYPE_SIZE;
-      unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
       unsigned long sign : 1;
       unsigned long exp : _FP_EXPBITS_E;
+      unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
       unsigned long frac1 : _FP_W_TYPE_SIZE;
       unsigned long frac0 : _FP_W_TYPE_SIZE;
 #else
@@ -257,6 +256,7 @@ union _FP_UNION_E
 #define FP_FROM_INT_E(X,r,rs,rt)	_FP_FROM_INT(E,4,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_E(X)	(X##_f[2])
+#define _FP_FRAC_ZEROHIGH_E(X)	(X##_f[3] = 0)
 #define _FP_FRAC_HIGH_RAW_E(X)	(X##_f[1])
 
 #else   /* not _FP_W_TYPE_SIZE < 64 */
@@ -265,9 +265,9 @@ union _FP_UNION_E
   XFtype flt;
   struct {
 #if __BYTE_ORDER == __BIG_ENDIAN
-    _FP_W_TYPE pad  : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     unsigned sign   : 1;
     unsigned exp    : _FP_EXPBITS_E;
+    _FP_W_TYPE pad  : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;
 #else
     _FP_W_TYPE frac : _FP_W_TYPE_SIZE;
@@ -426,6 +426,9 @@ union _FP_UNION_E
 #define FP_FROM_INT_E(X,r,rs,rt)	_FP_FROM_INT(E,2,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_E(X)	(X##_f1)
+#define _FP_FRAC_ZEROHIGH_E(X)
 #define _FP_FRAC_HIGH_RAW_E(X)	(X##_f0)
 
 #endif /* not _FP_W_TYPE_SIZE < 64 */
+
+#include "softfp-protos.h"
diff --git a/gcc/config/soft-fp/extendsfxf2.c b/gcc/config/soft-fp/extendsfxf2.c
new file mode 100644
index 00000000000..d9ae418f3ef
--- /dev/null
+++ b/gcc/config/soft-fp/extendsfxf2.c
@@ -0,0 +1,53 @@
+/* Software floating-point emulation.
+   Return a converted to IEEE quad
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXACT_UNDERFLOW
+#include "soft-fp.h"
+#include "single.h"
+#include "extended.h"
+
+XFtype
+__extendsfxf2 (SFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_S (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_S (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_EXTEND (E, S, 4, 1, R, A);
+#else
+  FP_EXTEND (E, S, 2, 1, R, A);
+#endif
+  FP_PACK_RAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/extendxftf2.c b/gcc/config/soft-fp/extendxftf2.c
index af29a2ae9cc..9d2c256fd37 100644
--- a/gcc/config/soft-fp/extendxftf2.c
+++ b/gcc/config/soft-fp/extendxftf2.c
@@ -28,6 +28,7 @@
    Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
    MA 02110-1301, USA.  */
 
+#define FP_NO_EXACT_UNDERFLOW
 #include "soft-fp.h"
 #include "extended.h"
 #include "quad.h"
diff --git a/gcc/config/soft-fp/fixunsxfdi.c b/gcc/config/soft-fp/fixunsxfdi.c
new file mode 100644
index 00000000000..7826eb586c1
--- /dev/null
+++ b/gcc/config/soft-fp/fixunsxfdi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 64bit unsigned integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+UDItype
+__fixunsxfdi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, DI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/fixunsxfsi.c b/gcc/config/soft-fp/fixunsxfsi.c
new file mode 100644
index 00000000000..2197c15af56
--- /dev/null
+++ b/gcc/config/soft-fp/fixunsxfsi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 32bit unsigned integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+USItype
+__fixunsxfsi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, SI_BITS, 0);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/fixxfdi.c b/gcc/config/soft-fp/fixxfdi.c
new file mode 100644
index 00000000000..191b2cc9640
--- /dev/null
+++ b/gcc/config/soft-fp/fixxfdi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 64bit signed integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+DItype
+__fixxfdi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  UDItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, DI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/fixxfsi.c b/gcc/config/soft-fp/fixxfsi.c
new file mode 100644
index 00000000000..d7b194e5094
--- /dev/null
+++ b/gcc/config/soft-fp/fixxfsi.c
@@ -0,0 +1,45 @@
+/* Software floating-point emulation.
+   Convert a to 32bit signed integer
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+SItype
+__fixxfsi (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  USItype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_TO_INT_E (r, A, SI_BITS, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/floatdixf.c b/gcc/config/soft-fp/floatdixf.c
new file mode 100644
index 00000000000..1ffc2b36e84
--- /dev/null
+++ b/gcc/config/soft-fp/floatdixf.c
@@ -0,0 +1,46 @@
+/* Software floating-point emulation.
+   Convert a 64bit signed integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatdixf (DItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_E (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_E (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff --git a/gcc/config/soft-fp/floatsixf.c b/gcc/config/soft-fp/floatsixf.c
new file mode 100644
index 00000000000..dc1589c844a
--- /dev/null
+++ b/gcc/config/soft-fp/floatsixf.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation.
+   Convert a 32bit signed integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatsixf (SItype i)
+{
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_FROM_INT_E (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_E (a, A);
+
+  return a;
+}
diff --git a/gcc/config/soft-fp/floatundixf.c b/gcc/config/soft-fp/floatundixf.c
new file mode 100644
index 00000000000..fa397ff2373
--- /dev/null
+++ b/gcc/config/soft-fp/floatundixf.c
@@ -0,0 +1,46 @@
+/* Software floating-point emulation.
+   Convert a 64bit unsigned integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatundixf (UDItype i)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_INIT_ROUNDMODE;
+  FP_FROM_INT_E (A, i, DI_BITS, UDItype);
+  FP_PACK_RAW_E (a, A);
+  FP_HANDLE_EXCEPTIONS;
+
+  return a;
+}
diff --git a/gcc/config/soft-fp/floatunsixf.c b/gcc/config/soft-fp/floatunsixf.c
new file mode 100644
index 00000000000..09994a9d01f
--- /dev/null
+++ b/gcc/config/soft-fp/floatunsixf.c
@@ -0,0 +1,43 @@
+/* Software floating-point emulation.
+   Convert a 32bit unsigned integer to IEEE double
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FP_NO_EXCEPTIONS
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__floatunsixf (USItype i)
+{
+  FP_DECL_E (A);
+  XFtype a;
+
+  FP_FROM_INT_E (A, i, SI_BITS, USItype);
+  FP_PACK_RAW_E (a, A);
+
+  return a;
+}
diff --git a/gcc/config/soft-fp/gexf2.c b/gcc/config/soft-fp/gexf2.c
new file mode 100644
index 00000000000..bae1915e825
--- /dev/null
+++ b/gcc/config/soft-fp/gexf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 iff a > b, -2 iff a ? b, -1 iff a < b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__gexf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_E (r, A, B, -2, 2);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__gexf2, __gtxf2);
diff --git a/gcc/config/soft-fp/lexf2.c b/gcc/config/soft-fp/lexf2.c
new file mode 100644
index 00000000000..2bf1b992f3a
--- /dev/null
+++ b/gcc/config/soft-fp/lexf2.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return 0 iff a == b, 1 iff a > b, 2 iff a ? b, -1 iff a < b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__lexf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_E (r, A, B, 2, 2);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
+
+strong_alias (__lexf2, __ltxf2);
diff --git a/gcc/config/soft-fp/mulxf3.c b/gcc/config/soft-fp/mulxf3.c
new file mode 100644
index 00000000000..1f720011865
--- /dev/null
+++ b/gcc/config/soft-fp/mulxf3.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return a * b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__mulxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_E (A, a);
+  FP_UNPACK_E (B, b);
+  FP_MUL_E (R, A, B);
+  FP_PACK_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/negxf2.c b/gcc/config/soft-fp/negxf2.c
new file mode 100644
index 00000000000..2da7d10ab3d
--- /dev/null
+++ b/gcc/config/soft-fp/negxf2.c
@@ -0,0 +1,44 @@
+/* Software floating-point emulation.
+   Return -a
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__negxf2 (XFtype a)
+{
+  FP_DECL_E (A);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_UNPACK_RAW_E (A, a);
+  FP_NEG_E (R, A);
+  FP_PACK_RAW_E (r, R);
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/op-2.h b/gcc/config/soft-fp/op-2.h
index 3a3b3aa0691..0e04402b809 100644
--- a/gcc/config/soft-fp/op-2.h
+++ b/gcc/config/soft-fp/op-2.h
@@ -189,9 +189,9 @@
 #undef __FP_FRAC_ADDI_2
 #define __FP_FRAC_ADDI_2(xh, xl, i)	add_ssaaaa(xh, xl, xh, xl, 0, i)
 #undef __FP_FRAC_ADD_2
-#define __FP_FRAC_ADD_2			add_ssaaaa
+#define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl) add_ssaaaa(rh, rl, xh, xl, yh, yl)
 #undef __FP_FRAC_SUB_2
-#define __FP_FRAC_SUB_2			sub_ddmmss
+#define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl) sub_ddmmss(rh, rl, xh, xl, yh, yl)
 #undef __FP_FRAC_DEC_2
 #define __FP_FRAC_DEC_2(xh, xl, yh, yl)	sub_ddmmss(xh, xl, xh, xl, yh, yl)
 
diff --git a/gcc/config/soft-fp/op-common.h b/gcc/config/soft-fp/op-common.h
index ef11b527b70..4b3e3a99044 100644
--- a/gcc/config/soft-fp/op-common.h
+++ b/gcc/config/soft-fp/op-common.h
@@ -144,6 +144,7 @@ do {								\
 	_FP_OVERFLOW_SEMIRAW(fs, wc, X);			\
     }								\
   _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);				\
+  _FP_FRAC_ZEROHIGH_##fs(X);				\
   if (!_FP_EXP_NORMAL(fs, wc, X) && !_FP_FRAC_ZEROP_##wc(X))	\
     {								\
       if (X##_e == 0)						\
@@ -694,6 +695,7 @@ do {									 \
 	     canceling it; renormalize.  */				 \
 	  _FP_FRAC_HIGH_##fs(R) &= _FP_IMPLBIT_SH_##fs - 1;		 \
 	norm:								 \
+      _FP_FRAC_ZEROHIGH_##fs(R); \
 	  _FP_FRAC_CLZ_##wc(diff, R);					 \
 	  diff -= _FP_WFRACXBITS_##fs;					 \
 	  _FP_FRAC_SLL_##wc(R, diff);					 \
diff --git a/gcc/config/soft-fp/quad.h b/gcc/config/soft-fp/quad.h
index c22e944029f..ea016644d0a 100644
--- a/gcc/config/soft-fp/quad.h
+++ b/gcc/config/soft-fp/quad.h
@@ -165,6 +165,7 @@ union _FP_UNION_Q
 #define FP_FROM_INT_Q(X,r,rs,rt)	_FP_FROM_INT(Q,4,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_Q(X)	_FP_FRAC_HIGH_4(X)
+#define _FP_FRAC_ZEROHIGH_Q(X)
 #define _FP_FRAC_HIGH_RAW_Q(X)	_FP_FRAC_HIGH_4(X)
 
 #else   /* not _FP_W_TYPE_SIZE < 64 */
@@ -266,6 +267,7 @@ union _FP_UNION_Q
 #define FP_FROM_INT_Q(X,r,rs,rt)	_FP_FROM_INT(Q,2,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_Q(X)	_FP_FRAC_HIGH_2(X)
+#define _FP_FRAC_ZEROHIGH_Q(X)
 #define _FP_FRAC_HIGH_RAW_Q(X)	_FP_FRAC_HIGH_2(X)
 
 #endif /* not _FP_W_TYPE_SIZE < 64 */
diff --git a/gcc/config/soft-fp/single.h b/gcc/config/soft-fp/single.h
index 9c3734adf48..d7fde7b4452 100644
--- a/gcc/config/soft-fp/single.h
+++ b/gcc/config/soft-fp/single.h
@@ -148,4 +148,7 @@ union _FP_UNION_S
 #define FP_FROM_INT_S(X,r,rs,rt)	_FP_FROM_INT(S,1,X,r,rs,rt)
 
 #define _FP_FRAC_HIGH_S(X)	_FP_FRAC_HIGH_1(X)
+#define _FP_FRAC_ZEROHIGH_S(X)
 #define _FP_FRAC_HIGH_RAW_S(X)	_FP_FRAC_HIGH_1(X)
+ 
+#include "softfp-protos.h"
diff --git a/gcc/config/soft-fp/softfp-protos.h b/gcc/config/soft-fp/softfp-protos.h
new file mode 100644
index 00000000000..6bf7e9bf42e
--- /dev/null
+++ b/gcc/config/soft-fp/softfp-protos.h
@@ -0,0 +1,215 @@
+#ifdef __FLT16_MANT_DIG__
+#define LIBGCC_HAS_HF_MODE
+#endif
+#ifdef __FLT_MANT_DIG__
+#define LIBGCC_HAS_SF_MODE
+#endif
+#ifdef __DBL_MANT_DIG__
+#define LIBGCC_HAS_DF_MODE
+#endif
+#if defined(__LDBL_MANT_DIG__) && __DBL_MANT_DIG__ != __LDBL_MANT_DIG__
+#define LIBGCC_HAS_XF_MODE
+#endif
+#if defined(__FLT128_MANT_DIG__) && (!defined(__LDBL_MANT_DIG__) || __FLT128_MANT_DIG__ != __LDBL_MANT_DIG__)
+#define LIBGCC_HAS_TF_MODE
+#endif
+
+/*
+ * half
+ */
+#ifdef LIBGCC_HAS_HF_MODE
+CMPtype __unordhf2(_Float16 a, _Float16 b);
+_Float16 __floatsihf (SItype a1);
+_Float16 __floatdihf (DItype a1);
+_Float16 __floatunsihf (USItype a1);
+_Float16 __floatundihf (UDItype a1);
+SItype __fixhfsi (_Float16 a1);
+DItype __fixhfdi (_Float16 a1);
+USItype __fixunshfsi (_Float16 a1);
+UDItype __fixunshfdi (_Float16 a1);
+_Float16 __addhf3 (_Float16 x1, _Float16 x2);
+_Float16 __subhf3 (_Float16 x1, _Float16 x2);
+_Float16 __mulhf3 (_Float16 x1, _Float16 x2);
+_Float16 __divhf3 (_Float16 x1, _Float16 x2);
+_Float16 __neghf2 (_Float16 x1);
+CMPtype __cmphf2 (_Float16 x1, _Float16 x2);
+CMPtype __eqhf2 (_Float16 x1, _Float16 x2);
+CMPtype __nehf2 (_Float16 x1, _Float16 x2);
+CMPtype __lthf2 (_Float16 x1, _Float16 x2);
+CMPtype __lehf2 (_Float16 x1, _Float16 x2);
+CMPtype __gthf2 (_Float16 x1, _Float16 x2);
+CMPtype __gehf2 (_Float16 x1, _Float16 x2);
+
+#ifdef LIBGCC_HAS_SF_MODE
+float __extendhfsf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __extendhfdf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extendhfxf2 (_Float16 a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128  __extendhftf2 (_Float16 a1);
+#endif
+#endif
+
+/*
+ * single
+ */
+#ifdef LIBGCC_HAS_SF_MODE
+CMPtype __unordsf2(float a, float b);
+float __floatsisf (SItype a1);
+float __floatdisf (DItype a1);
+float __floatunsisf (USItype a1);
+float __floatundisf (UDItype a1);
+SItype __fixsfsi (float a1);
+DItype __fixsfdi (float a1);
+USItype __fixunssfsi (float a1);
+UDItype __fixunssfdi (float a1);
+float __addsf3 (float x1, float x2);
+float __subsf3 (float x1, float x2);
+float __mulsf3 (float x1, float x2);
+float __divsf3 (float x1, float x2);
+float __negsf2 (float x1);
+CMPtype __cmpsf2 (float x1, float x2);
+CMPtype __eqsf2 (float x1, float x2);
+CMPtype __nesf2 (float x1, float x2);
+CMPtype __ltsf2 (float x1, float x2);
+CMPtype __lesf2 (float x1, float x2);
+CMPtype __gtsf2 (float x1, float x2);
+CMPtype __gesf2 (float x1, float x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncsfhf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __extendsfdf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extendsfxf2 (float a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extendsftf2 (float a1);
+#endif
+#endif
+
+/*
+ * double
+ */
+#ifdef LIBGCC_HAS_DF_MODE
+CMPtype __unorddf2(double a, double b);
+double __floatsidf (SItype a1);
+double __floatdidf (DItype a1);
+double __floatunsidf (USItype a1);
+double __floatundidf (UDItype a1);
+SItype __fixdfsi (double a1);
+DItype __fixdfdi (double a1);
+USItype __fixunsdfsi (double a1);
+UDItype __fixunsdfdi (double a1);
+double __adddf3 (double x1, double x2);
+double __subdf3 (double x1, double x2);
+double __muldf3 (double x1, double x2);
+double __divdf3 (double x1, double x2);
+double __negdf2 (double x1);
+CMPtype __cmpdf2 (double x1, double x2);
+CMPtype __eqdf2 (double x1, double x2);
+CMPtype __nedf2 (double x1, double x2);
+CMPtype __ltdf2 (double x1, double x2);
+CMPtype __ledf2 (double x1, double x2);
+CMPtype __gtdf2 (double x1, double x2);
+CMPtype __gedf2 (double x1, double x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncdfhf2 (double a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __truncdfsf2 (double a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __extenddfxf2(double a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extenddftf2(double a1);
+#endif
+#endif
+
+/*
+ * extended
+ */
+#ifdef LIBGCC_HAS_XF_MODE
+CMPtype __unordxf2(long double a, long double b);
+long double __floatsixf (SItype a1);
+long double __floatdixf (DItype a1);
+long double __floatunsixf (USItype a1);
+long double __floatundixf (UDItype a1);
+SItype __fixxfsi (long double a1);
+DItype __fixxfdi (long double a1);
+USItype __fixunsxfsi (long double a1);
+UDItype __fixunsxfdi (long double a1);
+long double __addxf3 (long double x1, long double x2);
+long double __subxf3 (long double x1, long double x2);
+long double __mulxf3 (long double x1, long double x2);
+long double __divxf3 (long double x1, long double x2);
+long double __negxf2 (long double x1);
+CMPtype __cmpxf2 (long double x1, long double x2);
+CMPtype __eqxf2 (long double x1, long double x2);
+CMPtype __nexf2 (long double x1, long double x2);
+CMPtype __ltxf2 (long double x1, long double x2);
+CMPtype __lexf2 (long double x1, long double x2);
+CMPtype __gtxf2 (long double x1, long double x2);
+CMPtype __gexf2 (long double x1, long double x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __truncxfhf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __truncxfsf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __truncxfdf2 (long double a1);
+#endif
+#ifdef LIBGCC_HAS_TF_MODE
+_Float128 __extendxftf2 (long double a1);
+#endif
+#endif
+
+/*
+ * quad
+ */
+#ifdef LIBGCC_HAS_TF_MODE
+CMPtype __unordtf2(_Float128 a, _Float128 b);
+_Float128 __floatsitf (SItype a1);
+_Float128 __floatditf (DItype a1);
+_Float128 __floatunsitf (USItype a1);
+_Float128 __floatunditf (UDItype a1);
+SItype __fixtfsi (_Float128 a1);
+DItype __fixtfdi (_Float128 a1);
+USItype __fixunstfsi (_Float128 a1);
+UDItype __fixunstfdi (_Float128 a1);
+_Float128 __addtf3 (_Float128 x1, _Float128 x2);
+_Float128 __subtf3 (_Float128 x1, _Float128 x2);
+_Float128 __multf3 (_Float128 x1, _Float128 x2);
+_Float128 __divtf3 (_Float128 x1, _Float128 x2);
+_Float128 __negtf2 (_Float128 x1);
+CMPtype __cmptf2 (_Float128 x1, _Float128 x2);
+CMPtype __eqtf2 (_Float128 x1, _Float128 x2);
+CMPtype __netf2 (_Float128 x1, _Float128 x2);
+CMPtype __lttf2 (_Float128 x1, _Float128 x2);
+CMPtype __letf2 (_Float128 x1, _Float128 x2);
+CMPtype __gttf2 (_Float128 x1, _Float128 x2);
+CMPtype __getf2 (_Float128 x1, _Float128 x2);
+
+#ifdef LIBGCC_HAS_HF_MODE
+_Float16 __trunctfhf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_SF_MODE
+float __trunctfsf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_DF_MODE
+double __trunctfdf2 (_Float128 a1);
+#endif
+#ifdef LIBGCC_HAS_XF_MODE
+long double __trunctfxf2 (_Float128 a1);
+#endif
+#endif
diff --git a/gcc/config/soft-fp/subxf3.c b/gcc/config/soft-fp/subxf3.c
new file mode 100644
index 00000000000..00fe2b3e039
--- /dev/null
+++ b/gcc/config/soft-fp/subxf3.c
@@ -0,0 +1,49 @@
+/* Software floating-point emulation.
+   Return a - b
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+XFtype
+__subxf3 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  FP_DECL_E (R);
+  XFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+  FP_UNPACK_SEMIRAW_E (B, b);
+  FP_SUB_E (R, A, B);
+  FP_PACK_SEMIRAW_E (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/test-double.c b/gcc/config/soft-fp/test-double.c
new file mode 100644
index 00000000000..d4253195b31
--- /dev/null
+++ b/gcc/config/soft-fp/test-double.c
@@ -0,0 +1,157 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee754_double_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:12;
+	uint32_t     mantissa0:20;
+	uint32_t     mantissa1:32;
+#else
+	uint32_t mantissa1:32;
+	uint32_t mantissa0:20;
+	unsigned int signexp:12;
+#endif
+};
+
+union ieee754_double
+{
+	struct ieee754_double_struct ieee;
+	double d;
+};
+
+
+struct test_data
+{
+	double arg1;
+	double arg2;
+	char op;
+	double expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0, 4.0),
+	TEST(3.0, 3.0),
+	TEST(1.123456789, 4.0),
+	TEST(1E38, 4.0),
+	TEST(1E308, 4.0),
+	TEST(1E-37, 4.0),
+	TEST(1E-307, 4.0),
+	TEST(0.0, 0.0),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee754_double a, b, z, r1;
+		double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __adddf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subdf3(lt->arg1, lt->arg2); break;
+			case '*': r = __muldf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divdf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negdf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			r1.ieee.mantissa0 != z.ieee.mantissa0 ||
+			r1.ieee.mantissa1 != z.ieee.mantissa1)
+		{
+#define is_binop(op) (op) != '~'
+			if (is_binop(lt->op))
+				printf("BAD %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("BAD -(%e)\n", a.d);
+			printf("arg1      %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa0,
+				a.ieee.mantissa1);
+			if (is_binop(lt->op))
+			printf("arg2      %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa0,
+				b.ieee.mantissa1);
+			printf("expected  %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa0,
+				z.ieee.mantissa1);
+			printf("got       %.20e 0x%04x, 0x%08x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa0,
+				r1.ieee.mantissa1);
+			errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%e)\n", a.d);
+		}
+	}
+
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/gcc/config/soft-fp/test-float.c b/gcc/config/soft-fp/test-float.c
new file mode 100644
index 00000000000..69d8dcd213a
--- /dev/null
+++ b/gcc/config/soft-fp/test-float.c
@@ -0,0 +1,158 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee754_float_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:9;
+	uint32_t     mantissa:23;
+#else
+	uint32_t mantissa:23;
+	unsigned int signexp:9;
+#endif
+};
+
+union ieee754_float
+{
+	struct ieee754_float_struct ieee;
+	float d;
+};
+
+
+struct test_data
+{
+	float arg1;
+	float arg2;
+	char op;
+	float expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0F, 4.0F),
+	TEST(3.0F, 3.0F),
+	TEST(1.123456789F, 4.0F),
+	TEST(1E38F, 4.0F),
+	TEST(1E-37F, 4.0F),
+	TEST(0.0F, 0.0F),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+	int warnings = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee754_float a, b, z, r1;
+		double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __addsf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subsf3(lt->arg1, lt->arg2); break;
+			case '*': r = __mulsf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divsf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negsf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			(z.ieee.mantissa != r1.ieee.mantissa))
+		{
+#define is_binop(op) (op) != '~'
+			int warning = r1.ieee.signexp == z.ieee.signexp && (z.ieee.mantissa - r1.ieee.mantissa) <= 1;
+			const char *round = warning ? " (rounding)" : "";
+			if (is_binop(lt->op))
+				printf("BAD %e %c %e%s\n", a.d, lt->op, b.d, round);
+			else
+				printf("BAD -(%e)%s\n", a.d, round);
+			printf("arg1      %.20e 0x%04x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa);
+			if (is_binop(lt->op))
+			printf("arg2      %.20e 0x%04x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa);
+			printf("expected  %.20e 0x%04x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa);
+			printf("got       %.20e 0x%04x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa);
+			if (warning)
+				warnings++;
+			else
+				errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %e %c %e\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%e)\n", a.d);
+		}
+	}
+
+	if (warnings != 0)
+	{
+		fprintf(stderr, "got %d warnings\n", warnings);
+	}
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/gcc/config/soft-fp/test-ldouble.c b/gcc/config/soft-fp/test-ldouble.c
new file mode 100644
index 00000000000..bd145431046
--- /dev/null
+++ b/gcc/config/soft-fp/test-ldouble.c
@@ -0,0 +1,160 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <endian.h>
+#include <stdint.h>
+#include <errno.h>
+#include "soft-fp.h"
+#include "softfp-protos.h"
+
+struct ieee854_long_double_struct
+{
+#if	__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	unsigned int signexp:16;
+	unsigned int empty:16;
+	uint32_t     mantissa0:32;
+	uint32_t     mantissa1:32;
+#else
+	uint32_t mantissa1:32;
+	uint32_t mantissa0:32;
+	unsigned int signexp:16;
+	unsigned int empty:16;
+#endif
+};
+
+union ieee854_long_double
+{
+	struct ieee854_long_double_struct ieee;
+	long double d;
+};
+
+struct test_data
+{
+	long double arg1;
+	long double arg2;
+	char op;
+	long double expected;
+};
+
+static struct test_data const double_tests[] = {
+#define OP2(a, op, b) { a, b, #op[0], a op b }
+#define OP1(a, op, opc) { a, 0, #opc[0], op(a) }
+#define TESTOPS(a, b) \
+	OP2(a, +, b), \
+	OP2(a, -, b), \
+	OP2(a, *, b), \
+	OP2(a, /, b), \
+	OP1(a, -, ~)
+#define TEST(a, b) \
+	TESTOPS(a, b), \
+	TESTOPS(b, a), \
+	TESTOPS(-(a), -(b)), \
+	TESTOPS(-(b), -(a))
+	
+	TEST(3.0L, 4.0L),
+	TEST(3.0L, 3.0L),
+	TEST(1.123456789L, 4.0L),
+	TEST(1E38L, 4.0L),
+	TEST(1E308L, 4.0L),
+	TEST(1E4000L, 4.0L),
+	TEST(1E-37L, 4.0L),
+	TEST(1E-307L, 4.0L),
+	TEST(1E-4000L, 4.0L),
+	TEST(0.0, 0.0),
+};
+
+
+double x, y;
+int a;
+long double lx, ly;
+int b;
+
+int main(void)
+{
+	int i;
+	int errors = 0;
+
+	/* to link in the comparison functions from softfp, not from libgcc */
+	a = x < y;
+	b = lx < ly;
+
+	for (i = 0; i < (int)(sizeof(double_tests) / sizeof(double_tests[0])); i++)
+	{
+		const struct test_data *lt = &double_tests[i];
+		volatile union ieee854_long_double a, b, z, r1;
+		long double r;
+		
+#define COPY(dst, src) dst.d = src
+		
+		COPY(a, lt->arg1);
+		COPY(b, lt->arg2);
+		switch (lt->op)
+		{
+#if 0
+			case '+': r = lt->arg1 + lt->arg2; break;
+			case '-': r = lt->arg1 - lt->arg2; break;
+			case '*': r = lt->arg1 * lt->arg2; break;
+			case '/': r = lt->arg1 / lt->arg2; break;
+			case '~': r = -(lt->arg1); break;
+#else
+			case '+': r = __addxf3(lt->arg1, lt->arg2); break;
+			case '-': r = __subxf3(lt->arg1, lt->arg2); break;
+			case '*': r = __mulxf3(lt->arg1, lt->arg2); break;
+			case '/': r = __divxf3(lt->arg1, lt->arg2); break;
+			case '~': r = __negxf2(lt->arg1); break;
+#endif
+			default: abort();
+		}
+		COPY(z, lt->expected);
+		COPY(r1, r);
+		if (r1.ieee.signexp != z.ieee.signexp ||
+			r1.ieee.mantissa0 != z.ieee.mantissa0 ||
+			r1.ieee.mantissa1 != z.ieee.mantissa1)
+		{
+#define is_binop(op) (op) != '~'
+			if (is_binop(lt->op))
+				printf("BAD %Le %c %Le\n", a.d, lt->op, b.d);
+			else
+				printf("BAD -(%Le)\n", a.d);
+			printf("arg1      %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				a.d,
+				a.ieee.signexp,
+				a.ieee.mantissa0,
+				a.ieee.mantissa1);
+			if (is_binop(lt->op))
+			printf("arg2      %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				b.d,
+				b.ieee.signexp,
+				b.ieee.mantissa0,
+				b.ieee.mantissa1);
+			printf("expected  %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				z.d,
+				z.ieee.signexp,
+				z.ieee.mantissa0,
+				z.ieee.mantissa1);
+			printf("got       %.20Le 0x%04x, 0x%08x, 0x%08x\n",
+				r1.d,
+				r1.ieee.signexp,
+				r1.ieee.mantissa0,
+				r1.ieee.mantissa1);
+			errors++;
+		} else
+		{
+			if (is_binop(lt->op))
+				printf("OK %Le %c %Le\n", a.d, lt->op, b.d);
+			else
+				printf("OK -(%Le)\n", a.d);
+		}
+	}
+
+	if (errors != 0)
+	{
+		fprintf(stderr, "got %d errors\n", errors);
+		return 1;
+	}
+	printf("no errors\n");
+	return 0;
+}
diff --git a/gcc/config/soft-fp/truncxfdf2.c b/gcc/config/soft-fp/truncxfdf2.c
new file mode 100644
index 00000000000..31690ed80bb
--- /dev/null
+++ b/gcc/config/soft-fp/truncxfdf2.c
@@ -0,0 +1,52 @@
+/* Software floating-point emulation.
+   Truncate IEEE double into IEEE single
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "double.h"
+#include "extended.h"
+
+DFtype
+__truncxfdf2 (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_D (R);
+  DFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_TRUNC (D, E, 2, 4, R, A);
+#else
+  FP_TRUNC (D, E, 1, 2, R, A);
+#endif
+  FP_PACK_SEMIRAW_D (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/truncxfsf2.c b/gcc/config/soft-fp/truncxfsf2.c
new file mode 100644
index 00000000000..041783904f5
--- /dev/null
+++ b/gcc/config/soft-fp/truncxfsf2.c
@@ -0,0 +1,52 @@
+/* Software floating-point emulation.
+   Truncate IEEE double into IEEE single
+   Copyright (C) 1997-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "single.h"
+#include "extended.h"
+
+SFtype
+__truncxfsf2 (XFtype a)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_S (R);
+  SFtype r;
+
+  FP_INIT_ROUNDMODE;
+  FP_UNPACK_SEMIRAW_E (A, a);
+#if _FP_W_TYPE_SIZE < 64
+  FP_TRUNC (S, E, 1, 4, R, A);
+#else
+  FP_TRUNC (S, E, 1, 2, R, A);
+#endif
+  FP_PACK_SEMIRAW_S (r, R);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/config/soft-fp/unordxf2.c b/gcc/config/soft-fp/unordxf2.c
new file mode 100644
index 00000000000..b2cf0511f68
--- /dev/null
+++ b/gcc/config/soft-fp/unordxf2.c
@@ -0,0 +1,47 @@
+/* Software floating-point emulation.
+   Return 1 iff a or b is a NaN, 0 otherwise.
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file into
+   combinations with other programs, and to distribute those
+   combinations without any restriction coming from the use of this
+   file.  (The Lesser General Public License restrictions do apply in
+   other respects; for example, they cover modification of the file,
+   and distribution when not linked into a combine executable.)
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "soft-fp.h"
+#include "extended.h"
+
+CMPtype
+__unordxf2 (XFtype a, XFtype b)
+{
+  FP_DECL_EX;
+  FP_DECL_E (A);
+  FP_DECL_E (B);
+  CMPtype r;
+
+  FP_INIT_EXCEPTIONS;
+  FP_UNPACK_RAW_E (A, a);
+  FP_UNPACK_RAW_E (B, b);
+  FP_CMP_UNORD_E (r, A, B, 1);
+  FP_HANDLE_EXCEPTIONS;
+
+  return r;
+}
diff --git a/gcc/configure b/gcc/configure
index c8caff252f4..ad548bb9545 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -12103,6 +12103,10 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
@@ -15451,6 +15455,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
@@ -17265,6 +17273,11 @@ else
     lt_cv_dlopen_libs=
     ;;
 
+  mint*)
+    lt_cv_dlopen="no"
+    lt_cv_dlopen_libs=
+    ;;
+
   darwin*)
   # if libdl is installed we need to link against it
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index d0a9e58133b..41c2dad14c8 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -63,7 +63,7 @@ g++spec.o: $(srcdir)/cp/g++spec.c $(SYSTEM_H) coretypes.h $(TM_H) $(GCC_H) \
 GXX_OBJS = $(GCC_OBJS) g++spec.o intl.o prefix.o version.o
 g++$(exeext): $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
-	  $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)
+	  $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBS) $(GLIBC_SO)
 
 # Create a version of the g++ driver which calls the cross-compiler.
 g++-cross$(exeext): g++$(exeext)
@@ -102,7 +102,7 @@ cc1plus-checksum.o : cc1plus-checksum.c $(CONFIG_H) $(SYSTEM_H)
 
 cc1plus$(exeext): $(CXX_OBJS) cc1plus-checksum.o $(BACKEND) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
-	      $(CXX_OBJS) cc1plus-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS)
+	      $(CXX_OBJS) cc1plus-checksum.o $(BACKEND) $(LIBS) $(BACKENDLIBS) $(GLIBC_SO)
 
 # Special build rules.
 $(srcdir)/cp/cfns.h: $(srcdir)/cp/cfns.gperf
diff --git a/gcc/cp/cfns.gperf b/gcc/cp/cfns.gperf
index ef1ed083d32..83a0957dd08 100644
--- a/gcc/cp/cfns.gperf
+++ b/gcc/cp/cfns.gperf
@@ -18,6 +18,9 @@ along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 #ifdef __GNUC__
 __inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
diff --git a/gcc/cp/cfns.h b/gcc/cp/cfns.h
index 62cdfab93aa..2fb9b4632b9 100644
--- a/gcc/cp/cfns.h
+++ b/gcc/cp/cfns.h
@@ -53,6 +53,9 @@ __inline
 static unsigned int hash (const char *, unsigned int);
 #ifdef __GNUC__
 __inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
 #endif
 const char * libc_name_p (const char *, unsigned int);
 /* maximum key range = 391, duplicates = 0 */
diff --git a/gcc/df-problems.c b/gcc/df-problems.c
index c3901b8bd34..58a8c64c461 100644
--- a/gcc/df-problems.c
+++ b/gcc/df-problems.c
@@ -4037,7 +4037,10 @@ can_move_insns_across (rtx from, rtx to, rtx across_from, rtx across_to,
 	  if (bitmap_intersect_p (merge_set, test_use)
 	      || bitmap_intersect_p (merge_use, test_set))
 	    break;
-	  max_to = insn;
+#ifdef HAVE_cc0
+	  if (!sets_cc0_p (insn))
+#endif
+	    max_to = insn;
 	}
       next = NEXT_INSN (insn);
       if (insn == to)
@@ -4074,7 +4077,11 @@ can_move_insns_across (rtx from, rtx to, rtx across_from, rtx across_to,
     {
       if (NONDEBUG_INSN_P (insn))
 	{
-	  if (!bitmap_intersect_p (test_set, local_merge_live))
+	  if (!bitmap_intersect_p (test_set, local_merge_live)
+#ifdef HAVE_cc0
+	      && !sets_cc0_p (insn)
+#endif
+	      )
 	    {
 	      max_to = insn;
 	      break;
diff --git a/gcc/doc/gcc.texi b/gcc/doc/gcc.texi
index 0e167bae004..39c93754e91 100644
--- a/gcc/doc/gcc.texi
+++ b/gcc/doc/gcc.texi
@@ -86,9 +86,15 @@ Published by:
 @item GNU Press
 @tab Website: www.gnupress.org
 @item a division of the
-@tab General: @tex press@@gnu.org @end tex
+@tab General:
+@tex
+press@@gnu.org
+@end tex
 @item Free Software Foundation
-@tab Orders:  @tex sales@@gnu.org @end tex
+@tab Orders:
+@tex
+sales@@gnu.org
+@end tex
 @item 51 Franklin Street, Fifth Floor
 @tab Tel 617-542-5942
 @item Boston, MA 02110-1301 USA
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 318064a809e..f695adc9b4d 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -87,7 +87,7 @@ gfortranspec.o: $(srcdir)/fortran/gfortranspec.c $(SYSTEM_H) $(TM_H) $(GCC_H) \
 GFORTRAN_D_OBJS = $(GCC_OBJS) gfortranspec.o version.o prefix.o intl.o
 gfortran$(exeext): $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
-	  $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)
+	  $(GFORTRAN_D_OBJS) $(EXTRA_GCC_OBJS) $(LIBS) $(GLIBC_SO)
 
 # Create a version of the gfortran driver which calls the cross-compiler.
 gfortran-cross$(exeext): gfortran$(exeext)
@@ -98,7 +98,7 @@ gfortran-cross$(exeext): gfortran$(exeext)
 f951$(exeext): $(F95_OBJS) \
 		$(BACKEND) $(LIBDEPS) attribs.o
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \
-		$(F95_OBJS) $(BACKEND) $(LIBS) attribs.o $(BACKENDLIBS)
+		$(F95_OBJS) $(BACKEND) $(LIBS) attribs.o $(BACKENDLIBS) $(GLIBC_SO)
 
 gt-fortran-trans.h    : s-gtype; @true
 #
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 6efd037c56f..71623aba982 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -6119,6 +6119,8 @@ compare_files (char *cmpfile[])
 
 extern int main (int, char **);
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/gcov-dump.c b/gcc/gcov-dump.c
index 3706f9ecd4e..942b16b52a3 100644
--- a/gcc/gcov-dump.c
+++ b/gcc/gcov-dump.c
@@ -72,6 +72,8 @@ static const tag_format_t tag_table[] =
   {0, NULL, NULL}
 };
 
+#include "libcmain.h"
+
 int
 main (int argc ATTRIBUTE_UNUSED, char **argv)
 {
diff --git a/gcc/gcov.c b/gcc/gcov.c
index 2fbeaf55e53..001c1d3d4ff 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -356,6 +356,8 @@ static char *make_gcov_file_name (const char *, const char *);
 static void release_structures (void);
 extern int main (int, char **);
 
+#include "libcmain.h"
+
 int
 main (int argc, char **argv)
 {
diff --git a/gcc/glibc.so b/gcc/glibc.so
new file mode 100644
index 00000000000..408ef8ba856
--- /dev/null
+++ b/gcc/glibc.so
@@ -0,0 +1,3 @@
+/* GNU ld script  */
+OUTPUT_FORMAT(elf64-x86-64)
+GROUP ( /lib64/libdl.so.2 /lib64/libc.so.6 /usr/lib64/libc_nonshared.a AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 ) )
diff --git a/gcc/libcmain.h b/gcc/libcmain.h
new file mode 100644
index 00000000000..0e3157bfb58
--- /dev/null
+++ b/gcc/libcmain.h
@@ -0,0 +1,39 @@
+#if defined(__LINUX_GLIBC_WRAP_H)
+
+/* ugly hack to get __libc_start_main versioned */
+
+#if __GLIBC_PREREQ(2, 34)
+
+#define STR_(s) #s
+#define STR(s)  STR_(s)
+#include <dlfcn.h>
+
+#ifdef __UCLIBC__
+#define __libc_start_main       __uClibc_main
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int __libc_start_main(
+        int (*main)(int,char**,char**), int ac, char **av,
+        int (*init)(void), void (*fini)(void),
+        void (*rtld_fini)(void), void *stack_end);
+int __libc_start_main(
+        int (*main)(int,char**,char**), int ac, char **av,
+        int (*init)(void), void (*fini)(void),
+        void (*rtld_fini)(void), void *stack_end)
+{
+	typeof(__libc_start_main) *real_lsm;
+	if ((*(void**)&real_lsm = dlsym(RTLD_NEXT, STR(__libc_start_main))) != 0)
+		return real_lsm(main, ac, av, init, fini, rtld_fini, stack_end);
+	fputs("BUG: dlsym error\n", stderr);
+	return 1;
+}
+#ifdef __cplusplus
+}
+#endif
+#undef STR
+#undef STR_
+#endif
+#endif
diff --git a/gcc/libcwrap.h b/gcc/libcwrap.h
new file mode 100644
index 00000000000..990c44c0d7d
--- /dev/null
+++ b/gcc/libcwrap.h
@@ -0,0 +1,1548 @@
+/* glibc bindings for target ABI version glibc 2.14 */
+#if defined(__linux__) && !defined (__LIBC_CUSTOM_BINDINGS_H__) && !defined(__ANDROID__)
+
+#if defined(__x86_64__)
+
+#define __LINUX_GLIBC_WRAP_H
+
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+#undef SYMVER
+#undef SYMVER1
+#ifdef __ASSEMBLER__
+#define SYMVER1(name, ver) .symver name, name##@##ver
+#else
+#define SYMVER1(name, ver) __asm__(".symver " #name ", " #name "@" #ver );
+#endif
+#define SYMVER(name, ver) SYMVER1(name, ver)
+
+
+/* Symbols redirected to earlier glibc versions */
+SYMVER(__libc_start_main, GLIBC_2.2.5)
+SYMVER(__libpthread_version_placeholder, GLIBC_2.12)
+SYMVER(__mq_open_2, GLIBC_2.7)
+SYMVER(__pthread_cleanup_routine, GLIBC_2.3.3)
+SYMVER(__pthread_key_create, GLIBC_2.2.5)
+SYMVER(__pthread_register_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_register_cancel_defer, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel, GLIBC_2.3.3)
+SYMVER(__pthread_unregister_cancel_restore, GLIBC_2.3.3)
+SYMVER(__pthread_unwind_next, GLIBC_2.3.3)
+SYMVER(_pthread_cleanup_pop, GLIBC_2.2.5)
+SYMVER(_pthread_cleanup_push, GLIBC_2.2.5)
+SYMVER(aio_cancel, GLIBC_2.2.5)
+SYMVER(aio_cancel64, GLIBC_2.2.5)
+SYMVER(aio_error, GLIBC_2.2.5)
+SYMVER(aio_error64, GLIBC_2.2.5)
+SYMVER(aio_fsync, GLIBC_2.2.5)
+SYMVER(aio_fsync64, GLIBC_2.2.5)
+SYMVER(aio_init, GLIBC_2.2.5)
+SYMVER(aio_read, GLIBC_2.2.5)
+SYMVER(aio_read64, GLIBC_2.2.5)
+SYMVER(aio_return, GLIBC_2.2.5)
+SYMVER(aio_return64, GLIBC_2.2.5)
+SYMVER(aio_suspend, GLIBC_2.2.5)
+SYMVER(aio_suspend64, GLIBC_2.2.5)
+SYMVER(aio_write, GLIBC_2.2.5)
+SYMVER(aio_write64, GLIBC_2.2.5)
+SYMVER(clock_adjtime, GLIBC_2.14)
+SYMVER(clock_getcpuclockid, GLIBC_2.2.5)
+SYMVER(clock_getres, GLIBC_2.2.5)
+SYMVER(clock_gettime, GLIBC_2.2.5)
+SYMVER(clock_nanosleep, GLIBC_2.2.5)
+SYMVER(clock_settime, GLIBC_2.2.5)
+SYMVER(dladdr, GLIBC_2.2.5)
+SYMVER(dladdr1, GLIBC_2.3.3)
+SYMVER(dlclose, GLIBC_2.2.5)
+SYMVER(dlerror, GLIBC_2.2.5)
+SYMVER(dlinfo, GLIBC_2.3.3)
+SYMVER(dlmopen, GLIBC_2.3.4)
+SYMVER(dlopen, GLIBC_2.2.5)
+SYMVER(dlsym, GLIBC_2.2.5)
+SYMVER(dlvsym, GLIBC_2.2.5)
+SYMVER(exp, GLIBC_2.2.5)
+SYMVER(exp10f, GLIBC_2.2.5)
+SYMVER(exp2, GLIBC_2.2.5)
+SYMVER(exp2f, GLIBC_2.2.5)
+SYMVER(expf, GLIBC_2.2.5)
+SYMVER(fmemopen, GLIBC_2.2.5)
+SYMVER(forkpty, GLIBC_2.2.5)
+SYMVER(gai_cancel, GLIBC_2.2.5)
+SYMVER(gai_error, GLIBC_2.2.5)
+SYMVER(gai_suspend, GLIBC_2.2.5)
+SYMVER(getaddrinfo_a, GLIBC_2.2.5)
+SYMVER(glob, GLIBC_2.2.5)
+SYMVER(glob64, GLIBC_2.2.5)
+SYMVER(hypot, GLIBC_2.2.5)
+SYMVER(hypotf, GLIBC_2.2.5)
+SYMVER(lgamma, GLIBC_2.2.5)
+SYMVER(lgammaf, GLIBC_2.2.5)
+SYMVER(lgammal, GLIBC_2.2.5)
+SYMVER(lio_listio, GLIBC_2.4)
+SYMVER(lio_listio64, GLIBC_2.4)
+SYMVER(log, GLIBC_2.2.5)
+SYMVER(log2, GLIBC_2.2.5)
+SYMVER(log2f, GLIBC_2.2.5)
+SYMVER(logf, GLIBC_2.2.5)
+SYMVER(login, GLIBC_2.2.5)
+SYMVER(login_tty, GLIBC_2.2.5)
+SYMVER(logout, GLIBC_2.2.5)
+SYMVER(logwtmp, GLIBC_2.2.5)
+SYMVER(memcpy, GLIBC_2.14)
+SYMVER(mq_close, GLIBC_2.3.4)
+SYMVER(mq_getattr, GLIBC_2.3.4)
+SYMVER(mq_notify, GLIBC_2.3.4)
+SYMVER(mq_open, GLIBC_2.3.4)
+SYMVER(mq_receive, GLIBC_2.3.4)
+SYMVER(mq_send, GLIBC_2.3.4)
+SYMVER(mq_setattr, GLIBC_2.3.4)
+SYMVER(mq_timedreceive, GLIBC_2.3.4)
+SYMVER(mq_timedsend, GLIBC_2.3.4)
+SYMVER(mq_unlink, GLIBC_2.3.4)
+SYMVER(name_to_handle_at, GLIBC_2.14)
+SYMVER(ns_name_compress, GLIBC_2.9)
+SYMVER(ns_name_ntop, GLIBC_2.9)
+SYMVER(ns_name_pack, GLIBC_2.9)
+SYMVER(ns_name_pton, GLIBC_2.9)
+SYMVER(ns_name_skip, GLIBC_2.9)
+SYMVER(ns_name_uncompress, GLIBC_2.9)
+SYMVER(ns_name_unpack, GLIBC_2.9)
+SYMVER(open_by_handle_at, GLIBC_2.14)
+SYMVER(openpty, GLIBC_2.2.5)
+SYMVER(posix_spawn, GLIBC_2.2.5)
+SYMVER(posix_spawnp, GLIBC_2.2.5)
+SYMVER(pow, GLIBC_2.2.5)
+SYMVER(powf, GLIBC_2.2.5)
+SYMVER(pthread_attr_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_getguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_getstacksize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_attr_setguardsize, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstack, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstackaddr, GLIBC_2.2.5)
+SYMVER(pthread_attr_setstacksize, GLIBC_2.2.5)
+SYMVER(pthread_barrier_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrier_init, GLIBC_2.2.5)
+SYMVER(pthread_barrier_wait, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_getpshared, GLIBC_2.3.3)
+SYMVER(pthread_barrierattr_init, GLIBC_2.2.5)
+SYMVER(pthread_barrierattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_cancel, GLIBC_2.2.5)
+SYMVER(pthread_condattr_getclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_condattr_setclock, GLIBC_2.3.3)
+SYMVER(pthread_condattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_create, GLIBC_2.2.5)
+SYMVER(pthread_detach, GLIBC_2.2.5)
+SYMVER(pthread_getaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_getattr_np, GLIBC_2.2.5)
+SYMVER(pthread_getconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_getcpuclockid, GLIBC_2.2.5)
+SYMVER(pthread_getname_np, GLIBC_2.12)
+SYMVER(pthread_getspecific, GLIBC_2.2.5)
+SYMVER(pthread_join, GLIBC_2.2.5)
+SYMVER(pthread_key_create, GLIBC_2.2.5)
+SYMVER(pthread_key_delete, GLIBC_2.2.5)
+SYMVER(pthread_kill, GLIBC_2.2.5)
+SYMVER(pthread_mutex_consistent, GLIBC_2.12)
+SYMVER(pthread_mutex_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutex_timedlock, GLIBC_2.2.5)
+SYMVER(pthread_mutex_trylock, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_getrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_gettype, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_init, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setprioceiling, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setprotocol, GLIBC_2.4)
+SYMVER(pthread_mutexattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_mutexattr_setrobust, GLIBC_2.12)
+SYMVER(pthread_mutexattr_settype, GLIBC_2.2.5)
+SYMVER(pthread_once, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_rdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_timedwrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_tryrdlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_trywrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_unlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlock_wrlock, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_destroy, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_getpshared, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_init, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setkind_np, GLIBC_2.2.5)
+SYMVER(pthread_rwlockattr_setpshared, GLIBC_2.2.5)
+SYMVER(pthread_setaffinity_np, GLIBC_2.3.4)
+SYMVER(pthread_setconcurrency, GLIBC_2.2.5)
+SYMVER(pthread_setname_np, GLIBC_2.12)
+SYMVER(pthread_setschedprio, GLIBC_2.3.4)
+SYMVER(pthread_setspecific, GLIBC_2.2.5)
+SYMVER(pthread_sigmask, GLIBC_2.2.5)
+SYMVER(pthread_sigqueue, GLIBC_2.11)
+SYMVER(pthread_spin_destroy, GLIBC_2.2.5)
+SYMVER(pthread_spin_init, GLIBC_2.2.5)
+SYMVER(pthread_spin_lock, GLIBC_2.2.5)
+SYMVER(pthread_spin_trylock, GLIBC_2.2.5)
+SYMVER(pthread_spin_unlock, GLIBC_2.2.5)
+SYMVER(pthread_testcancel, GLIBC_2.2.5)
+SYMVER(pthread_timedjoin_np, GLIBC_2.3.3)
+SYMVER(pthread_tryjoin_np, GLIBC_2.3.3)
+SYMVER(quick_exit, GLIBC_2.10)
+SYMVER(sem_close, GLIBC_2.2.5)
+SYMVER(sem_destroy, GLIBC_2.2.5)
+SYMVER(sem_getvalue, GLIBC_2.2.5)
+SYMVER(sem_init, GLIBC_2.2.5)
+SYMVER(sem_open, GLIBC_2.2.5)
+SYMVER(sem_post, GLIBC_2.2.5)
+SYMVER(sem_timedwait, GLIBC_2.2.5)
+SYMVER(sem_trywait, GLIBC_2.2.5)
+SYMVER(sem_unlink, GLIBC_2.2.5)
+SYMVER(sem_wait, GLIBC_2.2.5)
+SYMVER(sendmmsg, GLIBC_2.14)
+SYMVER(setns, GLIBC_2.14)
+SYMVER(shm_open, GLIBC_2.2.5)
+SYMVER(shm_unlink, GLIBC_2.2.5)
+SYMVER(syncfs, GLIBC_2.14)
+SYMVER(timer_create, GLIBC_2.3.3)
+SYMVER(timer_delete, GLIBC_2.3.3)
+SYMVER(timer_getoverrun, GLIBC_2.3.3)
+SYMVER(timer_gettime, GLIBC_2.3.3)
+SYMVER(timer_settime, GLIBC_2.3.3)
+
+/* Symbols introduced in newer glibc versions, which must not be used */
+SYMVER(_Fork, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(_ZGVbN2v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN2vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN2vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVbN4vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVbN4vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVcN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVcN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN4vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN4vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVdN8vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVdN8vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_acosf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_acoshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_asinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_atanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cbrtf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_cosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_coshf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erfcf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_erff, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_exp2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_expf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_expm1f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log10f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log1pf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_log2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_logf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16v_sinhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16v_tanhf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_atan2f, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_hypotf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN16vv_powf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN16vvv_sincosf, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_acos, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_acosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asin, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_asinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_atanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cbrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_cos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_cosh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_erfc, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_exp10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_exp2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_expm1, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_log10, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log1p, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_log2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_sin, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8v_sinh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tan, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8v_tanh, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_atan2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_hypot, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(_ZGVeN8vv_pow, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(_ZGVeN8vvv_sincos, GLIBC_DONT_USE_THIS_VERSION_2.22)
+SYMVER(__acos_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acosf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__acoshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acoshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__acosl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asin_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__asinf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__asinl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atan2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atan2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__atanhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__atanhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cosh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__coshf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__coshl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__cxa_thread_atexit_impl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__exp10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__exp2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__exp_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__expf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__expl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__explicit_bzero_chk, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__fdelt_chk, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fdelt_warn, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__finitef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmod_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__fmodf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fmodl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__fpclassifyf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__gammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__gammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__hypot_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__hypotf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__hypotl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__iscanonicall, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__iseqsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__iseqsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(__isinff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__isnanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__issignaling, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__issignalingf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__issignalingl, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(__j0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__j1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__j1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__jnf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__jnl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgamma_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammaf128_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__lgammaf_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__lgammal_r_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__libc_single_threaded, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(__log10_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log10f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log10l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__log2f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log2l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__log_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__logf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__logl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__memcmpeq, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__poll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__pow_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__powf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__powl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ppoll_chk, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(__remainder_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__remainderf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__remainderl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__rseq_flags, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_offset, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rseq_size, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(__rtld_version_placeholder, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(__scalb_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__scalbl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__signbitf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__signgam, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(__sinh_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sinhf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sinhl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrt_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__sqrtf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__sqrtl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__strtof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__wcstof128_internal, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__x86_get_cpuid_feature_leaf, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(__y0_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y0f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y0l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1f128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__y1f_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__y1l_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__yn_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynf128_finite, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(__ynf_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(__ynl_finite, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(_dl_find_object, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(acosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(acoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(acoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(aligned_alloc, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(arc4random, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_buf, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(arc4random_uniform, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(asinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(asinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(asinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atan2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atan2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(atanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(atanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(c16rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c32rtomb, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(c8rtomb, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(cabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cacoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cacoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(call_once, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(canonicalize, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(canonicalizef128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(canonicalizef32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizef64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(canonicalizel, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(cargf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cargf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cargf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(casinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(casinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(catanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(catanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cbrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cbrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ccoshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ccoshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ceilf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ceilf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cimagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cimagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clog10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clog10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(clogf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(clogf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(close_range, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(closefrom, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(cnd_broadcast, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_signal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_timedwait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(cnd_wait, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(conjf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(conjf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(conjf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copy_file_range, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(copysignf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(copysignf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(coshf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(coshf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cpowf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cpowf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(cprojf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(cprojf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(crealf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(crealf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(csqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(csqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ctanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ctanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(daddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(ddivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dfmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(dn_comp, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_expand, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dn_skipname, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(dsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(dsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(epoll_pwait2, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(erfcf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erfcf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erfcf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(erff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(erff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(execveat, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(exp10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(exp2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(exp2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(explicit_bzero, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(expm1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(expm1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(expm1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(f32addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf32x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xaddf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xdivf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xfmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xmulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f32xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f32xsubf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64addf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64divf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64mulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64mulf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64subf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64subf64x, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xaddf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xdivf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xfmaf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xmulf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(f64xsqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(f64xsubf128, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fabsf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fabsf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fabsf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fadd, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(faddl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fcntl64, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdimf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fdimf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdimf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fdiv, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fdivl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fegetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetexcept, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fesetmode, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fetestexceptflag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ffma, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(ffmal, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(floorf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(floorf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(floorf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaximum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaximuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fmaxmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmaxmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmaxmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmaxmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminimum, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_mag_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_magl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_num, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimum_numl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf128, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf32x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimumf64x, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminimuml, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fminmag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fminmagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fminmagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fminmagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fmodf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fmodf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmodf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fmul, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fmull, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(frexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(frexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(frexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(fromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(fromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(fsconfig, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsmount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsopen, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fspick, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(fsqrt, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fsqrtl, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(fstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fstatat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(fsub, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fsubl, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(fts64_children, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_close, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_open, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_read, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(fts64_set, GLIBC_DONT_USE_THIS_VERSION_2.23)
+SYMVER(getauxval, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(getcpu, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(getdents64, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(getentropy, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(getpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(getpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(getrandom, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(gettid, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(hypotf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(hypotf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(hypotf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ilogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ilogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(j1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(j1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(jnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(jnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ldexpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ldexpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf128_r, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf32x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lgammaf64x_r, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogb, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llogbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llogbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llogbl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(llrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(llroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(llroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log10f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log10f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log1pf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log1pf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(log2f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(log2f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logbf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logbf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(logf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(logf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lrintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lrintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(lroundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lroundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(lstat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(lstat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mallinfo2, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mbrtoc16, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc32, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(mbrtoc8, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(memfd_create, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mknod, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mknodat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(mlock2, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(modff32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(modff64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(mount_setattr, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(move_mount, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(mtx_destroy, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_init, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_lock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_timedlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_trylock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(mtx_unlock, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(nanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nearbyintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nearbyintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextafterf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextafterf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdown, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextdownf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextdownf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextdownl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextup, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(nextupf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(nextupf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(nextupl, GLIBC_DONT_USE_THIS_VERSION_2.24)
+SYMVER(open_tree, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_getfd, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_open, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pidfd_send_signal, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(pkey_alloc, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_free, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_get, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_mprotect, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(pkey_set, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(posix_spawn_file_actions_addchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addclosefrom_np, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(posix_spawn_file_actions_addfchdir_np, GLIBC_DONT_USE_THIS_VERSION_2.29)
+SYMVER(posix_spawn_file_actions_addtcsetpgrp_np, GLIBC_DONT_USE_THIS_VERSION_2.35)
+SYMVER(powf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(powf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(powf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(preadv2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(preadv64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(process_madvise, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_mrelease, GLIBC_DONT_USE_THIS_VERSION_2.36)
+SYMVER(process_vm_readv, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(process_vm_writev, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(pthread_attr_getsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_attr_setsigmask_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(pthread_clockjoin_np, GLIBC_DONT_USE_THIS_VERSION_2.31)
+SYMVER(pthread_cond_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_getattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pthread_mutex_clocklock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockrdlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_rwlock_clockwrlock, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(pthread_setattr_default_np, GLIBC_DONT_USE_THIS_VERSION_2.18)
+SYMVER(pwritev2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(pwritev64v2, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(reallocarray, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remainderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remainderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(remquof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(remquof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(renameat2, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(res_dnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_hnok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mailok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_mkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nmkquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquery, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nquerydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsearch, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_nsend, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_ownok, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_query, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_querydomain, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_search, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(res_send, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(rintf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(rintf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(rintf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundeven, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundevenf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundevenf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundevenl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(roundf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(roundf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(roundf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalblnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalblnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(scalbnf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scalbnf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(scandirat, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(scandirat64, GLIBC_DONT_USE_THIS_VERSION_2.15)
+SYMVER(secure_getenv, GLIBC_DONT_USE_THIS_VERSION_2.17)
+SYMVER(sem_clockwait, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(setpayload, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsig, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(setpayloadsigf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(setpayloadsigf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(setpayloadsigl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(sigabbrev_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sigdescr_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(sincosf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sincosf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sincosf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sinhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sinhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(sqrtf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(sqrtf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(stat, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(stat64, GLIBC_DONT_USE_THIS_VERSION_2.33)
+SYMVER(statx, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(strerrordesc_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strerrorname_np, GLIBC_DONT_USE_THIS_VERSION_2.32)
+SYMVER(strfromd, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strfromf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strfromf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfromf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strfroml, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(strtof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(strtof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(strtof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tanhf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tanhf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(tgammaf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgammaf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tgkill, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(thrd_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_current, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_detach, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_equal, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_exit, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_join, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_sleep, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(thrd_yield, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(timespec_get, GLIBC_DONT_USE_THIS_VERSION_2.16)
+SYMVER(timespec_getres, GLIBC_DONT_USE_THIS_VERSION_2.34)
+SYMVER(totalorder, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalorderf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalorderf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalorderl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermag, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(totalordermagf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(totalordermagf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(totalordermagl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(truncf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(truncf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(truncf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(tss_create, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_delete, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_get, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(tss_set, GLIBC_DONT_USE_THIS_VERSION_2.28)
+SYMVER(twalk_r, GLIBC_DONT_USE_THIS_VERSION_2.30)
+SYMVER(ufromfp, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpx, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(ufromfpxf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ufromfpxf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ufromfpxl, GLIBC_DONT_USE_THIS_VERSION_2.25)
+SYMVER(wcstof128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof128_l, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(wcstof32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof32x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(wcstof64x_l, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y0f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y0f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(y1f32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(y1f64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf128, GLIBC_DONT_USE_THIS_VERSION_2.26)
+SYMVER(ynf32, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf32x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64, GLIBC_DONT_USE_THIS_VERSION_2.27)
+SYMVER(ynf64x, GLIBC_DONT_USE_THIS_VERSION_2.27)
+
+#undef SYMVER
+#undef SYMVER1
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <sys/stat.h>
+
+#if __GLIBC_PREREQ(2, 33)
+
+/*
+ * avoid references to stat/lstat/fstat, which are only available in glibc >= 2.33
+ */
+
+extern int __fxstat(int __ver, int __fildes, struct stat *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+extern int __xstat(int __ver, const char *__filename,
+      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat(int __ver, const char *__filename,
+       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstatat (int __ver, int __fildes, const char *__filename,
+         struct stat *__stat_buf, int __flag)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
+#ifdef __USE_LARGEFILE64
+extern int __xstat64(int __ver, const char *__filename,
+      struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __lxstat64(int __ver, const char *__filename,
+       struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
+extern int __fxstat64(int __ver, int __fildes, struct stat64 *__stat_buf)
+     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
+#endif
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int stat(const char *__path, struct stat *__statbuf)
+{
+	return __xstat(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__)) 
+int lstat (const char *__path, struct stat *__statbuf)
+{
+	return __lxstat(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__)) 
+int fstat(int __fd, struct stat *__statbuf)
+{
+	return __fxstat(1, __fd, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__)) 
+int fstatat(int __fd, const char *__filename, struct stat *__statbuf, int __flag)
+{
+	return __fxstatat(1, __fd, __filename, __statbuf, __flag);
+}
+
+#ifdef __USE_LARGEFILE64
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__))
+int stat64(const char *__path, struct stat64 *__statbuf)
+{
+	return __xstat64(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__)) 
+int lstat64 (const char *__path, struct stat64 *__statbuf)
+{
+	return __lxstat64(1, __path, __statbuf);
+}
+
+extern __inline __attribute__((__gnu_inline__))
+__attribute__((__nothrow__)) 
+int fstat64(int __fd, struct stat64 *__statbuf)
+{
+	return __fxstat64(1, __fd, __statbuf);
+}
+
+#endif /* __USE_LARGEFILE64 */
+
+#endif /* __GLIBC_PREREQ */
+
+#if defined (__cplusplus)
+}
+#endif
+
+
+#endif /* __x86_64__ */
+#endif /* __linux__ */
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index 613c7b054df..c2f07540477 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -624,6 +624,8 @@ cont:
 
 /* Entry point.  */
 
+#include "libcmain.h"
+
 int
 main (int argc, char *argv[])
 {
diff --git a/gcc/main.c b/gcc/main.c
index b492289b362..24113cdf3d5 100644
--- a/gcc/main.c
+++ b/gcc/main.c
@@ -26,6 +26,8 @@ along with GCC; see the file COPYING3.  If not see
 
 int main (int argc, char **argv);
 
+#include "libcmain.h"
+
 /* We define main() to call toplev_main(), which is defined in toplev.c.
    We do this in a separate file in order to allow the language front-end
    to define a different main(), if it so desires.  */
diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
index 3b6d18e9254..d57d98678a2 100644
--- a/gcc/pretty-print.h
+++ b/gcc/pretty-print.h
@@ -305,7 +305,7 @@ extern void pp_base_append_text (pretty_printer *, const char *, const char *);
 
 /* This header may be included before diagnostics-core.h, hence the duplicate
    definitions to allow for GCC-specific formats.  */
-#if GCC_VERSION >= 3005
+#if GCC_VERSION >= 3005 && 0
 #define ATTRIBUTE_GCC_PPDIAG(m, n) __attribute__ ((__format__ (__gcc_diag__, m ,n))) ATTRIBUTE_NONNULL(m)
 #else
 #define ATTRIBUTE_GCC_PPDIAG(m, n) ATTRIBUTE_NONNULL(m)
diff --git a/libdecnumber/decNumberLocal.h b/libdecnumber/decNumberLocal.h
index dca79e51db7..24fb7f690d2 100644
--- a/libdecnumber/decNumberLocal.h
+++ b/libdecnumber/decNumberLocal.h
@@ -188,7 +188,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   #if (DECNUMMAXE != DEC_MAX_EMAX)
     #error Maximum exponent mismatch
   #endif
-  #if (DECNUMMINE != DEC_MIN_EMIN)
+  #if !(DECNUMMINE == DEC_MIN_EMIN) /* gcc 2.95.3 has bug in '!=' operator for negative constants */
     #error Minimum exponent mismatch
   #endif
 
diff --git a/libffi/configure b/libffi/configure
index 6b38089d8c8..6b414a1c9df 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -5065,6 +5065,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8690,6 +8696,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libgcc/config.host b/libgcc/config.host
index 25e949e0fe3..622ccdf5f26 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -387,6 +387,8 @@ m68k-*-linux*)		# Motorola m68k's running GNU/Linux
 				# with ELF format using glibc 2
 				# aka the GNU/Linux C library 6.
 	;;
+m68k-*-mint*)
+	;;
 m68k-*-rtems*)
 	;;
 mcore-*-elf)
diff --git a/libgfortran/configure b/libgfortran/configure
index 1e61aeb4910..0e0844fbace 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -6649,6 +6649,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -10009,6 +10015,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libgo/configure b/libgo/configure
index ca3544e5f2b..327881918b4 100644
--- a/libgo/configure
+++ b/libgo/configure
@@ -8822,6 +8822,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libgomp/configure b/libgomp/configure
index 6f25c6f5eb9..cdaf3720209 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -5381,6 +5381,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9006,6 +9012,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libiberty/configure b/libiberty/configure
index bdabe8d1a35..1304e0a6106 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -4850,6 +4850,7 @@ esac
 if [ "${shared}" = "yes" ]; then
   case "${host}" in
     *-*-cygwin*)	;;
+    *-*-mint*)		;;
     alpha*-*-linux*)	PICFLAG=-fPIC ;;
     arm*-*-*)		PICFLAG=-fPIC ;;
     hppa*-*-*)		PICFLAG=-fPIC ;;
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index 9f1ff04938e..df4a9d75b2c 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -201,6 +201,7 @@ esac
 if [[ "${shared}" = "yes" ]]; then
   case "${host}" in
     *-*-cygwin*)	;;
+    *-*-mint*)		;;
     alpha*-*-linux*)	PICFLAG=-fPIC ;;
     arm*-*-*)		PICFLAG=-fPIC ;;
     hppa*-*-*)		PICFLAG=-fPIC ;;
diff --git a/libiberty/hex.c b/libiberty/hex.c
index 5eeafdbd158..696d914e776 100644
--- a/libiberty/hex.c
+++ b/libiberty/hex.c
@@ -24,7 +24,7 @@ Boston, MA 02110-1301, USA.  */
 #include "libiberty.h"
 #include "safe-ctype.h" /* for HOST_CHARSET_ASCII */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "hex.c requires EOF == -1"
 #endif
 
diff --git a/libiberty/safe-ctype.c b/libiberty/safe-ctype.c
index 0972b4b354f..7418139d325 100644
--- a/libiberty/safe-ctype.c
+++ b/libiberty/safe-ctype.c
@@ -119,7 +119,7 @@ sets of characters:
 #include <safe-ctype.h>
 #include <stdio.h>  /* for EOF */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "<safe-ctype.h> requires EOF == -1"
 #endif
 
diff --git a/libjava/classpath/configure b/libjava/classpath/configure
index a25f5f75a47..309fc328cdd 100755
--- a/libjava/classpath/configure
+++ b/libjava/classpath/configure
@@ -6376,6 +6376,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9708,6 +9714,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libjava/configure b/libjava/configure
index d660561801d..86ff1e7a7f6 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -7613,6 +7613,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -11243,6 +11249,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libjava/libltdl/configure b/libjava/libltdl/configure
index 35b89dc5551..f10b8012781 100755
--- a/libjava/libltdl/configure
+++ b/libjava/libltdl/configure
@@ -5502,6 +5502,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
diff --git a/libmudflap/configure b/libmudflap/configure
index 441299f6552..bf52b149c1c 100755
--- a/libmudflap/configure
+++ b/libmudflap/configure
@@ -5153,6 +5153,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8507,6 +8513,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libmudflap/mf-hooks2.c b/libmudflap/mf-hooks2.c
index 5649e1c5882..1eea4cd544d 100644
--- a/libmudflap/mf-hooks2.c
+++ b/libmudflap/mf-hooks2.c
@@ -1668,6 +1668,8 @@ WRAPPER2(int, system, const char *string)
 }
 
 
+#ifdef HAVE_DLFCN_H
+
 WRAPPER2(void *, dlopen, const char *path, int flags)
 {
   void *p;
@@ -1735,6 +1737,8 @@ WRAPPER2(void *, dlsym, void *handle, char *symbol)
   return p;
 }
 
+#endif /* HAVE_DLFCN_H */
+
 
 #if defined (HAVE_SYS_IPC_H) && defined (HAVE_SYS_SEM_H) && defined (HAVE_SYS_SHM_H)
 
diff --git a/libmudflap/mf-runtime.h b/libmudflap/mf-runtime.h
index 4c512d5a690..662180fe28a 100644
--- a/libmudflap/mf-runtime.h
+++ b/libmudflap/mf-runtime.h
@@ -97,6 +97,7 @@ extern int __mf_set_options (const char *opts);
    instrumented modules are meant to be affected.  */
 
 #ifdef _MUDFLAP
+#ifndef __USER_LABEL_PREFIX__
 #pragma redefine_extname memcpy __mfwrap_memcpy
 #pragma redefine_extname memmove __mfwrap_memmove
 #pragma redefine_extname memset __mfwrap_memset
@@ -230,6 +231,141 @@ extern int __mf_set_options (const char *opts);
 #pragma redefine_extname getprotoent __mfwrap_getprotoent
 #pragma redefine_extname getprotobyname __mfwrap_getprotobyname
 #pragma redefine_extname getprotobynumber __mfwrap_getprotobynumber
+#else
+#pragma redefine_extname memcpy ___mfwrap_memcpy
+#pragma redefine_extname memmove ___mfwrap_memmove
+#pragma redefine_extname memset ___mfwrap_memset
+#pragma redefine_extname memcmp ___mfwrap_memcmp
+#pragma redefine_extname memchr ___mfwrap_memchr
+#pragma redefine_extname memrchr ___mfwrap_memrchr
+#pragma redefine_extname strcpy ___mfwrap_strcpy
+#pragma redefine_extname strncpy ___mfwrap_strncpy
+#pragma redefine_extname strcat ___mfwrap_strcat
+#pragma redefine_extname strncat ___mfwrap_strncat
+#pragma redefine_extname strcmp ___mfwrap_strcmp
+#pragma redefine_extname strcasecmp ___mfwrap_strcasecmp
+#pragma redefine_extname strncmp ___mfwrap_strncmp
+#pragma redefine_extname strncasecmp ___mfwrap_strncasecmp
+#pragma redefine_extname strdup ___mfwrap_strdup
+#pragma redefine_extname strndup ___mfwrap_strndup
+#pragma redefine_extname strchr ___mfwrap_strchr
+#pragma redefine_extname strrchr ___mfwrap_strrchr
+#pragma redefine_extname strstr ___mfwrap_strstr
+#pragma redefine_extname memmem ___mfwrap_memmem
+#pragma redefine_extname strlen ___mfwrap_strlen
+#pragma redefine_extname strnlen ___mfwrap_strnlen
+#pragma redefine_extname bzero ___mfwrap_bzero
+#pragma redefine_extname bcopy ___mfwrap_bcopy
+#pragma redefine_extname bcmp ___mfwrap_bcmp
+#pragma redefine_extname index ___mfwrap_index
+#pragma redefine_extname rindex ___mfwrap_rindex
+#pragma redefine_extname asctime ___mfwrap_asctime
+#pragma redefine_extname ctime ___mfwrap_ctime
+#pragma redefine_extname gmtime ___mfwrap_gmtime
+#pragma redefine_extname localtime ___mfwrap_localtime
+#pragma redefine_extname time ___mfwrap_time
+#pragma redefine_extname strerror ___mfwrap_strerror
+#pragma redefine_extname fopen ___mfwrap_fopen
+#pragma redefine_extname fdopen ___mfwrap_fdopen
+#pragma redefine_extname freopen ___mfwrap_freopen
+#pragma redefine_extname fclose ___mfwrap_fclose
+#pragma redefine_extname fread ___mfwrap_fread
+#pragma redefine_extname fwrite ___mfwrap_fwrite
+#pragma redefine_extname fgetc ___mfwrap_fgetc
+#pragma redefine_extname fgets ___mfwrap_fgets
+#pragma redefine_extname getc ___mfwrap_getc
+#pragma redefine_extname gets ___mfwrap_gets
+#pragma redefine_extname ungetc ___mfwrap_ungetc
+#pragma redefine_extname fputc ___mfwrap_fputc
+#pragma redefine_extname fputs ___mfwrap_fputs
+#pragma redefine_extname putc ___mfwrap_putc
+#pragma redefine_extname puts ___mfwrap_puts
+#pragma redefine_extname clearerr ___mfwrap_clearerr
+#pragma redefine_extname feof ___mfwrap_feof
+#pragma redefine_extname ferror ___mfwrap_ferror
+#pragma redefine_extname fileno ___mfwrap_fileno
+#pragma redefine_extname printf ___mfwrap_printf
+#pragma redefine_extname fprintf ___mfwrap_fprintf
+#pragma redefine_extname sprintf ___mfwrap_sprintf
+#pragma redefine_extname snprintf ___mfwrap_snprintf
+#pragma redefine_extname vprintf ___mfwrap_vprintf
+#pragma redefine_extname vfprintf ___mfwrap_vfprintf
+#pragma redefine_extname vsprintf ___mfwrap_vsprintf
+#pragma redefine_extname vsnprintf ___mfwrap_vsnprintf
+#pragma redefine_extname access ___mfwrap_access
+#pragma redefine_extname remove ___mfwrap_remove
+#pragma redefine_extname fflush ___mfwrap_fflush
+#pragma redefine_extname fseek ___mfwrap_fseek
+#pragma redefine_extname ftell ___mfwrap_ftell
+#pragma redefine_extname rewind ___mfwrap_rewind
+#pragma redefine_extname fgetpos ___mfwrap_fgetpos
+#pragma redefine_extname fsetpos ___mfwrap_fsetpos
+#pragma redefine_extname stat ___mfwrap_stat
+#pragma redefine_extname fstat ___mfwrap_fstat
+#pragma redefine_extname lstat ___mfwrap_lstat
+#pragma redefine_extname mkfifo ___mfwrap_mkfifo
+#pragma redefine_extname setvbuf ___mfwrap_setvbuf
+#pragma redefine_extname setbuf ___mfwrap_setbuf
+#pragma redefine_extname setbuffer ___mfwrap_setbuffer
+#pragma redefine_extname setlinebuf ___mfwrap_setlinebuf
+#pragma redefine_extname opendir ___mfwrap_opendir
+#pragma redefine_extname closedir ___mfwrap_closedir
+#pragma redefine_extname readdir ___mfwrap_readdir
+#pragma redefine_extname recv ___mfwrap_recv
+#pragma redefine_extname recvfrom ___mfwrap_recvfrom
+#pragma redefine_extname recvmsg ___mfwrap_recvmsg
+#pragma redefine_extname send ___mfwrap_send
+#pragma redefine_extname sendto ___mfwrap_sendto
+#pragma redefine_extname sendmsg ___mfwrap_sendmsg
+#pragma redefine_extname setsockopt ___mfwrap_setsockopt
+#pragma redefine_extname getsockopt ___mfwrap_getsockopt
+#pragma redefine_extname accept ___mfwrap_accept
+#pragma redefine_extname bind ___mfwrap_bind
+#pragma redefine_extname connect ___mfwrap_connect
+#pragma redefine_extname gethostname ___mfwrap_gethostname
+#pragma redefine_extname sethostname ___mfwrap_sethostname
+#pragma redefine_extname gethostbyname ___mfwrap_gethostbyname
+#pragma redefine_extname wait ___mfwrap_wait
+#pragma redefine_extname waitpid ___mfwrap_waitpid
+#pragma redefine_extname popen ___mfwrap_popen
+#pragma redefine_extname pclose ___mfwrap_pclose
+#pragma redefine_extname execve ___mfwrap_execve
+#pragma redefine_extname execv ___mfwrap_execv
+#pragma redefine_extname execvp ___mfwrap_execvp
+#pragma redefine_extname system ___mfwrap_system
+#pragma redefine_extname dlopen ___mfwrap_dlopen
+#pragma redefine_extname dlerror ___mfwrap_dlerror
+#pragma redefine_extname dlsym ___mfwrap_dlsym
+#pragma redefine_extname dlclose ___mfwrap_dlclose
+#pragma redefine_extname fopen64 ___mfwrap_fopen64
+#pragma redefine_extname freopen64 ___mfwrap_freopen64
+#pragma redefine_extname stat64 ___mfwrap_stat64
+#pragma redefine_extname fseeko64 ___mfwrap_fseeko64
+#pragma redefine_extname ftello64 ___mfwrap_ftello64
+#pragma redefine_extname semop ___mfwrap_semop
+#pragma redefine_extname semctl ___mfwrap_semctl
+#pragma redefine_extname shmctl ___mfwrap_shmctl
+#pragma redefine_extname shmat ___mfwrap_shmat
+#pragma redefine_extname shmdt ___mfwrap_shmdt
+#pragma redefine_extname __ctype_b_loc ___mfwrap___ctype_b_loc
+#pragma redefine_extname __ctype_toupper_loc ___mfwrap___ctype_toupper_loc
+#pragma redefine_extname __ctype_tolower_loc ___mfwrap___ctype_tolower_loc
+#pragma redefine_extname getlogin ___mfwrap_getlogin
+#pragma redefine_extname cuserid ___mfwrap_cuserid
+#pragma redefine_extname getpwnam ___mfwrap_getpwnam
+#pragma redefine_extname getpwuid ___mfwrap_getpwuid
+#pragma redefine_extname getgrnam ___mfwrap_getgrnam
+#pragma redefine_extname getgrgid ___mfwrap_getgrgid
+#pragma redefine_extname getservent ___mfwrap_getservent
+#pragma redefine_extname getservbyname ___mfwrap_getservbyname
+#pragma redefine_extname getservbyport ___mfwrap_getservbyport
+#pragma redefine_extname gai_strerror ___mfwrap_gai_strerror
+#pragma redefine_extname getmntent ___mfwrap_getmntent
+#pragma redefine_extname inet_ntoa ___mfwrap_inet_ntoa
+#pragma redefine_extname getprotoent ___mfwrap_getprotoent
+#pragma redefine_extname getprotobyname ___mfwrap_getprotobyname
+#pragma redefine_extname getprotobynumber ___mfwrap_getprotobynumber
+#endif
 
 /* Disable glibc macros.  */
 #define __NO_STRING_INLINES
diff --git a/libobjc/configure b/libobjc/configure
index e6f0afdfa3b..59e4a5fea2a 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -4812,6 +4812,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8480,6 +8486,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libquadmath/configure b/libquadmath/configure
index 9d979337d18..fc45ba2710c 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -8410,6 +8410,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libssp/configure b/libssp/configure
index bd3f5662c4b..53a3ac87a1b 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -5185,6 +5185,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8547,6 +8553,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/libssp/ssp.c b/libssp/ssp.c
index aaa5a322c8d..886dd8160d3 100644
--- a/libssp/ssp.c
+++ b/libssp/ssp.c
@@ -63,6 +63,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef HAVE_SYSLOG_H
 # include <syslog.h>
 #endif
+#ifdef __MINT__
+#include <mint/osbind.h>
+#endif
 
 void *__stack_chk_guard = 0;
 
@@ -98,6 +101,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
 {
 #ifdef __GNU_LIBRARY__
   extern char * __progname;
+#elif defined (__MINT__)
+  extern char * program_invocation_short_name;
+  #define __progname program_invocation_short_name
 #else
   static const char __progname[] = "";
 #endif
@@ -139,6 +145,9 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
     syslog (LOG_CRIT, msg3);
 #endif /* HAVE_SYSLOG_H */
 
+#ifdef __MINT__
+    Pterm(127);
+#else
   /* Try very hard to exit.  Note that signals may be blocked preventing
      the first two options from working.  The use of volatile is here to
      prevent optimizers from "knowing" that __builtin_trap is called first,
@@ -160,6 +169,7 @@ fail (const char *msg1, size_t msg1len, const char *msg3)
           break;
         }
   }
+#endif
 }
 
 void
diff --git a/libstdc++-v3/config/os/mint/ctype_base.h b/libstdc++-v3/config/os/mint/ctype_base.h
new file mode 100644
index 00000000000..d6b3ec7d56a
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_base.h
@@ -0,0 +1,67 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+//  We don't use the C-locale masks defined in usr/include/ctype.h
+//  because those masks do not conform to the requirements of 22.2.1.
+//  In particular, a separate 'print' bitmask does not exist (isprint(c)
+//  relies on a combination of flags) and the  '_ALPHA' mask is also a
+//  combination of simple bitmasks.  Thus, we define libstdc++-specific
+//  masks here, based on the generic masks, and the corresponding
+//  classic_table in ctype_noninline.h.
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned short 	mask;   
+    static const mask upper	= 1 << 0;
+    static const mask lower	= 1 << 1;
+    static const mask alpha	= 1 << 2;
+    static const mask digit	= 1 << 3;
+    static const mask xdigit	= 1 << 4;
+    static const mask space	= 1 << 5;
+    static const mask print	= 1 << 6;
+    static const mask graph	= (1 << 2) | (1 << 3) | (1 << 9);  // alnum|punct
+    static const mask cntrl	= 1 << 8;
+    static const mask punct 	= 1 << 9;
+    static const mask alnum	= (1 << 2) | (1 << 3);  // alpha|digit
+#if __cplusplus >= 201103L
+    static const mask blank	= 1 << 10;
+#endif
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_inline.h b/libstdc++-v3/config/os/mint/ctype_inline.h
new file mode 100644
index 00000000000..586c2aeab3e
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_inline.h
@@ -0,0 +1,75 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2016 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }
+
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    while (__low < __high)
+      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && !this->is(__m, *__low))
+      ++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && this->is(__m, *__low) != 0)
+      ++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/mint/ctype_noninline.h b/libstdc++-v3/config/os/mint/ctype_noninline.h
new file mode 100644
index 00000000000..30045899f76
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/ctype_noninline.h
@@ -0,0 +1,92 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2009, 2010
+//  Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_noninline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+  
+// Information as gleaned from /usr/include/ctype.h
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  { return 0; }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del, 
+		     size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table()) 
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table())
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return ::toupper((int) __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::toupper((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return ::tolower((int) __c); }
+
+  const char* 
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::tolower((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
diff --git a/libstdc++-v3/config/os/mint/os_defines.h b/libstdc++-v3/config/os/mint/os_defines.h
new file mode 100644
index 00000000000..3199bf30bb3
--- /dev/null
+++ b/libstdc++-v3/config/os/mint/os_defines.h
@@ -0,0 +1,36 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000, 2009, 2010 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+#endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 84b6ea94a01..e9478a0b373 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -5890,6 +5890,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -9381,6 +9387,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
@@ -11207,6 +11217,11 @@ else
     lt_cv_dlopen_libs=
     ;;
 
+  mint*)
+    lt_cv_dlopen="no"
+    lt_cv_dlopen_libs=
+    ;;
+
   darwin*)
   # if libdl is installed we need to link against it
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
@@ -44718,7 +44733,7 @@ $as_echo "#define HAVE_TLS 1" >>confdefs.h
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-mint*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
diff --git a/libstdc++-v3/configure.host b/libstdc++-v3/configure.host
index e29404c026f..123dea6a0ff 100644
--- a/libstdc++-v3/configure.host
+++ b/libstdc++-v3/configure.host
@@ -258,6 +258,10 @@ case "${host_os}" in
     error_constants_dir="os/mingw32"
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
+  mint*)
+    SECTION_FLAGS="${SECTION_FLAGS} -D_GNU_SOURCE"
+    os_include_dir="os/mint"
+    ;;
   netbsd*)
     os_include_dir="os/bsd/netbsd"
     ;;
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index 2d0a4a83ded..2964c93cd25 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -141,7 +141,7 @@ case "${host}" in
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-knetbsd*-gnu | *-mint*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
diff --git a/libtool.m4 b/libtool.m4
index 67321a7d070..c4d4b98e3c2 100644
--- a/libtool.m4
+++ b/libtool.m4
@@ -1500,6 +1500,12 @@ AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
     # This has been around since 386BSD, at least.  Likely further.
     if test -x /sbin/sysctl; then
diff --git a/lto-plugin/configure b/lto-plugin/configure
index 48b414e99f7..4a4ea507b91 100755
--- a/lto-plugin/configure
+++ b/lto-plugin/configure
@@ -8462,6 +8462,10 @@ _LT_EOF
       hardcode_shlibpath_var=no
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     *)
       if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
diff --git a/zlib/configure b/zlib/configure
index f7fe2b7bd51..b0392e1c5ff 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -4652,6 +4652,12 @@ else
     lt_cv_sys_max_cmd_len=8192;
     ;;
 
+  mint*)
+    # On MiNT this test can take minutes to run, and I'm not sure it's
+    # healthy for this platform. Let's restrict it to 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
   amigaos*)
     # On AmigaOS with pdksh, this test takes hours, literally.
     # So we just punt and use a minimum line length of 8192.
@@ -8276,6 +8282,10 @@ _LT_EOF
       esac
       ;;
 
+    mint*)
+      ld_shlibs=no
+      ;;
+
     sunos4*)
       archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
       wlarc=
