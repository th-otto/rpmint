diff -aurN gdb-5.1/bfd/Makefile.am gdb-5.1-mint-20081102/bfd/Makefile.am
--- gdb-5.1/bfd/Makefile.am	2001-07-24 11:59:53.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/Makefile.am	2008-11-02 14:44:24.265625000 +0100
@@ -258,6 +258,7 @@
 	pei-mips.lo \
 	peigen.lo \
 	ppcboot.lo \
+	prg-mint.lo \
 	reloc16.lo \
 	riscix.lo \
 	sparclinux.lo \
@@ -396,6 +397,7 @@
 	pe-mips.c \
 	pei-mips.c \
 	ppcboot.c \
+	prg-mint.c \
 	reloc16.c \
 	riscix.c \
 	sparclinux.c \
diff -aurN gdb-5.1/bfd/acinclude.m4 gdb-5.1-mint-20081102/bfd/acinclude.m4
--- gdb-5.1/bfd/acinclude.m4	2000-08-31 11:35:50.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/acinclude.m4	2008-11-02 14:44:24.265625000 +0100
@@ -3,7 +3,7 @@
 [AC_REQUIRE([AC_CANONICAL_SYSTEM])
 case "${host}" in
 changequote(,)dnl
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 changequote([,])dnl
   AC_DEFINE(USE_BINARY_FOPEN, 1, [Use b modifier when opening binary files?]) ;;
 esac])dnl
diff -aurN gdb-5.1/bfd/aoutx.h gdb-5.1-mint-20081102/bfd/aoutx.h
--- gdb-5.1/bfd/aoutx.h	2001-06-13 09:58:05.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/aoutx.h	2008-11-02 14:44:24.296875000 +0100
@@ -1916,6 +1916,11 @@
 {
   bfd_byte buffer[BYTES_IN_WORD];
 
+  /* The MiNT backend writes past the string table.  It therefore has to
+     know about the table size.  */
+  obj_aout_external_string_size (abfd) = _bfd_stringtab_size (tab) +
+    BYTES_IN_WORD;
+
   /* The string table starts with the size.  */
   PUT_WORD (abfd, _bfd_stringtab_size (tab) + BYTES_IN_WORD, buffer);
   if (bfd_write ((PTR) buffer, 1, BYTES_IN_WORD, abfd) != BYTES_IN_WORD)
diff -aurN gdb-5.1/bfd/bfd-in.h gdb-5.1-mint-20081102/bfd/bfd-in.h
--- gdb-5.1/bfd/bfd-in.h	2001-06-19 00:05:10.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/bfd-in.h	2008-11-02 14:44:24.312500000 +0100
@@ -681,6 +681,10 @@
 extern boolean bfd_sparclinux_size_dynamic_sections
   PARAMS ((bfd *, struct bfd_link_info *));
 
+/* MiNT routine to set the special flags in exec header.  */
+extern boolean bfd_m68kmint_set_extended_flags
+  PARAMS ((bfd *, flagword));
+
 /* mmap hacks */
 
 struct _bfd_window_internal;
diff -aurN gdb-5.1/bfd/config.bfd gdb-5.1-mint-20081102/bfd/config.bfd
--- gdb-5.1/bfd/config.bfd	2001-06-08 08:21:29.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/config.bfd	2008-11-02 14:44:24.328125000 +0100
@@ -541,6 +541,11 @@
     targ_defvec=m68klynx_coff_vec
     targ_selvecs=m68klynx_aout_vec
     ;;
+  m68*-*-mint*)
+    targ_defvec=aout0_big_vec
+    targ_selvecs=m68kmint_prg_vec
+    targ_underscore=yes
+    ;;
   m68*-hp*-netbsd*)
     targ_defvec=m68k4knetbsd_vec
     targ_selvecs="m68knetbsd_vec hp300bsd_vec sunos_big_vec"
diff -aurN gdb-5.1/bfd/configure gdb-5.1-mint-20081102/bfd/configure
--- gdb-5.1/bfd/configure	2001-10-31 03:30:22.000000000 +0100
+++ gdb-5.1-mint-20081102/bfd/configure	2008-11-02 14:44:24.375000000 +0100
@@ -4737,7 +4737,7 @@
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
   cat >> confdefs.h <<\EOF
 #define USE_BINARY_FOPEN 1
 EOF
@@ -6035,6 +6035,7 @@
     m68klinux_vec)		tb="$tb m68klinux.lo aout32.lo" ;;
     m68klynx_aout_vec)		tb="$tb m68klynx.lo lynx-core.lo aout32.lo" ;;
     m68klynx_coff_vec)		tb="$tb cf-m68klynx.lo coff-m68k.lo cofflink.lo lynx-core.lo" ;;
+    m68kmint_prg_vec)           tb="$tb prg-mint.lo aout32.lo" ;;
     m68knetbsd_vec)		tb="$tb m68knetbsd.lo aout32.lo" ;;
     m68k4knetbsd_vec)		tb="$tb m68k4knetbsd.lo aout32.lo" ;;
     m68kaux_coff_vec)		tb="$tb coff-aux.lo coff-m68k.lo cofflink.lo" ;;
diff -aurN gdb-5.1/bfd/configure.in gdb-5.1-mint-20081102/bfd/configure.in
--- gdb-5.1/bfd/configure.in	2001-05-26 00:50:27.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/configure.in	2008-11-02 14:44:24.406250000 +0100
@@ -606,6 +606,7 @@
     m68klinux_vec)		tb="$tb m68klinux.lo aout32.lo" ;;
     m68klynx_aout_vec)		tb="$tb m68klynx.lo lynx-core.lo aout32.lo" ;;
     m68klynx_coff_vec)		tb="$tb cf-m68klynx.lo coff-m68k.lo cofflink.lo lynx-core.lo" ;;
+    m68kmint_prg_vec)           tb="$tb prg-mint.lo aout32.lo" ;;
     m68knetbsd_vec)		tb="$tb m68knetbsd.lo aout32.lo" ;;
     m68k4knetbsd_vec)		tb="$tb m68k4knetbsd.lo aout32.lo" ;;
     m68kaux_coff_vec)		tb="$tb coff-aux.lo coff-m68k.lo cofflink.lo" ;;
diff -aurN gdb-5.1/bfd/libaout.h gdb-5.1-mint-20081102/bfd/libaout.h
--- gdb-5.1/bfd/libaout.h	2001-03-08 22:04:01.000000000 +0100
+++ gdb-5.1-mint-20081102/bfd/libaout.h	2008-11-02 14:44:24.421875000 +0100
@@ -392,6 +392,10 @@
      table, used when linking on SunOS.  This is indexed by the symbol
      index.  */
   bfd_vma *local_got_offsets;
+
+  /* A pointer for data used by aout extensions.  (Currently only used
+     by MiNT executables (see prg-mint.c).  */
+  PTR ext;
 };
 
 struct  aout_data_struct {
@@ -418,6 +422,7 @@
 #define obj_aout_string_window(bfd) (adata(bfd).string_window)
 #define obj_aout_sym_hashes(bfd) (adata(bfd).sym_hashes)
 #define obj_aout_dynamic_info(bfd) (adata(bfd).dynamic_info)
+#define obj_aout_ext(bfd)	(adata(bfd).ext)
 
 /* We take the address of the first element of an asymbol to ensure that the
    macro is only ever applied to an asymbol */
diff -aurN gdb-5.1/bfd/prg-mint.c gdb-5.1-mint-20081102/bfd/prg-mint.c
--- gdb-5.1/bfd/prg-mint.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/bfd/prg-mint.c	2008-11-02 14:44:24.437500000 +0100
@@ -0,0 +1,1619 @@
+/* BFD backend for traditional MiNT executables.
+   Copyright 1998, 2000 Free Software Foundation, Inc.
+   Written by Guido Flohr (guido@imperia.net).
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* The format of executables on Atari is actually not a.out,  it is
+   only chosen as an approach which comes close enough.  The layout of a
+   program image on disk looked like this:
+
+   +-----------------+
+   | 28 Bytes Header |
+   +-----------------+
+   | Text segment    |
+   +-----------------+
+   | Data segment    |
+   +-----------------+
+   | BSS             |
+   +-----------------+
+   | Symbol table    |
+   +-----------------+
+   | TPA relocation  |
+   +-----------------+
+
+   The 28 byte exec header used to look like this:
+
+   struct old_exec_header {
+     bfd_byte a_magic[2];
+     bfd_byte a_text[4];
+     bfd_byte a_data[4];
+     bfd_byte a_bss[4];
+     bfd_byte a_syms[4];
+     bfd_byte a_resvd[4];
+     bfd_byte a_abs[2];
+   };
+  
+   The first two bytes (A_MAGIC) contained an assembler branch
+   instruction to the beginning of the text segment.  Because the
+   exec header had a fixed size and the text entry point was constant
+   this assembler instruction also had a constant value (0x601a).
+   In fact the operating system never really executed the branch
+   instruction but used this value (0x601a) as a magic value.
+
+   TEXT, DATA and BSS were as one would expect them.  The symbol
+   table wasn't.  Several different formats were in use, none of them
+   very efficient, none of them powerful enough to support source
+   level debugging.  I've changed that and the GNU symbol table will
+   now be used instead (unless the --traditional-format option was
+   given to the linker).
+
+   If the last member A_ABS of the exec header is zero the program
+   image contains an additional table with relocation information
+   at the end of the image.  The kernel can load program images at 
+   virtually any address in the address space.  In fact it will load
+   it at the start of the biggest block of free memory.  This block
+   is then called the Transient Program Area TPA and the image has
+   to be relocated against the TPA at runtime.  The relocation info
+   itself is in a simply way compressed:  It starts with a four-byte
+   value, the first address within the image to be relocated.  Now
+   following are one-byte offsets to the last address.  The special
+   value of 1 (which is impossible as an offset) signifies that 254
+   has to be added to the next offset.  The table is finished with
+   a zero-byte.
+
+   I now simply extended the header from its old 28 bytes to 256
+   bytes.  The first 28 bytes give home to a standard Atari header,
+   the rest is for extensions.  The extension header starts with
+   a ``real'' assembler instsruction, a far jump to the text entry
+   point.  The extension header gives home to a standard a.out
+   exec header (currently NMAGIC or OMAGIC only) plus some extra
+   more or less useful fields plus space to future extensions.
+   For the OS the extension header will already belong to the text
+   segment, for BFD backends the text segment is 228 (or 0xe4)
+   bytes smaller than for the OS.  This explains for example the
+   funny TEXT_START_ADDR 0xe4.
+
+   The TARGET_PAGE_SIZE is 2 which is only fake.  There is currently
+   no such thing as memory paging on the Atari (and this is why
+   ZMAGICs are disabled for now to allow for future enhancements).
+
+   If you think that this whole file looks quite like a big hack 
+   you're probably right.  But the results (mainly the output of
+   the linker) seem to work and they allow to use up-to-date
+   binutils on the Atari until a better executable format (maybe
+   ELF) has been established for this machine.  */
+
+#define N_HEADER_IN_TEXT(x) 0
+#define BYTES_IN_WORD 4
+#define ENTRY_CAN_BE_ZERO
+#define N_SHARED_LIB(x) 0 /* Avoids warning.  */
+#define TEXT_START_ADDR 0xe4  
+#define TARGET_PAGE_SIZE 2
+#define SEGMENT_SIZE TARGET_PAGE_SIZE
+#define TARGET_IS_BIG_ENDIAN_P
+#define DEFAULT_ARCH bfd_arch_m68k
+#define N_TXTADDR(x) TEXT_START_ADDR
+
+#define MY(OP) CAT(m68kmint_prg_,OP)
+#define TARGETNAME "a.out-mintprg"
+
+#define NAME(x,y) CAT3(mintprg,_32_,y)
+
+/* The only location that the macro ZMAGIC_DISK_BLOCK_SIZE seems to
+   be needed is in aout-target.h where the file position of the text
+   segment is determined.  Our target page size of 2 is actually just a
+   joke (no paging on Atari, we simply short-word-align sections) so
+   we have to explicitely tell aout-target here.  Nonetheless, this
+   doesn't seem clean to me.  Does aoutx.h (adjust_n_magic) has to
+   be modified?  */
+#define ZMAGIC_DISK_BLOCK_SIZE EXEC_BYTES_SIZE
+
+/* If --traditional-format was given to the linker an old-style DRI
+   symbol table is written into the executable.  This is with respect 
+   to many old debugging tools or disassemblers which expect this format.  
+   Although created by the linker, these executables will not be recognized
+   as a valid bfd input file.  It is too much effort to evaluate the
+   symbols from such files.  */
+#define _MINT_SYMBOL_FORMAT_GNU  0
+#define _MINT_SYMBOL_FORMAT_DRI  1
+
+#include "bfd.h"
+#include "sysdep.h"
+
+#include <libiberty.h>
+
+     /* Forward declarations.  */
+struct internal_exec;
+struct external_exec;
+struct aout_final_link_info;
+struct bfd_link_info;
+struct reloc_std_external;
+
+/* Data structure that holds some private information for us.  */
+struct mint_internal_info {
+  struct bfd_link_info* linkinfo;    /* Remembered from final_link.  */
+  boolean       traditional_format;  /* Saved from link info.  */
+  int           symbol_format;       /* Format of the symbol table.  */
+  PTR           tparel;              /* Data for TPA relative relocation
+                                        information.  */
+  file_ptr      tparel_pos;          /* File position of TPA relative
+					relocation information.  */
+  bfd_size_type tparel_size;         /* Size of TPA relative relocation
+					information.  */
+  bfd_size_type symtab_size;         /* Size of traditional symbol table.  */
+
+#define MINT_RELOC_CHUNKSIZE 0x1000
+  bfd_vma*      relocs;              /* Array of address relocations.  */
+  unsigned long relocs_used;         /* Number of relocation entries 
+                                        already used up.  */
+  unsigned long relocs_allocated;    /* Number of relocation entries
+                                        allocated.  */
+
+  bfd_vma       stkpos;              /* File offset to value of _stksize.  */
+
+  flagword      prg_flags;           /* Standard GEMDOS flags.  */
+
+  boolean       reloc_error;         /* True if an unhandled error during
+					relocation occured.  */
+};
+
+/* We have to do quite a lot of magic to make the Atari format
+   for GEMDOS executables fit into the standard a.out format.
+   We start with the original header.  */
+#define external_exec external_exec
+struct external_exec {
+  bfd_byte g_branch[2];              /* 0x601a (or 0xdead for relocatable
+				        linker output).  */
+  bfd_byte g_text[4];                /* Length of text section.  */
+  bfd_byte g_data[4];                /* Length of data section.  */
+  bfd_byte g_bss[4];                 /* Length of bss section.  */
+  bfd_byte g_syms[4];                /* Length of symbol table.  */
+  bfd_byte g_extmagic[4];            /* Always 0x4d694e54
+					(in ASCII: ``MiNT'').  */
+  bfd_byte g_flags[4];               /* Atari special flags.  */
+  bfd_byte g_abs[2];                 /* Non-zero if absolute (no relocation
+                                        info.  */
+  
+  /* We extend this header now to provide the information that the
+     binutils want to see.  Everything following will actually be part
+     of the text segment (from MiNT's point of view).  As a
+     consequence the text section has 228 bytes of redundancy.
+
+     The following eight bytes should be treated as opaque.
+     If the word ``opaque'' always attracts your curiosity in
+     typedefs and structs, here's the explanation:  These eight bytes
+     are really two assembler instructions.  The first one moves
+     the contents of e_entry into register d4, the second one
+     jumps (pc-relative) to the entry point.  See swap_exec_header_out
+     for details.  */
+  bfd_byte g_jump_entry[8];
+
+  /* Now following a standard a.out header.  Note that the values
+     may differ from the one given on top.  The traditional header
+     contains the values that the OS wants to see, the values below
+     are the values that make the binutils work.  */
+  bfd_byte e_info[4];                /* Magic number and stuff.  */
+  bfd_byte e_text[4];                /* Length of text section in bytes.  */
+  bfd_byte e_data[4];                /* Length of data section.  */
+  bfd_byte e_bss[4];                 /* Length of standard symbol 
+					table.  */
+  bfd_byte e_syms[4];                /* Length of symbol table.  */
+  bfd_byte e_entry[4];               /* Start address.  */
+  bfd_byte e_trsize[4];              /* Length of text relocation
+                                        info.  */
+  bfd_byte e_drsize[4];              /* Length of data relocation
+					info.  */
+
+  bfd_byte g_tparel_pos[4];          /* File position of TPA relative
+					relocation info.  */
+  bfd_byte g_tparel_size[4];         /* Length of TPA relative relocation
+					info.  */
+
+  /* This is for extensions.  */
+  bfd_byte g_stkpos[4];              /* If stacksize is hardcoded into
+                                        the executable you will find it
+					at file offset g_stkpos.  If
+					not this is NULL.  */
+
+  bfd_byte g_symbol_format[4];       /* Format of the symbol table.  See
+                                        definitions for _MINT_SYMBOL_FORMAT*
+                                        above.  */
+                                     
+  /* Pad with zeros.  */
+  bfd_byte g_pad0[172];
+};
+
+#define EXEC_BYTES_SIZE 256
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+
+#ifndef N_BADMAG
+# define N_BADMAG(e) (N_MAGIC (e) != OMAGIC && \
+		      N_MAGIC (e) != NMAGIC && \
+		      N_MAGIC (e) != ZMAGIC)
+#endif
+
+     /* For DRI symbol table format.  */
+struct dri_symbol {
+  bfd_byte a_name[8];     /* Symbol name */
+  bfd_byte a_type[2];     /* Type flag, i.e. A_TEXT etc; see below.  */
+  bfd_byte a_value[4];    /* value of this symbol (or sdb offset).  */
+};
+#define DRI_SYMBOL_SIZE 14
+
+/* Simple values for a_type.  */
+#define A_UNDF  0             
+#define A_BSS   0x0100      
+#define A_TEXT  0x0200       
+#define A_DATA  0x0400        
+#define A_EXT   0x0800        /* External.  */
+#define A_EQREG 0x1000        /* Equated register.  */
+#define A_GLOBL 0x2000        /* Global.  */
+#define A_EQU   0x4000        /* Equated.  */
+#define A_DEF   0x8000        /* Defined.  */
+#define A_LNAM  0x0048        /* GST compatible long name.  */
+                              /* File symbols ala aln.  */
+#define A_TFILE 0x0280        /* Text file corresponding to object module.  */
+#define A_TFARC 0x02C0        /* Text file archive.  Unfortunately this
+			         conflicts with the bits in A_LNAM.  */
+
+
+#define MY_object_p MY_object_p
+#define MY_BFD_TARGET MY_bfd_target
+#define MY_get_section_contents _bfd_generic_get_section_contents
+#define MY_bfd_final_link MY_bfd_final_link
+#define MY_bfd_free_cached_info MY_bfd_free_cached_info
+#define MY_close_and_cleanup MY_bfd_free_cached_info
+#define MY_bfd_copy_private_bfd_data MY_bfd_copy_private_bfd_data
+
+static const bfd_target* MY_object_p PARAMS ((bfd*));
+
+/* This is a hack.  We have to retrieve the symbol name.  But
+   to do achieve this with reasonable effort we need an extra
+   parameter.   */
+#define MY_final_link_relocate(howto, ibfd, isec, contents, \
+			       address, value, addend) \
+m68kmint_prg_final_link_relocate (howto, ibfd, isec, contents, \
+				  address, value, addend, \
+				  (struct reloc_std_external*) rel)
+
+bfd_reloc_status_type m68kmint_prg_final_link_relocate
+     PARAMS ((reloc_howto_type*, bfd*, asection*, bfd_byte*, bfd_vma,
+	      bfd_vma, bfd_vma, struct reloc_std_external*));
+
+static boolean MY_bfd_final_link PARAMS ((bfd*, struct bfd_link_info*));
+static boolean MY_bfd_free_cached_info PARAMS ((bfd*));
+static boolean MY_bfd_copy_private_bfd_data PARAMS ((bfd*, bfd*));
+static const char* m68kmint_prg_find_symbol_name
+  PARAMS ((reloc_howto_type*, bfd*, bfd_byte*,
+	   struct reloc_std_external* rel));
+static int vma_cmp PARAMS ((const void*, const void*));
+
+static int squirt_out_tparel PARAMS ((bfd*, struct internal_exec*,
+				      struct external_exec*));
+
+static boolean link_write_traditional_syms
+     PARAMS ((bfd*, struct bfd_link_info*));
+static int write_dri_symbol PARAMS ((bfd*, const char*, bfd_vma, bfd_vma));
+
+extern const bfd_target MY(vec);
+
+/* aoutx.h requires definitions for BMAGIC and QMAGIC.  Other 
+   implementations have either chosen OMAGIC or zero for BMAGIC if
+   not available.  We try it with 0777 which is hopefully impossible. */
+#define BMAGIC 0777
+#define QMAGIC 0314
+
+#define WRITE_HEADERS(abfd, execp)					      \
+      {									      \
+	bfd_size_type text_size; /* dummy vars */			      \
+	file_ptr text_end;						      \
+                                                                              \
+	if (adata(abfd).magic == undecided_magic)			      \
+	  NAME(aout,adjust_sizes_and_vmas) (abfd, &text_size, &text_end);     \
+    									      \
+	execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;	      \
+	execp->a_entry = bfd_get_start_address (abfd);			      \
+    									      \
+	execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *		      \
+			   obj_reloc_entry_size (abfd));		      \
+	execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *		      \
+			   obj_reloc_entry_size (abfd));		      \
+	/* We don't have to call swap_exec_header_out here because the        \
+           contents will be overwritten in a second pass.  */                 \
+									      \
+	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0) return false;	      \
+	if (bfd_write ((PTR) &exec_bytes, 1, EXEC_BYTES_SIZE, abfd)	      \
+	    != EXEC_BYTES_SIZE)						      \
+	  return false;							      \
+	/* Now write out reloc info, followed by syms and strings.  */	      \
+  									      \
+        if (bfd_seek (abfd, (file_ptr)(N_SYMOFF(*execp)), SEEK_SET) != 0)     \
+          return false;                                                       \
+	if (bfd_get_outsymbols (abfd) != (asymbol**) NULL		      \
+	    && bfd_get_symcount (abfd) != 0) 				      \
+	  {								      \
+            if (! NAME(aout,write_syms)(abfd))                                \
+              return false;		                                      \
+	  }								      \
+									      \
+	/* This will also rewrite  the exec header.  */                       \
+        if (squirt_out_tparel (abfd, execp, &exec_bytes) != 0)                \
+          return false;                                                       \
+	if (bfd_seek (abfd, (file_ptr)(N_TRELOFF(*execp)), SEEK_SET) != 0)    \
+	  return false;						      	      \
+	if (!NAME(aout,squirt_out_relocs) (abfd, obj_textsec (abfd)))         \
+	  return false;						      	      \
+									      \
+	if (bfd_seek (abfd, (file_ptr)(N_DRELOFF(*execp)), SEEK_SET) != 0)    \
+	  return false;						      	      \
+	if (!NAME(aout,squirt_out_relocs)(abfd, obj_datasec (abfd)))          \
+	  return false;						      	      \
+      }									      
+
+#include "aoutx.h"
+
+#include "libaout.h"
+
+#include "aout-target.h"
+
+boolean
+bfd_m68kmint_set_extended_flags (abfd, prg_flags)
+     bfd* abfd;
+     flagword prg_flags;
+{
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+
+  if (myinfo == NULL)
+    myinfo = bfd_zalloc (abfd, sizeof (struct bfd_link_info));
+  
+  if (myinfo == NULL) 
+    {
+      /* The internal function bfd_zalloc has already set the error
+	 state to "out of memory".  */
+      return false;
+    }
+
+  obj_aout_ext (abfd) = myinfo;
+
+  if (abfd->xvec != &(MY (vec)) || myinfo == NULL)
+    return false;
+  
+  myinfo->prg_flags = prg_flags;
+  return true;
+}
+
+static const bfd_target*
+MY_object_p (abfd)
+     bfd* abfd;
+{
+  struct external_exec exec_bytes;	/* Raw exec header from file */
+  struct internal_exec exec;		/* Cleaned-up exec header */
+  const bfd_target* target;
+  struct mint_internal_info* myinfo;
+  boolean is_executable = true;
+
+  if (bfd_read ((PTR) &exec_bytes, 1, EXEC_BYTES_SIZE, abfd)
+      != EXEC_BYTES_SIZE) {
+    if (bfd_get_error () != bfd_error_system_call)
+      bfd_set_error (bfd_error_wrong_format);
+    return 0;
+  }
+
+  /* Instead of byte-swapping we compare bytes.  */
+  if (exec_bytes.g_branch[0] == 0xde
+      && exec_bytes.g_branch[1] == 0xad)
+    {
+      /* This is the result of an invalid objcopy operation.  */
+      is_executable = false;
+    }
+  else if (exec_bytes.g_branch[0] != 0x60
+	   || exec_bytes.g_branch[1] != 0x1a)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return 0;
+    } 
+
+  if (exec_bytes.g_branch[0] != 0x60
+      || exec_bytes.g_branch[1] != 0x1a
+      || exec_bytes.g_extmagic[0] != 'M' 
+      || exec_bytes.g_extmagic[1] != 'i' 
+      || exec_bytes.g_extmagic[2] != 'N' 
+      || exec_bytes.g_extmagic[3] != 'T' 
+      || exec_bytes.g_symbol_format[0] != 0 
+      || exec_bytes.g_symbol_format[1] != 0 
+      || exec_bytes.g_symbol_format[2] != 0 
+      || exec_bytes.g_symbol_format[3] != 0)
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return 0;
+    }
+
+#ifdef SWAP_MAGIC
+  exec.a_info = SWAP_MAGIC (exec_bytes.e_info);
+#else
+  exec.a_info = bfd_h_get_32 (abfd, exec_bytes.e_info);
+#endif /* SWAP_MAGIC */
+
+  if (N_BADMAG (exec)) return 0;
+#ifdef MACHTYPE_OK
+  if (!(MACHTYPE_OK (N_MACHTYPE (exec)))) return 0;
+#endif
+
+  NAME(aout,swap_exec_header_in)(abfd, &exec_bytes, &exec);
+
+#ifdef SWAP_MAGIC
+  /* swap_exec_header_in read in a_info with the wrong byte order */
+  exec.a_info = SWAP_MAGIC (exec_bytes.e_info);
+#endif /* SWAP_MAGIC */
+
+  target = NAME(aout,some_aout_object_p) (abfd, &exec, MY(callback));
+
+  myinfo = bfd_zalloc (abfd, sizeof (struct bfd_link_info));
+  
+  if (myinfo == NULL)
+    {
+      /* Error is already set to "out of memory".  */
+      return 0;
+    }
+
+  obj_aout_ext (abfd) = myinfo;
+
+  /* Now get the missing information.  */
+  myinfo->tparel_pos = GET_WORD (abfd, exec_bytes.g_tparel_pos);
+  myinfo->tparel_size = GET_WORD (abfd, exec_bytes.g_tparel_size);
+
+  /* FIXME:  Currently we always read the TPA relative relocation
+     information.  This is suboptimal because often times there
+     is no need for it.  Read it only if need be!  Maybe this should
+     also depend on abfd->cacheable?  */
+  if (myinfo->tparel_size == 0)
+    myinfo->tparel = bfd_zalloc (abfd, 4);
+  else
+    myinfo->tparel = bfd_alloc (abfd, myinfo->tparel_size);
+  
+  if (myinfo->tparel == NULL)
+    return 0;
+
+  if (myinfo->tparel_size == 0)
+    {
+      myinfo->tparel_size = 4;
+    }
+  else 
+    {
+    /* Read the information from the bfd.  */
+    if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0
+	|| (bfd_read (myinfo->tparel, 1, myinfo->tparel_size, abfd)
+	    != myinfo->tparel_size))
+      {
+	return 0;
+      }
+    }
+
+  myinfo->stkpos = GET_WORD (abfd, exec_bytes.g_stkpos);
+  myinfo->prg_flags = GET_WORD (abfd, exec_bytes.g_flags);
+
+  /* We don't support other formats for the symbol table actively.  */
+  myinfo->symbol_format = _MINT_SYMBOL_FORMAT_GNU;
+  return target;
+}
+
+static boolean 
+MY_bfd_free_cached_info (abfd)
+     bfd* abfd;
+{
+  if (obj_aout_ext (abfd) != NULL) 
+    {
+      struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+      if (myinfo != NULL) 
+	{
+	  if (myinfo->relocs != NULL) 
+	    {
+	      free (myinfo->relocs);
+	      myinfo->relocs = NULL;
+	    }
+	}
+    }
+
+  return NAME (aout, bfd_free_cached_info) (abfd);
+}
+
+/* This is used for qsort to sort addresses for the TPA relocation table.  */
+static int vma_cmp (v1, v2)
+     const void* v1;
+     const void* v2;
+{
+  return (int) ((*((bfd_vma*) v1)) - (*((bfd_vma*) v2)));
+}
+
+/* Final link routine.  We need to use a call back to get the correct
+   offsets in the output file.  And we need to malloc some internal
+   buffers.  */
+
+static boolean
+MY_bfd_final_link (abfd, info)
+     bfd* abfd;
+     struct bfd_link_info* info;
+{
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+  unsigned long i;
+  bfd_size_type bytes;
+  unsigned char* ptr;
+  struct bfd_link_hash_table* hash = info->hash;
+
+  if (myinfo == NULL)
+    myinfo = bfd_zalloc (abfd, sizeof (struct bfd_link_info));
+  
+  if (myinfo == NULL) 
+    {
+      /* The internal function bfd_zalloc has already set the error
+	 state to "out of memory".  */
+      return false;
+    }
+
+  obj_aout_ext (abfd) = myinfo;
+  
+  myinfo->linkinfo = info;
+
+  /* Make sure that for now we never write zmagics.  */
+  abfd->flags &= ~D_PAGED;
+
+  /* Find the __stksize symbol.  This symbol is used for a MiNT
+     special kludge.  The libc defines this symbol in an object file
+     initialized to a default value to make sure it is defined in
+     every output file.  The start-up code in crtinit() then simply
+     sets the stacksize accordingly.  In your programs (if they need
+     an unusual stacksize) you can then simply code:
+
+           long _stksize = 0x2000;
+	   
+     This will create a program stack of 2k.  Since MiNT cannot detect
+     a stack overflow this is the only way to prevent program crashes
+     caused by a stack that is too small.
+
+     The ancient linker ignored this feature, the ancient strip
+     program paid heed to it.  By default, strip never stripped this
+     special symbol from the binary.
+
+     Another program called ``printstk'' and its colleague ``fixstk''
+     could be used to either print the current value of the stacksize
+     or to modify it without recompiling and rebuilding.  These
+     programs traversed the symbol table and then took the appropriate
+     measures if the symbol was found.
+
+     Here we do a different approach.  Since we already expanded the
+     standard executable header we now hardcode the address (as a file
+     offset) that the __stksize symbol points to into the header.  We
+     can now let strip safely remove the entry from the symbol table
+     and we're not dependent on a special format of the symbol table.
+     Because the address is kept in the header we will always be able
+     to manipulate the stacksize value later.  */
+  if (hash != NULL) 
+    {
+      struct aout_link_hash_entry* h =
+	aout_link_hash_lookup (aout_hash_table (info), "__stksize",
+			       false, false, false);
+      asection* sec;
+
+      if (h != NULL) 
+	{
+	  switch (h->root.type) 
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      sec = h->root.u.def.section->output_section;
+	      BFD_ASSERT (bfd_is_abs_section (sec)
+			  || sec->owner == abfd);
+	      
+	      myinfo->stkpos = (h->root.u.def.value + sec->vma 
+				+ h->root.u.def.section->output_offset
+				+ 0x1c);
+	      break;
+	    case bfd_link_hash_common:
+	      myinfo->stkpos = h->root.u.c.size + 0x1c;
+	      break;
+	    default:  /* Ignore other types.  */
+	      break;
+	    }
+	}
+    }
+  
+  if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0) 
+    {
+      if (info->relocateable) 
+	{
+	  _bfd_error_handler ("\
+warning: traditional format not supported for relocatable output");
+	} 
+      else 
+	{
+	  _bfd_error_handler ("\
+warning: traditional format is obsolete");
+	  _bfd_error_handler ("\
+(Executables in traditional format will not be recognized");
+	  _bfd_error_handler ("by other bfd front ends.)");
+	  myinfo->traditional_format = true;
+	  myinfo->symbol_format = _MINT_SYMBOL_FORMAT_DRI;
+	}
+    }
+  
+  /* Unconditionally unset the traditional flag.  The only effect in
+     the a.out code is to disable string hashing (with respect to
+     SunOS gdx).  This is not necessary for us.
+
+     Just in case you are interested in orthography:  In the above
+     paragraph there seems to be an apostrophe missing after SunOS.
+     But this breaks emacs (sigh, again) C mode.  */
+
+  abfd->flags &= ~BFD_TRADITIONAL_FORMAT;
+  
+  if (NAME(aout,final_link) (abfd, info, MY_final_link_callback)
+      != true)
+    return false;
+
+  if (myinfo->reloc_error)
+    return false;
+
+  if (myinfo->traditional_format
+      && link_write_traditional_syms (abfd, info) != true)
+    return false;
+
+  /* Sort the relocation info.  */
+  if (myinfo->relocs != NULL)
+    qsort (myinfo->relocs, myinfo->relocs_used, sizeof (bfd_vma),
+	   vma_cmp);
+
+  /* Now calculate the number of bytes we need.  The relocation info
+     is encoded as follows:  The first entry is a 32-bit value 
+     denoting the first offset to relocate.  All following entries
+     are relative to the preceding one.  For relative offsets of 
+     more than 254 bytes a value of 1 is used.  The OS will then
+     add 254 bytes to the current offset.  The list is then terminated
+     with 0L.  */
+  bytes = 4 + 4;    /* First entry is a long, last is (long) 0.  */
+  for (i = 1; i < myinfo->relocs_used; i++) {
+    unsigned long diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+    bytes += 1 + diff / 254;
+  }
+  
+  myinfo->tparel_size = bytes;  
+  myinfo->tparel = bfd_alloc (abfd, bytes);
+  if (myinfo->tparel == NULL)
+    return false;
+  
+  /* Now fill the array.  */
+  ptr = (bfd_byte*) myinfo->tparel;
+  if (myinfo->relocs != NULL)
+    bfd_put_32 (abfd, myinfo->relocs[0], ptr);
+
+  ptr += 4;
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      unsigned long addr = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      while (addr > 254) {
+	*ptr = 1;
+	addr -= 254;
+	ptr++;
+      } 
+      *ptr = (bfd_byte) addr;
+      ptr++;
+    }
+  bfd_put_32 (abfd, 0, ptr);
+  
+  return true;
+}
+
+static boolean 
+MY_bfd_copy_private_bfd_data (ibfd, obfd)
+     bfd* ibfd;
+     bfd* obfd;
+{
+  struct mint_internal_info* myinfo_in = obj_aout_ext (ibfd);
+  struct mint_internal_info* myinfo_out = obj_aout_ext (obfd);
+
+  /* Our routine only makes sense if both the input and the output
+     bfd are MiNT program files.  FIXME:  It is not absolutely clear
+     to me if this function is a method of the input or the output
+     bfd.  One part of the following AND relation is not redundant,
+     but which one?  */
+  if (ibfd->xvec == &(MY (vec)) && obfd->xvec == &(MY (vec))) 
+    {
+      BFD_ASSERT (myinfo_in != NULL);
+    
+      if (myinfo_out == NULL) {
+	myinfo_out = bfd_zalloc (obfd, sizeof (struct mint_internal_info));
+	
+	if (myinfo_out == NULL) {
+	  /* The internal function bfd_zalloc has already set the error
+	     state to "out of memory".  */
+	  return false;
+	}
+
+	memcpy (myinfo_out, myinfo_in, sizeof (struct mint_internal_info));
+	myinfo_out->tparel = NULL;
+	obj_aout_ext (obfd) = myinfo_out;
+      }
+      
+      if (myinfo_out->tparel != NULL)
+	free (myinfo_out->tparel);
+
+      if (myinfo_in->tparel != NULL) 
+      {
+	if (bfd_seek (ibfd, myinfo_in->tparel_pos, SEEK_SET) != 0)
+	  return false;
+
+	if (bfd_read (myinfo_in->tparel, 1, myinfo_in->tparel_size, ibfd) 
+	    != myinfo_in->tparel_size)
+	  return false;
+      }
+      myinfo_out->tparel = bfd_alloc (obfd, myinfo_out->tparel_size);
+      if (myinfo_out->tparel == NULL)
+	return false;
+      
+      memcpy (myinfo_out->tparel, myinfo_in->tparel,
+	      myinfo_out->tparel_size);
+    } 
+  else if (ibfd->xvec != &(MY (vec))) 
+    {
+      /* Can this ever happen?  FIXME!  */
+      _bfd_error_handler ("\
+error: the input file ``%s'' contains no", ibfd->filename);
+      _bfd_error_handler ("TPA-relative relocation info.");
+      
+      /* We will invalidate the output file so that no attempt is
+	 made to actually run the image.  Maybe we should return
+	 false instead but it is possible that some curious soul has
+	 tried to objcopy onto our format for research reasons.  */
+      _bfd_error_handler ("Will mark output file ``%s''");
+      _bfd_error_handler ("as non-executable.");
+      obfd->flags &= (~EXEC_P);
+    }
+  
+  return true; /*_bfd_generic_bfd_copy_private_bfd_data (ibfd, obfd);*/
+}
+
+static
+const char* m68kmint_prg_find_symbol_name (howto, input_bfd,
+					   location, rel)
+     reloc_howto_type* howto;
+     bfd* input_bfd;
+     bfd_byte* location;
+     struct reloc_std_external* rel;
+{
+  /* Find out the symbol name.  */
+  struct external_nlist *syms = obj_aout_external_syms (input_bfd);
+  char* strings = obj_aout_external_strings (input_bfd);
+  struct aout_link_hash_entry** sym_hashes
+    = obj_aout_sym_hashes (input_bfd);
+  struct aout_link_hash_entry* h = NULL;
+  const char* name;
+  int r_index;
+  int r_extern;
+  
+  if (bfd_get_reloc_size (howto) != 4)
+    return "(not a symbol)";
+
+  /* The input bfd is always big-endian.  There is no need to
+     call bfd_header_big_endian (input_bfd).  */
+  r_index  = ((rel->r_index[0] << 16)
+	      | (rel->r_index[1] << 8)
+	      | (rel->r_index[2]));
+  r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+  
+  if (sym_hashes != NULL)
+    h = sym_hashes[r_index];
+  
+  if (!r_extern)
+    {
+      bfd_size_type i;
+      bfd_vma wanted_value = bfd_get_32 (input_bfd, location);
+
+      name = NULL;
+      for (i = 0; i < obj_aout_external_sym_count (input_bfd); i++)
+	{
+	  bfd_vma this_value = bfd_get_32 (input_bfd, syms[i].e_value);
+
+	  if (this_value == wanted_value)
+	    {
+              bfd_byte symtype = bfd_get_8 (input_bfd, syms[i].e_type);
+
+	      /* Skip debug symbols and the like.  */
+	      if ((symtype & N_STAB) != 0)
+		continue;
+		
+	      /* This is dirty but preferable to a plethoria of
+		 single comparisons.  */
+	      if (symtype <= (N_BSS | N_EXT)
+		  || (symtype >= N_WEAKU && symtype <= N_COMM))
+		{
+		  name = strings + GET_WORD (input_bfd, syms[i].e_strx);
+		  break;
+		}
+	    }
+	}
+
+      /* FIXME:  If the relocation is against a section there is
+	 probably a symbol for that section floating around somewhere
+	 in the bfd jungle.  */
+      if (name == NULL)
+	{
+	  switch ((r_index & N_TYPE) & ~N_EXT)
+	    {
+	    case N_TEXT:
+	      name = "text section";
+	      break;
+	    case N_DATA:
+	      name = "data section";
+	      break;
+	    case N_BSS:
+	      name = "bss section";
+	      break;
+	    case N_ABS:
+	      name = "absolute section";
+	      break;
+	    default:
+	      name = "unknown section";
+	      break;
+	    }
+	}
+    }
+  else if (h != NULL)
+    name = h->root.root.string;
+  else if ((unsigned) r_index >= obj_aout_external_sym_count (input_bfd))
+    name = "(unknown symbol)";  /* Shouldn't happen.  */
+  else
+    name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
+  
+  return name;
+}
+
+/* This relocation routine is used by some of the backend linkers.
+   They do not construct asymbol or arelent structures, so there is no
+   reason for them to use bfd_perform_relocation.  Also,
+   bfd_perform_relocation is so hacked up it is easier to write a new
+   function than to try to deal with it.
+
+   This routine does a final relocation.  Whether it is useful for a
+   relocateable link depends upon how the object format defines
+   relocations.
+
+   FIXME: This routine ignores any special_function in the HOWTO,
+   since the existing special_function values have been written for
+   bfd_perform_relocation.
+
+   HOWTO is the reloc howto information.
+   INPUT_BFD is the BFD which the reloc applies to.
+   INPUT_SECTION is the section which the reloc applies to.
+   CONTENTS is the contents of the section.
+   ADDRESS is the address of the reloc within INPUT_SECTION.
+   VALUE is the value of the symbol the reloc refers to.
+   ADDEND is the addend of the reloc.  */
+
+bfd_reloc_status_type
+m68kmint_prg_final_link_relocate (howto, input_bfd, input_section,
+				  contents, address, value, addend, rel)
+     reloc_howto_type* howto;
+     bfd* input_bfd;
+     asection* input_section;
+     bfd_byte* contents;
+     bfd_vma address;
+     bfd_vma value;
+     bfd_vma addend;
+     struct reloc_std_external* rel;
+{
+  bfd_vma relocation;
+  bfd* output_bfd = input_section->output_section->owner;
+  struct mint_internal_info* myinfo = obj_aout_ext (output_bfd);
+  bfd_reloc_status_type retval;
+
+#define _MINT_F_SHTEXT 0x800
+
+  /* Sanity check the address.  */
+  if (address > input_section->_raw_size)
+    return bfd_reloc_outofrange;
+
+  /* This function assumes that we are dealing with a basic relocation
+     against a symbol.  We want to compute the value of the symbol to
+     relocate to.  This is just VALUE, the value of the symbol, plus
+     ADDEND, any addend associated with the reloc.  */
+  relocation = value + addend;
+
+  /* Check for dangerous relocations in images with a sharable
+     text section.  */
+  if ((myinfo->prg_flags & _MINT_F_SHTEXT) != 0
+      && bfd_get_reloc_size (howto) == 4)
+    {
+      boolean error_found = false;
+      const char* name = NULL;
+      /* The input bfd is always big-endian.  There is no need to
+	 call bfd_header_big_endian (input_bfd).  */
+      int r_index  = ((rel->r_index[0] << 16)
+		      | (rel->r_index[1] << 8)
+		      | (rel->r_index[2]));
+      int r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+	  
+
+      if (input_section == obj_textsec (input_bfd))
+	{
+	  if (!r_extern)
+	    {
+	      /* This is a relocation against another section.  Only
+		 relocations against the text section are allowed.  */
+	      if (r_index != N_TEXT && r_index != (N_TEXT | N_EXT))
+		error_found = true;
+	    }
+	  else if (relocation > (input_section->output_section->vma
+			    + input_section->output_section->_raw_size))
+	    {
+	      error_found = true;
+	    }
+	  else if (relocation == (input_section->output_section->vma
+				  + input_section->output_section->_raw_size))
+	    {
+	      name = m68kmint_prg_find_symbol_name (howto, input_bfd,
+						    contents + address,
+						    rel);
+	      if (strcmp (name, "_etext") == 0)
+		error_found = false;
+	    }
+	}
+
+      if (error_found)
+	{
+	  const struct bfd_link_callbacks* callbacks
+	    = myinfo->linkinfo->callbacks;
+
+          myinfo->reloc_error = true;
+
+	  if (callbacks->reloc_dangerous != NULL)
+	    {
+	      if (name == NULL)
+		name = m68kmint_prg_find_symbol_name (howto, input_bfd,
+						      contents + address,
+						      rel);
+
+	      callbacks->reloc_dangerous (myinfo->linkinfo, name,
+					  input_bfd,
+					  input_section, address);
+	    }
+	}
+    }
+
+  /* If the relocation is PC relative, we want to set RELOCATION to
+     the distance between the symbol (currently in RELOCATION) and the
+     location we are relocating.  Some targets (e.g., i386-aout)
+     arrange for the contents of the section to be the negative of the
+     offset of the location within the section; for such targets
+     pcrel_offset is false.  Other targets (e.g., m88kbcs or ELF)
+     simply leave the contents of the section as zero; for such
+     targets pcrel_offset is true.  If pcrel_offset is false we do not
+     need to subtract out the offset of the location within the
+     section (which is just ADDRESS).  */
+  if (howto->pc_relative)
+    {
+      relocation -= (input_section->output_section->vma
+		     + input_section->output_offset);
+      if (howto->pcrel_offset)
+	relocation -= address;
+    }
+  else if (bfd_get_reloc_size (howto) < 4)
+    {
+      /* Umh, don't know why... */
+      relocation += (-32768 - (obj_textsec (output_bfd))->_raw_size
+		     -228);
+    }
+						      
+  retval = _bfd_relocate_contents (howto, input_bfd, relocation,
+				   contents + address);
+  
+  /* The symbol has to be relocated again iff the length of the relocation
+     is 2 words and it is not pc relative.  */
+
+  if (!howto->pc_relative && bfd_get_reloc_size (howto) == 4) {
+
+    /* Enlarge the buffer if necessary.  */
+    if (myinfo->relocs_used * sizeof (bfd_vma) >= myinfo->relocs_allocated) {
+      bfd_vma* newbuf;
+      myinfo->relocs_allocated += MINT_RELOC_CHUNKSIZE;
+      newbuf = bfd_realloc (myinfo->relocs, myinfo->relocs_allocated);
+      if (newbuf == NULL) {
+        bfd_set_error (bfd_error_no_memory);
+        bfd_perror ("fatal error");
+        xexit (1);
+      }
+      myinfo->relocs = newbuf;
+    }
+
+    /* The TPA relative relocation actually just adds the address of
+       the text segment (i. e. beginning of the executable in memory)
+       to the addresses at the specified locations.  This allows an
+       executable to be loaded everywhere in the address space without
+       memory management.  */
+
+    myinfo->relocs[myinfo->relocs_used++] =
+      input_section->output_section->vma
+      + input_section->output_offset + address;
+  }
+
+  return retval;
+}
+
+static int
+squirt_out_tparel (abfd, execp, exec_bytes)
+     bfd* abfd;
+     struct internal_exec* execp;
+     struct external_exec* exec_bytes;
+{
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+  
+  if (myinfo->symtab_size == 0)
+    myinfo->tparel_pos = N_STROFF (*execp) 
+      + obj_aout_external_string_size (abfd);
+  else
+    myinfo->tparel_pos = N_SYMOFF (*execp) 
+      + myinfo->symtab_size;
+
+  if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0)
+    return 1;
+
+  if (bfd_write (myinfo->tparel, 1, myinfo->tparel_size, abfd) 
+      != myinfo->tparel_size)
+    return 1;
+
+  /* Now that we have all the information we need we can fill in the
+     MiNT-specific header fields.  Unfortunately this is already the
+     second time that we write out the header.  */
+
+  if ((abfd->flags & EXEC_P) == 0)
+    bfd_h_put_16 (abfd, 0xdead, exec_bytes->g_branch);
+  else
+    bfd_h_put_16 (abfd, 0x601a, exec_bytes->g_branch);
+  
+  /* The OS will load our extension header fields into the text segment.  */
+  PUT_WORD (abfd, execp->a_text + EXEC_BYTES_SIZE - 28,
+	    exec_bytes->g_text);
+  PUT_WORD (abfd, execp->a_data, exec_bytes->g_data);
+  PUT_WORD (abfd, execp->a_bss, exec_bytes->g_bss);
+  
+  /* The OS' notion of the size of the symbol table is another than
+     the bfd library's.  We have to fill in the size of the table
+     itself plus the size of the string table but only if we have not written
+     a traditional symbol table.  If we have written a traditional symbol
+     table we know the size.  */
+  if (myinfo->symtab_size != 0)
+    PUT_WORD (abfd, myinfo->symtab_size, exec_bytes->g_syms);
+  else
+    PUT_WORD (abfd, myinfo->tparel_pos - N_SYMOFF (*execp),
+	      exec_bytes->g_syms);
+  bfd_h_put_32 (abfd, 0x4d694e54, exec_bytes->g_extmagic);
+  bfd_h_put_32 (abfd, myinfo->prg_flags, exec_bytes->g_flags);
+  bfd_h_put_16 (abfd, 0, exec_bytes->g_abs);
+  
+  /* Generate the jump instruction to the entry point.  In m68k
+     assembler mnemnonics it looks more or less like this:
+
+       move.l  exec_bytes->e_entry(pc), d4
+       jmp     0(pc,d4.l)
+
+     Sorry for the wrong syntax.  As a real assembler addict I
+     never actually use an assembler.  I edit my binaries manually
+     with a hex editor, looks much cooler and it strengthens your
+     abstraction abilities.  */
+
+  exec_bytes->g_jump_entry[0] = 0x28;
+  exec_bytes->g_jump_entry[1] = 0x3a;
+  exec_bytes->g_jump_entry[2] = 0x00;
+  exec_bytes->g_jump_entry[3] = 0x1a;
+  exec_bytes->g_jump_entry[4] = 0x4e;
+  exec_bytes->g_jump_entry[5] = 0xfb;
+  exec_bytes->g_jump_entry[6] = 0x48;
+  exec_bytes->g_jump_entry[7] = 0xfa;
+
+  bfd_h_put_32 (abfd, myinfo->tparel_pos, exec_bytes->g_tparel_pos);
+  bfd_h_put_32 (abfd, myinfo->tparel_size, exec_bytes->g_tparel_size);
+  
+  PUT_WORD (abfd, myinfo->stkpos, exec_bytes->g_stkpos);
+  PUT_WORD (abfd, myinfo->symbol_format, exec_bytes->g_symbol_format);
+  
+  memset (&exec_bytes->g_pad0, 0, sizeof (exec_bytes->g_pad0));  
+  
+  /* The standard stuff.  */
+  NAME(aout,swap_exec_header_out) (abfd, execp, exec_bytes);
+  if (myinfo->symbol_format != _MINT_SYMBOL_FORMAT_GNU)
+    PUT_WORD (abfd, 0, exec_bytes->e_syms);
+  
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0) return false;
+  
+  if (bfd_write ((PTR) exec_bytes, 1, EXEC_BYTES_SIZE, abfd)
+      != EXEC_BYTES_SIZE)						      
+    return 1;							      
+  
+  return 0;
+} 
+
+/* Emit a traditional DRI symbol table while linking.  */
+static boolean
+link_write_traditional_syms (abfd, info)
+     bfd* abfd;
+     struct bfd_link_info* info;
+{
+  bfd*                       ibfd;
+  enum bfd_link_strip        strip = info->strip;
+  enum bfd_link_discard      discard = info->discard;
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+  bfd*                       last_archive = NULL;
+
+  /* Position file pointer.  */
+  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)
+    return false;
+
+  myinfo->symtab_size = 0;
+
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      bfd_size_type sym_count = obj_aout_external_sym_count (ibfd);
+      char* strings = obj_aout_external_strings (ibfd);
+      register struct external_nlist* sym = obj_aout_external_syms (ibfd);
+      struct external_nlist* sym_end = sym + sym_count;
+      struct aout_link_hash_entry** sym_hash = obj_aout_sym_hashes (ibfd);
+      boolean pass = false;
+      boolean skip = false;
+      boolean skip_next = false;
+      int written_bytes;
+      int a_type;
+      boolean write_archive_name = false;
+      bfd_vma val = 0;
+      
+      /* First write out a symbol for the archive if we do not
+	 strip these symbols and if it differs from the last
+	 one.  */
+      if (ibfd->my_archive != last_archive
+	  && ibfd->my_archive != NULL) 
+	{
+	  write_archive_name = true;
+	  last_archive = ibfd->my_archive;
+	}
+
+      if (write_archive_name
+	  && strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash,
+				  ibfd->my_archive->filename,
+				  false, false) != NULL)
+	  && discard != discard_all) 
+	{
+	  val = bfd_get_section_vma (abfd,
+				     obj_textsec (ibfd)->output_section)
+	    + obj_textsec (ibfd)->output_offset;
+	  
+	  written_bytes = write_dri_symbol (abfd,
+					    ibfd->my_archive->filename,
+					    A_TFILE, val);
+
+	  if (written_bytes <= 0)
+	    return false;
+	  else
+	    myinfo->symtab_size += written_bytes;
+	}
+
+      /* Now write out a symbol for the object file if we do not
+	 strip these symbols.  */
+      if (strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash, ibfd->filename,
+				  false, false) != NULL)
+	  && discard != discard_all) 
+	{
+	  val = bfd_get_section_vma (abfd,
+				     obj_textsec (ibfd)->output_section)
+	    + obj_textsec (ibfd)->output_offset;
+				     
+	  written_bytes = write_dri_symbol (abfd, ibfd->filename,
+					    A_TFILE, val);
+	  if (written_bytes <= 0)
+	    return false;
+	  else
+	    myinfo->symtab_size += written_bytes;
+	}
+
+      /* Now we have a problem.  All symbols that we see have already
+	 been marked written (because we write them a second time
+	 here.  If we would do it the clean way we would have
+	 to traverse the entire symbol map and reset the written
+	 flag.  We hack here instead...  */
+#define mark_written(h) (* (int *) &h->written = (int) true + 1)
+#define is_written(h) ((int) h->written == (int) true + 1)
+      for (; sym < sym_end; sym++, sym_hash++) {
+	const char* name = strings + GET_WORD (ibfd, sym->e_strx);
+	struct aout_link_hash_entry* h = NULL;
+	int type;
+	
+	val = 0;
+	type = bfd_h_get_8 (ibfd, sym->e_type);
+	name = strings + GET_WORD (ibfd, sym->e_strx);
+	
+	if (pass) {
+	  /* Pass this symbol through.  It is the target of an
+	     indirect or warning symbol.  */
+	  val = GET_WORD (ibfd, sym->e_value);
+	  pass = false;
+	} else if (skip_next) {
+	  /* Skip this symbol, which is the target of an indirect
+	     symbol that we have changed to no longer be an indirect
+	     symbol.  */
+	  skip_next = false;
+	  continue;
+	} else {
+	  struct aout_link_hash_entry* hresolve = *sym_hash;
+	  asection* symsec;
+	  
+	  /* We have saved the hash table entry for this symbol, if
+	     there is one.  Note that we could just look it up again
+	     in the hash table, provided we first check that it is an
+	     external symbol. */
+	  h = *sym_hash;
+	  
+	  /* Use the name from the hash table, in case the symbol was
+	     wrapped.  */
+	  if (h != NULL)
+	    name = h->root.root.string;	
+	  
+	  /* If this is an indirect or warning symbol, then change
+	     hresolve to the base symbol.  */
+	  hresolve = h;
+	  if (h != (struct aout_link_hash_entry*) NULL
+	      && (h->root.type == bfd_link_hash_indirect
+		  || h->root.type == bfd_link_hash_warning)) {
+	    hresolve = (struct aout_link_hash_entry*) h->root.u.i.link;
+	    while (hresolve->root.type == bfd_link_hash_indirect
+		   || hresolve->root.type == bfd_link_hash_warning)
+	      hresolve = ((struct aout_link_hash_entry*)
+			  hresolve->root.u.i.link);
+	  }
+
+	  /* If the symbol has already been written out skip it.  */
+	  if (h != (struct aout_link_hash_entry*) NULL
+	      && h->root.type != bfd_link_hash_warning
+	      && is_written (h)) {
+	    if ((type & N_TYPE) == N_INDR
+		|| type == N_WARNING)
+	      skip_next = true;
+	    continue;
+	  }
+	  
+	  /* See if we are stripping this symbol.  */
+	  skip = false;
+        
+	  /* Skip all debugger symbols.  No way to output them in
+	     DRI format.  This will also reduce a lot of headaches.  */
+	  if ((type & N_STAB) != 0)
+	    skip = true;
+	
+	  switch (strip)
+	    {
+	    case strip_none:
+	    case strip_debugger:
+	      break;
+	    case strip_some:
+	      if (bfd_hash_lookup (info->keep_hash, name, false, false)
+		  == NULL)
+		skip = true;
+	      break;
+	    case strip_all:
+	      skip = true;
+	      break;
+	    }
+	  
+	  if (skip) 
+	    {
+	      if (h != (struct aout_link_hash_entry*) NULL)
+		mark_written (h);
+	      continue;
+	    }
+
+	  /* Get the value of the symbol.  */
+	  if ((type & N_TYPE) == N_TEXT
+	      || type == N_WEAKT)
+	    symsec = obj_textsec (ibfd);
+	  else if ((type & N_TYPE) == N_DATA
+		   || type == N_WEAKD)
+	    symsec = obj_datasec (ibfd);
+	  else if ((type & N_TYPE) == N_BSS
+		   || type == N_WEAKB)
+	    symsec = obj_bsssec (ibfd);
+	  else if ((type & N_TYPE) == N_ABS
+		   || type == N_WEAKA)
+	    symsec = bfd_abs_section_ptr;
+	  else if (((type & N_TYPE) == N_INDR
+		    && (hresolve == (struct aout_link_hash_entry*) NULL
+			|| (hresolve->root.type != bfd_link_hash_defined
+			    && hresolve->root.type != bfd_link_hash_defweak
+			    && hresolve->root.type != bfd_link_hash_common)))
+		   || type == N_WARNING) {
+	    /* Pass the next symbol through unchanged.  The
+	       condition above for indirect symbols is so that if
+	       the indirect symbol was defined, we output it with
+	       the correct definition so the debugger will
+	       understand it.  */
+	    pass = true;
+	    val = GET_WORD (ibfd, sym->e_value);
+	    symsec = NULL;
+	  } else {
+	    /* If we get here with an indirect symbol, it means that
+	       we are outputting it with a real definition.  In such
+	       a case we do not want to output the next symbol,
+	       which is the target of the indirection.  */
+	    if ((type & N_TYPE) == N_INDR)
+	      skip_next = true;
+	    
+	    symsec = NULL;
+	  
+	    /* We need to get the value from the hash table.  We use
+	       hresolve so that if we have defined an indirect
+	       symbol we output the final definition.  */
+	    if (h == (struct aout_link_hash_entry*) NULL) 
+	      {
+		switch (type & N_TYPE)
+		  {
+		  case N_SETT:
+		    symsec = obj_textsec (ibfd);
+		    break;
+		  case N_SETD:
+		    symsec = obj_datasec (ibfd);
+		    break;
+		  case N_SETB:
+		    symsec = obj_bsssec (ibfd);
+		    break;
+		  case N_SETA:
+		    symsec = bfd_abs_section_ptr;
+		    break;
+		  default:
+		    val = 0;
+		    break;
+		  }
+	      } 
+	    else if (hresolve->root.type == bfd_link_hash_defined
+		     || hresolve->root.type == bfd_link_hash_defweak) 
+	      {
+		asection* input_section;
+		asection* output_section;
+
+		/* This case usually means a common symbol which was
+		   turned into a defined symbol.  */
+		input_section = hresolve->root.u.def.section;
+		output_section = input_section->output_section;
+		BFD_ASSERT (bfd_is_abs_section (output_section)
+			    || output_section->owner == abfd);
+		val = (hresolve->root.u.def.value
+		       + bfd_get_section_vma (abfd, output_section)
+		       + input_section->output_offset);
+	    
+		/* Get the correct type based on the section.  If
+		   this is a constructed set, force it to be
+		   globally visible.  */
+		if (type == N_SETT
+		    || type == N_SETD
+		    || type == N_SETB
+		    || type == N_SETA)
+		  type |= N_EXT;
+		
+		type &=~ N_TYPE;
+
+		if (output_section == obj_textsec (abfd))
+		  type |= N_TEXT;
+		else if (output_section == obj_datasec (abfd))
+		  type |= N_DATA;
+		else if (output_section == obj_bsssec (abfd))
+		  type |= N_BSS;
+		else
+	      type |= N_ABS;
+	      } 
+	    else if (hresolve->root.type == bfd_link_hash_common)
+	      val = hresolve->root.u.c.size;
+	    else if (hresolve->root.type == bfd_link_hash_undefweak) {
+	      val = 0;
+	      type = N_UNDF;
+	    } 
+	    else
+	      val = 0;
+	  }
+	  if (symsec != (asection*) NULL)
+	  val = (symsec->output_section->vma
+		 + symsec->output_offset
+		 + (GET_WORD (ibfd, sym->e_value)
+		    - symsec->vma));
+
+	  /* If this is a global symbol set the written flag, and if
+	     it is a local symbol see if we should discard it.  */
+	  if (h != (struct aout_link_hash_entry*) NULL) {
+	    mark_written (h);
+	  } else if ((type & N_TYPE) != N_SETT
+		     && (type & N_TYPE) != N_SETD
+		     && (type & N_TYPE) != N_SETB
+		     && (type & N_TYPE) != N_SETA) {
+	    switch (discard)
+	      {
+	      case discard_none:
+		break;
+	      case discard_l:
+		if (bfd_is_local_label_name (ibfd, name))
+		  skip = true;
+		break;
+	      case discard_all:
+		skip = true;
+		break;
+	      }
+	    if (skip)
+	      {
+		pass = false;
+		continue;
+	      }
+	  }
+	}
+
+	/* Now find the nearest type in DRI format.  We actually
+	   don't have to care about weak symbols because we have
+	   ignored the weak character of a symbol above.  Better
+	   is better yet.  */
+	switch (type & ~N_EXT)
+	  {
+	  case N_UNDF:
+	  case N_WEAKU:
+	    a_type = A_UNDF;
+	    break;
+	  case N_ABS:
+	  case N_WEAKA:
+	  case N_SETA:
+	    a_type = A_EQU;
+	    break;
+	  case N_TEXT:
+	  case N_WEAKT:
+	  case N_SETT:
+	    a_type = A_TEXT;
+	    break;
+	  case N_DATA:
+	  case N_WEAKD:
+	  case N_SETD:
+	    a_type = A_DATA;
+	    break;
+	  case N_BSS:
+	  case N_WEAKB:
+	  case N_SETB:
+	    a_type = A_BSS;
+	    break;
+	  default:
+	    a_type = A_UNDF;
+	    break;
+	  }
+	
+	if (type & N_EXT)
+	  a_type |= A_GLOBL;
+	
+	written_bytes = write_dri_symbol (abfd, name, a_type, val);
+	if (written_bytes <= 0)
+	  return false;
+	myinfo->symtab_size += written_bytes;
+      }
+    }
+  
+  obj_aout_external_string_size (abfd) = 0;
+  return true;
+}
+
+/* Write a DRI symbol with TYPE and VALUE.  If the NAME of the
+   symbol exceeds 8 characters write a long symbol.  If it 
+   exceeds 22 characters truncate the name.  */
+static int
+write_dri_symbol (abfd, name, type, value)
+     bfd* abfd;
+     const char* name;
+     bfd_vma type;
+     bfd_vma value;
+{
+  struct dri_symbol sym;
+  char* ptr = (char*)&sym.a_name[0];
+  const char* str = name;
+  char more_name[DRI_SYMBOL_SIZE];
+  int i = sizeof (sym.a_name);
+  int written_bytes = 0;
+  
+  bfd_put_16 (abfd, type, sym.a_type);
+  bfd_put_32 (abfd, value, sym.a_value);
+  
+  while (--i >= 0 && ('\0' != (*ptr++ = *str)))
+    str++;
+  
+  /* If i >= 0 then *str == '\0' and if i == 0 there is nothing to fill.  */
+  if (i > 0) 
+    {   /* We are done - fill it with 0.  */
+      do
+	*ptr++ = '\0';
+      while (--i > 0);
+    } 
+  else if (*str) 
+    {	/* If more to write.  */
+      type |= A_LNAM;
+      bfd_put_16 (abfd, type, sym.a_type);
+      i = sizeof sym;
+    }
+  
+  if (bfd_write ((PTR) &sym, 1, DRI_SYMBOL_SIZE, abfd) != DRI_SYMBOL_SIZE)
+    return -1;
+  written_bytes += DRI_SYMBOL_SIZE;
+  
+  if (i > 0) 
+    {
+      ptr = more_name;
+      i = sizeof more_name;
+      while (--i >= 0 && ('\0' != (*ptr++ = *str)))
+	str++;
+      
+      if (bfd_write ((PTR) more_name, 1, sizeof more_name, abfd)
+	  != sizeof more_name)
+	return -1;
+      written_bytes += sizeof more_name;
+    }
+  
+  return written_bytes;
+}
+
+const bfd_target MY(vec) = 
+{
+  TARGETNAME,           /* name */
+  bfd_target_aout_flavour,
+  BFD_ENDIAN_BIG,               /* target byte order (big) */
+  BFD_ENDIAN_BIG,               /* target headers byte order (big) */
+  (HAS_RELOC | EXEC_P |         /* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT),
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
+  MY_symbol_leading_char,
+  AR_PAD_CHAR,                  /* ar_pad_char */
+  15,                           /* ar_max_namelen */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */
+  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
+     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
+  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */
+  {_bfd_dummy_target, MY_object_p, /* bfd_check_format */
+   bfd_generic_archive_p, MY_core_file_p},
+  {bfd_false, MY_mkobject,    /* bfd_set_format */
+   _bfd_generic_mkarchive, bfd_false},
+  {bfd_false, MY_write_object_contents, /* bfd_write_contents */
+   _bfd_write_archive_contents, bfd_false},
+
+  BFD_JUMP_TABLE_GENERIC (MY),
+  BFD_JUMP_TABLE_COPY (MY),
+  BFD_JUMP_TABLE_CORE (MY),
+  BFD_JUMP_TABLE_ARCHIVE (MY),
+  BFD_JUMP_TABLE_SYMBOLS (MY),
+  BFD_JUMP_TABLE_RELOCS (MY),
+  BFD_JUMP_TABLE_WRITE (MY),
+  BFD_JUMP_TABLE_LINK (MY),
+  BFD_JUMP_TABLE_DYNAMIC (MY),
+  
+  NULL,
+
+  (PTR) MY_backend_data,
+};
diff -aurN gdb-5.1/bfd/targets.c gdb-5.1-mint-20081102/bfd/targets.c
--- gdb-5.1/bfd/targets.c	2001-05-11 14:23:47.000000000 +0200
+++ gdb-5.1-mint-20081102/bfd/targets.c	2008-11-02 14:44:24.453125000 +0100
@@ -616,6 +616,7 @@
 extern const bfd_target m68klinux_vec;
 extern const bfd_target m68klynx_aout_vec;
 extern const bfd_target m68klynx_coff_vec;
+extern const bfd_target m68kmint_prg_vec;
 extern const bfd_target m68knetbsd_vec;
 extern const bfd_target m68ksysvcoff_vec;
 extern const bfd_target m88kbcs_vec;
diff -aurN gdb-5.1/config/mh-mint gdb-5.1-mint-20081102/config/mh-mint
--- gdb-5.1/config/mh-mint	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/config/mh-mint	2008-11-02 14:44:24.468750000 +0100
@@ -0,0 +1,2 @@
+CFLAGS = -O2 -fomit-frame-pointer -D_GNU_SOURCE
+CXXFLAGS = -O -fomit-frame-pointer -D_GNU_SOURCE
diff -aurN gdb-5.1/config/mt-mint gdb-5.1-mint-20081102/config/mt-mint
--- gdb-5.1/config/mt-mint	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/config/mt-mint	2008-11-02 14:44:24.468750000 +0100
@@ -0,0 +1,2 @@
+CFLAGS_FOR_TARGET = $(CFLAGS) -D_GNU_SOURCE
+CXXFLAGS_FOR_TARGET = $(CXXFLAGS) -D_GNU_SOURCE
diff -aurN gdb-5.1/config.guess gdb-5.1-mint-20081102/config.guess
--- gdb-5.1/config.guess	2001-03-22 12:09:20.000000000 +0100
+++ gdb-5.1-mint-20081102/config.guess	2008-11-02 14:44:24.484375000 +0100
@@ -340,22 +340,22 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+        echo m68k-atari-mint
 	exit 0 ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint
         exit 0 ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+        echo m68k-atari-mint
 	exit 0 ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
+        echo m68k-milan-mint
         exit 0 ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
+        echo m68k-hades-mint
         exit 0 ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
+        echo m68k-unknown-mint
         exit 0 ;;
     sun3*:OpenBSD:*:*)
 	echo m68k-unknown-openbsd${UNAME_RELEASE}
diff -aurN gdb-5.1/gdb/config/m68k/mint.mh gdb-5.1-mint-20081102/gdb/config/m68k/mint.mh
--- gdb-5.1/gdb/config/m68k/mint.mh	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/config/m68k/mint.mh	2008-11-02 14:44:24.484375000 +0100
@@ -0,0 +1,9 @@
+# Host: m68k-atari running FreeMiNT
+
+XM_FILE= xm-mint.h
+XDEPFILES= ser-tcp.o
+
+NAT_FILE= nm-mint.h
+NATDEPFILES= infptrace.o inftarg.o fork-child.o m68kmint-nat.o
+
+GDBSERVER_DEPFILES= low-mint.o
diff -aurN gdb-5.1/gdb/config/m68k/mint.mt gdb-5.1-mint-20081102/gdb/config/m68k/mint.mt
--- gdb-5.1/gdb/config/m68k/mint.mt	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/config/m68k/mint.mt	2008-11-02 14:44:24.500000000 +0100
@@ -0,0 +1,3 @@
+# Target: m68k-atari running FreeMiNT
+TDEPFILES= m68k-tdep.o
+TM_FILE= tm-mint.h
diff -aurN gdb-5.1/gdb/config/m68k/nm-mint.h gdb-5.1-mint-20081102/gdb/config/m68k/nm-mint.h
--- gdb-5.1/gdb/config/m68k/nm-mint.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/config/m68k/nm-mint.h	2008-11-02 14:44:24.500000000 +0100
@@ -0,0 +1,31 @@
+/* Native-dependent definitions for m68k-atari running FreeMiNT, for GDB.
+   Copyright 2000 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define PTRACE_ARG3_TYPE void*
+
+#define FETCH_INFERIOR_REGISTERS
+#define ATTACH_DETACH
+
+#define CHILD_POST_STARTUP_INFERIOR
+#define CHILD_POST_ATTACH
+
+struct target_ops;
+extern void mint_post_unpush_target (struct target_ops *t);
+#define TARGET_POST_UNPUSH_TARGET_HOOK(t) mint_post_unpush_target (t)
diff -aurN gdb-5.1/gdb/config/m68k/tm-mint.h gdb-5.1-mint-20081102/gdb/config/m68k/tm-mint.h
--- gdb-5.1/gdb/config/m68k/tm-mint.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/config/m68k/tm-mint.h	2008-11-02 14:44:24.515625000 +0100
@@ -0,0 +1,32 @@
+/* Macro definitions for m68k-atari running under FreeMiNT.
+   Copyright 2000 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef TM_MINT_H
+#define TM_MINT_H
+
+
+#define BREAKPOINT {0x4a, 0xfc}
+#define REMOTE_BREAKPOINT BREAKPOINT
+#define DECR_PC_AFTER_BREAK 0
+
+#include "m68k/tm-m68k.h"
+
+
+#endif /* TM_MINT_H */
diff -aurN gdb-5.1/gdb/config/m68k/xm-mint.h gdb-5.1-mint-20081102/gdb/config/m68k/xm-mint.h
--- gdb-5.1/gdb/config/m68k/xm-mint.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/config/m68k/xm-mint.h	2008-11-02 14:44:24.515625000 +0100
@@ -0,0 +1,36 @@
+/* Parameters for execution on a m68k-atari running FreeMiNT, for GDB.
+   Copyright 2000 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef XM_MINT_H
+#define XM_MINT_H
+
+/* Include this to get things like NGROUPS which <limits.h> doesn't
+   define on some systems. */
+#include <sys/param.h>
+
+/* We have to include these files now, so that GDB will not make
+   competing definitions in defs.h.  */
+#include <limits.h>
+
+
+#include "m68k/xm-m68k.h"
+
+
+#endif /* XM_MINT_H */
diff -aurN gdb-5.1/gdb/configure gdb-5.1-mint-20081102/gdb/configure
--- gdb-5.1/gdb/configure	2001-08-02 23:30:20.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/configure	2008-11-02 15:19:33.343750000 +0100
@@ -6697,7 +6697,7 @@
 if test x$gdb_host = xgo32; then
   TERM_LIB=
 else
-if test x$gdb_cv_os_cygwin = xyes; then
+if test neverx$gdb_cv_os_cygwin = xyes; then
   TERM_LIB='`if test -r ../libtermcap/libtermcap.a; then echo ../libtermcap/libtermcap.a; else echo -ltermcap; fi`'
 else
   TERM_LIB=
diff -aurN gdb-5.1/gdb/configure.host gdb-5.1-mint-20081102/gdb/configure.host
--- gdb-5.1/gdb/configure.host	2001-07-10 22:41:54.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/configure.host	2008-11-02 14:44:24.609375000 +0100
@@ -98,6 +98,7 @@
 # OBSOLETE m68*-isi-*)		gdb_host=isi ;;
 m68*-*-linux*)		gdb_host=linux ;;
 m68*-*-lynxos*)		gdb_host=m68klynx ;;
+m68*-*-mint*)		gdb_host=mint ;;
 m68*-*-netbsd*)		gdb_host=nbsd ;;
 m68*-*-sysv4*)		gdb_host=m68kv4 ;;
 m68*-motorola-*)	gdb_host=delta68 ;;
diff -aurN gdb-5.1/gdb/configure.in gdb-5.1-mint-20081102/gdb/configure.in
--- gdb-5.1/gdb/configure.in	2001-08-02 23:30:22.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/configure.in	2008-11-02 15:19:27.234375000 +0100
@@ -830,7 +830,7 @@
 if test x$gdb_host = xgo32; then
   TERM_LIB=
 else
-if test x$gdb_cv_os_cygwin = xyes; then
+if test neverx$gdb_cv_os_cygwin = xyes; then
   TERM_LIB='`if test -r ../libtermcap/libtermcap.a; then echo ../libtermcap/libtermcap.a; else echo -ltermcap; fi`'
 else
   TERM_LIB=
diff -aurN gdb-5.1/gdb/configure.tgt gdb-5.1-mint-20081102/gdb/configure.tgt
--- gdb-5.1/gdb/configure.tgt	2001-07-19 07:10:38.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/configure.tgt	2008-11-02 14:44:24.640625000 +0100
@@ -169,6 +169,8 @@
 		configdirs="${configdirs} gdbserver" ;;
 m68*-*-lynxos*)		gdb_target=m68klynx
 		configdirs="${configdirs} gdbserver" ;;
+m68*-*-mint*)		gdb_target=mint
+		configdirs="${configdirs} gdbserver" ;;
 m68*-*-netbsd*)		gdb_target=nbsd
 		configdirs="${configdirs} gdbserver" ;;
 m68*-*-os68k*)		gdb_target=os68k ;;
diff -aurN gdb-5.1/gdb/gdbserver/Makefile.in gdb-5.1-mint-20081102/gdb/gdbserver/Makefile.in
--- gdb-5.1/gdb/gdbserver/Makefile.in	2001-03-06 09:21:43.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/gdbserver/Makefile.in	2008-11-02 14:44:24.640625000 +0100
@@ -128,9 +128,9 @@
 # All source files that go into linking GDB remote server.
 
 SFILES = $(srcdir)/low-hppabsd.c $(srcdir)/low-linux.c $(srcdir)/low-lynx.c \
-	 $(srcdir)/low-nbsd.c $(srcdir)/low-sim.c $(srcdir)/low-sparc.c \
-	 $(srcdir)/low-sun3.c $(srcdir)/utils.c $(srcdir)/server.c \
-	 $(srcdir)/remote-utils.c
+	 $(srcdir)/low-mint.c $(srcdir)/low-nbsd.c $(srcdir)/low-sim.c \
+	 $(srcdir)/low-sparc.c $(srcdir)/low-sun3.c $(srcdir)/utils.c \
+	 $(srcdir)/server.c $(srcdir)/remote-utils.c
 
 DEPFILES = $(GDBSERVER_DEPFILES)
 
@@ -241,6 +241,7 @@
 remote-utils.o : ${srcdir}/remote-utils.c ${srcdir}/server.h
 low-linux.o : ${srcdir}/low-linux.c ${srcdir}/server.h
 low-lynx.o : ${srcdir}/low-lynx.c ${srcdir}/server.h
+low-mint.o : ${srcdir}/low-mint.c ${srcdir}/server.h
 low-nbsd.o : ${srcdir}/low-nbsd.c ${srcdir}/server.h
 low-sim.o : ${srcdir}/low-sim.c ${srcdir}/server.h
 low-sparc.o : $(srcdir)/low-sparc.c $(srcdir)/server.h
diff -aurN gdb-5.1/gdb/gdbserver/gdbreplay.c gdb-5.1-mint-20081102/gdb/gdbserver/gdbreplay.c
--- gdb-5.1/gdb/gdbserver/gdbreplay.c	2001-03-06 09:21:43.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/gdbserver/gdbreplay.c	2008-11-02 14:44:24.656250000 +0100
@@ -146,7 +146,9 @@
 					   exits when the remote side dies.  */
     }
 
+#ifndef __MINT__
   fcntl (remote_desc, F_SETFL, FASYNC);
+#endif
 
   fprintf (stderr, "Replay logfile using %s\n", name);
   fflush (stderr);
diff -aurN gdb-5.1/gdb/gdbserver/low-mint.c gdb-5.1-mint-20081102/gdb/gdbserver/low-mint.c
--- gdb-5.1/gdb/gdbserver/low-mint.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/gdbserver/low-mint.c	2008-11-02 14:44:24.656250000 +0100
@@ -0,0 +1,281 @@
+/* Low level interface to ptrace, for the remote server for GDB.
+   Copyright 1986, 1987, 1993, 2000, 2001 Free Software Foundation, Inc.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "server.h"
+#include <sys/types.h>
+#include <sys/wait.h>
+#include "frame.h"
+#include "inferior.h"
+
+#include <stdio.h>
+#include <errno.h>
+
+/***************Begin MY defs*********************/
+int quit_flag = 0;
+static char my_registers[REGISTER_BYTES];
+char *registers = my_registers;
+
+/* Index within `registers' of the first byte of the space for
+   register N.  */
+
+char buf2[MAX_REGISTER_RAW_SIZE];
+/***************End MY defs*********************/
+
+#include <sys/ptrace.h>
+
+struct reg
+{
+	long	regs[16];	/* D0-D7/A0-A7 */
+	long	sr;
+	long	pc;
+};
+
+struct fpreg
+{
+	long	regs[3*8];	/* FP0-FP7 */
+	long	fpcr;
+	long	fpsr;
+	long	fpiar;
+};
+
+extern int sys_nerr;
+// extern char **sys_errlist;
+extern char **environ;
+extern int inferior_pid;
+void quit (), perror_with_name ();
+
+
+/* Start an inferior process and returns its pid.
+   ALLARGS is a vector of program-name and args. */
+
+int
+create_inferior (char *program, char **allargs)
+{
+  int pid;
+
+  pid = fork ();
+  if (pid < 0)
+    perror_with_name ("fork");
+
+  if (pid == 0)
+    {
+      ptrace (PT_TRACE_ME, 0, 0, 0);
+
+      execv (program, allargs);
+
+      fprintf (stderr, "Cannot exec %s: %s.\n", program,
+	       errno < sys_nerr ? sys_errlist[errno] : "unknown error");
+      fflush (stderr);
+      _exit (0177);
+    }
+
+  return pid;
+}
+
+/* Kill the inferior process.  Make us have no inferior.  */
+
+void
+kill_inferior (void)
+{
+  if (inferior_pid == 0)
+    return;
+  ptrace (PT_KILL, inferior_pid, 0, 0);
+  wait (0);
+  /*************inferior_died ();****VK**************/
+}
+
+/* Return nonzero if the given thread is still alive.  */
+int
+mythread_alive (int pid)
+{
+  return 1;
+}
+
+/* Wait for process, returns status */
+
+unsigned char
+mywait (char *status)
+{
+  int pid;
+  int w;
+
+  pid = wait (&w);
+  if (pid != inferior_pid)
+    perror_with_name ("wait");
+
+  if (WIFEXITED (w))
+    {
+      fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
+      *status = 'W';
+      return ((unsigned char) WEXITSTATUS (w));
+    }
+  else if (!WIFSTOPPED (w))
+    {
+      fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
+      *status = 'X';
+      return ((unsigned char) WTERMSIG (w));
+    }
+
+  fetch_inferior_registers (0);
+
+  *status = 'T';
+  return ((unsigned char) WSTOPSIG (w));
+}
+
+/* Resume execution of the inferior process.
+   If STEP is nonzero, single-step it.
+   If SIGNAL is nonzero, give it that signal.  */
+
+void
+myresume (int step, int signal)
+{
+  errno = 0;
+  ptrace (step ? PT_STEP : PT_CONTINUE, inferior_pid, 
+	  (PTRACE_ARG3_TYPE) 1, signal);
+  if (errno)
+    perror_with_name ("ptrace");
+}
+
+/* Fetch one or more registers from the inferior.  REGNO == -1 to get
+   them all.  We actually fetch more than requested, when convenient,
+   marking them as valid so we won't fetch them again.  */
+
+void
+fetch_inferior_registers (int ignored)
+{
+  struct reg inferior_registers;
+  struct fpreg inferior_fp_registers;
+
+  ptrace (PT_GETREGS, inferior_pid,
+	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
+  memcpy (&registers[REGISTER_BYTE(0)], &inferior_registers, 
+	  sizeof(inferior_registers));
+
+#if 0 /* def FP0_REGNUM */
+  ptrace (PT_GETFPREGS, inferior_pid,
+	  (PTRACE_ARG3_TYPE) &inferior_fp_registers, 0);
+  memcpy (&registers[REGISTER_BYTE(FP0_REGNUM)], &inferior_fp_registers,
+	  sizeof(inferior_fp_registers));
+#endif
+}
+
+/* Store our register values back into the inferior.
+   If REGNO is -1, do this for all registers.
+   Otherwise, REGNO specifies which register (so we can save time).  */
+
+void
+store_inferior_registers (int ignored)
+{
+  struct reg inferior_registers;
+  struct fpreg inferior_fp_registers;
+
+  memcpy (&inferior_registers, &registers[REGISTER_BYTE(0)], 
+	  sizeof(inferior_registers));
+  ptrace (PT_SETREGS, inferior_pid,
+	  (PTRACE_ARG3_TYPE) &inferior_registers, 0);
+
+#if 0 /* def FP0_REGNUM */
+  memcpy (&inferior_fp_registers, &registers[REGISTER_BYTE (FP0_REGNUM)],
+	  sizeof (inferior_fp_registers));
+  ptrace (PT_SETFPREGS, inferior_pid,
+	  (PTRACE_ARG3_TYPE) &inferior_fp_registers, 0);
+#endif
+}
+
+/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
+   in the NEW_SUN_PTRACE case.
+   It ought to be straightforward.  But it appears that writing did
+   not write the data that I specified.  I cannot understand where
+   it got the data that it actually did write.  */
+
+/* Copy LEN bytes from inferior's memory starting at MEMADDR
+   to debugger memory starting at MYADDR.  */
+
+void
+read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
+{
+  register int i;
+  /* Round starting address down to longword boundary.  */
+  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
+  /* Round ending address up; get number of longwords that makes.  */
+  register int count
+  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
+  /* Allocate buffer of that many longwords.  */
+  register int *buffer = (int *) alloca (count * sizeof (int));
+
+  /* Read all the longwords */
+  for (i = 0; i < count; i++, addr += sizeof (int))
+    {
+      buffer[i] = ptrace (PT_READ_D, inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
+    }
+
+  /* Copy appropriate bytes out of the buffer.  */
+  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
+}
+
+/* Copy LEN bytes of data from debugger memory at MYADDR
+   to inferior's memory at MEMADDR.
+   On failure (cannot write the inferior)
+   returns the value of errno.  */
+
+int
+write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
+{
+  register int i;
+  /* Round starting address down to longword boundary.  */
+  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
+  /* Round ending address up; get number of longwords that makes.  */
+  register int count
+  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
+  /* Allocate buffer of that many longwords.  */
+  register int *buffer = (int *) alloca (count * sizeof (int));
+  extern int errno;
+
+  /* Fill start and end extra bytes of buffer with existing memory data.  */
+
+  buffer[0] = ptrace (PT_READ_D, inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
+
+  if (count > 1)
+    {
+      buffer[count - 1]
+	= ptrace (PT_READ_D, inferior_pid,
+		  (PTRACE_ARG3_TYPE) addr + (count - 1) * sizeof (int), 0);
+    }
+
+  /* Copy data to be written over corresponding part of buffer */
+
+  memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);
+
+  /* Write the entire buffer.  */
+
+  for (i = 0; i < count; i++, addr += sizeof (int))
+    {
+      errno = 0;
+      ptrace (PT_WRITE_D, inferior_pid, (PTRACE_ARG3_TYPE) addr, buffer[i]);
+      if (errno)
+	return errno;
+    }
+
+  return 0;
+}
+
+void 
+initialize_low (void)
+{
+}
diff -aurN gdb-5.1/gdb/gdbserver/server.c gdb-5.1-mint-20081102/gdb/gdbserver/server.c
--- gdb-5.1/gdb/gdbserver/server.c	2001-03-06 09:21:44.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/gdbserver/server.c	2008-11-02 14:44:24.671875000 +0100
@@ -199,6 +199,31 @@
 		  own_buf[0] = '\0';
 		  break;
 		}
+#ifdef __MINT__
+	    case 'q':
+	      if (strcmp ("qOffsets", own_buf) == 0)
+		{
+		  CORE_ADDR offset;
+
+		  if (ptrace (999, inferior_pid, 0, (long) &offset))
+		  {
+		    fprintf (stderr, "cannot get basepage address for pid %d\n", inferior_pid);
+		    write_enn (own_buf);
+		    break;
+		  }
+
+		  offset += 0x100;
+
+		  sprintf (own_buf, "Text=%lX;Data=%lX;Bss=%lX",
+		    (long)offset, (long)offset, (long)offset);
+		}
+	      else
+	        {
+		  /* Unknown query */
+		  own_buf[0] = '\0';
+	        }
+	      break;
+#endif /* __MINT__ */
 	    default:
 	      /* It is a request we don't understand.  Respond with an
 	         empty packet so that gdb knows that we don't support this
diff -aurN gdb-5.1/gdb/m68kmint-nat.c gdb-5.1-mint-20081102/gdb/m68kmint-nat.c
--- gdb-5.1/gdb/m68kmint-nat.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-5.1-mint-20081102/gdb/m68kmint-nat.c	2008-11-02 14:44:24.687500000 +0100
@@ -0,0 +1,154 @@
+/* Native-dependent code for Motorola m68k's running FreeMiNT, for GDB.
+   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <sys/wait.h>
+
+struct reg
+{
+	long	regs[16];	/* D0-D7/A0-A7 */
+	long	sr;
+	long	pc;
+};
+
+struct fpreg
+{
+	long	regs[3*8];	/* FP0-FP7 */
+	long	fpcr;
+	long	fpsr;
+	long	fpiar;
+};
+
+#include "inferior.h"
+#include "gdbcore.h"
+#include "regcache.h"
+
+void
+fetch_inferior_registers (int regno)
+{
+  struct reg inferior_registers;
+  struct fpreg inferior_fp_registers;
+
+  ptrace (PT_GETREGS, PIDGET (inferior_ptid),
+	  (PTRACE_ARG3_TYPE) & inferior_registers, 0);
+  memcpy (&registers[REGISTER_BYTE (0)], &inferior_registers,
+	  sizeof (inferior_registers));
+
+  ptrace (PT_GETFPREGS, PIDGET (inferior_ptid),
+	  (PTRACE_ARG3_TYPE) & inferior_fp_registers, 0);
+  memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], &inferior_fp_registers,
+	  sizeof (inferior_fp_registers));
+
+  registers_fetched ();
+}
+
+void
+store_inferior_registers (int regno)
+{
+  struct reg inferior_registers;
+  struct fpreg inferior_fp_registers;
+
+  memcpy (&inferior_registers, &registers[REGISTER_BYTE (0)],
+	  sizeof (inferior_registers));
+  ptrace (PT_SETREGS, PIDGET (inferior_ptid),
+	  (PTRACE_ARG3_TYPE) & inferior_registers, 0);
+
+  memcpy (&inferior_fp_registers, &registers[REGISTER_BYTE (FP0_REGNUM)],
+	  sizeof (inferior_fp_registers));
+  ptrace (PT_SETFPREGS, PIDGET (inferior_ptid),
+	  (PTRACE_ARG3_TYPE) & inferior_fp_registers, 0);
+}
+
+# include "gdb-stabs.h"
+# include "symfile.h"
+# include "objfiles.h"
+
+static void
+child_initialize (int pid)
+{
+  CORE_ADDR basepage;
+  struct objfile *objfile;
+
+  if (ptrace (999, pid, 0, (long) &basepage))
+    error ("cannot get basepage address for pid %d", pid);
+
+  basepage += 0x100;
+
+  ALL_OBJFILES(objfile)
+  {
+    struct section_offsets *new_offsets;
+    int i;
+
+    new_offsets = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
+
+    for (i = 0; i < objfile->num_sections; ++i)
+      new_offsets->offsets[i] = objfile->section_offsets->offsets[i];
+
+    new_offsets->offsets[SECT_OFF_TEXT (objfile)] = basepage;
+    new_offsets->offsets[SECT_OFF_DATA (objfile)] = basepage;
+    new_offsets->offsets[SECT_OFF_BSS (objfile)] = basepage;
+    /* new_offsets->offsets[SECT_OFF_RODATA (objfile)] = basepage; */
+
+    objfile_relocate (objfile, new_offsets);
+  }
+}
+
+void
+child_post_startup_inferior (ptid_t ptid)
+{
+  child_initialize (PIDGET (ptid));
+}
+
+void
+child_post_attach (int pid)
+{
+  child_initialize (pid);
+}
+
+void
+mint_post_unpush_target (struct target_ops *t)
+{
+  extern struct target_ops child_ops; /* inftarg.c */
+  struct objfile *objfile;
+
+  if (t != &child_ops)
+    return;
+
+  ALL_OBJFILES(objfile)
+  {
+    struct section_offsets *new_offsets;
+    int i;
+
+    new_offsets = (struct section_offsets *) alloca (SIZEOF_SECTION_OFFSETS);
+
+    for (i = 0; i < objfile->num_sections; ++i)
+      new_offsets->offsets[i] = objfile->section_offsets->offsets[i];
+
+    new_offsets->offsets[SECT_OFF_TEXT (objfile)] = 0;
+    new_offsets->offsets[SECT_OFF_DATA (objfile)] = 0;
+    new_offsets->offsets[SECT_OFF_BSS (objfile)] = 0;
+    /* new_offsets->offsets[SECT_OFF_RODATA (objfile)] = 0; */
+
+    objfile_relocate (objfile, new_offsets);
+  }
+}
diff -aurN gdb-5.1/gdb/target.c gdb-5.1-mint-20081102/gdb/target.c
--- gdb-5.1/gdb/target.c	2001-07-19 20:09:11.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/target.c	2008-11-02 14:44:24.718750000 +0100
@@ -721,6 +721,8 @@
   update_current_target ();
   cleanup_target (&current_target);
 
+  TARGET_POST_UNPUSH_TARGET_HOOK(t);
+
   return 1;
 }
 
diff -aurN gdb-5.1/gdb/target.h gdb-5.1-mint-20081102/gdb/target.h
--- gdb-5.1/gdb/target.h	2001-05-04 06:15:27.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/target.h	2008-11-02 14:44:24.734375000 +0100
@@ -1012,6 +1012,13 @@
 #define TARGET_CREATE_INFERIOR_HOOK(PID)
 #endif
 
+/* Hook to call target dependant code just after a target ops vector is
+   pushed from stack.  */
+
+#ifndef TARGET_POST_UNPUSH_TARGET_HOOK
+#define TARGET_POST_UNPUSH_TARGET_HOOK(t)
+#endif
+
 /* Hardware watchpoint interfaces.  */
 
 /* Returns non-zero if we were stopped by a hardware watchpoint (memory read or
diff -aurN gdb-5.1/gdb/top.c gdb-5.1-mint-20081102/gdb/top.c
--- gdb-5.1/gdb/top.c	2001-10-21 21:41:19.000000000 +0200
+++ gdb-5.1-mint-20081102/gdb/top.c	2008-11-02 15:20:11.890625000 +0100
@@ -1228,7 +1228,7 @@
      program to parse, and is just canonical program name and version
      number, which starts after last space. */
 
-  fprintf_filtered (stream, "GNU gdb %s\n", version);
+  fprintf_filtered (stream, "GNU gdb %s (MiNT 20081102)\n", version);
 
   /* Second line is a copyright notice. */
 
diff -aurN gdb-5.1/include/obstack.h gdb-5.1-mint-20081102/include/obstack.h
--- gdb-5.1/include/obstack.h	2001-03-14 03:27:43.000000000 +0100
+++ gdb-5.1-mint-20081102/include/obstack.h	2008-11-02 14:44:24.765625000 +0100
@@ -423,7 +423,8 @@
 ({ struct obstack *__o = (OBSTACK);					\
    if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
      _obstack_newchunk (__o, sizeof (void *));				\
-   *((void **)__o->next_free)++ = ((void *)datum);			\
+   *((void **)__o->next_free) = ((void *)datum);			\
+   __o->next_free += sizeof (void *);					\
    (void) 0; })
 
 # define obstack_int_grow(OBSTACK,datum)				\
diff -aurN gdb-5.1/readline/Makefile.in gdb-5.1-mint-20081102/readline/Makefile.in
--- gdb-5.1/readline/Makefile.in	2000-07-09 19:19:55.000000000 +0200
+++ gdb-5.1-mint-20081102/readline/Makefile.in	2008-11-02 14:44:24.765625000 +0100
@@ -63,7 +63,7 @@
 TERMCAP_LIB = @TERMCAP_LIB@
 
 # For libraries which include headers from other libraries.
-INCLUDES = -I. -I$(srcdir) -I$(includedir)
+INCLUDES = -I. -I$(srcdir)
 
 CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)
 
diff -aurN gdb-5.1/readline/terminal.c gdb-5.1-mint-20081102/readline/terminal.c
--- gdb-5.1/readline/terminal.c	2000-07-10 17:22:16.000000000 +0200
+++ gdb-5.1-mint-20081102/readline/terminal.c	2008-11-02 14:44:24.781250000 +0100
@@ -537,7 +537,7 @@
 int
 crlf ()
 {
-#if defined (NEW_TTY_DRIVER)
+#if defined (NEW_TTY_DRIVER) || defined (__MINT__)
   if (term_cr)
     tputs (term_cr, 1, _rl_output_character_function);
 #endif /* NEW_TTY_DRIVER */
