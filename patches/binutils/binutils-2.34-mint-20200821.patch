diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index d32640a12c..550f18f6d9 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -265,6 +265,7 @@ BFD32_BACKENDS = \
 	aout-cris.lo \
 	aout-ns32k.lo \
 	aout-tic30.lo \
+	aout0.lo \
 	aout32.lo \
 	cf-i386lynx.lo \
 	coff-go32.lo \
@@ -385,6 +386,7 @@ BFD32_BACKENDS = \
 	peigen.lo \
 	plugin.lo \
 	ppcboot.lo \
+	prg-mint.lo \
 	reloc16.lo \
 	som.lo \
 	vax1knetbsd.lo \
@@ -401,6 +403,7 @@ BFD32_BACKENDS_CFILES = \
 	aout-cris.c \
 	aout-ns32k.c \
 	aout-tic30.c \
+	aout0.c \
 	aout32.c \
 	cf-i386lynx.c \
 	coff-go32.c \
@@ -520,6 +523,7 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	plugin.c \
 	ppcboot.c \
+	prg-mint.c \
 	reloc16.c \
 	som.c \
 	vax1knetbsd.c \
@@ -681,7 +685,7 @@ CFILES = $(SOURCE_CFILES) $(BUILD_CFILES)
 ## This is a list of all .h files in the source tree minus those that
 ## are processed to produce other .h files
 SOURCE_HFILES = \
-	aout-target.h aoutx.h arc-got.h arc-plt.h \
+	aout-target.h aoutf1.h aoutx.h arc-got.h arc-plt.h \
 	coff-arm.h coff-bfd.h coffcode.h coffswap.h \
 	cpu-aarch64.h cpu-arm.h cpu-h8300.h cpu-m68k.h \
 	ecoff-bfd.h ecoffswap.h \
@@ -972,11 +976,6 @@ bfdver.h: $(srcdir)/version.h $(srcdir)/development.sh $(srcdir)/Makefile.in
 	bfd_version_package="\"$(PKGVERSION)\"" ;\
 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
 	. $(srcdir)/development.sh ;\
-	if test "$$development" = true ; then \
-	  bfd_version_date=`$(SED) -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
-	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
-	fi ;\
 	$(SED) -e "s,@bfd_version@,$$bfd_version," \
 	    -e "s,@bfd_version_string@,$$bfd_version_string," \
 	    -e "s,@bfd_version_package@,$$bfd_version_package," \
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 78555ccbbc..53d13a0768 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -690,6 +690,7 @@ BFD32_BACKENDS = \
 	aout-cris.lo \
 	aout-ns32k.lo \
 	aout-tic30.lo \
+	aout0.lo \
 	aout32.lo \
 	cf-i386lynx.lo \
 	coff-go32.lo \
@@ -810,6 +811,7 @@ BFD32_BACKENDS = \
 	peigen.lo \
 	plugin.lo \
 	ppcboot.lo \
+	prg-mint.lo \
 	reloc16.lo \
 	som.lo \
 	vax1knetbsd.lo \
@@ -826,6 +828,7 @@ BFD32_BACKENDS_CFILES = \
 	aout-cris.c \
 	aout-ns32k.c \
 	aout-tic30.c \
+	aout0.c \
 	aout32.c \
 	cf-i386lynx.c \
 	coff-go32.c \
@@ -945,6 +948,7 @@ BFD32_BACKENDS_CFILES = \
 	pei-sh.c \
 	plugin.c \
 	ppcboot.c \
+	prg-mint.c \
 	reloc16.c \
 	som.c \
 	vax1knetbsd.c \
@@ -1103,7 +1107,7 @@ BUILD_CFILES = \
 
 CFILES = $(SOURCE_CFILES) $(BUILD_CFILES)
 SOURCE_HFILES = \
-	aout-target.h aoutx.h arc-got.h arc-plt.h \
+	aout-target.h aoutf1.h aoutx.h arc-got.h arc-plt.h \
 	coff-arm.h coff-bfd.h coffcode.h coffswap.h \
 	cpu-aarch64.h cpu-arm.h cpu-h8300.h cpu-m68k.h \
 	ecoff-bfd.h ecoffswap.h \
@@ -1298,6 +1302,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout-cris.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout-ns32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout-tic30.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout0.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aout64.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/archive.Plo@am__quote@
@@ -1567,6 +1572,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pex64igen.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ppcboot.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prg-mint.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reloc16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rs6000-core.Plo@am__quote@
@@ -2086,11 +2092,6 @@ bfdver.h: $(srcdir)/version.h $(srcdir)/development.sh $(srcdir)/Makefile.in
 	bfd_version_package="\"$(PKGVERSION)\"" ;\
 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
 	. $(srcdir)/development.sh ;\
-	if test "$$development" = true ; then \
-	  bfd_version_date=`$(SED) -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
-	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
-	fi ;\
 	$(SED) -e "s,@bfd_version@,$$bfd_version," \
 	    -e "s,@bfd_version_string@,$$bfd_version_string," \
 	    -e "s,@bfd_version_package@,$$bfd_version_package," \
diff --git a/bfd/acinclude.m4 b/bfd/acinclude.m4
index b014ef3a8c..e3fbbee602 100644
--- a/bfd/acinclude.m4
+++ b/bfd/acinclude.m4
@@ -21,7 +21,7 @@ AC_DEFUN([BFD_BINARY_FOPEN],
 [AC_REQUIRE([AC_CANONICAL_TARGET])
 case "${host}" in
 changequote(,)dnl
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 changequote([,])dnl
   AC_DEFINE(USE_BINARY_FOPEN, 1, [Use b modifier when opening binary files?]) ;;
 esac])dnl
diff --git a/bfd/aout0.c b/bfd/aout0.c
new file mode 100644
index 0000000000..890dce6de1
--- /dev/null
+++ b/bfd/aout0.c
@@ -0,0 +1,38 @@
+/* BFD backend for SunOS style a.out with flags set to 0
+   Copyright (C) 1990-2018 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#define TARGETNAME "a.out-zero-big"
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (aout0_be_,OP)
+
+#include "sysdep.h"
+#include "bfd.h"
+
+#define MY_exec_hdr_flags 0
+
+#define MACHTYPE_OK(mtype) \
+  ((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020)
+
+/* Include the usual a.out support.  */
+#include "aoutf1.h"
diff --git a/bfd/aoutf1.h b/bfd/aoutf1.h
new file mode 100644
index 0000000000..b039d6aea8
--- /dev/null
+++ b/bfd/aoutf1.h
@@ -0,0 +1,793 @@
+/* A.out "format 1" file handling code for BFD.
+   Copyright (C) 1990-2018 Free Software Foundation, Inc.
+   Written by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+#include "aout/sun4.h"
+#include "libaout.h"		/* BFD a.out internal data structures.  */
+
+#include "aout/aout64.h"
+#include "aout/stab_gnu.h"
+#include "aout/ar.h"
+
+/* This is needed to reject a NewsOS file, e.g. in
+   gdb/testsuite/gdb.t10/crossload.exp. <kingdon@cygnus.com>
+   I needed to add M_UNKNOWN to recognize a 68000 object, so this will
+   probably no longer reject a NewsOS object.  <ian@cygnus.com>.  */
+#ifndef MACHTYPE_OK
+#define MACHTYPE_OK(mtype) \
+  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
+   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
+       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))
+#endif
+
+/* The file @code{aoutf1.h} contains the code for BFD's
+   a.out back end.  Control over the generated back end is given by these
+   two preprocessor names:
+   @table @code
+   @item ARCH_SIZE
+   This value should be either 32 or 64, depending upon the size of an
+   int in the target format. It changes the sizes of the structs which
+   perform the memory/disk mapping of structures.
+
+   The 64 bit backend may only be used if the host compiler supports 64
+   ints (eg long long with gcc), by defining the name @code{BFD_HOST_64_BIT} in @code{bfd.h}.
+   With this name defined, @emph{all} bfd operations are performed with 64bit
+   arithmetic, not just those to a 64bit target.
+
+   @item TARGETNAME
+   The name put into the target vector.
+   @item
+   @end table.  */
+
+#if ARCH_SIZE == 64
+#define sunos_set_arch_mach sunos_64_set_arch_mach
+#define sunos_write_object_contents aout_64_sunos4_write_object_contents
+#else
+#define sunos_set_arch_mach sunos_32_set_arch_mach
+#define sunos_write_object_contents aout_32_sunos4_write_object_contents
+#endif
+
+/* Merge backend data into the output file.
+   This is necessary on sparclet-aout where we want the resultant machine
+   number to be M_SPARCLET if any input file is M_SPARCLET.  */
+
+#define MY_bfd_merge_private_bfd_data sunos_merge_private_bfd_data
+
+static bfd_boolean
+sunos_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  if (bfd_get_flavour (ibfd) != bfd_target_aout_flavour
+      || bfd_get_flavour (obfd) != bfd_target_aout_flavour)
+    return TRUE;
+
+  if (bfd_get_arch (obfd) == bfd_arch_sparc)
+    {
+      if (bfd_get_mach (obfd) < bfd_get_mach (ibfd))
+	bfd_set_arch_mach (obfd, bfd_arch_sparc, bfd_get_mach (ibfd));
+    }
+
+  return TRUE;
+}
+
+/* This is either sunos_32_set_arch_mach or sunos_64_set_arch_mach,
+   depending upon ARCH_SIZE.  */
+
+static void
+sunos_set_arch_mach (bfd *abfd, enum machine_type machtype)
+{
+  /* Determine the architecture and machine type of the object file.  */
+  enum bfd_architecture arch;
+  unsigned long machine;
+
+  switch (machtype)
+    {
+    case M_UNKNOWN:
+      /* Some Sun3s make magic numbers without cpu types in them, so
+	 we'll default to the 68000.  */
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68000;
+      break;
+
+    case M_68010:
+    case M_HP200:
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68010;
+      break;
+
+    case M_68020:
+    case M_HP300:
+      arch = bfd_arch_m68k;
+      machine = bfd_mach_m68020;
+      break;
+
+    case M_SPARC:
+      arch = bfd_arch_sparc;
+      machine = 0;
+      break;
+
+    case M_SPARCLET:
+      arch = bfd_arch_sparc;
+      machine = bfd_mach_sparc_sparclet;
+      break;
+
+    case M_SPARCLITE_LE:
+      arch = bfd_arch_sparc;
+      machine = bfd_mach_sparc_sparclite_le;
+      break;
+
+    case M_386:
+    case M_386_DYNIX:
+      arch = bfd_arch_i386;
+      machine = 0;
+      break;
+
+    case M_HPUX:
+      arch = bfd_arch_m68k;
+      machine = 0;
+      break;
+
+    default:
+      arch = bfd_arch_obscure;
+      machine = 0;
+      break;
+    }
+  bfd_set_arch_mach (abfd, arch, machine);
+}
+
+#define SET_ARCH_MACH(ABFD, EXECP) \
+  NAME(sunos,set_arch_mach) (ABFD, N_MACHTYPE (EXECP)); \
+  choose_reloc_size(ABFD);
+
+/* Determine the size of a relocation entry, based on the architecture.  */
+
+static void
+choose_reloc_size (bfd *abfd)
+{
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_sparc:
+      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
+      break;
+    default:
+      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
+      break;
+    }
+}
+
+/* Write an object file in SunOS format.  Section contents have
+   already been written.  We write the file header, symbols, and
+   relocation.  The real name of this function is either
+   aout_64_sunos4_write_object_contents or
+   aout_32_sunos4_write_object_contents, depending upon ARCH_SIZE.  */
+
+static bfd_boolean
+sunos_write_object_contents (bfd *abfd)
+{
+  struct external_exec exec_bytes;
+  struct internal_exec *execp = exec_hdr (abfd);
+
+  /* Magic number, maestro, please!  */
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_m68k:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_m68000:
+	  N_SET_MACHTYPE (execp, M_UNKNOWN);
+	  break;
+	case bfd_mach_m68010:
+	  N_SET_MACHTYPE (execp, M_68010);
+	  break;
+	default:
+	case bfd_mach_m68020:
+	  N_SET_MACHTYPE (execp, M_68020);
+	  break;
+	}
+      break;
+    case bfd_arch_sparc:
+      switch (bfd_get_mach (abfd))
+	{
+	case bfd_mach_sparc_sparclet:
+	  N_SET_MACHTYPE (execp, M_SPARCLET);
+	  break;
+	case bfd_mach_sparc_sparclite_le:
+	  N_SET_MACHTYPE (execp, M_SPARCLITE_LE);
+	  break;
+	default:
+	  N_SET_MACHTYPE (execp, M_SPARC);
+	  break;
+	}
+      break;
+    case bfd_arch_i386:
+      N_SET_MACHTYPE (execp, M_386);
+      break;
+    default:
+      N_SET_MACHTYPE (execp, M_UNKNOWN);
+    }
+
+  choose_reloc_size (abfd);
+
+  N_SET_FLAGS (execp, aout_backend_info (abfd)->exec_hdr_flags);
+
+  N_SET_DYNAMIC (execp, (long)(bfd_get_file_flags (abfd) & DYNAMIC));
+
+  WRITE_HEADERS (abfd, execp);
+
+  return TRUE;
+}
+
+/* Core files.  */
+
+#define CORE_MAGIC   0x080456
+#define CORE_NAMELEN 16
+
+/* The core structure is taken from the Sun documentation.
+  Unfortunately, they don't document the FPA structure, or at least I
+  can't find it easily.  Fortunately the core header contains its own
+  length.  So this shouldn't cause problems, except for c_ucode, which
+  so far we don't use but is easy to find with a little arithmetic.  */
+
+/* But the reg structure can be gotten from the SPARC processor handbook.
+  This really should be in a GNU include file though so that gdb can use
+  the same info.  */
+struct regs
+{
+  int r_psr;
+  int r_pc;
+  int r_npc;
+  int r_y;
+  int r_g1;
+  int r_g2;
+  int r_g3;
+  int r_g4;
+  int r_g5;
+  int r_g6;
+  int r_g7;
+  int r_o0;
+  int r_o1;
+  int r_o2;
+  int r_o3;
+  int r_o4;
+  int r_o5;
+  int r_o6;
+  int r_o7;
+};
+
+/* Taken from Sun documentation: */
+
+/* FIXME:  It's worse than we expect.  This struct contains TWO substructs
+  neither of whose size we know, WITH STUFF IN BETWEEN THEM!  We can't
+  even portably access the stuff in between!  */
+
+struct external_sparc_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SPARC_CORE_LEN	432
+  struct regs c_regs;			/* General purpose registers -- MACHDEP SIZE.  */
+  struct external_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+/* Core files generated by the BCP (the part of Solaris which allows
+   it to run SunOS4 a.out files).  */
+struct external_solaris_bcp_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SOLARIS_BCP_CORE_LEN	456
+  struct regs c_regs;			/* General purpose registers -- MACHDEP SIZE.  */
+  int c_exdata_vp;			/* Exdata structure.  */
+  int c_exdata_tsize;
+  int c_exdata_dsize;
+  int c_exdata_bsize;
+  int c_exdata_lsize;
+  int c_exdata_nshlibs;
+  short c_exdata_mach;
+  short c_exdata_mag;
+  int c_exdata_toffset;
+  int c_exdata_doffset;
+  int c_exdata_loffset;
+  int c_exdata_txtorg;
+  int c_exdata_datorg;
+  int c_exdata_entloc;
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+struct external_sun3_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+#define	SUN3_CORE_LEN	826		/* As of SunOS 4.1.1.  */
+  int c_regs[18];			/* General purpose registers -- MACHDEP SIZE.  */
+  struct external_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  double fp_stuff[1];			/* External FPU state (size unknown by us).  */
+  /* The type "double" is critical here, for alignment.
+     SunOS declares a struct here, but the struct's
+     alignment is double since it contains doubles.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+  /* This member is not accessible by name since
+     we don't portably know the size of fp_stuff.  */
+};
+
+struct internal_sunos_core
+{
+  int c_magic;				/* Corefile magic number.  */
+  int c_len;				/* Sizeof (struct core).  */
+  long c_regs_pos;			/* File offset of General purpose registers.  */
+  int c_regs_size;			/* Size of General purpose registers.  */
+  struct internal_exec c_aouthdr;	/* A.out header.  */
+  int c_signo;				/* Killing signal, if any.  */
+  int c_tsize;				/* Text size (bytes).  */
+  int c_dsize;				/* Data size (bytes).  */
+  bfd_vma c_data_addr;			/* Data start (address).  */
+  int c_ssize;				/* Stack size (bytes).  */
+  bfd_vma c_stacktop;			/* Stack top (address).  */
+  char c_cmdname[CORE_NAMELEN + 1];	/* Command name.  */
+  long fp_stuff_pos;			/* File offset of external FPU state (regs).  */
+  int fp_stuff_size;			/* Size of it.  */
+  int c_ucode;				/* Exception no. from u_code.  */
+};
+
+/* Byte-swap in the Sun-3 core structure.  */
+
+static void
+swapcore_sun3 (bfd *abfd, char *ext, struct internal_sunos_core *intcore)
+{
+  struct external_sun3_core *extcore = (struct external_sun3_core *) ext;
+
+  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
+  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
+  intcore->c_regs_pos = offsetof (struct external_sun3_core, c_regs);
+  intcore->c_regs_size = sizeof (extcore->c_regs);
+#if ARCH_SIZE == 64
+  aout_64_swap_exec_header_in
+#else
+  aout_32_swap_exec_header_in
+#endif
+    (abfd, &extcore->c_aouthdr, &intcore->c_aouthdr);
+  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
+  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
+  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
+  intcore->c_data_addr = N_DATADDR (&intcore->c_aouthdr);
+  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
+  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
+  intcore->fp_stuff_pos = offsetof (struct external_sun3_core, fp_stuff);
+  /* FP stuff takes up whole rest of struct, except c_ucode.  */
+  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
+    offsetof (struct external_sun3_core, fp_stuff);
+  /* Ucode is the last thing in the struct -- just before the end.  */
+  intcore->c_ucode = H_GET_32 (abfd,
+			       (intcore->c_len
+				- sizeof (extcore->c_ucode)
+				+ (unsigned char *) extcore));
+  intcore->c_stacktop = 0x0E000000;	/* By experimentation.  */
+}
+
+/* Byte-swap in the Sparc core structure.  */
+
+static void
+swapcore_sparc (bfd *abfd, char *ext, struct internal_sunos_core *intcore)
+{
+  struct external_sparc_core *extcore = (struct external_sparc_core *) ext;
+
+  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
+  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
+  intcore->c_regs_pos = offsetof (struct external_sparc_core, c_regs);
+  intcore->c_regs_size = sizeof (extcore->c_regs);
+#if ARCH_SIZE == 64
+  aout_64_swap_exec_header_in
+#else
+  aout_32_swap_exec_header_in
+#endif
+    (abfd, &extcore->c_aouthdr, &intcore->c_aouthdr);
+  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
+  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
+  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
+  intcore->c_data_addr = N_DATADDR (&intcore->c_aouthdr);
+  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
+  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
+  intcore->fp_stuff_pos = offsetof (struct external_sparc_core, fp_stuff);
+  /* FP stuff takes up whole rest of struct, except c_ucode.  */
+  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
+    offsetof (struct external_sparc_core, fp_stuff);
+  /* Ucode is the last thing in the struct -- just before the end.  */
+  intcore->c_ucode = H_GET_32 (abfd,
+			       (intcore->c_len
+				- sizeof (extcore->c_ucode)
+				+ (unsigned char *) extcore));
+
+  /* Supposedly the user stack grows downward from the bottom of kernel memory.
+     Presuming that this remains true, this definition will work.  */
+  /* Now sun has provided us with another challenge.  The value is different
+     for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or
+     the other based on the current value of the stack pointer.  This
+     loses (a) if the stack pointer has been clobbered, or (b) if the stack
+     is larger than 128 megabytes.
+
+     It's times like these you're glad they're switching to ELF.
+
+     Note that using include files or nlist on /vmunix would be wrong,
+     because we want the value for this core file, no matter what kind of
+     machine we were compiled on or are running on.  */
+#define SPARC_USRSTACK_SPARC2 ((bfd_vma)0xf8000000)
+#define SPARC_USRSTACK_SPARC10 ((bfd_vma)0xf0000000)
+  {
+    bfd_vma sp = H_GET_32 (abfd, &extcore->c_regs.r_o6);
+    if (sp < SPARC_USRSTACK_SPARC10)
+      intcore->c_stacktop = SPARC_USRSTACK_SPARC10;
+    else
+      intcore->c_stacktop = SPARC_USRSTACK_SPARC2;
+  }
+}
+
+/* Byte-swap in the Solaris BCP core structure.  */
+
+static void
+swapcore_solaris_bcp (bfd *abfd, char *ext, struct internal_sunos_core *intcore)
+{
+  struct external_solaris_bcp_core *extcore =
+    (struct external_solaris_bcp_core *) ext;
+
+  intcore->c_magic = H_GET_32 (abfd, &extcore->c_magic);
+  intcore->c_len = H_GET_32 (abfd, &extcore->c_len);
+  intcore->c_regs_pos = offsetof (struct external_solaris_bcp_core, c_regs);
+  intcore->c_regs_size = sizeof (extcore->c_regs);
+
+  /* The Solaris BCP exdata structure does not contain an a_syms field,
+     so we are unable to synthesize an internal exec header.
+     Luckily we are able to figure out the start address of the data section,
+     which is the only thing needed from the internal exec header,
+     from the exdata structure.
+
+     As of Solaris 2.3, BCP core files for statically linked executables
+     are buggy. The exdata structure is not properly filled in, and
+     the data section is written from address zero instead of the data
+     start address.  */
+  memset ((void *) &intcore->c_aouthdr, 0, sizeof (struct internal_exec));
+  intcore->c_data_addr = H_GET_32 (abfd, &extcore->c_exdata_datorg);
+  intcore->c_signo = H_GET_32 (abfd, &extcore->c_signo);
+  intcore->c_tsize = H_GET_32 (abfd, &extcore->c_tsize);
+  intcore->c_dsize = H_GET_32 (abfd, &extcore->c_dsize);
+  intcore->c_ssize = H_GET_32 (abfd, &extcore->c_ssize);
+  memcpy (intcore->c_cmdname, extcore->c_cmdname, sizeof (intcore->c_cmdname));
+  intcore->fp_stuff_pos =
+    offsetof (struct external_solaris_bcp_core, fp_stuff);
+  /* FP stuff takes up whole rest of struct, except c_ucode.  */
+  intcore->fp_stuff_size = intcore->c_len - (sizeof extcore->c_ucode) -
+    offsetof (struct external_solaris_bcp_core, fp_stuff);
+  /* Ucode is the last thing in the struct -- just before the end */
+  intcore->c_ucode = H_GET_32 (abfd,
+			       (intcore->c_len
+				- sizeof (extcore->c_ucode)
+				+ (unsigned char *) extcore));
+
+  /* Supposedly the user stack grows downward from the bottom of kernel memory.
+     Presuming that this remains true, this definition will work.  */
+  /* Now sun has provided us with another challenge.  The value is different
+     for sparc2 and sparc10 (both running SunOS 4.1.3).  We pick one or
+     the other based on the current value of the stack pointer.  This
+     loses (a) if the stack pointer has been clobbered, or (b) if the stack
+     is larger than 128 megabytes.
+
+     It's times like these you're glad they're switching to ELF.
+
+     Note that using include files or nlist on /vmunix would be wrong,
+     because we want the value for this core file, no matter what kind of
+     machine we were compiled on or are running on.  */
+#define SPARC_USRSTACK_SPARC2 ((bfd_vma)0xf8000000)
+#define SPARC_USRSTACK_SPARC10 ((bfd_vma)0xf0000000)
+  {
+    bfd_vma sp = H_GET_32 (abfd, &extcore->c_regs.r_o6);
+    if (sp < SPARC_USRSTACK_SPARC10)
+      intcore->c_stacktop = SPARC_USRSTACK_SPARC10;
+    else
+      intcore->c_stacktop = SPARC_USRSTACK_SPARC2;
+  }
+}
+
+/* Need this cast because ptr is really void *.  */
+#define core_hdr(bfd)      ((bfd)->tdata.sun_core_data)
+#define core_datasec(bfd)  (core_hdr (bfd)->data_section)
+#define core_stacksec(bfd) (core_hdr (bfd)->stack_section)
+#define core_regsec(bfd)   (core_hdr (bfd)->reg_section)
+#define core_reg2sec(bfd)  (core_hdr (bfd)->reg2_section)
+
+/* These are stored in the bfd's tdata.  */
+struct sun_core_struct
+{
+  struct internal_sunos_core *hdr;	/* Core file header.  */
+  asection *data_section;
+  asection *stack_section;
+  asection *reg_section;
+  asection *reg2_section;
+};
+
+static const bfd_target *
+sunos4_core_file_p (bfd *abfd)
+{
+  unsigned char longbuf[4];	/* Raw bytes of various header fields.  */
+  bfd_size_type core_size, amt;
+  unsigned long core_mag;
+  struct internal_sunos_core *core;
+  char *extcore;
+  struct mergem
+    {
+      struct sun_core_struct suncoredata;
+      struct internal_sunos_core internal_sunos_core;
+      char external_core[1];
+    } *mergem;
+  flagword flags;
+
+  if (bfd_bread ((void *) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
+      != sizeof (longbuf))
+    return NULL;
+  core_mag = H_GET_32 (abfd, longbuf);
+
+  if (core_mag != CORE_MAGIC)
+    return NULL;
+
+  /* SunOS core headers can vary in length; second word is size; */
+  if (bfd_bread ((void *) longbuf, (bfd_size_type) sizeof (longbuf), abfd)
+      != sizeof (longbuf))
+    return NULL;
+  core_size = H_GET_32 (abfd, longbuf);
+  /* Sanity check.  */
+  if (core_size > 20000)
+    return NULL;
+
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
+    return NULL;
+
+  amt = core_size + sizeof (struct mergem);
+  mergem = bfd_zalloc (abfd, amt);
+  if (mergem == NULL)
+    return NULL;
+
+  extcore = mergem->external_core;
+
+  if ((bfd_bread ((void *) extcore, core_size, abfd)) != core_size)
+    {
+    loser:
+      bfd_release (abfd, (char *) mergem);
+      abfd->tdata.any = NULL;
+      bfd_section_list_clear (abfd);
+      return NULL;
+    }
+
+  /* Validate that it's a core file we know how to handle, due to sun
+     botching the positioning of registers and other fields in a machine
+     dependent way.  */
+  core = &mergem->internal_sunos_core;
+  switch (core_size)
+    {
+    case SPARC_CORE_LEN:
+      swapcore_sparc (abfd, extcore, core);
+      break;
+    case SUN3_CORE_LEN:
+      swapcore_sun3 (abfd, extcore, core);
+      break;
+    case SOLARIS_BCP_CORE_LEN:
+      swapcore_solaris_bcp (abfd, extcore, core);
+      break;
+    default:
+      bfd_set_error (bfd_error_system_call);	/* FIXME.  */
+      goto loser;
+    }
+
+  abfd->tdata.sun_core_data = &mergem->suncoredata;
+  abfd->tdata.sun_core_data->hdr = core;
+
+  /* Create the sections.  */
+  flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
+  core_stacksec (abfd) = bfd_make_section_anyway_with_flags (abfd, ".stack",
+							     flags);
+  if (core_stacksec (abfd) == NULL)
+    /* bfd_release frees everything allocated after it's arg.  */
+    goto loser;
+
+  flags = SEC_ALLOC + SEC_LOAD + SEC_HAS_CONTENTS;
+  core_datasec (abfd) = bfd_make_section_anyway_with_flags (abfd, ".data",
+							    flags);
+  if (core_datasec (abfd) == NULL)
+    goto loser;
+
+  flags = SEC_HAS_CONTENTS;
+  core_regsec (abfd) = bfd_make_section_anyway_with_flags (abfd, ".reg",
+							   flags);
+  if (core_regsec (abfd) == NULL)
+    goto loser;
+
+  flags = SEC_HAS_CONTENTS;
+  core_reg2sec (abfd) = bfd_make_section_anyway_with_flags (abfd, ".reg2",
+							    flags);
+  if (core_reg2sec (abfd) == NULL)
+    goto loser;
+
+  core_stacksec (abfd)->size = core->c_ssize;
+  core_datasec (abfd)->size = core->c_dsize;
+  core_regsec (abfd)->size = core->c_regs_size;
+  core_reg2sec (abfd)->size = core->fp_stuff_size;
+
+  core_stacksec (abfd)->vma = (core->c_stacktop - core->c_ssize);
+  core_datasec (abfd)->vma = core->c_data_addr;
+  core_regsec (abfd)->vma = 0;
+  core_reg2sec (abfd)->vma = 0;
+
+  core_stacksec (abfd)->filepos = core->c_len + core->c_dsize;
+  core_datasec (abfd)->filepos = core->c_len;
+  /* We'll access the regs afresh in the core file, like any section:  */
+  core_regsec (abfd)->filepos = (file_ptr) core->c_regs_pos;
+  core_reg2sec (abfd)->filepos = (file_ptr) core->fp_stuff_pos;
+
+  /* Align to word at least.  */
+  core_stacksec (abfd)->alignment_power = 2;
+  core_datasec (abfd)->alignment_power = 2;
+  core_regsec (abfd)->alignment_power = 2;
+  core_reg2sec (abfd)->alignment_power = 2;
+
+  return abfd->xvec;
+}
+
+static char *
+sunos4_core_file_failing_command (bfd *abfd)
+{
+  return core_hdr (abfd)->hdr->c_cmdname;
+}
+
+static int
+sunos4_core_file_failing_signal (bfd *abfd)
+{
+  return core_hdr (abfd)->hdr->c_signo;
+}
+
+static bfd_boolean
+sunos4_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)
+{
+  if (core_bfd->xvec != exec_bfd->xvec)
+    {
+      bfd_set_error (bfd_error_system_call);
+      return FALSE;
+    }
+
+  /* Solaris core files do not include an aouthdr.  */
+  if ((core_hdr (core_bfd)->hdr)->c_len == SOLARIS_BCP_CORE_LEN)
+    return TRUE;
+
+  return memcmp ((char *) &((core_hdr (core_bfd)->hdr)->c_aouthdr),
+		 (char *) exec_hdr (exec_bfd),
+		 sizeof (struct internal_exec)) == 0;
+}
+
+#define MY_set_sizes sunos4_set_sizes
+
+static bfd_boolean
+sunos4_set_sizes (bfd *abfd)
+{
+  switch (bfd_get_arch (abfd))
+    {
+    default:
+      return FALSE;
+    case bfd_arch_sparc:
+      adata (abfd).page_size = 0x2000;
+      adata (abfd).segment_size = 0x2000;
+      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
+      return TRUE;
+    case bfd_arch_m68k:
+      adata (abfd).page_size = 0x2000;
+      adata (abfd).segment_size = 0x20000;
+      adata (abfd).exec_bytes_size = EXEC_BYTES_SIZE;
+      return TRUE;
+    }
+}
+
+/* We default to setting the toolversion field to 1, as is required by
+   SunOS.  */
+#ifndef MY_exec_hdr_flags
+#define MY_exec_hdr_flags 1
+#endif
+
+#ifndef MY_entry_is_text_address
+#define MY_entry_is_text_address 0
+#endif
+#ifndef MY_add_dynamic_symbols
+#define MY_add_dynamic_symbols 0
+#endif
+#ifndef MY_add_one_symbol
+#define MY_add_one_symbol 0
+#endif
+#ifndef MY_link_dynamic_object
+#define MY_link_dynamic_object 0
+#endif
+#ifndef MY_write_dynamic_symbol
+#define MY_write_dynamic_symbol 0
+#endif
+#ifndef MY_check_dynamic_reloc
+#define MY_check_dynamic_reloc 0
+#endif
+#ifndef MY_finish_dynamic_link
+#define MY_finish_dynamic_link 0
+#endif
+
+static const struct aout_backend_data sunos4_aout_backend =
+{
+  0,				/* Zmagic files are not contiguous.  */
+  1,				/* Text includes header.  */
+  MY_entry_is_text_address,
+  MY_exec_hdr_flags,
+  0,				/* Default text vma.  */
+  sunos4_set_sizes,
+  0,				/* Header is counted in zmagic text.  */
+  MY_add_dynamic_symbols,
+  MY_add_one_symbol,
+  MY_link_dynamic_object,
+  MY_write_dynamic_symbol,
+  MY_check_dynamic_reloc,
+  MY_finish_dynamic_link
+};
+
+#define	MY_core_file_failing_command	sunos4_core_file_failing_command
+#define	MY_core_file_failing_signal	sunos4_core_file_failing_signal
+#define	MY_core_file_matches_executable_p sunos4_core_file_matches_executable_p
+
+#define MY_bfd_debug_info_start		_bfd_void_bfd
+#define MY_bfd_debug_info_end		_bfd_void_bfd
+#define MY_bfd_debug_info_accumulate	_bfd_void_bfd_asection
+#define MY_core_file_p			sunos4_core_file_p
+#define MY_write_object_contents	NAME(aout, sunos4_write_object_contents)
+#define MY_backend_data			& sunos4_aout_backend
+
+#ifndef TARGET_IS_LITTLE_ENDIAN_P
+#define TARGET_IS_BIG_ENDIAN_P
+#endif
+
+#include "aout-target.h"
diff --git a/bfd/aoutx.h b/bfd/aoutx.h
index fa3a9746b6..a5c72ba178 100644
--- a/bfd/aoutx.h
+++ b/bfd/aoutx.h
@@ -468,7 +468,10 @@ NAME (aout, some_aout_object_p) (bfd *abfd,
   oldrawptr = abfd->tdata.aout_data;
   abfd->tdata.aout_data = rawptr;
 
-  /* Copy the contents of the old tdata struct.  */
+  /* Copy the contents of the old tdata struct.
+     In particular, we want the subformat, since for hpux it was set in
+     hp300hpux.c:swap_exec_header_in and will be used in
+     hp300hpux.c:callback.  */
   if (oldrawptr != NULL)
     *abfd->tdata.aout_data = *oldrawptr;
 
@@ -749,6 +752,17 @@ NAME (aout, machine_type) (enum bfd_architecture arch,
 	arch_flags = M_SPARCLET;
       break;
 
+    case bfd_arch_m68k:
+      switch (machine)
+	{
+	case 0:		      arch_flags = M_68010; break;
+	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = FALSE; break;
+	case bfd_mach_m68010: arch_flags = M_68010; break;
+	case bfd_mach_m68020: arch_flags = M_68020; break;
+	default:	      arch_flags = M_UNKNOWN; break;
+	}
+      break;
+
     case bfd_arch_i386:
       if (machine == 0
 	  || machine == bfd_mach_i386_i386
@@ -1284,6 +1298,8 @@ NAME (aout, set_section_contents) (bfd *abfd,
 static bfd_boolean
 aout_get_external_symbols (bfd *abfd)
 {
+  if (bfd_get_flavour(abfd) != bfd_target_aout_flavour)
+    return FALSE;
   if (obj_aout_external_syms (abfd) == NULL)
     {
       bfd_size_type count;
@@ -1853,13 +1869,32 @@ emit_stringtab (bfd *abfd, struct bfd_strtab_hash *tab)
 {
   bfd_byte buffer[BYTES_IN_WORD];
   bfd_size_type amt = BYTES_IN_WORD;
+  bfd_size_type odd;
+
+  /* The MiNT backend writes past the string table.  It therefore has to
+     know about the table size.  */
+  obj_aout_external_string_size (abfd) = _bfd_stringtab_size (tab) +
+    BYTES_IN_WORD;
+  /* For MiNT atleast, the size of the string table should be even,
+     or the TPA relocation (and its first longword) will start on
+     an odd address */
+  odd = obj_aout_external_string_size (abfd) & 1;
+  obj_aout_external_string_size (abfd) += odd;
 
   /* The string table starts with the size.  */
-  PUT_WORD (abfd, _bfd_stringtab_size (tab) + BYTES_IN_WORD, buffer);
+  PUT_WORD (abfd, obj_aout_external_string_size (abfd), buffer);
   if (bfd_bwrite ((void *) buffer, amt, abfd) != amt)
     return FALSE;
 
-  return _bfd_stringtab_emit (abfd, tab);
+  if (_bfd_stringtab_emit (abfd, tab) == FALSE)
+    return FALSE;
+  if (odd)
+    {
+      buffer[0] = 0;
+      if (bfd_bwrite ((void *) buffer, 1, abfd) != 1)
+        return FALSE;
+    }
+  return TRUE;
 }
 
 bfd_boolean
@@ -4286,10 +4321,17 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,
 		(flaginfo->info, name, input_bfd, input_section, r_addr, TRUE);
 	    }
 
+#ifdef MY_final_link_relocate_rel
+	  r = MY_final_link_relocate_rel (howto,
+					  input_bfd, input_section,
+					  contents, r_addr, relocation,
+					  (bfd_vma) 0, rel);
+#else
 	  r = MY_final_link_relocate (howto,
 				      input_bfd, input_section,
 				      contents, r_addr, relocation,
 				      (bfd_vma) 0);
+#endif
 	}
 
       if (r != bfd_reloc_ok)
@@ -5487,7 +5529,8 @@ NAME (aout, final_link) (bfd *abfd,
      FIXME: At this point we do not know how much space the symbol
      table will require.  This will not work for any (nonstandard)
      a.out target that needs to know the symbol table size before it
-     can compute the relocation file positions.  */
+     can compute the relocation file positions.  This may or may not
+     be the case for the hp300hpux target, for example.  */
   (*callback) (abfd, &aout_info.treloff, &aout_info.dreloff,
 	       &aout_info.symoff);
   obj_textsec (abfd)->rel_filepos = aout_info.treloff;
diff --git a/bfd/archive.c b/bfd/archive.c
index 3d5635a9f2..263a447458 100644
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -894,7 +894,7 @@ bfd_generic_archive_p (bfd *abfd)
       return NULL;
     }
 
-  if (abfd->target_defaulted && bfd_has_map (abfd))
+  if (bfd_has_map (abfd))
     {
       bfd *first;
       unsigned int save;
@@ -919,7 +919,14 @@ bfd_generic_archive_p (bfd *abfd)
 	  first->target_defaulted = FALSE;
 	  if (bfd_check_format (first, bfd_object)
 	      && first->xvec != abfd->xvec)
-	    bfd_set_error (bfd_error_wrong_object_format);
+	    {
+	      bfd_set_error (bfd_error_wrong_object_format);
+	      if (abfd->is_linker_input)
+	        {
+	          bfd_ardata (abfd) = tdata_hold;
+	          return NULL;
+	        }
+	    }
 	  bfd_close (first);
 	}
     }
@@ -1196,6 +1203,13 @@ bfd_slurp_armap (bfd *abfd)
   return TRUE;
 }
 
+/* Returns FALSE on error, TRUE otherwise.  */
+/* Flavor 2 of a bsd armap, similar to bfd_slurp_bsd_armap except the
+   header is in a slightly different order and the map name is '/'.
+   This flavour is used by hp300hpux.  */
+
+#define HPUX_SYMDEF_COUNT_SIZE 2
+
 /** Extended name table.
 
   Normally archives support only 14-character filenames.
diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
index 76b17bf734..05734dfaa5 100644
--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -23,11 +23,6 @@
 #ifndef __BFD_H_SEEN__
 #define __BFD_H_SEEN__
 
-/* PR 14072: Ensure that config.h is included first.  */
-#if !defined PACKAGE && !defined PACKAGE_VERSION
-#error config.h must be included before this header
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -510,6 +505,15 @@ bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
 void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
 
 
+/* MiNT executable support routines for the linker.  */
+
+extern bfd_boolean bfd_m68kmint_set_extended_flags
+  (bfd *, flagword);
+extern bfd_boolean bfd_m68kmint_set_stack_size
+  (bfd *, bfd_signed_vma);
+extern bfd_boolean bfd_m68kmint_add_tpa_relocation_entry
+  (bfd *, bfd_vma);
+
 /* mmap hacks */
 
 struct _bfd_window_internal;
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 7c13bc8c91..dc161f313c 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -517,6 +517,15 @@ bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
 void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
 
 
+/* MiNT executable support routines for the linker.  */
+
+extern bfd_boolean bfd_m68kmint_set_extended_flags
+  (bfd *, flagword);
+extern bfd_boolean bfd_m68kmint_set_stack_size
+  (bfd *, bfd_signed_vma);
+extern bfd_boolean bfd_m68kmint_add_tpa_relocation_entry
+  (bfd *, bfd_vma);
+
 /* mmap hacks */
 
 struct _bfd_window_internal;
diff --git a/bfd/compress.c b/bfd/compress.c
index 728ba39dfb..415d928edf 100644
--- a/bfd/compress.c
+++ b/bfd/compress.c
@@ -343,7 +343,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
 	return FALSE;
       if (p == NULL)
 	{
-	  p = (bfd_byte *) bfd_malloc (sz);
+	  p = (bfd_byte *) bfd_zmalloc (sz);
 	  if (p == NULL)
 	    return FALSE;
 	  *ptr = p;
diff --git a/bfd/config.bfd b/bfd/config.bfd
index b96931f52e..bf18ac3677 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -69,6 +69,9 @@ case $targ in
  mips*-*-irix5* | mips*-*-irix6*)
     # Not obsolete
     ;;
+ m68*-*-mint*)
+    # Not obsolete
+    ;;
  *-adobe-* | \
  *-go32-rtems* | \
  *-sony-* | \
@@ -813,6 +816,16 @@ case "${targ}" in
     targ_selvecs="m68hc11_elf32_vec m68hc12_elf32_vec"
     ;;
 
+  m68*-*-mintelf*)
+    targ_defvec=m68k_elf32_vec
+    targ_selvecs="aout0_be_vec m68k_aout_mintprg_vec"
+    ;;
+  m68*-*-mint*)
+    targ_defvec=aout0_be_vec
+    targ_selvecs=m68k_aout_mintprg_vec
+    targ_underscore=yes
+    ;;
+
   m68*-*-*)
     targ_defvec=m68k_elf32_vec
     ;;
diff --git a/bfd/configure b/bfd/configure
index bc576b7894..fffd0de841 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -14201,7 +14201,7 @@ _ACEOF
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
@@ -14789,6 +14789,7 @@ do
     m68hc11_elf32_vec)		 tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68hc12_elf32_vec)		 tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68k_elf32_vec)		 tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
+    m68k_aout_mintprg_vec)	 tb="$tb prg-mint.lo aout32.lo" ;;
     s12z_elf32_vec)		 tb="$tb elf32-s12z.lo elf32.lo $elf" ;;
     mach_o_be_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
     mach_o_le_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
diff --git a/bfd/configure.ac b/bfd/configure.ac
index c5bfbd5d12..db7d6b6fef 100644
--- a/bfd/configure.ac
+++ b/bfd/configure.ac
@@ -525,6 +525,7 @@ do
     m68hc11_elf32_vec)		 tb="$tb elf32-m68hc11.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68hc12_elf32_vec)		 tb="$tb elf32-m68hc12.lo elf32-m68hc1x.lo elf32.lo $elf" ;;
     m68k_elf32_vec)		 tb="$tb elf32-m68k.lo elf32.lo $elf" ;;
+    m68k_aout_mintprg_vec)	 tb="$tb prg-mint.lo aout32.lo" ;;
     s12z_elf32_vec)		 tb="$tb elf32-s12z.lo elf32.lo $elf" ;;
     mach_o_be_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
     mach_o_le_vec)		 tb="$tb mach-o.lo dwarf2.lo" ;;
diff --git a/bfd/elf.c b/bfd/elf.c
index f02b7249dd..fb2e434e84 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -8459,7 +8459,12 @@ _bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
   long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
 
   if (symcount >= 0)
-    abfd->symcount = symcount;
+    {
+      abfd->symcount = symcount;
+      /* Cache symbols for the generic linker.  */
+      abfd->outsymbols = allocation;
+    }
+    
   return symcount;
 }
 
diff --git a/bfd/format.c b/bfd/format.c
index a80a175b8a..c6da4be8b8 100644
--- a/bfd/format.c
+++ b/bfd/format.c
@@ -219,7 +219,7 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
   int match_count, best_count, best_match;
   int ar_match_index;
   unsigned int initial_section_id = _bfd_section_id;
-  struct bfd_preserve preserve, preserve_match;
+  struct bfd_preserve preserve;
 
   if (matching != NULL)
     *matching = NULL;
@@ -247,10 +247,7 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
   /* Presume the answer is yes.  */
   abfd->format = format;
   save_targ = abfd->xvec;
-
-  preserve_match.marker = NULL;
-  if (!bfd_preserve_save (abfd, &preserve))
-    goto err_ret;
+  preserve.marker = NULL;
 
   /* If the target type was explicitly specified, just check that target.  */
   if (!abfd->target_defaulted)
@@ -292,7 +289,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
   for (target = bfd_target_vector; *target != NULL; target++)
     {
       const bfd_target *temp;
-      void **high_water;
 
       /* The binary target matches anything, so don't return it when
 	 searching.  Don't match the plugin target if we have another
@@ -310,14 +306,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	 have sections attached, which will confuse the next
 	 _bfd_check_format call.  */
       bfd_reinit (abfd, initial_section_id);
-      /* Free bfd_alloc memory too.  If we have matched and preserved
-	 a target then the high water mark is that much higher.  */
-      if (preserve_match.marker)
-	high_water = &preserve_match.marker;
-      else
-	high_water = &preserve.marker;
-      bfd_release (abfd, *high_water);
-      *high_water = bfd_alloc (abfd, 1);
 
       /* Change BFD's target temporarily.  */
       abfd->xvec = *target;
@@ -325,6 +313,12 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
       if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
 	goto err_ret;
 
+      /* If _bfd_check_format neglects to set bfd_error, assume
+	 bfd_error_wrong_format.  We didn't used to even pay any
+	 attention to bfd_error, so I suspect that some
+	 _bfd_check_format might have this problem.  */
+      bfd_set_error (bfd_error_wrong_format);
+
       temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
       if (temp)
 	{
@@ -338,6 +332,10 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	    match_priority = (*target)->match_priority;
 #endif
 
+	  match_targ = temp;
+	  if (preserve.marker != NULL)
+	    bfd_preserve_finish (abfd, &preserve);
+
 	  if (abfd->format != bfd_archive
 	      || (bfd_has_map (abfd)
 		  && bfd_get_error () != bfd_error_wrong_object_format))
@@ -376,13 +374,11 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	      ar_match_index++;
 	    }
 
-	  if (preserve_match.marker == NULL)
-	    {
-	      match_targ = temp;
-	      if (!bfd_preserve_save (abfd, &preserve_match))
-		goto err_ret;
-	    }
+	  if (!bfd_preserve_save (abfd, &preserve))
+	    goto err_ret;
 	}
+      else if (bfd_get_error () != bfd_error_wrong_format)
+	goto err_ret;
     }
 
   if (best_count == 1)
@@ -452,8 +448,8 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
      really shouldn't iterate on live bfd's.  Note that saving the
      whole bfd and restoring it would be even worse; the first thing
      you notice is that the cached bfd file position gets out of sync.  */
-  if (preserve_match.marker != NULL)
-    bfd_preserve_restore (abfd, &preserve_match);
+  if (preserve.marker != NULL)
+    bfd_preserve_restore (abfd, &preserve);
 
   if (match_count == 1)
     {
@@ -468,7 +464,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
       if (match_targ != right_targ)
 	{
 	  bfd_reinit (abfd, initial_section_id);
-	  bfd_release (abfd, preserve.marker);
 	  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
 	    goto err_ret;
 	  match_targ = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd));
@@ -486,9 +481,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 
       if (matching_vector)
 	free (matching_vector);
-      if (preserve_match.marker != NULL)
-	bfd_preserve_finish (abfd, &preserve_match);
-      bfd_preserve_finish (abfd, &preserve);
 
       /* File position has moved, BTW.  */
       return TRUE;
@@ -503,9 +495,8 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
       abfd->format = bfd_unknown;
       if (matching_vector)
 	free (matching_vector);
-      if (preserve_match.marker != NULL)
-	bfd_preserve_finish (abfd, &preserve_match);
-      bfd_preserve_restore (abfd, &preserve);
+      if (preserve.marker != NULL)
+	bfd_preserve_restore (abfd, &preserve);
       return FALSE;
     }
 
@@ -526,11 +517,6 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 	  *(const char **) &matching_vector[match_count] = name;
 	}
     }
-  else if (matching_vector)
-    free (matching_vector);
-  if (preserve_match.marker != NULL)
-    bfd_preserve_finish (abfd, &preserve_match);
-  bfd_preserve_restore (abfd, &preserve);
   return FALSE;
 }
 
diff --git a/bfd/gen-aout.c b/bfd/gen-aout.c
index cf0a3e943b..31bd3ddaf2 100644
--- a/bfd/gen-aout.c
+++ b/bfd/gen-aout.c
@@ -92,6 +92,9 @@ main (int argc, char** argv)
 
 #ifdef vax
   arch = "vax";
+#endif
+#ifdef m68k
+  arch = "m68k";
 #endif
   if (arch[0] == '1')
     {
diff --git a/bfd/libaout.h b/bfd/libaout.h
index 81ef4cffd5..744d1991fb 100644
--- a/bfd/libaout.h
+++ b/bfd/libaout.h
@@ -420,6 +420,10 @@ struct aoutdata
      table, used when linking on SunOS.  This is indexed by the symbol
      index.  */
   bfd_vma *local_got_offsets;
+
+  /* A pointer for data used by aout extensions.  (Currently only used
+     by MiNT executables (see prg-mint.c).  */
+  void *ext;
 };
 
 struct  aout_data_struct
@@ -447,6 +451,7 @@ struct  aout_data_struct
 #define obj_aout_string_window(bfd)	   (adata (bfd).string_window)
 #define obj_aout_sym_hashes(bfd)	   (adata (bfd).sym_hashes)
 #define obj_aout_dynamic_info(bfd)	   (adata (bfd).dynamic_info)
+#define obj_aout_ext(bfd)              (adata (bfd).ext)
 
 /* We take the address of the first element of an asymbol to ensure that the
    macro is only ever applied to an asymbol.  */
diff --git a/bfd/prg-mint.c b/bfd/prg-mint.c
new file mode 100644
index 0000000000..f77fdc02cb
--- /dev/null
+++ b/bfd/prg-mint.c
@@ -0,0 +1,1728 @@
+/* BFD backend for traditional MiNT executables.
+   Copyright (C) 1998-2017 Free Software Foundation, Inc.
+   Originally written by Guido Flohr (guido@freemint.de).
+   Modified by Vincent Riviere (vincent.riviere@freesbee.fr).
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* The format of executables on Atari is actually not a.out,  it is
+   only chosen as an approach which comes close enough.  The layout of a
+   program image on disk looked like this:
+
+   +-----------------+
+   | 28 Bytes Header |
+   +-----------------+
+   | Text segment    |
+   +-----------------+
+   | Data segment    |
+   +-----------------+
+   | BSS	     |
+   +-----------------+
+   | Symbol table    |
+   +-----------------+
+   | TPA relocation  |
+   +-----------------+
+
+   The 28 byte exec header used to look like this:
+
+   struct old_exec_header
+   {
+     bfd_byte a_magic[2];
+     bfd_byte a_text[4];
+     bfd_byte a_data[4];
+     bfd_byte a_bss[4];
+     bfd_byte a_syms[4];
+     bfd_byte a_resvd[4];
+     bfd_byte a_abs[2];
+   };
+
+   The first two bytes (A_MAGIC) contained an assembler branch
+   instruction to the beginning of the text segment.  Because the
+   exec header had a fixed size and the text entry point was constant
+   this assembler instruction also had a constant value (0x601a).
+   In fact the operating system never really executed the branch
+   instruction but used this value (0x601a) as a magic value.
+
+   TEXT, DATA and BSS were as one would expect them.  The symbol
+   table wasn't.  Several different formats were in use, none of them
+   very efficient, none of them powerful enough to support source
+   level debugging.  I've changed that and the GNU symbol table will
+   now be used instead (unless the --traditional-format option was
+   given to the linker).
+
+   If the last member A_ABS of the exec header is zero the program
+   image contains an additional table with relocation information
+   at the end of the image.  The kernel can load program images at
+   virtually any address in the address space.  In fact it will load
+   it at the start of the biggest block of free memory.  This block
+   is then called the Transient Program Area TPA and the image has
+   to be relocated against the TPA at runtime.  The relocation info
+   itself is in a simply way compressed:  It starts with a four-byte
+   value, the first address within the image to be relocated.  Now
+   following are one-byte offsets to the last address.  The special
+   value of 1 (which is impossible as an offset) signifies that 254
+   has to be added to the next offset.  The table is finished with
+   a zero-byte.
+
+   I now simply extended the header from its old 28 bytes to 256
+   bytes.  The first 28 bytes give home to a standard Atari header,
+   the rest is for extensions.  The extension header starts with
+   a ``real'' assembler instruction, a far jump to the text entry
+   point.  The extension header gives home to a standard a.out
+   exec header (currently NMAGIC) plus some extra
+   more or less useful fields plus space to future extensions.
+   For the OS the extension header will already belong to the text
+   segment, for BFD backends the text segment is 228 (or 0xe4)
+   bytes smaller than for the OS.  This explains for example the
+   funny TEXT_START_ADDR 0xe4.
+
+   The TARGET_PAGE_SIZE is 2 which is only fake.  There is currently
+   no such thing as memory paging on the Atari (and this is why
+   ZMAGICs are disabled for now to allow for future enhancements).
+
+   If you think that this whole file looks quite like a big hack
+   you're probably right.  But the results (mainly the output of
+   the linker) seem to work and they allow to use up-to-date
+   binutils on the Atari until a better executable format (maybe
+   ELF) has been established for this machine.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+
+#define N_HEADER_IN_TEXT(x) 0
+#define BYTES_IN_WORD 4
+#define ENTRY_CAN_BE_ZERO
+#define N_SHARED_LIB(x) 0
+#define TEXT_START_ADDR 0xe4
+#define TARGET_PAGE_SIZE 2
+#define TARGET_IS_BIG_ENDIAN_P
+#define DEFAULT_ARCH bfd_arch_m68k
+#define N_TXTADDR(x) TEXT_START_ADDR
+
+/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
+   remove whitespace added here, and thus will fail to concatenate
+   the tokens.  */
+#define MY(OP) CONCAT2 (m68k_aout_mintprg_,OP)
+#define TARGETNAME "a.out-mintprg"
+#define NAME(x,y) CONCAT3 (mintprg,_32_,y)
+
+/* We have to do quite a lot of magic to make the Atari format
+   for GEMDOS executables fit into the standard a.out format.
+   We start with the original header.  */
+#define external_exec mint_external_exec
+struct mint_external_exec
+{
+  bfd_byte g_branch[2]; 	     /* 0x601a.  */
+  bfd_byte g_text[4];		     /* Length of text section.  */
+  bfd_byte g_data[4];		     /* Length of data section.  */
+  bfd_byte g_bss[4];		     /* Length of bss section.  */
+  bfd_byte g_syms[4];		     /* Length of symbol table.  */
+  bfd_byte g_extmagic[4];	     /* Always 0x4d694e54
+					(in ASCII: ``MiNT'').  */
+  bfd_byte g_flags[4];		     /* Atari special flags.  */
+  bfd_byte g_abs[2];		     /* Non-zero if absolute (no relocation
+					info.  */
+
+  /* We extend this header now to provide the information that the
+     binutils want to see.  Everything following will actually be part
+     of the text segment (from MiNT's point of view).  As a
+     consequence the text section has 228 bytes of redundancy.
+
+     The following eight bytes should be treated as opaque.
+     If the word ``opaque'' always attracts your curiosity in
+     typedefs and structs, here's the explanation:  These eight bytes
+     are really two assembler instructions.  The first one moves
+     the contents of e_entry into register d0, the second one
+     jumps (pc-relative) to the entry point.  See swap_exec_header_out
+     for details.  */
+  bfd_byte g_jump_entry[8];
+
+  /* Now following a standard a.out header.  Note that the values
+     may differ from the one given on top.  The traditional header
+     contains the values that the OS wants to see, the values below
+     are the values that make the binutils work.  */
+  bfd_byte e_info[4];		     /* Magic number and stuff.  */
+  bfd_byte e_text[4];		     /* Length of text section in bytes.  */
+  bfd_byte e_data[4];		     /* Length of data section.  */
+  bfd_byte e_bss[4];		     /* Length of standard symbol
+					table.  */
+  bfd_byte e_syms[4];		     /* Length of symbol table.  */
+  bfd_byte e_entry[4];		     /* Start address.  */
+  bfd_byte e_trsize[4]; 	     /* Length of text relocation
+					info.  */
+  bfd_byte e_drsize[4]; 	     /* Length of data relocation
+					info.  */
+
+  bfd_byte g_tparel_pos[4];	     /* File position of TPA relative
+					relocation info.  */
+  bfd_byte g_tparel_size[4];	     /* Length of TPA relative relocation
+					info.  */
+
+  /* This is for extensions.  */
+  bfd_byte g_stkpos[4]; 	     /* If stacksize is hardcoded into
+					the executable you will find it
+					at file offset g_stkpos.  If
+					not this is NULL.  */
+
+  bfd_byte g_symbol_format[4];	     /* Format of the symbol table.  See
+					definitions for _MINT_SYMBOL_FORMAT*
+					above.  */
+
+  /* Pad with zeros.  */
+  bfd_byte g_pad0[172];
+};
+#define EXEC_BYTES_SIZE 256
+#define GEMDOS_HEADER_SIZE 28
+
+/* The following defines are required by aoutx.h.
+   They are not automatically defined in aout/aout64.h
+   if external_exec is defined.  */
+
+#define OMAGIC 0407	/* Object file or impure executable.  */
+#define NMAGIC 0410	/* Code indicating pure executable.  */
+#define ZMAGIC 0413	/* Code indicating demand-paged executable.  */
+#define BMAGIC 0415	/* Used by a b.out object.  */
+#define QMAGIC 0314	/* Like ZMAGIC but with N_HEADER_IN_TEXT true.  */
+
+/* Files using the following magic flags will not be loaded.  */
+#define N_BADMAG(x)	(N_MAGIC(x) != NMAGIC)
+
+/* For DRI symbol table format.  */
+struct dri_symbol
+{
+  bfd_byte a_name[8];	  /* Symbol name */
+  bfd_byte a_type[2];	  /* Type flag, i.e. A_TEXT etc; see below.  */
+  bfd_byte a_value[4];	  /* value of this symbol (or sdb offset).  */
+};
+#define DRI_SYMBOL_SIZE 14
+
+/* Simple values for a_type.  */
+#define A_UNDF	0
+#define A_BSS	0x0100
+#define A_TEXT	0x0200
+#define A_DATA	0x0400
+#define A_EXT	0x0800	      /* External.  */
+#define A_EQREG 0x1000	      /* Equated register.  */
+#define A_GLOBL 0x2000	      /* Global.  */
+#define A_EQU	0x4000	      /* Equated.  */
+#define A_DEF	0x8000	      /* Defined.  */
+#define A_LNAM	0x0048	      /* GST compatible long name.  */
+			      /* File symbols ala aln.  */
+#define A_TFILE 0x0280	      /* Text file corresponding to object module.  */
+#define A_TFARC 0x02C0	      /* Text file archive.  Unfortunately this
+				 conflicts with the bits in A_LNAM.  */
+
+/* The following include contains the definitions for internal a.out structures
+   as well as the prototypes for the NAME(...) functions defined in aoutx.h.  */
+
+#include "libaout.h"
+
+/* The following function is similar to _bfd_final_link_relocate, except it
+   adds the reloc structure as an additional parameter.
+   It will be used int aoutx.h.  */
+
+static bfd_reloc_status_type
+MY (final_link_relocate_rel) (reloc_howto_type *howto,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      bfd_vma address,
+			      bfd_vma value,
+			      bfd_vma addend,
+			      struct reloc_std_external *rel);
+
+#define MY_final_link_relocate_rel MY (final_link_relocate_rel)
+
+/* The following include contains the definitions for the NAME(...) functions.  */
+
+#include "aoutx.h"
+
+/* Data structure that holds some private information for us.  */
+struct mint_internal_info
+{
+  struct bfd_link_info *linkinfo;    /* Remembered from final_link.  */
+  bfd_boolean	traditional_format;  /* Saved from link info.  */
+  int		symbol_format;	     /* Format of the symbol table.  */
+  void		*tparel;	     /* Data for TPA relative relocation
+					information.  */
+  file_ptr	tparel_pos;	     /* File position of TPA relative
+					relocation information.  */
+  bfd_size_type tparel_size;	     /* Size of TPA relative relocation
+					information.  */
+  bfd_size_type dri_symtab_size;     /* Size of traditional symbol table.  */
+
+#define MINT_RELOC_CHUNKSIZE 0x1000
+  bfd_vma	*relocs;	     /* Array of address relocations.  */
+  unsigned long relocs_used;	     /* Number of relocation entries
+					already used up.  */
+  unsigned long relocs_allocated;    /* Number of relocation entries
+					allocated.  */
+
+  bfd_vma	stkpos; 	     /* File offset to value of _stksize.  */
+
+  flagword	prg_flags;	     /* Standard GEMDOS flags.  */
+
+  bfd_boolean 	override_stack_size; /* TRUE if the executable stack size
+					must be overriden with stack_size.  */
+  bfd_signed_vma stack_size;
+
+  bfd_boolean	reloc_error;	     /* TRUE if an unhandled error during
+					relocation occured.  */
+};
+
+/* If --traditional-format was given to the linker an old-style DRI
+   symbol table is written into the executable.  This is with respect
+   to many old debugging tools or disassemblers which expect this format.
+   Although created by the linker, these symbols will be ignored from
+   input files.  */
+#define _MINT_SYMBOL_FORMAT_GNU  0
+#define _MINT_SYMBOL_FORMAT_DRI  1
+
+/* Declarations for the variables and functions
+   defined later in aout-target.h.  */
+
+static const bfd_target *
+MY (callback) (bfd *abfd);
+
+static void
+MY_final_link_callback (bfd *abfd,
+			file_ptr *ptreloff,
+			file_ptr *pdreloff,
+			file_ptr *psymoff);
+
+extern const bfd_target MY (vec);
+
+/* Initialize a new BFD using our file format.  */
+
+#define MY_mkobject MY (mkobject)
+
+static bfd_boolean
+MY (mkobject) (bfd *abfd)
+{
+  struct mint_internal_info *myinfo;
+
+  if (!NAME (aout, mkobject (abfd)))
+    return FALSE;
+
+  /* Allocate our private BFD data.  */
+  myinfo = bfd_zalloc (abfd, sizeof (*myinfo));
+  if (myinfo == NULL)
+    return FALSE;
+  obj_aout_ext (abfd) = myinfo;
+
+  return TRUE;
+}
+
+/* Finish up the reading of an a.out file header.  */
+
+#define MY_object_p MY (object_p)
+
+static const bfd_target *
+MY (object_p) (bfd *abfd)
+{
+  struct external_exec exec_bytes;	/* Raw exec header from file.  */
+  struct internal_exec exec;		/* Cleaned-up exec header.  */
+  const bfd_target *target;
+  bfd_size_type amt = EXEC_BYTES_SIZE;
+  struct mint_internal_info *myinfo;
+
+  /* Read the exec bytesd from the file.  */
+  if (bfd_bread (&exec_bytes, amt, abfd) != amt)
+    {
+      if (bfd_get_error () != bfd_error_system_call)
+	bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Instead of byte-swapping we compare bytes.  */
+  if (exec_bytes.g_branch[0] != 0x60
+      || exec_bytes.g_branch[1] != 0x1a
+      || exec_bytes.g_extmagic[0] != 'M'
+      || exec_bytes.g_extmagic[1] != 'i'
+      || exec_bytes.g_extmagic[2] != 'N'
+      || exec_bytes.g_extmagic[3] != 'T')
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Swap the standard a.out fields.  */
+  NAME (aout, swap_exec_header_in) (abfd, &exec_bytes, &exec);
+
+  /* Check a.out magic value.  */
+  if (N_BADMAG (&exec))
+    {
+      bfd_set_error (bfd_error_wrong_format);
+      return NULL;
+    }
+
+  /* Initialize this BFD with the exec values.  */
+  target = NAME (aout, some_aout_object_p) (abfd, &exec, MY (callback));
+
+  /* Allocate our private BFD data.  */
+  myinfo = bfd_zalloc (abfd, sizeof (*myinfo));
+  if (myinfo == NULL)
+    return NULL;
+  obj_aout_ext (abfd) = myinfo;
+
+  /* Now get the missing information.  */
+  myinfo->prg_flags = bfd_h_get_32 (abfd, exec_bytes.g_flags);
+  myinfo->stkpos = bfd_h_get_32 (abfd, exec_bytes.g_stkpos);
+  myinfo->symbol_format = bfd_h_get_32 (abfd, exec_bytes.g_symbol_format);
+
+  /* TPA relocation information.  */
+  myinfo->tparel_pos = bfd_h_get_32 (abfd, exec_bytes.g_tparel_pos);
+  myinfo->tparel_size = bfd_h_get_32 (abfd, exec_bytes.g_tparel_size);
+
+  /* FIXME:  Currently we always read the TPA relative relocation
+     information.  This is suboptimal because often times there
+     is no need for it.  Read it only if need be!  Maybe this should
+     also depend on abfd->cacheable?  */
+  if (myinfo->tparel_size == 0)
+    myinfo->tparel = bfd_zalloc (abfd, 4);
+  else
+    myinfo->tparel = bfd_alloc (abfd, myinfo->tparel_size);
+
+  if (myinfo->tparel == NULL)
+    return NULL;
+
+  if (myinfo->tparel_size == 0)
+    {
+      myinfo->tparel_size = 4;
+    }
+  else
+    {
+      /* Read the information from the bfd.  */
+      if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0
+	  || (bfd_bread (myinfo->tparel, myinfo->tparel_size, abfd)
+	      != myinfo->tparel_size))
+	return NULL;
+    }
+
+  return target;
+}
+
+/* Free all information we have cached for this BFD.  We can always
+   read it again later if we need it.  */
+
+#define MY_bfd_free_cached_info MY (bfd_free_cached_info)
+
+static bfd_boolean
+MY (bfd_free_cached_info) (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+
+  if (myinfo != NULL && myinfo->relocs != NULL)
+    {
+      free (myinfo->relocs);
+      myinfo->relocs = NULL;
+    }
+
+  /* myinfo itself has been allocated by bfd_zalloc()
+     so will be automatically freed along with the BFD.
+     Same for myinfo->tparel.  */
+
+  return NAME (aout, bfd_free_cached_info) (abfd);
+}
+
+/* Write a DRI symbol with TYPE and VALUE.  If the NAME of the
+   symbol exceeds 8 characters write a long symbol.  If it
+   exceeds 22 characters truncate the name.  */
+
+static int
+write_dri_symbol (bfd *abfd, const char *name, int type, bfd_vma value)
+{
+  int written_bytes = 0;
+  struct dri_symbol sym;
+  int is_long_name = strlen (name) > sizeof (sym.a_name);
+
+  if (is_long_name)
+    type |= A_LNAM;
+
+  strncpy ((char*)sym.a_name, name, sizeof (sym.a_name));
+  bfd_put_16 (abfd, type, sym.a_type);
+  bfd_put_32 (abfd, value, sym.a_value);
+
+  if (bfd_bwrite (&sym, DRI_SYMBOL_SIZE, abfd) != DRI_SYMBOL_SIZE)
+    return -1;
+  written_bytes += DRI_SYMBOL_SIZE;
+
+  if (is_long_name)
+    {
+      char more_name[DRI_SYMBOL_SIZE + 1];
+
+      strncpy (more_name, name + sizeof (sym.a_name), DRI_SYMBOL_SIZE);
+
+      if (bfd_bwrite (more_name, DRI_SYMBOL_SIZE, abfd) != DRI_SYMBOL_SIZE)
+	return -1;
+      written_bytes += DRI_SYMBOL_SIZE;
+    }
+
+  return written_bytes;
+}
+
+/* Emit a traditional DRI symbol table while linking.
+   Most of this code comes from aout_link_write_symbols() in aoutx.h.  */
+
+static bfd_boolean
+link_write_traditional_syms (bfd *abfd, struct bfd_link_info *info)
+{
+  bfd			     *input_bfd;
+  enum bfd_link_strip	     strip = info->strip;
+  enum bfd_link_discard      discard = info->discard;
+  struct mint_internal_info  *myinfo = obj_aout_ext (abfd);
+  bfd			     *last_archive = NULL;
+
+  /* Position file pointer.  */
+  if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)
+    return FALSE;
+
+  myinfo->dri_symtab_size = 0;
+
+  for (input_bfd = info->input_bfds; input_bfd != NULL; input_bfd = input_bfd->link.next)
+    {
+      bfd_size_type sym_count = obj_aout_external_sym_count (input_bfd);
+      char *strings = obj_aout_external_strings (input_bfd);
+      struct external_nlist *sym = obj_aout_external_syms (input_bfd);
+      struct external_nlist *sym_end = sym + sym_count;
+      struct aout_link_hash_entry **sym_hash = obj_aout_sym_hashes (input_bfd);
+      bfd_boolean pass = FALSE;
+      bfd_boolean skip = FALSE;
+      bfd_boolean skip_next = FALSE;
+      int written_bytes;
+      int a_type;
+      bfd_boolean write_archive_name = FALSE;
+      bfd_vma val = 0;
+
+      /* First write out a symbol for the archive if we do not
+	 strip these symbols and if it differs from the last
+	 one.  */
+      if (input_bfd->my_archive != last_archive
+	  && input_bfd->my_archive != NULL)
+	{
+	  write_archive_name = TRUE;
+	  last_archive = input_bfd->my_archive;
+	}
+
+      if (write_archive_name
+	  && strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash,
+				  input_bfd->my_archive->filename,
+				  FALSE, FALSE) != NULL)
+	  && discard != discard_all)
+	{
+	  asection *section = obj_textsec (input_bfd)->output_section;
+	  val = bfd_section_vma (section) + section->output_offset;
+
+	  written_bytes = write_dri_symbol (abfd,
+					    input_bfd->my_archive->filename,
+					    A_TFILE, val);
+
+	  if (written_bytes < 0)
+	    return FALSE;
+	  else
+	    myinfo->dri_symtab_size += written_bytes;
+	}
+
+      /* Now write out a symbol for the object file if we do not
+	 strip these symbols.  */
+      if (strip != strip_all
+	  && (strip != strip_some
+	      || bfd_hash_lookup (info->keep_hash, input_bfd->filename,
+				  FALSE, FALSE) != NULL)
+	  && discard != discard_all)
+	{
+	  asection *section = obj_textsec (input_bfd)->output_section;
+	  val = bfd_section_vma (section) + section->output_offset;
+
+	  written_bytes = write_dri_symbol (abfd, input_bfd->filename,
+					    A_TFILE, val);
+	  if (written_bytes < 0)
+	    return FALSE;
+	  else
+	    myinfo->dri_symtab_size += written_bytes;
+	}
+
+      /* Now we have a problem.  All symbols that we see have already
+	 been marked written (because we write them a second time
+	 here.  If we would do it the clean way we would have
+	 to traverse the entire symbol map and reset the written
+	 flag.  We hack here instead...  */
+#define mark_written(h) (* (int *) &h->written = (int) TRUE + 1)
+#define is_written(h) ((int) h->written == (int) TRUE + 1)
+      for (; sym < sym_end; sym++, sym_hash++)
+	{
+	  const char *name;
+	  int type;
+	  struct aout_link_hash_entry *h;
+	  asection *symsec;
+	  val = 0;
+
+	  type = H_GET_8 (input_bfd, sym->e_type);
+	  name = strings + GET_WORD (input_bfd, sym->e_strx);
+
+	  h = NULL;
+
+	  if (pass)
+	    {
+	      /* Pass this symbol through.  It is the target of an
+	      indirect or warning symbol.  */
+	      val = GET_WORD (input_bfd, sym->e_value);
+	      pass = FALSE;
+	    }
+	  else if (skip_next)
+	    {
+	      /* Skip this symbol, which is the target of an indirect
+		 symbol that we have changed to no longer be an indirect
+		 symbol.  */
+	      skip_next = FALSE;
+	      continue;
+	    }
+	  else
+	    {
+	      struct aout_link_hash_entry *hresolve = *sym_hash;
+
+	      /* We have saved the hash table entry for this symbol, if
+		 there is one.  Note that we could just look it up again
+		 in the hash table, provided we first check that it is an
+		 external symbol. */
+	      h = *sym_hash;
+
+	      /* Use the name from the hash table, in case the symbol was
+		 wrapped.  */
+	    if (h != NULL
+		&& h->root.type != bfd_link_hash_warning)
+		name = h->root.root.string;
+
+	      /* If this is an indirect or warning symbol, then change
+		 hresolve to the base symbol.  */
+	      hresolve = h;
+	      if (h != (struct aout_link_hash_entry *) NULL
+		  && (h->root.type == bfd_link_hash_indirect
+		      || h->root.type == bfd_link_hash_warning))
+		{
+		  hresolve = (struct aout_link_hash_entry*) h->root.u.i.link;
+		  while (hresolve->root.type == bfd_link_hash_indirect
+			 || hresolve->root.type == bfd_link_hash_warning)
+		    hresolve = ((struct aout_link_hash_entry*)
+				hresolve->root.u.i.link);
+		}
+
+	      /* If the symbol has already been written out skip it.  */
+	      if (h != NULL
+		  && is_written (h))
+		{
+		  if ((type & N_TYPE) == N_INDR
+		      || type == N_WARNING)
+		    skip_next = TRUE;
+		  continue;
+		}
+
+	      /* See if we are stripping this symbol.  */
+	      skip = FALSE;
+
+	      /* Skip all debugger symbols.  No way to output them in
+		 DRI format.  This will also reduce a lot of headaches.  */
+	      if ((type & N_STAB) != 0)
+		skip = TRUE;
+
+	      switch (strip)
+		{
+		case strip_none:
+		case strip_debugger:
+		  break;
+		case strip_some:
+		  if (bfd_hash_lookup (info->keep_hash, name, FALSE, FALSE)
+		      == NULL)
+		    skip = TRUE;
+		  break;
+		case strip_all:
+		  skip = TRUE;
+		  break;
+		}
+
+	      if (skip)
+		{
+		  if (h != NULL)
+		    mark_written (h);
+		  continue;
+		}
+
+	      /* Get the value of the symbol.  */
+	      if ((type & N_TYPE) == N_TEXT
+		  || type == N_WEAKT)
+		symsec = obj_textsec (input_bfd);
+	      else if ((type & N_TYPE) == N_DATA
+		       || type == N_WEAKD)
+		symsec = obj_datasec (input_bfd);
+	      else if ((type & N_TYPE) == N_BSS
+		       || type == N_WEAKB)
+		symsec = obj_bsssec (input_bfd);
+	      else if ((type & N_TYPE) == N_ABS
+		       || type == N_WEAKA)
+		symsec = bfd_abs_section_ptr;
+	      else if (((type & N_TYPE) == N_INDR
+			&& (hresolve == NULL
+			    || (hresolve->root.type != bfd_link_hash_defined
+				&& hresolve->root.type != bfd_link_hash_defweak
+				&& hresolve->root.type != bfd_link_hash_common)))
+		       || type == N_WARNING)
+		{
+		  /* Pass the next symbol through unchanged.  The
+		     condition above for indirect symbols is so that if
+		     the indirect symbol was defined, we output it with
+		     the correct definition so the debugger will
+		     understand it.  */
+		  pass = TRUE;
+		  val = GET_WORD (input_bfd, sym->e_value);
+		  symsec = NULL;
+		}
+	      else
+		{
+		  /* If we get here with an indirect symbol, it means that
+		     we are outputting it with a real definition.  In such
+		     a case we do not want to output the next symbol,
+		     which is the target of the indirection.  */
+		  if ((type & N_TYPE) == N_INDR)
+		    skip_next = TRUE;
+
+		  symsec = NULL;
+
+		  /* We need to get the value from the hash table.  We use
+		     hresolve so that if we have defined an indirect
+		     symbol we output the final definition.  */
+		  if (h == NULL)
+		    {
+		      switch (type & N_TYPE)
+			{
+			case N_SETT:
+			  symsec = obj_textsec (input_bfd);
+			  break;
+			case N_SETD:
+			  symsec = obj_datasec (input_bfd);
+			  break;
+			case N_SETB:
+			  symsec = obj_bsssec (input_bfd);
+			  break;
+			case N_SETA:
+			  symsec = bfd_abs_section_ptr;
+			  break;
+			default:
+			  val = 0;
+			  break;
+			}
+		    }
+		  else if (hresolve->root.type == bfd_link_hash_defined
+			   || hresolve->root.type == bfd_link_hash_defweak)
+		    {
+		      asection *input_section;
+		      asection *output_section;
+
+		      /* This case usually means a common symbol which was
+			 turned into a defined symbol.  */
+		      input_section = hresolve->root.u.def.section;
+		      output_section = input_section->output_section;
+		      BFD_ASSERT (bfd_is_abs_section (output_section)
+				  || output_section->owner == abfd);
+
+		      /* The following reference to the output section VMA
+			 is commented out because DRI symbols are relative
+			 to the beginning of the section.  */
+		      val = (hresolve->root.u.def.value
+			     /*+ bfd_section_vma (output_section)*/
+			     + input_section->output_offset);
+
+		      /* TEXT symbols values must be adjusted
+			 by adding the size of the extended header.  */
+		      if (output_section == obj_textsec (abfd))
+			val += TEXT_START_ADDR;
+
+		      /* Get the correct type based on the section.  If
+			 this is a constructed set, force it to be
+			 globally visible.  */
+		      if (type == N_SETT
+			  || type == N_SETD
+			  || type == N_SETB
+			  || type == N_SETA)
+			type |= N_EXT;
+
+		      type &=~ N_TYPE;
+
+		      if (output_section == obj_textsec (abfd))
+			type |= N_TEXT;
+		      else if (output_section == obj_datasec (abfd))
+			type |= N_DATA;
+		      else if (output_section == obj_bsssec (abfd))
+			type |= N_BSS;
+		      else
+			type |= N_ABS;
+		    }
+		  else if (hresolve->root.type == bfd_link_hash_common)
+		    val = hresolve->root.u.c.size;
+		  else if (hresolve->root.type == bfd_link_hash_undefweak)
+		    {
+		      val = 0;
+		      type = N_UNDF;
+		    }
+		  else
+		    val = 0;
+		}
+	      if (symsec != NULL)
+		{
+		  /* The following reference to the output section VMA
+		     is commented out because DRI symbols are relative
+		     to the beginning of the section.  */
+		  val = (/*symsec->output_section->vma
+			 +*/ symsec->output_offset
+			 + (GET_WORD (input_bfd, sym->e_value)
+			 - symsec->vma));
+
+		  /* TEXT symbols values must be adjusted
+		     by adding the size of the extended header.  */
+		  if (symsec == obj_textsec (input_bfd))
+		    val += TEXT_START_ADDR;
+		}
+
+	      /* If this is a global symbol set the written flag, and if
+		 it is a local symbol see if we should discard it.  */
+	      if (h != NULL)
+		{
+		  mark_written (h);
+		}
+	      else if ((type & N_TYPE) != N_SETT
+		       && (type & N_TYPE) != N_SETD
+		       && (type & N_TYPE) != N_SETB
+		       && (type & N_TYPE) != N_SETA)
+		{
+		  switch (discard)
+		    {
+		    case discard_none:
+		    case discard_sec_merge:
+		      break;
+		    case discard_l:
+		      if (bfd_is_local_label_name (input_bfd, name))
+			skip = TRUE;
+		      break;
+		    default:
+		    case discard_all:
+		      skip = TRUE;
+		      break;
+		    }
+		  if (skip)
+		    {
+		      pass = FALSE;
+		      continue;
+		    }
+		}
+	    }
+
+	  /* Now find the nearest type in DRI format.  */
+	  switch (type)
+	    {
+	    case N_ABS:
+	    case N_ABS | N_EXT:
+	    case N_SETA:
+	    case N_SETA | N_EXT:
+	    case N_WEAKA:
+	      a_type = A_EQU | A_DEF | A_GLOBL;
+	      break;
+	    case N_TEXT:
+	    case N_TEXT | N_EXT:
+	    case N_SETT:
+	    case N_SETT | N_EXT:
+	    case N_WEAKT:
+	      a_type = A_TEXT | A_DEF | A_GLOBL;
+	      break;
+	    case N_DATA:
+	    case N_DATA | N_EXT:
+	    case N_SETD:
+	    case N_SETD | N_EXT:
+	    case N_WEAKD:
+	      a_type = A_DATA | A_DEF | A_GLOBL;
+	      break;
+	    case N_BSS:
+	    case N_BSS | N_EXT:
+	    case N_SETB:
+	    case N_SETB | N_EXT:
+	    case N_WEAKB:
+	      a_type = A_BSS | A_DEF | A_GLOBL;
+	      break;
+	    default:
+	      continue;
+	    }
+
+	  written_bytes = write_dri_symbol (abfd, name, a_type, val);
+	  if (written_bytes < 0)
+	    return FALSE;
+
+	  myinfo->dri_symtab_size += written_bytes;
+	}
+    }
+
+  obj_aout_external_string_size (abfd) = 0;
+  return TRUE;
+}
+
+/* This is used for qsort() to sort addresses
+   for the TPA relocation table.  */
+
+static int
+vma_cmp (const void *v1, const void *v2)
+{
+  return (int) ((*((bfd_vma *) v1)) - (*((bfd_vma *) v2)));
+}
+
+/* Alloc and fill the TPA relocation table.  */
+
+static bfd_boolean
+fill_tparel (bfd *abfd)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  unsigned long i;
+  bfd_size_type bytes;
+  unsigned char *ptr;
+
+  /* Sort the relocation info.  */
+  if (myinfo->relocs != NULL)
+    qsort (myinfo->relocs, myinfo->relocs_used, sizeof (bfd_vma),
+	   vma_cmp);
+
+  /* Now calculate the number of bytes we need.  The relocation info
+     is encoded as follows:  The first entry is a 32-bit value
+     denoting the first offset to relocate.  All following entries
+     are relative to the preceding one.  For relative offsets of
+     more than 254 bytes a value of 1 is used.  The OS will then
+     add 254 bytes to the current offset.  The list is then terminated
+     with the byte 0.  */
+  bytes = 4; /* First entry is a long.  */
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      unsigned long diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      BFD_ASSERT(diff > 0);
+      bytes += (diff + 253) / 254;
+    }
+  /* Last entry is (bfd_byte) 0 if there are some relocations.  */
+  if (myinfo->relocs_used > 0)
+    bytes++;
+
+  myinfo->tparel_size = bytes;
+  myinfo->tparel = bfd_alloc (abfd, bytes);
+  if (myinfo->tparel == NULL)
+    return FALSE;
+
+  /* Now fill the array.  */
+  ptr = (bfd_byte*) myinfo->tparel;
+  if (myinfo->relocs != NULL)
+    bfd_put_32 (abfd, myinfo->relocs[0], ptr);
+  else
+    bfd_put_32 (abfd, 0, ptr);
+  ptr += 4;
+
+  for (i = 1; i < myinfo->relocs_used; i++)
+    {
+      unsigned long diff = myinfo->relocs[i] - myinfo->relocs[i - 1];
+      while (diff > 254)
+	{
+	  *ptr++ = 1;
+	  diff -= 254;
+	}
+      *ptr++ = (bfd_byte) diff;
+    }
+
+  if (myinfo->relocs_used > 0)
+    *ptr = 0;
+
+  return TRUE;
+}
+
+/* Final link routine.  We need to use a call back to get the correct
+   offsets in the output file.  And we need to malloc some internal
+   buffers.  */
+
+#define MY_bfd_final_link MY (bfd_final_link)
+
+static bfd_boolean
+MY (bfd_final_link) (bfd *abfd, struct bfd_link_info *info)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  struct bfd_link_hash_table *hash = info->hash;
+  enum bfd_link_strip original_strip = info->strip;
+
+  if (bfd_link_relocatable (info))
+    {
+      _bfd_error_handler ("%pB: relocatable output is not supported by format %s",
+	abfd, bfd_get_target (abfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return FALSE;
+    }
+
+  myinfo->linkinfo = info;
+
+  /* Make sure that for now we never write zmagics.  */
+  abfd->flags &= ~D_PAGED;
+
+  /* Find the __stksize symbol.  This symbol is used for a MiNT
+     special kludge.  The libc defines this symbol in an object file
+     initialized to a default value to make sure it is defined in
+     every output file.  The start-up code in crtinit() then simply
+     sets the stacksize accordingly.  In your programs (if they need
+     an unusual stacksize) you can then simply code:
+
+	   long _stksize = 0x2000;
+
+     This will create a program stack of 2k.  Since MiNT cannot detect
+     a stack overflow this is the only way to prevent program crashes
+     caused by a stack that is too small.
+
+     The ancient linker ignored this feature, the ancient strip
+     program paid heed to it.  By default, strip never stripped this
+     special symbol from the binary.
+
+     Another program called ``printstk'' and its colleague ``fixstk''
+     could be used to either print the current value of the stacksize
+     or to modify it without recompiling and rebuilding.  These
+     programs traversed the symbol table and then took the appropriate
+     measures if the symbol was found.
+
+     Here we do a different approach.  Since we already expanded the
+     standard executable header we now hardcode the address (as a file
+     offset) that the __stksize symbol points to into the header.  We
+     can now let strip safely remove the entry from the symbol table
+     and we're not dependent on a special format of the symbol table.
+     Because the address is kept in the header we will always be able
+     to manipulate the stacksize value later.  */
+  if (hash != NULL)
+    {
+      struct aout_link_hash_entry *h =
+	aout_link_hash_lookup (aout_hash_table (info), "__stksize",
+			       FALSE, FALSE, FALSE);
+      asection *sec;
+
+      if (h != NULL)
+	{
+	  switch (h->root.type)
+	    {
+	    case bfd_link_hash_defined:
+	    case bfd_link_hash_defweak:
+	      sec = h->root.u.def.section->output_section;
+	      BFD_ASSERT (sec->owner == abfd);
+
+	      myinfo->stkpos = (h->root.u.def.value + sec->vma
+				+ h->root.u.def.section->output_offset
+				+ GEMDOS_HEADER_SIZE);
+	      break;
+	    default:  /* Ignore other types.  */
+	      break;
+	    }
+	}
+    }
+
+  if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
+    {
+      myinfo->traditional_format = TRUE;
+      myinfo->symbol_format = _MINT_SYMBOL_FORMAT_DRI;
+    }
+
+  /* Unconditionally unset the traditional flag.  The only effect in
+     the a.out code is to disable string hashing (with respect to
+     SunOS gdx).  This is not necessary for us.  */
+
+  abfd->flags &= ~BFD_TRADITIONAL_FORMAT;
+
+  /* Do not write GNU symbols in traditional format.  */
+  if (myinfo->traditional_format)
+    info->strip = strip_all;
+
+  if (NAME(aout,final_link) (abfd, info, MY_final_link_callback)
+      != TRUE)
+    return FALSE;
+
+  if (myinfo->reloc_error)
+    return FALSE;
+
+  /* Restore the strip status for the traditional symbols.  */
+  info->strip = original_strip;
+
+  if (myinfo->traditional_format
+      && link_write_traditional_syms (abfd, info) != TRUE)
+    return FALSE;
+
+  if (fill_tparel (abfd) != TRUE)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Copy private BFD header information from the input BFD.  */
+
+#define MY_bfd_copy_private_header_data MY (bfd_copy_private_header_data)
+
+static bfd_boolean
+MY (bfd_copy_private_header_data) (bfd *ibfd, bfd *obfd)
+{
+  (void)obfd; /* Unused.  */
+
+  /* We can only copy BFD files using our own file format.  */
+  if (ibfd->xvec != &MY (vec))
+    {
+      _bfd_error_handler ("%pB: cannot convert from format %s to format %s",
+	ibfd, bfd_get_target (ibfd), bfd_get_target (obfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Copy backend specific data from one object module to another.
+   This function is used by objcopy and strip.  */
+
+#define MY_bfd_copy_private_bfd_data MY (bfd_copy_private_bfd_data)
+
+static bfd_boolean
+MY (bfd_copy_private_bfd_data) (bfd *ibfd, bfd *obfd)
+{
+  struct mint_internal_info *myinfo_in;
+  struct mint_internal_info *myinfo_out;
+
+  /* obfd uses our file format, ibfd may be foreign.  */
+  if (ibfd->xvec != &MY (vec))
+    return TRUE;
+
+  myinfo_in = obj_aout_ext (ibfd);
+  BFD_ASSERT (myinfo_in != NULL);
+
+  myinfo_out = obj_aout_ext (obfd);
+  BFD_ASSERT (myinfo_out != NULL);
+
+  /* Copy myinfo.  */
+  memcpy (myinfo_out, myinfo_in, sizeof (*myinfo_out));
+
+  /* Copy tparel.  */
+  myinfo_out->tparel = bfd_alloc (obfd, myinfo_out->tparel_size);
+  if (myinfo_out->tparel == NULL)
+    return FALSE;
+  memcpy (myinfo_out->tparel, myinfo_in->tparel, myinfo_out->tparel_size);
+
+  /* Normalize the type of empty symbols.  */
+  if (bfd_get_symcount (obfd) == 0)
+    myinfo_out->symbol_format = _MINT_SYMBOL_FORMAT_GNU;
+
+  return TRUE; /* _bfd_generic_bfd_copy_private_bfd_data (ibfd, obfd); */
+}
+
+/* Merge private BFD information from an input BFD to the output BFD when linking.  */
+
+#define MY_bfd_merge_private_bfd_data MY (merge_private_bfd_data)
+
+static bfd_boolean
+MY (merge_private_bfd_data) (bfd *ibfd, struct bfd_link_info *info)
+{
+  (void)info; /* Unused.  */
+
+  /* Our file format cannot be used as linker input.  */
+  if (ibfd->xvec == &MY (vec))
+    {
+      _bfd_error_handler ("%pB: file format %s cannot be used as linker input",
+	ibfd, bfd_get_target (ibfd));
+      bfd_set_error (bfd_error_invalid_operation);
+      return FALSE;
+    }
+
+  return TRUE; /* _bfd_generic_bfd_merge_private_bfd_data (ibfd, info); */
+}
+
+/* Find out the symbol name.  */
+
+static const char *
+find_symbol_name (reloc_howto_type *howto, bfd *input_bfd,
+		  bfd_byte *location, struct reloc_std_external *rel)
+{
+  struct external_nlist *syms = obj_aout_external_syms (input_bfd);
+  char *strings = obj_aout_external_strings (input_bfd);
+  struct aout_link_hash_entry **sym_hashes
+    = obj_aout_sym_hashes (input_bfd);
+  struct aout_link_hash_entry *h = NULL;
+  const char *name;
+  bfd_size_type r_index;
+  int r_extern;
+
+  if (bfd_get_reloc_size (howto) != 4)
+    return "(not a symbol)";
+
+  /* The input bfd is always big-endian.  There is no need to
+     call bfd_header_big_endian (input_bfd).  */
+  r_index  = ((rel->r_index[0] << 16)
+	      | (rel->r_index[1] << 8)
+	      | (rel->r_index[2]));
+  r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+
+  if (sym_hashes != NULL)
+    h = sym_hashes[r_index];
+
+  if (!r_extern)
+    {
+      bfd_size_type i;
+      bfd_vma wanted_value = bfd_get_32 (input_bfd, location);
+
+      name = NULL;
+      for (i = 0; i < obj_aout_external_sym_count (input_bfd); i++)
+	{
+	  bfd_vma this_value = bfd_get_32 (input_bfd, syms[i].e_value);
+
+	  if (this_value == wanted_value)
+	    {
+	      bfd_byte symtype = bfd_get_8 (input_bfd, syms[i].e_type);
+
+	      /* Skip debug symbols and the like.  */
+	      if ((symtype & N_STAB) != 0)
+		continue;
+
+	      /* This is dirty but preferable to a plethoria of
+		 single comparisons.  */
+	      if (symtype <= (N_BSS | N_EXT)
+		  || (symtype >= N_WEAKU && symtype <= N_COMM))
+		{
+		  name = strings + GET_WORD (input_bfd, syms[i].e_strx);
+		  break;
+		}
+	    }
+	}
+
+      /* FIXME:  If the relocation is against a section there is
+	 probably a symbol for that section floating around somewhere
+	 in the bfd jungle.  */
+      if (name == NULL)
+	{
+	  switch ((r_index & N_TYPE) & ~N_EXT)
+	    {
+	    case N_TEXT:
+	      name = "text section";
+	      break;
+	    case N_DATA:
+	      name = "data section";
+	      break;
+	    case N_BSS:
+	      name = "bss section";
+	      break;
+	    case N_ABS:
+	      name = "absolute section";
+	      break;
+	    default:
+	      name = "unknown section";
+	      break;
+	    }
+	}
+    }
+  else if (h != NULL)
+    name = h->root.root.string;
+  else if (r_index >= obj_aout_external_sym_count (input_bfd))
+    name = "(unknown symbol)";	/* Shouldn't happen.  */
+  else
+    name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
+
+  return name;
+}
+
+/* This relocation routine is used by some of the backend linkers.
+   They do not construct asymbol or arelent structures, so there is no
+   reason for them to use bfd_perform_relocation.  Also,
+   bfd_perform_relocation is so hacked up it is easier to write a new
+   function than to try to deal with it.
+
+   This routine does a final relocation.  Whether it is useful for a
+   relocatable link depends upon how the object format defines
+   relocations.
+
+   FIXME: This routine ignores any special_function in the HOWTO,
+   since the existing special_function values have been written for
+   bfd_perform_relocation.
+
+   HOWTO is the reloc howto information.
+   INPUT_BFD is the BFD which the reloc applies to.
+   INPUT_SECTION is the section which the reloc applies to.
+   CONTENTS is the contents of the section.
+   ADDRESS is the address of the reloc within INPUT_SECTION.
+   VALUE is the value of the symbol the reloc refers to.
+   ADDEND is the addend of the reloc.  */
+
+/* The additional parameter REL is specific to this backend.
+   This function is derived from _bfd_final_link_relocate()
+   found in reloc.c. It adds additional checking for dangerous
+   relocations in MiNT sharable text sections, then it records
+   the relocated offset in myinfo->relocs[] for further processing.  */
+
+static bfd_reloc_status_type
+MY (final_link_relocate_rel) (reloc_howto_type *howto,
+			      bfd *input_bfd,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      bfd_vma address,
+			      bfd_vma value,
+			      bfd_vma addend,
+			      struct reloc_std_external *rel)
+{
+  bfd_vma relocation;
+  bfd *output_bfd = input_section->output_section->owner;
+  struct mint_internal_info *myinfo = obj_aout_ext (output_bfd);
+  bfd_reloc_status_type retval;
+  int r_index;
+  int r_extern;
+  bfd_boolean need_tpa_relocation;
+
+  /* The input bfd is always big-endian.  There is no need to
+     call bfd_header_big_endian (input_bfd).  */
+  r_index  = ((rel->r_index[0] << 16)
+	      | (rel->r_index[1] << 8)
+	      | (rel->r_index[2]));
+  r_extern = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
+
+#define _MINT_F_SHTEXT 0x800
+
+  /* Sanity check the address.  */
+  if (address > bfd_get_section_limit (input_bfd, input_section))
+    return bfd_reloc_outofrange;
+
+  /* This function assumes that we are dealing with a basic relocation
+     against a symbol.  We want to compute the value of the symbol to
+     relocate to.  This is just VALUE, the value of the symbol, plus
+     ADDEND, any addend associated with the reloc.  */
+  relocation = value + addend;
+
+  /* Check for dangerous relocations in images with a sharable
+     text section.  */
+  if ((myinfo->prg_flags & _MINT_F_SHTEXT) != 0
+      && bfd_get_reloc_size (howto) == 4)
+    {
+      bfd_boolean error_found = FALSE;
+      const char *name = NULL;
+
+      if (input_section == obj_textsec (input_bfd))
+	{
+	  if (!r_extern)
+	    {
+	      /* This is a relocation against another section.  Only
+		 relocations against the text section are allowed.  */
+	      if (r_index != N_TEXT && r_index != (N_TEXT | N_EXT))
+		error_found = TRUE;
+	    }
+	  else if (relocation > (input_section->output_section->vma
+			    + input_section->output_section->size))
+	    {
+	      error_found = TRUE;
+	    }
+	  else if (relocation == (input_section->output_section->vma
+				  + input_section->output_section->size))
+	    {
+	      name = find_symbol_name (howto, input_bfd,
+						    contents + address,
+						    rel);
+	      if (strcmp (name, "_etext") == 0)
+		error_found = FALSE;
+	    }
+	}
+
+      if (error_found)
+	{
+	  const struct bfd_link_callbacks *callbacks
+	    = myinfo->linkinfo->callbacks;
+
+	  myinfo->reloc_error = TRUE;
+
+	  if (callbacks->reloc_dangerous != NULL)
+	    {
+	      if (name == NULL)
+		name = find_symbol_name (howto, input_bfd,
+						      contents + address,
+						      rel);
+
+	      callbacks->reloc_dangerous (myinfo->linkinfo, name,
+					  input_bfd,
+					  input_section, address);
+	    }
+	}
+    }
+
+  /* If the relocation is PC relative, we want to set RELOCATION to
+     the distance between the symbol (currently in RELOCATION) and the
+     location we are relocating.  Some targets (e.g., i386-aout)
+     arrange for the contents of the section to be the negative of the
+     offset of the location within the section; for such targets
+     pcrel_offset is FALSE.  Other targets (e.g., m88kbcs or ELF)
+     simply leave the contents of the section as zero; for such
+     targets pcrel_offset is TRUE.  If pcrel_offset is FALSE we do not
+     need to subtract out the offset of the location within the
+     section (which is just ADDRESS).  */
+  if (howto->pc_relative)
+    {
+      relocation -= (input_section->output_section->vma
+		     + input_section->output_offset);
+      if (howto->pcrel_offset)
+	relocation -= address;
+    }
+
+  retval = _bfd_relocate_contents (howto, input_bfd, relocation,
+				   contents + address);
+
+  /* The symbol has to be relocated again iff the length of the relocation
+     is 2 words and it is not pc relative.  */
+  need_tpa_relocation = FALSE;
+  if (!howto->pc_relative && bfd_get_reloc_size (howto) == 4)
+    {
+      if (r_extern)
+	{
+	  struct aout_link_hash_entry **sym_hashes = obj_aout_sym_hashes (input_bfd);
+	  struct aout_link_hash_entry *h = sym_hashes[r_index];
+	  asection *output_section = h->root.u.def.section->output_section;
+
+	  /* Do not relocate absolute symbols.  */
+	  if (output_section == obj_textsec (output_bfd)
+	      || output_section == obj_datasec (output_bfd)
+	      || output_section == obj_bsssec (output_bfd))
+	    {
+	      need_tpa_relocation = TRUE;
+	    }
+	}
+      else
+	{
+	  need_tpa_relocation = TRUE;
+	}
+    }
+
+  /* Here we add the TPA relocation entries for the address references
+     located inside the input sections. Note that if some references
+     to addresses are generated using data statements in the linker
+     script, they will not be relocated here because they do not
+     belong to any input section.  */
+  if (need_tpa_relocation)
+    {
+      bfd_vma tpa_address = input_section->output_section->vma
+	+ input_section->output_offset + address;
+
+      if (!bfd_m68kmint_add_tpa_relocation_entry(output_bfd, tpa_address))
+	return bfd_reloc_other;
+    }
+
+  return retval;
+}
+
+/* Write out the TPA relocation table.  */
+
+static bfd_boolean
+write_tparel (bfd *abfd, struct internal_exec *execp)
+{
+  struct mint_internal_info* myinfo = obj_aout_ext (abfd);
+
+  if (myinfo->dri_symtab_size == 0)
+    myinfo->tparel_pos = N_STROFF (execp)
+      + obj_aout_external_string_size (abfd);
+  else
+    myinfo->tparel_pos = N_SYMOFF (execp)
+      + myinfo->dri_symtab_size;
+
+  if (bfd_seek (abfd, myinfo->tparel_pos, SEEK_SET) != 0)
+    return FALSE;
+
+  if (bfd_bwrite (myinfo->tparel, myinfo->tparel_size, abfd)
+      != myinfo->tparel_size)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Write the full exec header.
+   This function must be called last to ensure that we have all the
+   information needed to fill the MiNT-specific header fields.  */
+
+static bfd_boolean
+write_exec_header (bfd *abfd, struct internal_exec *execp, struct external_exec *exec_bytes)
+{
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  bfd_size_type symtab_size;
+
+  bfd_h_put_16 (abfd, 0x601a, exec_bytes->g_branch);
+
+  /* The OS will load our extension header fields into the text segment.  */
+  bfd_h_put_32 (abfd, execp->a_text + (EXEC_BYTES_SIZE - GEMDOS_HEADER_SIZE),
+		exec_bytes->g_text);
+  bfd_h_put_32 (abfd, execp->a_data, exec_bytes->g_data);
+  bfd_h_put_32 (abfd, execp->a_bss, exec_bytes->g_bss);
+
+  /* The OS' notion of the size of the symbol table is another than
+     the bfd library's.  We have to fill in the size of the table
+     itself plus the size of the string table but only if we have not written
+     a traditional symbol table.  If we have written a traditional symbol
+     table we know the size.  */
+  if (myinfo->dri_symtab_size != 0)
+    symtab_size = myinfo->dri_symtab_size;
+  else
+    symtab_size = myinfo->tparel_pos - N_SYMOFF (execp);
+
+  bfd_h_put_32 (abfd, symtab_size, exec_bytes->g_syms);
+
+  bfd_h_put_32 (abfd, 0x4d694e54, exec_bytes->g_extmagic);
+  bfd_h_put_32 (abfd, myinfo->prg_flags, exec_bytes->g_flags);
+  bfd_h_put_16 (abfd, 0, exec_bytes->g_abs);
+
+  /* Generate the jump instruction to the entry point.  In m68k
+     assembler mnemnonics it looks more or less like this:
+
+       move.l  exec_bytes->e_entry(pc),d0
+       jmp     -6(pc,d0.l)
+
+     Sorry for the wrong syntax.  As a real assembler addict I
+     never actually use an assembler.  I edit my binaries manually
+     with a hex editor, looks much cooler and it strengthens your
+     abstraction abilities.  */
+
+  exec_bytes->g_jump_entry[0] = 0x20;
+  exec_bytes->g_jump_entry[1] = 0x3a;
+  exec_bytes->g_jump_entry[2] = 0x00;
+  exec_bytes->g_jump_entry[3] = 0x1a;
+  exec_bytes->g_jump_entry[4] = 0x4e;
+  exec_bytes->g_jump_entry[5] = 0xfb;
+  exec_bytes->g_jump_entry[6] = 0x08;
+  exec_bytes->g_jump_entry[7] = 0xfa;
+
+  bfd_h_put_32 (abfd, myinfo->tparel_pos, exec_bytes->g_tparel_pos);
+  bfd_h_put_32 (abfd, myinfo->tparel_size, exec_bytes->g_tparel_size);
+  bfd_h_put_32 (abfd, myinfo->stkpos, exec_bytes->g_stkpos);
+
+  /* If there are no symbols, pretend they are in GNU format.  */
+  if (symtab_size == 0)
+    myinfo->symbol_format = _MINT_SYMBOL_FORMAT_GNU;
+
+  bfd_h_put_32 (abfd, myinfo->symbol_format, exec_bytes->g_symbol_format);
+
+  memset (&exec_bytes->g_pad0, 0, sizeof (exec_bytes->g_pad0));
+
+  /* The standard stuff.  */
+  NAME(aout, swap_exec_header_out) (abfd, execp, exec_bytes);
+  if (myinfo->symbol_format != _MINT_SYMBOL_FORMAT_GNU)
+    PUT_WORD (abfd, 0, exec_bytes->e_syms);
+
+  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
+    return FALSE;
+
+  if (bfd_bwrite (exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, abfd)
+      != EXEC_BYTES_SIZE)
+    return FALSE;
+
+  /* Override the stack size.  */
+  if (myinfo->override_stack_size && myinfo->stkpos)
+  {
+    bfd_byte big_endian_stack_size[4];
+
+    bfd_put_32 (abfd, myinfo->stack_size, &big_endian_stack_size);
+
+    if (bfd_seek (abfd, (file_ptr) myinfo->stkpos, SEEK_SET) != 0)
+      return FALSE;
+
+    if (bfd_bwrite (big_endian_stack_size, 4, abfd) != 4)
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/* Write an object file.
+   Section contents have already been written.  We write the
+   file header, symbols, and relocation.  */
+
+#define MY_write_object_contents MY (write_object_contents)
+
+static bfd_boolean
+MY (write_object_contents) (bfd *abfd)
+{
+  struct external_exec exec_bytes;
+  struct internal_exec *execp = exec_hdr (abfd);
+
+  BFD_ASSERT (obj_aout_ext (abfd) != NULL);
+
+  obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
+
+  /* Most of the following code come from the WRITE_HEADERS macro
+     found in libaout.h.  */
+
+  if (adata(abfd).magic == undecided_magic)
+    NAME (aout, adjust_sizes_and_vmas) (abfd);
+
+  execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;
+  execp->a_entry = bfd_get_start_address (abfd);
+
+  execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *
+		     obj_reloc_entry_size (abfd));
+  execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *
+		     obj_reloc_entry_size (abfd));
+
+  /* Now write out reloc info, followed by syms and strings.  */
+
+  if (bfd_get_outsymbols (abfd) != NULL
+      && bfd_get_symcount (abfd) != 0)
+    {
+      if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(execp)), SEEK_SET) != 0)
+	return FALSE;
+
+      if (! NAME (aout, write_syms) (abfd))
+	return FALSE;
+    }
+
+  if (bfd_seek (abfd, (file_ptr) (N_TRELOFF (execp)), SEEK_SET) != 0)
+    return FALSE;
+  if (!NAME (aout, squirt_out_relocs) (abfd, obj_textsec (abfd)))
+    return FALSE;
+
+  if (bfd_seek (abfd, (file_ptr) (N_DRELOFF (execp)), SEEK_SET) != 0)
+    return FALSE;
+  if (!NAME (aout, squirt_out_relocs) (abfd, obj_datasec (abfd)))
+    return FALSE;
+
+  if (write_tparel (abfd, execp) != TRUE)
+    return FALSE;
+
+  if (write_exec_header (abfd, execp, &exec_bytes) != TRUE)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Print private BFD data. Used by objdump -p.  */
+
+#define MY_bfd_print_private_bfd_data MY (print_private_bfd_data)
+
+static bfd_boolean
+MY (print_private_bfd_data) (bfd *abfd, void *ptr)
+{
+  FILE *file = (FILE *) ptr;
+  struct mint_internal_info *myinfo = obj_aout_ext (abfd);
+  const char* symbol_format;
+  long stksize = 0;
+
+  fprintf (file, "\n");
+
+  fprintf (file, " GEMDOS flags: 0x%08lx\n", (unsigned long) myinfo->prg_flags);
+  fprintf (file, "Start address: 0x%08lx\n", (unsigned long) bfd_get_start_address (abfd));
+
+  /* Stack size.  */
+  if (myinfo->stkpos != 0)
+    {
+      if (bfd_seek (abfd, myinfo->stkpos, SEEK_SET) != 0
+	  || (bfd_bread (&stksize, sizeof(long), abfd) != sizeof(long)))
+	return FALSE;
+
+      stksize = bfd_get_signed_32 (abfd, &stksize);
+    }
+  fprintf (file, "   Stack size: %ld\n", stksize);
+
+  /* Symbol format.  */
+  switch (myinfo->symbol_format)
+    {
+      case _MINT_SYMBOL_FORMAT_GNU: symbol_format = "stabs"; break;
+      case _MINT_SYMBOL_FORMAT_DRI: symbol_format = "DRI";   break;
+      default:			    symbol_format = "?";     break;
+    }
+  fprintf (file, "Symbol format: %s\n", symbol_format);
+
+  return TRUE;
+}
+
+/* Special case for NAME (aout, get_section_contents)
+   It is not declared in libaout.h, neither implemented in aoutx.h.
+   Instead, a macro named aout_32_get_section_contents is defined in libaout.h.
+   So the default value of MY_get_section_contents provided by aout-target.h
+   is not correct, it has to be defined here with the right value.  */
+
+#define MY_get_section_contents aout_32_get_section_contents
+
+/* The following include will define MY (vec)
+   and a default implementation for all the MY_ functions
+   not overriden here.  */
+
+#include "aout-target.h"
+
+/* Set the GEMDOS executable flags.
+   It is called by the linker emulation script.  */
+
+bfd_boolean
+bfd_m68kmint_set_extended_flags (bfd *abfd, flagword prg_flags)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  myinfo->prg_flags = prg_flags;
+
+  return TRUE;
+}
+
+/* Override the stack size.
+   It is called by the linker emulation script.  */
+
+bfd_boolean
+bfd_m68kmint_set_stack_size (bfd *abfd, bfd_signed_vma stack_size)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  myinfo->stack_size = stack_size;
+  myinfo->override_stack_size = TRUE;
+
+  return TRUE;
+}
+
+/* Add a TPA relocation entry.
+   It is called by BFD when linking the input sections, and by the
+   linker when it generates a reference to an address (in particular,
+   when building the constructors list).  */
+
+bfd_boolean
+bfd_m68kmint_add_tpa_relocation_entry (bfd *abfd, bfd_vma address)
+{
+  struct mint_internal_info *myinfo;
+
+  BFD_ASSERT(abfd->xvec == &MY (vec));
+  myinfo = obj_aout_ext (abfd);
+  BFD_ASSERT(myinfo != NULL);
+
+  /* Enlarge the buffer if necessary.  */
+  if (myinfo->relocs_used * sizeof (bfd_vma) >= myinfo->relocs_allocated)
+    {
+      bfd_vma *newbuf;
+      myinfo->relocs_allocated += MINT_RELOC_CHUNKSIZE;
+      newbuf = bfd_realloc (myinfo->relocs, myinfo->relocs_allocated);
+      if (newbuf == NULL)
+	return FALSE;
+
+      myinfo->relocs = newbuf;
+    }
+
+  /* The TPA relative relocation actually just adds the address of
+     the text segment (i. e. beginning of the executable in memory)
+     to the addresses at the specified locations.  This allows an
+     executable to be loaded everywhere in the address space without
+     memory management.  */
+  myinfo->relocs[myinfo->relocs_used++] = address;
+
+  return TRUE;
+}
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 33cd67150c..0a07b7dc42 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -983,6 +983,18 @@ space consuming.  For each target:
 
   data = (bfd_byte *) data + octets;
   apply_reloc (abfd, data, howto, relocation);
+
+  extern const bfd_target m68k_aout_mintprg_vec;
+  if (flag == bfd_reloc_ok
+      && input_section->output_section->owner->xvec == &m68k_aout_mintprg_vec
+      && !howto->pc_relative && (howto->size == 2 || howto->size == -2))
+    {
+      bfd_vma tpa_address = input_section->output_section->vma
+	+ input_section->output_offset + reloc_entry->address;
+	
+      bfd_m68kmint_add_tpa_relocation_entry (input_section->output_section->owner, tpa_address);
+    }
+
   return flag;
 }
 
diff --git a/bfd/targets.c b/bfd/targets.c
index 1b7e29d1e6..e8bffc4120 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -671,6 +671,7 @@ extern const bfd_target alpha_elf64_fbsd_vec;
 extern const bfd_target alpha_vms_vec;
 extern const bfd_target alpha_vms_lib_txt_vec;
 extern const bfd_target am33_elf32_linux_vec;
+extern const bfd_target aout0_be_vec;
 extern const bfd_target aout_vec;
 extern const bfd_target arc_elf32_be_vec;
 extern const bfd_target arc_elf32_le_vec;
@@ -764,6 +765,7 @@ extern const bfd_target m32r_elf32_linux_le_vec;
 extern const bfd_target m68hc11_elf32_vec;
 extern const bfd_target m68hc12_elf32_vec;
 extern const bfd_target m68k_elf32_vec;
+extern const bfd_target m68k_aout_mintprg_vec;
 extern const bfd_target s12z_elf32_vec;
 extern const bfd_target mach_o_be_vec;
 extern const bfd_target mach_o_le_vec;
@@ -995,6 +997,7 @@ static const bfd_target * const _bfd_target_vector[] =
 
 	&am33_elf32_linux_vec,
 
+	&aout0_be_vec,
 #if 0
 	/* Since a.out files lack decent magic numbers, no way to recognize
 	   which kind of a.out file it is.  */
@@ -1132,6 +1135,7 @@ static const bfd_target * const _bfd_target_vector[] =
 	&m68hc12_elf32_vec,
 
 	&m68k_elf32_vec,
+	&m68k_aout_mintprg_vec,
 
 	&s12z_elf32_vec,
 
diff --git a/binutils/Makefile.am b/binutils/Makefile.am
index f1f3907b0b..80b43e754e 100644
--- a/binutils/Makefile.am
+++ b/binutils/Makefile.am
@@ -33,7 +33,7 @@ EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
 YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
 YFLAGS = -d
 LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
-LEXLIB = @LEXLIB@
+#LEXLIB = @LEXLIB@
 
 # Automake 1.10+ disables lex and yacc output file regeneration if
 # maintainer mode is disabled.  Avoid this.
diff --git a/binutils/Makefile.in b/binutils/Makefile.in
index 39f08563f9..24f858e836 100644
--- a/binutils/Makefile.in
+++ b/binutils/Makefile.in
@@ -449,7 +449,7 @@ INSTOBJEXT = @INSTOBJEXT@
 LD = @LD@
 LDFLAGS = @LDFLAGS@
 LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
-LEXLIB = @LEXLIB@
+#LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBDEBUGINFOD = @LIBDEBUGINFOD@
 LIBICONV = @LIBICONV@
diff --git a/binutils/ar.c b/binutils/ar.c
index 1057db9980..85d12c53fa 100644
--- a/binutils/ar.c
+++ b/binutils/ar.c
@@ -583,6 +583,7 @@ decode_options (int argc, char **argv)
           break;
         case 'T':
           make_thin_archive = TRUE;
+          make_thin_archive = FALSE;
           break;
         case 'D':
           deterministic = TRUE;
diff --git a/binutils/configure b/binutils/configure
index a8dfd4bd68..f5b5c08654 100755
--- a/binutils/configure
+++ b/binutils/configure
@@ -14246,7 +14246,7 @@ fi
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
diff --git a/binutils/dlltool.c b/binutils/dlltool.c
index 734c727a06..fca0e00f5b 100644
--- a/binutils/dlltool.c
+++ b/binutils/dlltool.c
@@ -4415,7 +4415,7 @@ deduce_name (const char *prog_name)
       if (*cp == '-')
 	dash = cp;
       if (
-#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
+#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__) || defined(__MINT__)
 	  *cp == ':' || *cp == '\\' ||
 #endif
 	  *cp == '/')
diff --git a/binutils/dllwrap.c b/binutils/dllwrap.c
index c8cdf84301..645c793f84 100644
--- a/binutils/dllwrap.c
+++ b/binutils/dllwrap.c
@@ -256,7 +256,7 @@ deduce_name (const char * name)
 	dash = cp;
 
       if (
-#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
+#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__) || defined(__MINT__)
 	  *cp == ':' || *cp == '\\' ||
 #endif
 	  *cp == '/')
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index 212e25144e..9b5b597513 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -1661,6 +1661,9 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
       if (keep && is_strip_section (abfd, bfd_asymbol_section (sym)))
 	keep = FALSE;
 
+      if (strip_symbols != STRIP_ALL && (flags & BSF_CONSTRUCTOR))
+         keep = TRUE;
+
       if (keep)
 	{
 	  if ((flags & BSF_GLOBAL) != 0
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 6b5bebe743..5a746af873 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -13738,7 +13738,11 @@ dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
 #ifndef __MSVCRT__
 	  /* PR 11128: Use two separate invocations in order to work
              around bugs in the Solaris 8 implementation of printf.  */
+#if GCC_VERSION < 3000
+	  printf ("  [%6lx]  ", (unsigned long) (data - start));
+#else
 	  printf ("  [%6tx]  ", data - start);
+#endif
 #else
 	  printf ("  [%6Ix]  ", (size_t) (data - start));
 #endif
diff --git a/binutils/resrc.c b/binutils/resrc.c
index 1d43355915..3da0438eff 100644
--- a/binutils/resrc.c
+++ b/binutils/resrc.c
@@ -391,7 +391,7 @@ look_for_default (char *cmd, const char *prefix, int end_prefix,
     *space = 0;
 
   if (
-#if defined (__DJGPP__) || defined (__CYGWIN__) || defined (_WIN32)
+#if defined (__DJGPP__) || defined (__CYGWIN__) || defined (_WIN32) || defined (__MINT__)
       strchr (cmd, '\\') ||
 #endif
       strchr (cmd, '/'))
@@ -509,7 +509,7 @@ read_rc_file (const char *filename, const char *preprocessor,
 	  if (*cp == '-')
 	    dash = cp;
 	  if (
-#if defined (__DJGPP__) || defined (__CYGWIN__) || defined(_WIN32)
+#if defined (__DJGPP__) || defined (__CYGWIN__) || defined(_WIN32) || defined (__MINT__)
 	      *cp == ':' || *cp == '\\' ||
 #endif
 	      *cp == '/')
diff --git a/binutils/testsuite/binutils-all/copy-2.d b/binutils/testsuite/binutils-all/copy-2.d
index 9eda63bc87..f5ad70aea3 100644
--- a/binutils/testsuite/binutils-all/copy-2.d
+++ b/binutils/testsuite/binutils-all/copy-2.d
@@ -3,7 +3,7 @@
 #objcopy: --set-section-flags foo=contents,alloc,load,code
 #name: copy with setting section flags 2
 #source: copytest.s
-#notarget: *-*-*aout *-*-aix* h8300-*-* hppa*-*-hpux* mips-*-ultrix* mips-*-osf* mips-*-ecoff* mips-*-irix mips-*-irix[2-4] mips-*-riscos* ns32k-*-*
+#notarget: *-*-*aout *-*-aix* h8300-*-* hppa*-*-hpux* m68k-*-mint* mips-*-ultrix* mips-*-osf* mips-*-ecoff* mips-*-irix mips-*-irix[2-4] mips-*-riscos* ns32k-*-*
 # Note - we use copytest.s and a section named "foo" rather
 # than .text because for some file formats (eg PE) the .text
 # section has a fixed set of flags and these cannot be changed.
diff --git a/binutils/testsuite/binutils-all/copy-3.d b/binutils/testsuite/binutils-all/copy-3.d
index dd28719e8b..569d1c507e 100644
--- a/binutils/testsuite/binutils-all/copy-3.d
+++ b/binutils/testsuite/binutils-all/copy-3.d
@@ -3,7 +3,7 @@
 #objcopy: --set-section-flags .text=alloc,data
 #name: copy with setting section flags 3
 #source: bintest.s
-#notarget: *-*-*aout *-*-*coff *-*-cygwin* *-*-darwin *-*-mingw* *-*-go32 *-*-*pe hppa*-*-hpux* ns32k-*-* powerpc-*-aix* rs6000-*-* rx-*-*
+#notarget: *-*-*aout *-*-*coff *-*-cygwin* *-*-darwin *-*-mingw* *-*-go32 *-*-*pe hppa*-*-hpux* m68k-*-mint* ns32k-*-* powerpc-*-aix* rs6000-*-* rx-*-*
 # The .text # section in PE/COFF has a fixed set of flags and these
 # cannot be changed.  We skip it for them.
 
diff --git a/config.rpath b/config.rpath
index 4dea75957c..863ce0dcc4 100755
--- a/config.rpath
+++ b/config.rpath
@@ -438,7 +438,7 @@ case "$host_os" in
   bsdi4*)
     ;;
   cygwin* | mingw* | pw32*)
-    shrext=.dll
+    shrext=.dll.a
     ;;
   darwin* | rhapsody*)
     shrext=.dylib
diff --git a/config.sub b/config.sub
index f02d43ad50..27c051e026 100755
--- a/config.sub
+++ b/config.sub
@@ -805,6 +805,11 @@ case $basic_machine in
 		cpu=m68000
 		vendor=convergent
 		;;
+	*mintelf*)
+		cpu=m68k
+		vendor=atari
+		os=mintelf
+		;;
 	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		cpu=m68k
 		vendor=atari
@@ -1481,6 +1486,9 @@ case $os in
 	ose*)
 		os=ose
 		;;
+	*mintelf)
+		os=mintelf
+		;;
 	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
 		os=mint
 		;;
@@ -1511,6 +1519,12 @@ case $os in
 		;;
 	*-eabi)
 		;;
+	-mintelf*)
+		os=mintelf
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=mint
+		;;
 	*)
 		echo Invalid configuration \`"$1"\': system \`"$os"\' not recognized 1>&2
 		exit 1
diff --git a/configure b/configure
index 91dc42f6c7..bfd72dca5c 100755
--- a/configure
+++ b/configure
@@ -3847,6 +3847,9 @@ case "${target}" in
   i[3456789]86-*-rdos*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs gdb libdecnumber sim"
+    ;;
   mmix-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff --git a/configure.ac b/configure.ac
index 4bd869a63a..bea1ca8314 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1091,6 +1091,9 @@ case "${target}" in
   i[[3456789]]86-*-rdos*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs gdb libdecnumber sim"
+    ;;
   mmix-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff --git a/gas/config/tc-m68k.c b/gas/config/tc-m68k.c
index 5483f8e017..77317d3bd0 100644
--- a/gas/config/tc-m68k.c
+++ b/gas/config/tc-m68k.c
@@ -27,9 +27,14 @@
 
 #include "opcode/m68k.h"
 #include "m68k-parse.h"
+
+#if defined (OBJ_ELF)
 #include "elf/m68k.h"
+#endif
 
+#ifdef OBJ_ELF
 static void m68k_elf_cons (int);
+#endif
 
 /* This string holds the chars that always start a comment.  If the
    pre-processor is disabled, these aren't very useful.  The macro
@@ -375,9 +380,11 @@ struct m68k_it
 	 significance of some values (in the branch instruction, for
 	 example).  */
       int pcrel_fix;
+#ifdef OBJ_ELF
       /* Whether this expression needs special pic relocation, and if
 	 so, which.  */
       enum pic_relocation pic_reloc;
+#endif
     }
   reloc[5];			/* Five is enough???  */
 };
@@ -438,7 +445,9 @@ add_fix (int width, struct m68k_exp *exp, int pc_rel, int pc_fix)
   the_ins.reloc[the_ins.nrel].exp = exp->exp;
   the_ins.reloc[the_ins.nrel].wid = width;
   the_ins.reloc[the_ins.nrel].pcrel_fix = pc_fix;
+#ifdef OBJ_ELF
   the_ins.reloc[the_ins.nrel].pic_reloc = exp->pic_reloc;
+#endif
   the_ins.reloc[the_ins.nrel++].pcrel = pc_rel;
 }
 
@@ -881,9 +890,13 @@ const pseudo_typeS md_pseudo_table[] =
   {"even", s_even, 0},
   {"skip", s_space, 0},
   {"proc", s_proc, 0},
+#if defined (TE_SUN3) || defined (OBJ_ELF)
   {"align", s_align_bytes, 0},
+#endif
+#ifdef OBJ_ELF
   {"swbeg", s_ignore, 0},
   {"long", m68k_elf_cons, 4},
+#endif
   {"extend", float_cons, 'x'},
   {"ldouble", float_cons, 'x'},
 
@@ -950,7 +963,11 @@ const pseudo_typeS mote_pseudo_table[] =
   {"dsb", s_space, 1},
 
   {"xdef", s_globl, 0},
+#ifdef OBJ_ELF
   {"align", s_align_bytes, 0},
+#else
+  {"align", s_align_ptwo, 0},
+#endif
   {0, 0, 0}
 };
 
@@ -975,6 +992,7 @@ static char alt_notend_table[256];
       || (*s == ':'						\
 	  && alt_notend_table[(unsigned char) s[1]])))
 
+#ifdef OBJ_ELF
 
 /* Return zero if the reference to SYMBOL from within the same segment may
    be relaxed.  */
@@ -1200,6 +1218,60 @@ tc_m68k_fix_adjustable (fixS *fixP)
     }
 }
 
+#else /* !OBJ_ELF */
+
+/* Compute the relocation code for a fixup of SIZE bytes, using pc
+   relative relocation if PCREL is non-zero.  PIC says whether a special
+   pic relocation was requested.  */
+
+static bfd_reloc_code_real_type
+get_reloc_code (int size, int pcrel)
+{
+      if (pcrel)
+	{
+	  switch (size)
+	    {
+	    case 1:
+	      return BFD_RELOC_8_PCREL;
+	    case 2:
+	      return BFD_RELOC_16_PCREL;
+	    case 4:
+	      return BFD_RELOC_32_PCREL;
+	    }
+	}
+      else
+	{
+	  switch (size)
+	    {
+	    case 1:
+	      return BFD_RELOC_8;
+	    case 2:
+	      return BFD_RELOC_16;
+	    case 4:
+	      return BFD_RELOC_32;
+	    }
+	}
+
+  if (pcrel)
+    {
+	as_bad (_("Can not do %d byte pc-relative relocation"), size);
+    }
+  else
+    {
+	as_bad (_("Can not do %d byte relocation"), size);
+    }
+
+  return BFD_RELOC_NONE;
+}
+
+#define get_reloc_code(SIZE,PCREL,OTHER) (get_reloc_code)(SIZE, PCREL)
+
+/* PR gas/3041 Weak symbols are not relaxable
+   because they must be treated as extern.  */
+#define relaxable_symbol(symbol)   (!(S_IS_WEAK (symbol)))
+
+#endif /* OBJ_ELF */
+
 arelent *
 tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 {
@@ -1302,6 +1374,39 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
   reloc->sym_ptr_ptr = XNEW (asymbol *);
   *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
   reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+#ifndef OBJ_ELF
+  if (OUTPUT_FLAVOR == bfd_target_aout_flavour
+      && fixp->fx_addsy
+      && S_IS_WEAK (fixp->fx_addsy)
+      && ! bfd_is_und_section (S_GET_SEGMENT (fixp->fx_addsy)))
+    {
+      /* PR gas/3041 References to weak symbols must be treated as extern
+	 in order to be overridable by the linker, even if they are defined
+	 in the same object file. So the original addend must be written
+	 "as is" into the output section without further processing.
+	 The addend value must be hacked here in order to force
+	 bfd_install_relocation() to write the original value into the
+	 output section.
+	 1) MD_APPLY_SYM_VALUE() is set to 1 for m68k/a.out, so the symbol
+	 value has already been added to the addend in fixup_segment(). We
+	 have to remove it.
+	 2) bfd_install_relocation() will incorrectly treat this symbol as
+	 resolved, so it will write the symbol value plus its addend and
+	 section VMA. As a workaround we can tweak the addend value here in
+	 order to get the original value in the section after the call to
+	 bfd_install_relocation().  */
+      reloc->addend = fixp->fx_addnumber
+		      /* Fix because of MD_APPLY_SYM_VALUE() */
+		      - S_GET_VALUE (fixp->fx_addsy)
+		      /* Fix for bfd_install_relocation() */
+		      - (S_GET_VALUE (fixp->fx_addsy)
+			 + S_GET_SEGMENT (fixp->fx_addsy)->vma);
+    }
+  else if (fixp->fx_pcrel)
+    reloc->addend = fixp->fx_addnumber;
+  else
+    reloc->addend = 0;
+#else
   if (!fixp->fx_pcrel)
     reloc->addend = fixp->fx_addnumber;
   else
@@ -1309,6 +1414,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 		     + fixp->fx_pcrel_adjust
 		     + fixp->fx_addnumber
 		     + md_pcrel_from (fixp));
+#endif
 
   reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
   gas_assert (reloc->howto != 0);
@@ -2600,9 +2706,12 @@ m68k_ip (char *instring)
 		      if (opP->reg == PC)
 			{
 			  if (opP->disp.size == SIZE_LONG
+#ifdef OBJ_ELF
 			      /* If the displacement needs pic
 				 relocation it cannot be relaxed.  */
-			      || opP->disp.pic_reloc != pic_none)
+			      || opP->disp.pic_reloc != pic_none
+#endif
+			      )
 			    {
 			      addword (0x0170);
 			      add_fix ('l', &opP->disp, 1, 2);
@@ -2767,9 +2876,12 @@ m68k_ip (char *instring)
 			       && opP->reg == PC
 			       && isvar (&opP->disp)
 			       && subs (&opP->disp) == NULL
+#ifdef OBJ_ELF
 			       /* If the displacement needs pic
 				  relocation it cannot be relaxed.  */
-			       && opP->disp.pic_reloc == pic_none)
+			       && opP->disp.pic_reloc == pic_none
+#endif
+			       )
 			{
 			  /* The code in md_convert_frag_1 needs to be
                              able to adjust nextword.  Call frag_grow
@@ -2913,9 +3025,11 @@ m68k_ip (char *instring)
 		  if (isvar (&opP->disp)
 		      && !subs (&opP->disp)
 		      && adds (&opP->disp)
+#ifdef OBJ_ELF
 		      /* If the displacement needs pic relocation it
 			 cannot be relaxed.  */
 		      && opP->disp.pic_reloc == pic_none
+#endif
 		      && !flag_long_jumps
 		      && !strchr ("~%&$?", s[0]))
 		    {
@@ -3082,9 +3196,12 @@ m68k_ip (char *instring)
 
 	      var_branch:
 	      if (subs (&opP->disp)	/* We can't relax it.  */
+#ifdef OBJ_ELF
 		  /* If the displacement needs pic relocation it cannot be
 		     relaxed.  */
-		  || opP->disp.pic_reloc != pic_none)
+		  || opP->disp.pic_reloc != pic_none
+#endif
+		  || 0)
 		{
 		  if (!have_disp)
 		    as_warn (_("Can't use long branches on this architecture"));
@@ -4313,8 +4430,10 @@ md_assemble (char *str)
       current_label = NULL;
     }
 
+#ifdef OBJ_ELF
   /* Tie dwarf2 debug info to the address at the start of the insn.  */
   dwarf2_emit_insn (0);
+#endif
 
   if (the_ins.nfrag == 0)
     {
@@ -4689,9 +4808,11 @@ md_begin (void)
 
   init_regtable ();
 
+#ifdef OBJ_ELF
   record_alignment (text_section, 2);
   record_alignment (data_section, 2);
   record_alignment (bss_section, 2);
+#endif
 }
 
 
@@ -4710,7 +4831,9 @@ m68k_frob_label (symbolS *sym)
   labels = n;
   current_label = n;
 
+#ifdef OBJ_ELF
   dwarf2_emit_label (sym);
+#endif
 }
 
 /* This is called when a value that is not an instruction is emitted.  */
@@ -4820,6 +4943,7 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
   if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
     fixP->fx_done = 1;
 
+#ifdef OBJ_ELF
   if (fixP->fx_addsy)
     {
       memset (buf, 0, fixP->fx_size);
@@ -4856,6 +4980,15 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
 
       return;
     }
+#elif defined(OBJ_AOUT)
+  /* PR gas/3041 Do not fix frags referencing a weak symbol.  */
+  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
+    {
+      memset (buf, 0, fixP->fx_size);
+      fixP->fx_addnumber = val;	/* Remember value for emit_reloc.  */
+      return;
+    }
+#endif
 
   if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@@ -7746,6 +7879,18 @@ md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
 valueT
 md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
 {
+#ifdef OBJ_AOUT
+  /* For a.out, force the section size to be aligned.  If we don't do
+     this, BFD will align it for us, but it will not write out the
+     final bytes of the section.  This may be a bug in BFD, but it is
+     easier to fix it here since that is how the other a.out targets
+     work.  */
+  int align = bfd_section_alignment (segment);
+  valueT mask = ((valueT) 1 << align) - 1;
+
+  size = (size + mask) & ~mask;
+#endif
+
   return size;
 }
 
@@ -7764,6 +7909,7 @@ md_pcrel_from (fixS *fixP)
   return fixP->fx_where + fixP->fx_frag->fr_address - adjust;
 }
 
+#ifdef OBJ_ELF
 void
 m68k_elf_final_processing (void)
 {
@@ -7951,6 +8097,7 @@ m68k_elf_cons (int nbytes /* 4=.long */)
   input_line_pointer--;
   demand_empty_rest_of_line ();
 }
+#endif
 
 int
 tc_m68k_regname_to_dw2regnum (const char *regname)
diff --git a/gas/config/tc-m68k.h b/gas/config/tc-m68k.h
index e586eca35c..25ab95b601 100644
--- a/gas/config/tc-m68k.h
+++ b/gas/config/tc-m68k.h
@@ -24,7 +24,12 @@ struct fix;
 
 #define TARGET_BYTES_BIG_ENDIAN 1
 
+#ifdef OBJ_ELF
 #define TARGET_FORMAT "elf32-m68k"
+#endif
+#ifdef OBJ_AOUT
+#define TARGET_FORMAT "a.out-zero-big"
+#endif
 #define TARGET_ARCH bfd_arch_m68k
 
 #define tc_comment_chars m68k_comment_chars
@@ -41,7 +46,11 @@ extern const char *m68k_comment_chars;
 #endif
 
 #ifndef REGISTER_PREFIX_OPTIONAL
+#if defined (OBJ_ELF)
 #define REGISTER_PREFIX_OPTIONAL 0
+#else
+#define REGISTER_PREFIX_OPTIONAL 1
+#endif
 #endif
 
 extern void m68k_mri_mode_change (int);
@@ -75,6 +84,7 @@ while (0)
 #define RELAX_RELOC_PC16  BFD_RELOC_16_PCREL
 #define RELAX_RELOC_PC32  BFD_RELOC_32_PCREL
 
+#ifdef OBJ_ELF
 #define tc_fix_adjustable(X) tc_m68k_fix_adjustable(X)
 extern int tc_m68k_fix_adjustable (struct fix *);
 
@@ -89,6 +99,7 @@ extern int tc_m68k_fix_adjustable (struct fix *);
 
 #define elf_tc_final_processing m68k_elf_final_processing
 extern void m68k_elf_final_processing (void);
+#endif
 
 #define DIFF_EXPR_OK
 
@@ -116,7 +127,11 @@ extern struct relax_type md_relax_table[];
 #define TARGET_USE_CFIPOP 1
 
 #define DWARF2_DEFAULT_RETURN_COLUMN 24
+#ifdef TE_MINT
+#define DWARF2_CIE_DATA_ALIGNMENT (-2)
+#else
 #define DWARF2_CIE_DATA_ALIGNMENT (-4)
+#endif
 
 #define tc_regname_to_dw2regnum tc_m68k_regname_to_dw2regnum
 extern int tc_m68k_regname_to_dw2regnum (const char *regname);
diff --git a/gas/config/te-mint.h b/gas/config/te-mint.h
new file mode 100644
index 0000000000..ba1def1712
--- /dev/null
+++ b/gas/config/te-mint.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2008-2017 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GAS is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TE_MINT
+
+#define LOCAL_LABELS_DOLLAR 1
+#define LOCAL_LABELS_FB 1
+
+/* These define interfaces.  */
+#ifdef   OBJ_HEADER
+#include OBJ_HEADER
+#else
+#include "obj-format.h"
+#endif
diff --git a/gas/configure.tgt b/gas/configure.tgt
index 37224c5144..00ed73bf97 100644
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -288,6 +288,8 @@ case ${generic_target} in
   m68k-*-linux-*)			fmt=elf em=linux ;;
   m68k-*-uclinux*)			fmt=elf em=uclinux ;;
   m68k-*-gnu*)				fmt=elf ;;
+  m68k-*-mintelf*)			fmt=elf em=mint bfd_gas=yes ;;
+  m68k-*-mint*)				fmt=aout em=mint bfd_gas=yes ;;
   m68k-*-netbsdelf*)			fmt=elf em=nbsd ;;
 
   s12z-*-*)				fmt=elf ;;
diff --git a/gas/testsuite/gas/all/weakref1u.d b/gas/testsuite/gas/all/weakref1u.d
index 5b8d84895b..bac68fcda4 100644
--- a/gas/testsuite/gas/all/weakref1u.d
+++ b/gas/testsuite/gas/all/weakref1u.d
@@ -3,7 +3,7 @@
 #source: weakref1.s
 # aout turns undefined into *ABS* symbols.
 # see weakref1.d for comments on the other notargets
-#notarget: *-*-*aout ns32k-*-* alpha*-*-osf* *-*-ecoff
+#notarget: *-*-*aout m68k-*-mint* ns32k-*-* alpha*-*-osf* *-*-ecoff
 
 # the rest of this file is generated with the following script:
 # # script begin
diff --git a/gas/testsuite/gas/m68k/br-isaa.d b/gas/testsuite/gas/m68k/br-isaa.d
index cccb484893..21f048bce3 100644
--- a/gas/testsuite/gas/m68k/br-isaa.d
+++ b/gas/testsuite/gas/m68k/br-isaa.d
@@ -1,6 +1,7 @@
 #name: br-isaa.d
 #objdump: -dr
 #as: -march=isaa -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/gas/testsuite/gas/m68k/br-isab.d b/gas/testsuite/gas/m68k/br-isab.d
index bcac0d22ed..7187de7b32 100644
--- a/gas/testsuite/gas/m68k/br-isab.d
+++ b/gas/testsuite/gas/m68k/br-isab.d
@@ -1,6 +1,7 @@
 #name: br-isab.d
 #objdump: -dr
 #as: -march=isab -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/gas/testsuite/gas/m68k/br-isac.d b/gas/testsuite/gas/m68k/br-isac.d
index c876abb0c2..3eeb16f534 100644
--- a/gas/testsuite/gas/m68k/br-isac.d
+++ b/gas/testsuite/gas/m68k/br-isac.d
@@ -1,6 +1,7 @@
 #name: br-isac.d
 #objdump: -dr
 #as: -march=isac -pcrel
+#not-target: m68k-*-mint*
 
 .*:     file format .*
 
diff --git a/include/filenames.h b/include/filenames.h
index 1ed441221a..e979222a03 100644
--- a/include/filenames.h
+++ b/include/filenames.h
@@ -32,7 +32,7 @@ Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
 extern "C" {
 #endif
 
-#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)
+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__) || defined (__MINT__)
 #  ifndef HAVE_DOS_BASED_FILE_SYSTEM
 #    define HAVE_DOS_BASED_FILE_SYSTEM 1
 #  endif
diff --git a/include/getopt.h b/include/getopt.h
index eca40f43a9..83bcd85518 100644
--- a/include/getopt.h
+++ b/include/getopt.h
@@ -105,7 +105,7 @@ struct option
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_GETOPT
-#if defined (__GNU_LIBRARY__) || defined (HAVE_DECL_GETOPT)
+#if defined (__GNU_LIBRARY__) || defined (__MINT__) || defined (HAVE_DECL_GETOPT)
 /* Many other libraries have conflicting prototypes for getopt, with
    differences in the consts, in unistd.h.  To avoid compilation
    errors, only prototype getopt for the GNU C library.  */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index 4a9b8404b7..57f17be494 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -331,6 +331,9 @@ ALL_EMULATION_SOURCES = \
 	em68hc12elfb.c \
 	em68kelf.c \
 	em68kelfnbsd.c \
+	em68kaout.c \
+	em68kmintelf.c \
+	em68kmint.c \
 	em9s12zelf.c \
 	emcorepe.c \
 	emn10200.c \
diff --git a/ld/Makefile.in b/ld/Makefile.in
index 46d9b14077..8ee3690c6f 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -821,6 +821,9 @@ ALL_EMULATION_SOURCES = \
 	em68hc12elfb.c \
 	em68kelf.c \
 	em68kelfnbsd.c \
+	em68kaout.c \
+	em68kmintelf.c \
+	em68kmint.c \
 	em9s12zelf.c \
 	emcorepe.c \
 	emn10200.c \
@@ -1438,6 +1441,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elfb.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelfnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kmintelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kmint.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em9s12zelf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emcorepe.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emmo.Po@am__quote@
diff --git a/ld/configure b/ld/configure
index 811134a503..f9471a498d 100755
--- a/ld/configure
+++ b/ld/configure
@@ -17332,7 +17332,7 @@ fi
 
 
 case "${host}" in
-*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows*)
+*-*-msdos* | *-*-go32* | *-*-mingw32* | *-*-cygwin* | *-*-windows* | *-*-mint*)
 
 $as_echo "#define USE_BINARY_FOPEN 1" >>confdefs.h
  ;;
diff --git a/ld/configure.tgt b/ld/configure.tgt
index 23194e357f..a4ddfc25a8 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -457,6 +457,10 @@ m68hc11-*-*|m6811-*-*)	targ_emul=m68hc11elf
 m68hc12-*-*|m6812-*-*)	targ_emul=m68hc12elf
 			targ_extra_emuls="m68hc12elfb m68hc11elf m68hc11elfb"
 			;;
+m68*-*-mintelf*)	targ_emul=m68kmintelf
+			;;
+m68*-*-mint*)		targ_emul=m68kmint
+			;;
 m68*-*-netbsdelf*)	targ_emul=m68kelfnbsd
 			;;
 m68*-*-*)		targ_emul=m68kelf
diff --git a/ld/emulparams/elf_i386.sh b/ld/emulparams/elf_i386.sh
index 645707ddbd..de20e81749 100644
--- a/ld/emulparams/elf_i386.sh
+++ b/ld/emulparams/elf_i386.sh
@@ -33,6 +33,10 @@ case "$target" in
 	LIBPATH_SUFFIX=32
 	LIBPATH_SUFFIX_SKIP=64
 	;;
+      *64*)
+	LIBPATH_SUFFIX=64
+	LIBPATH_SUFFIX_SKIP=32
+	;;
     esac
     ;;
 esac
diff --git a/ld/emulparams/m68kaout.sh b/ld/emulparams/m68kaout.sh
new file mode 100644
index 0000000000..09e6c72b4b
--- /dev/null
+++ b/ld/emulparams/m68kaout.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=aout
+OUTPUT_FORMAT="a.out-zero-big"
+TEXT_START_ADDR=0x2020
+TARGET_PAGE_SIZE=0x2000
+SEGMENT_SIZE=0x20000
+ARCH=m68k
diff --git a/ld/emulparams/m68kmint.sh b/ld/emulparams/m68kmint.sh
new file mode 100644
index 0000000000..4cb45edbeb
--- /dev/null
+++ b/ld/emulparams/m68kmint.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=m68kmint
+OUTPUT_FORMAT="a.out-mintprg"
+RELOCATEABLE_OUTPUT_FORMAT="a.out-zero-big"
+TEXT_START_ADDR=0xe4
+ARCH=m68k
+EXTRA_EM_FILE=mint
diff --git a/ld/emulparams/m68kmintelf.sh b/ld/emulparams/m68kmintelf.sh
new file mode 100644
index 0000000000..54d9df6f05
--- /dev/null
+++ b/ld/emulparams/m68kmintelf.sh
@@ -0,0 +1,6 @@
+SCRIPT_NAME=m68kmintelf
+OUTPUT_FORMAT="a.out-mintprg"
+RELOCATEABLE_OUTPUT_FORMAT="a.out-zero-big"
+TEXT_START_ADDR=0xe4
+ARCH=m68k
+EXTRA_EM_FILE=mint
diff --git a/ld/emultempl/mint.em b/ld/emultempl/mint.em
new file mode 100644
index 0000000000..1e8d18e331
--- /dev/null
+++ b/ld/emultempl/mint.em
@@ -0,0 +1,330 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2006-2017 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+
+# This file is sourced from generic.em
+#
+fragment <<EOF
+
+#include "getopt.h"
+#include "ldgram.h"
+
+/* Standard GEMDOS program flags.  */
+#define _MINT_F_FASTLOAD      0x01    /* Don't clear heap.  */
+#define _MINT_F_ALTLOAD       0x02    /* OK to load in alternate RAM.  */
+#define _MINT_F_ALTALLOC      0x04    /* OK to malloc from alt. RAM.  */
+#define _MINT_F_BESTFIT       0x08    /* Load with optimal heap size.  */
+/* The memory flags are mutually exclusive.  */
+#define _MINT_F_MEMPROTECTION 0xf0    /* Masks out protection bits.  */
+#define _MINT_F_MEMPRIVATE    0x00    /* Memory is private.  */
+#define _MINT_F_MEMGLOBAL     0x10    /* Read/write access to mem allowed.  */
+#define _MINT_F_MEMSUPER      0x20    /* Only supervisor access allowed.  */
+#define _MINT_F_MEMREADABLE   0x30    /* Any read access OK.  */
+#define _MINT_F_SHTEXT        0x800   /* Program's text may be shared */
+
+/* Option flags.  */
+static flagword prg_flags = (_MINT_F_FASTLOAD | _MINT_F_ALTLOAD
+			     | _MINT_F_ALTALLOC | _MINT_F_MEMPRIVATE);
+
+/* If override_stack_size is TRUE, then the executable stack size
+ * must be overriden with the value of stack_size.  */
+static bfd_boolean override_stack_size = FALSE;
+static bfd_signed_vma stack_size;
+
+/* MiNT format extra command line options.  */
+
+/* Used for setting flags in the MiNT header.  */
+#define OPTION_FASTLOAD (300)
+#define OPTION_NO_FASTLOAD (OPTION_FASTLOAD + 1)
+#define OPTION_FASTRAM (OPTION_NO_FASTLOAD + 1)
+#define OPTION_NO_FASTRAM (OPTION_FASTRAM + 1)
+#define OPTION_FASTALLOC (OPTION_NO_FASTRAM + 1)
+#define OPTION_NO_FASTALLOC (OPTION_FASTALLOC + 1)
+#define OPTION_BESTFIT (OPTION_NO_FASTALLOC + 1)
+#define OPTION_NO_BESTFIT (OPTION_BESTFIT + 1)
+#define OPTION_BASEREL (OPTION_NO_BESTFIT + 1)
+#define OPTION_NO_BASEREL (OPTION_BASEREL + 1)
+#define OPTION_MEM_PRIVATE (OPTION_NO_BASEREL + 1)
+#define OPTION_MEM_GLOBAL (OPTION_MEM_PRIVATE + 1)
+#define OPTION_MEM_SUPER (OPTION_MEM_GLOBAL + 1)
+#define OPTION_MEM_READONLY (OPTION_MEM_SUPER + 1)
+#define OPTION_PRG_FLAGS (OPTION_MEM_READONLY + 1)
+#define OPTION_STACK (OPTION_PRG_FLAGS + 1)
+
+static void
+gld${EMULATION_NAME}_add_options
+  (int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
+    struct option **longopts, int nrl ATTRIBUTE_UNUSED,
+    struct option **really_longopts ATTRIBUTE_UNUSED)
+{
+  static const struct option xtra_long[] = {
+    {"mfastload", no_argument, NULL, OPTION_FASTLOAD},
+    {"mno-fastload", no_argument, NULL, OPTION_NO_FASTLOAD},
+    {"mfastram", no_argument, NULL, OPTION_FASTRAM},
+    {"mno-fastram", no_argument, NULL, OPTION_NO_FASTRAM},
+    {"maltram", no_argument, NULL, OPTION_FASTRAM},
+    {"mno-altram", no_argument, NULL, OPTION_NO_FASTRAM},
+    {"mfastalloc", no_argument, NULL, OPTION_FASTALLOC},
+    {"mno-fastalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+    {"maltalloc", no_argument, NULL, OPTION_FASTALLOC},
+    {"mno-altalloc", no_argument, NULL, OPTION_NO_FASTALLOC},
+    {"mbest-fit", no_argument, NULL, OPTION_BESTFIT},
+    {"mno-best-fit", no_argument, NULL, OPTION_NO_BESTFIT},
+    {"mbaserel", no_argument, NULL, OPTION_BASEREL},
+    {"mno-baserel", no_argument, NULL, OPTION_NO_BASEREL},
+    {"mshared-text", no_argument, NULL, OPTION_BASEREL},
+    {"mno-shared-text", no_argument, NULL, OPTION_NO_BASEREL},
+    {"msharable-text", no_argument, NULL, OPTION_BASEREL},
+    {"mno-sharable-text", no_argument, NULL, OPTION_NO_BASEREL},
+    /* Memory protection bits.  */
+    {"mprivate-memory", no_argument, NULL, OPTION_MEM_PRIVATE },
+    {"mglobal-memory", no_argument, NULL, OPTION_MEM_GLOBAL},
+    {"msuper-memory", no_argument, NULL, OPTION_MEM_SUPER},
+    {"mreadable-memory", no_argument, NULL, OPTION_MEM_READONLY},
+    {"mreadonly-memory", no_argument, NULL, OPTION_MEM_READONLY},
+    {"mprg-flags", required_argument, NULL, OPTION_PRG_FLAGS},
+    {"stack", required_argument, NULL, OPTION_STACK},
+    {NULL, no_argument, NULL, 0}
+  };
+
+  *longopts = (struct option *)
+    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
+  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
+}
+
+static bfd_boolean
+gld${EMULATION_NAME}_handle_option (int optc)
+{
+  switch (optc)
+    {
+    default:
+      return FALSE;
+
+    case OPTION_FASTLOAD:
+      prg_flags |= _MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_NO_FASTLOAD:
+      prg_flags &= ~_MINT_F_FASTLOAD;
+      break;
+
+    case OPTION_FASTRAM:
+      prg_flags |= _MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_NO_FASTRAM:
+      prg_flags &= ~_MINT_F_ALTLOAD;
+      break;
+
+    case OPTION_FASTALLOC:
+      prg_flags |= _MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_NO_FASTALLOC:
+      prg_flags &= ~_MINT_F_ALTALLOC;
+      break;
+
+    case OPTION_BESTFIT:
+      prg_flags |= _MINT_F_BESTFIT;
+      break;
+
+    case OPTION_NO_BESTFIT:
+      prg_flags &= ~_MINT_F_BESTFIT;
+      break;
+
+    case OPTION_BASEREL:
+      prg_flags |= _MINT_F_SHTEXT;
+      break;
+
+    case OPTION_NO_BASEREL:
+      prg_flags &= ~_MINT_F_SHTEXT;
+      break;
+
+    case OPTION_MEM_PRIVATE:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      break;
+
+    case OPTION_MEM_GLOBAL:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMPRIVATE;
+      break;
+
+    case OPTION_MEM_SUPER:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMSUPER;
+      break;
+
+    case OPTION_MEM_READONLY:
+      prg_flags &= ~_MINT_F_MEMPROTECTION;
+      prg_flags |= _MINT_F_MEMREADABLE;
+      break;
+
+    case OPTION_PRG_FLAGS:
+      {
+	char* tail;
+	unsigned long flag_value = strtoul (optarg, &tail, 0);
+
+	if (*tail != '\0')
+	  einfo (_("%P: warning: ignoring invalid program flags %s\n"), optarg);
+	else
+	  prg_flags = flag_value;
+
+	break;
+      }
+    case OPTION_STACK:
+      {
+	char* tail;
+	long size = strtol (optarg, &tail, 0);
+
+	if (*tail == 'K' || *tail == 'k')
+	  {
+	    size *= 1024;
+	    ++tail;
+	  }
+	else if (*tail == 'M' || *tail == 'm')
+	  {
+	    size *= 1024*1024;
+	    ++tail;
+	  }
+
+	if (*tail != '\0')
+	  einfo (_("%P: warning: ignoring invalid stack size %s\n"), optarg);
+	else
+	{
+	  stack_size = (bfd_signed_vma) size;
+	  override_stack_size = TRUE;
+	}
+
+	break;
+      }
+    }
+  return TRUE;
+}
+
+/* This callback is called when ld is invoked
+   with the --help and --target-help options.  */
+
+static void
+gld_${EMULATION_NAME}_list_options (FILE *file)
+{
+  fprintf (file, _("  --m[no-]fastload            Enable/Disable not cleaning the heap on startup\n"));
+  fprintf (file, _("  --m[no-]altram, --m[no-]fastram\n"));
+  fprintf (file, _("                              Enable/Disable loading into alternate RAM\n"));
+  fprintf (file, _("  --m[no-]altalloc, --m[no-]fastalloc\n"));
+  fprintf (file, _("                              Enable/Disable malloc from alternate RAM\n"));
+  fprintf (file, _("  --m[no-]best-fit            Enable/Disable loading with optimal heap size\n"));
+  fprintf (file, _("  --m[no-]sharable-text, --m[no-]shared-text, --m[no-]baserel\n"));
+  fprintf (file, _("                              Enable/Disable sharing the text segment\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("The following memory options are mutually exclusive:\n"));
+  fprintf (file, _("  --mprivate-memory           Process memory is not accessible\n"));
+  fprintf (file, _("  --mglobal-memory            Process memory is readable and writable\n"));
+  fprintf (file, _("  --msuper-memory             Process memory is accessible in supervisor mode\n"));
+  fprintf (file, _("  --mreadonly-memory, --mreadable-memory\n"));
+  fprintf (file, _("                              Process memory is readable but not writable\n"));
+  fprintf (file, "\n");
+  fprintf (file, _("  --mprg-flags <value>        Set all the flags with an integer raw value\n"));
+  fprintf (file, _("  --stack <size>              Override the stack size (suffix k or M allowed)\n"));
+}
+
+/* This callback is called by lang_for_each_statement. It checks that the
+   output sections speficied in the linker script are compatible with the MiNT
+   executable format.  */
+
+static void
+gld${EMULATION_NAME}_check_output_sections (lang_statement_union_type *s)
+{
+  if (s->header.type == lang_output_section_statement_enum)
+    {
+      lang_output_section_statement_type *oss = &s->output_section_statement;
+
+      if (strcmp(oss->name, ".text") == 0 && oss->bfd_section->vma != ${TEXT_START_ADDR})
+	einfo (_("%F%P: the VMA of section %A must be 0x%V, but actual value is 0x%V\n"),
+	  oss->bfd_section, ${TEXT_START_ADDR}, oss->bfd_section->vma);
+      else if (strcmp(oss->name, ".data") == 0 && oss->addr_tree != NULL)
+	einfo (_("%F%P: the VMA of section %A must not be specified\n"),
+	  oss->bfd_section);
+      else if (strcmp(oss->name, ".bss") == 0 && oss->addr_tree != NULL)
+	einfo (_("%F%P: the VMA of section %A must not be specified\n"),
+	  oss->bfd_section);
+    }
+}
+
+/* This callback is called by lang_for_each_statement. It looks for the data
+   statements of type REL generated by the linker, and adds a TPA relocation
+   entry for them. This is used by the CONSTRUCTORS list.  */
+
+static void
+gld${EMULATION_NAME}_add_tpa_relocs (lang_statement_union_type *s)
+{
+  if (s->header.type == lang_data_statement_enum)
+    {
+      lang_data_statement_type *ds = &s->data_statement;
+
+      if (ds->exp->type.node_code == REL)
+	{
+	  if (ds->type == LONG)
+	    {
+	      bfd_vma tpa_address = ds->output_section->vma + ds->output_offset;
+	      if (!bfd_m68kmint_add_tpa_relocation_entry(link_info.output_bfd, tpa_address))
+		einfo (_("%F%P:%B: unable to add a relocation entry\n"), link_info.output_bfd);
+	    }
+	    else
+	    {
+	      einfo (_("%F%P:%B: invalid size for TPA relocation entry in section %A, offset 0x%V\n"),
+		link_info.output_bfd, ds->output_section, ds->output_offset);
+	    }
+	}
+    }
+}
+
+/* Final emulation specific call.  */
+
+static void
+gld${EMULATION_NAME}_finish (void)
+{
+  /* Do nothing if we are not generating a MiNT executable (ex: binary).  */
+  if (strcmp (bfd_get_target (link_info.output_bfd), "${OUTPUT_FORMAT}") != 0)
+    return;
+
+  /* Check the output sections.  */
+  lang_for_each_statement (gld${EMULATION_NAME}_check_output_sections);
+
+  /* Set the GEMDOS executable header flags.  */
+  if (!bfd_m68kmint_set_extended_flags (link_info.output_bfd, prg_flags))
+    einfo (_("%F%P:%B: unable to set the header flags\n"), link_info.output_bfd);
+
+  /* Override the stack size.  */
+  if (override_stack_size)
+    if (!bfd_m68kmint_set_stack_size (link_info.output_bfd, stack_size))
+      einfo (_("%F%P:%B: unable to set the stack size\n"), link_info.output_bfd);
+
+  /* Generate TPA relocation entries for the data statements.  */
+  lang_for_each_statement (gld${EMULATION_NAME}_add_tpa_relocs);
+}
+
+EOF
+
+# Put these extra routines in ld_${EMULATION_NAME}_emulation
+#
+LDEMUL_ADD_OPTIONS=gld${EMULATION_NAME}_add_options
+LDEMUL_HANDLE_OPTION=gld${EMULATION_NAME}_handle_option
+LDEMUL_LIST_OPTIONS=gld_${EMULATION_NAME}_list_options
+LDEMUL_FINISH=gld${EMULATION_NAME}_finish
diff --git a/ld/ldfile.c b/ld/ldfile.c
index 411f7ddf97..6eb0fdd76a 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -341,7 +341,10 @@ ldfile_open_file_search (const char *arch,
     {
       if (entry->flags.sysrooted && IS_ABSOLUTE_PATH (entry->filename))
 	{
-	  char *name = concat (ld_sysroot, entry->filename,
+	  char *name;
+	  if (strncmp(ld_sysroot, entry->filename, strlen(ld_sysroot)) == 0 && ldfile_try_open_bfd (entry->filename, entry))
+	return TRUE;
+	  name = concat (ld_sysroot, entry->filename,
 			       (const char *) NULL);
 	  if (ldfile_try_open_bfd (name, entry))
 	    {
diff --git a/ld/scripttempl/m68kmint.sc b/ld/scripttempl/m68kmint.sc
new file mode 100644
index 0000000000..a0aa896b28
--- /dev/null
+++ b/ld/scripttempl/m68kmint.sc
@@ -0,0 +1,47 @@
+# Copyright (C) 2014-2017 Free Software Foundation, Inc.
+#
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+#
+cat <<EOF
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+   Copying and distribution of this script, with or without modification,
+   are permitted in any medium without royalty provided the copyright
+   notice and this notice are preserved.  */
+
+${RELOCATING+OUTPUT_FORMAT(${OUTPUT_FORMAT})}
+${RELOCATING-OUTPUT_FORMAT(${RELOCATEABLE_OUTPUT_FORMAT})}
+${RELOCATING+${LIB_SEARCH_DIRS}}
+SECTIONS
+{
+  ${RELOCATING+/* The VMA of the .text section is ${TEXT_START_ADDR} instead of 0
+     because the extended MiNT header is just before,
+     at the beginning of the TEXT segment.  */}
+  .text ${RELOCATING+${TEXT_START_ADDR}}:
+  {
+    CREATE_OBJECT_SYMBOLS
+    *(.text)
+    ${CONSTRUCTING+CONSTRUCTORS}
+    ${RELOCATING+_etext = .;}
+    ${RELOCATING+__etext = .;}
+  }
+
+  .data :
+  {
+    *(.data)
+    ${RELOCATING+_edata = .;}
+    ${RELOCATING+__edata = .;}
+  }
+
+  .bss :
+  {
+    ${RELOCATING+__bss_start = .;}
+    *(.bss)
+    *(COMMON)
+    ${RELOCATING+_end = .;}
+    ${RELOCATING+__end = .;}
+  }
+}
+EOF
diff --git a/ld/scripttempl/m68kmintelf.sc b/ld/scripttempl/m68kmintelf.sc
new file mode 100644
index 0000000000..e47e0fbc68
--- /dev/null
+++ b/ld/scripttempl/m68kmintelf.sc
@@ -0,0 +1,82 @@
+# Copyright (C) 2014-2017 Free Software Foundation, Inc.
+#
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+#
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#  .lrodata	.gnu.linkonce.lr.foo
+#  .ldata	.gnu.linkonce.l.foo
+#  .lbss	.gnu.linkonce.lb.foo
+#
+cat <<EOF
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+   Copying and distribution of this script, with or without modification,
+   are permitted in any medium without royalty provided the copyright
+   notice and this notice are preserved.  */
+
+${RELOCATING+OUTPUT_FORMAT(${OUTPUT_FORMAT})}
+${RELOCATING-OUTPUT_FORMAT(${RELOCATEABLE_OUTPUT_FORMAT})}
+${RELOCATING+${LIB_SEARCH_DIRS}}
+SECTIONS
+{
+  ${RELOCATING+/* The VMA of the .text section is ${TEXT_START_ADDR} instead of 0
+     because the extended MiNT header is just before,
+     at the beginning of the TEXT segment.  */}
+  .text ${RELOCATING+${TEXT_START_ADDR}}: SUBALIGN(2)
+  {
+    CREATE_OBJECT_SYMBOLS
+    *(.text .text.* .gnu.linkonce.t.*)
+    *(.rodata .rodata.* .gnu.linkonce.r.*) /* Only present in ELF objects */
+    *(.eh_frame*)
+    *(.gcc_except_table*)
+    ${RELOCATING+ *(.ctors)}
+    ${RELOCATING+ *(.dtors)}
+    ${CONSTRUCTING+CONSTRUCTORS}
+    ${RELOCATING+etext = .;}
+    ${RELOCATING+_etext = .;}
+  }
+
+  .data : SUBALIGN(2)
+  {
+    *(.data .data.* .gnu.linkonce.d.* .gnu.linkonce.s.* .gnu.linkonce.s2.*)
+    ${RELOCATING+edata = .;}
+    ${RELOCATING+_edata = .;}
+  }
+
+  .bss :
+  {
+    ${RELOCATING+_bss_start = .;}
+    *(.bss .bss.* .gnu.linkonce.b.* .gnu.linkonce.sb.* .gnu.linkonce.sb2.*)
+    *(COMMON)
+    ${RELOCATING+end = .;}
+    ${RELOCATING+_end = .;}
+  }
+
+  /* Unfortunately, stabs are not mappable from ELF to a.out.
+     It can probably be fixed with some amount of work.  */
+  /DISCARD/ :
+  { *(.stab) *(.stab*) *(.debug) *(.debug*) *(.comment) *(.gnu.warning.*) }
+
+}
+EOF
diff --git a/libctf/ctf-archive.c b/libctf/ctf-archive.c
index 73d772ffc3..be0a79bf5a 100644
--- a/libctf/ctf-archive.c
+++ b/libctf/ctf-archive.c
@@ -44,6 +44,10 @@ static int arc_mmap_writeout (int fd, void *header, size_t headersz,
 			      const char **errmsg);
 static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);
 
+#if defined(__MINT__) || defined(__clang__)
+#define __thread
+#endif
+
 /* bsearch() internal state.  */
 static __thread char *search_nametbl;
 
diff --git a/libiberty/dyn-string.c b/libiberty/dyn-string.c
index e10f691181..bf155effb5 100644
--- a/libiberty/dyn-string.c
+++ b/libiberty/dyn-string.c
@@ -277,7 +277,7 @@ dyn_string_insert_cstr (dyn_string_t dest, int pos, const char *src)
   for (i = dest->length; i >= pos; --i)
     dest->s[i + length] = dest->s[i];
   /* Splice in the new stuff.  */
-  strncpy (dest->s + pos, src, length);
+  memcpy (dest->s + pos, src, length);
   /* Compute the new length.  */
   dest->length += length;
   return 1;
diff --git a/libiberty/hex.c b/libiberty/hex.c
index f2b57e3b81..b2dc3ecd23 100644
--- a/libiberty/hex.c
+++ b/libiberty/hex.c
@@ -24,7 +24,7 @@ Boston, MA 02110-1301, USA.  */
 #include "libiberty.h"
 #include "safe-ctype.h" /* for HOST_CHARSET_ASCII */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "hex.c requires EOF == -1"
 #endif
 
diff --git a/libiberty/safe-ctype.c b/libiberty/safe-ctype.c
index 56364e6ecd..7704f46e04 100644
--- a/libiberty/safe-ctype.c
+++ b/libiberty/safe-ctype.c
@@ -118,7 +118,7 @@ sets of characters:
 #include <safe-ctype.h>
 #include <stdio.h>  /* for EOF */
 
-#if EOF != -1
+#if !(EOF == -1)	/* gcc 2.95.3 has bug in '!=' operator for negative constants */
  #error "<safe-ctype.h> requires EOF == -1"
 #endif
 
