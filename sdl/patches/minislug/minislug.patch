diff -rupN minislug.orig/Makefile minislug.new/Makefile
--- minislug.orig/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ minislug.new/Makefile	2023-12-09 14:50:57.667683648 +0100
@@ -0,0 +1,4 @@
+SUBDIRS = minislug0 config0 exechk0 edtile0 psdprot0
+
+all clean::
+	for i in $(SUBDIRS); do $(MAKE) -C $$i $@ || exit $@; done
diff -rupN minislug.orig/config0/Makefile minislug.new/config0/Makefile
--- minislug.orig/config0/Makefile	2016-09-27 10:57:29.000000000 +0200
+++ minislug.new/config0/Makefile	2023-12-10 07:10:44.778526630 +0100
@@ -1,18 +1,19 @@
 # Mon Makefile
-#PATH = /usr/include/SDL
-TARGET = config 
+TARGET = config
 OBJECTS = main.o font.o 
 
-CFLAGS = -O3 -Wall -g -I/usr/include/SDL -L/usr/lib -fno-strict-aliasing -s 
-LIBS = -lSDL
-#LIBS = -lSDL -lSDL_image
-CC = gcc
+SDL_CFLAGS := $(shell pkg-config --cflags sdl)
+SDL_LIBS := $(shell pkg-config --libs sdl)
+CFLAGS = $(CPU_CFLAGS) -O2 -fomit-frame-pointer -Wall $(SDL_CFLAGS) -fno-strict-aliasing
+LDFLAGS = -s
+LIBS = $(SDL_LIBS)
+CC = $(CROSS_PREFIX)gcc
 
 all: $(TARGET)
 
 $(TARGET): $(OBJECTS)
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS) 
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) 
 
 clean:
-	rm $(TARGET) $(OBJECTS)
+	rm -f $(TARGET) $(OBJECTS)
 
Binary files minislug.orig/config0/config and minislug.new/config0/config differ
Binary files minislug.orig/config0/font.o and minislug.new/config0/font.o differ
diff -rupN minislug.orig/config0/main.c minislug.new/config0/main.c
--- minislug.orig/config0/main.c	2012-09-02 12:16:33.000000000 +0200
+++ minislug.new/config0/main.c	2023-12-10 03:41:50.226967185 +0100
@@ -25,7 +25,7 @@ enum
 };
 
 #pragma pack(1)
-struct SMSCfg
+__attribute__((packed)) struct SMSCfg
 {
 	u16	pKeys[e_CfgKey_MAX];
 	u16	nVideoMode;			// 0 = 320x224 / 1 = x2 / 2 = TV2x.
Binary files minislug.orig/config0/main.o and minislug.new/config0/main.o differ
Binary files minislug.orig/edtile0/EdTile1 and minislug.new/edtile0/EdTile1 differ
diff -rupN minislug.orig/edtile0/Makefile minislug.new/edtile0/Makefile
--- minislug.orig/edtile0/Makefile	2013-07-16 16:36:08.000000000 +0200
+++ minislug.new/edtile0/Makefile	2023-12-10 07:10:44.778526630 +0100
@@ -2,16 +2,18 @@
 TARGET = EdTile1 
 OBJECTS = main.o font.o infobox.o keyboard.o mouse.o plane.o psd.o map.o cmd.o file.o visu.o undo.o
 
-#CFLAGS = -O3 -Wall -Wno-write-strings -g -I/usr/include/SDL -L/usr/lib		# debug
-CFLAGS = -O3 -Wall -Wno-write-strings -s -I/usr/include/SDL -L/usr/lib  
-LIBS = -lSDL
-CPP = gcc
+SDL_CFLAGS := $(shell pkg-config --cflags sdl)
+SDL_LIBS := $(shell pkg-config --libs sdl)
+CFLAGS = $(CPU_CFLAGS) -O2 -fomit-frame-pointer -Wall $(SDL_CFLAGS) -fno-strict-aliasing
+LDFLAGS = -s
+LIBS = $(SDL_LIBS)
+CC = $(CROSS_PREFIX)gcc
 
 all: $(TARGET)
 
 $(TARGET): $(OBJECTS)
-	$(CPP) $(CFLAGS) -o $@ $^ $(LIBS) 
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) 
 
 clean:
-	rm $(TARGET) $(OBJECTS)
+	rm -f $(TARGET) $(OBJECTS)
 
diff -rupN minislug.orig/edtile0/_FILE_FORMAT.txt minislug.new/edtile0/_FILE_FORMAT.txt
--- minislug.orig/edtile0/_FILE_FORMAT.txt	2011-11-02 14:20:00.000000000 +0100
+++ minislug.new/edtile0/_FILE_FORMAT.txt	2023-12-09 18:52:45.694572942 +0100
@@ -1,16 +1,16 @@
 
-* Format de fichier EDT :
+* EDT File format :
 
-3B : Header : "EDT"
-2B : Version du fichier : 0x0100
+3Bytes : Header : "EDT"
+2Bytes : File version : 0x0100
 
-Ensuite, ce sont des containers.
+Then, there are containers.
 
 
-* Chaque container à un header de la forme suivante :
+* Each container has a header of the following form :
 
 #pragma pack(1)
-// Header de chaque container.
+// Header of each container.
 struct SContainer0
 {
 	u32	nSz;
@@ -19,28 +19,28 @@ struct SContainer0
 };
 #pragma pack()
 
-- nSz contient la taille totale bu bloc : taille de la struct SContainer0 + taille des datas derrière.
-=> Pour passer au container suivant, il faut skipper nSz bytes.
+- nSz contains the total size of the block: size of the SContainer0 struct + size of the data behind it.
+=> To move on to the next container, you must skip nSz bytes.
 
-- nType peut prendre les valeurs suivantes :
-	e_FileSection_Map	> Infos de la map.
-	e_FileSection_Plane	> Datas d'un plan.
-	e_FileSection_Cmd	> Datas des monstres d'un plan.
-	e_FileSection_Misc	> Infos diverses.
+- nType can take the following values :
+	e_FileSection_Map	> Map info.
+	e_FileSection_Plane	> Data of a plane.
+	e_FileSection_Cmd	> Monster data of a plane.
+	e_FileSection_Misc	> Miscellaneous information.
 
 
 
 * e_FileSection_Map :
 
- Pour stocker les infos générales de la map : Nb de plans, hauteur, largeur...
+ To store general information about the map: Number of planes, height, width, etc.
 
- Il y doit y avoir un (et un seul) enregistrement de ce type.
- On doit le trouver avant les containers de type e_FileSection_Plane.
+ There must be one (and only one) such record.
+ We must find it before containers of type e_FileSection_Plane.
 
- Après le header, on trouve les données suivantes :
+ After the header, we find the following data:
 
 #pragma pack(1)
-// Struct pour datas de la map.
+// Struct for map data.
 struct SMap0
 {
 	u32	nMapLg, nMapHt, nMapPosX, nMapPosY, nPlanesNb, nFirstWnd, nActivePlane;
@@ -51,89 +51,89 @@ struct SMap0
 
 * e_FileSection_Plane :
 
- Pour stocker un plan (n°s des blocs utilisés).
+ To store a plane (numbers of blocks used).
 
- Après le header, on trouve les données suivantes :
+ After the header, we find the following data :
 
 #pragma pack(1)
-// Struct pour datas d'un plan.
+// Struct for plane data.
 struct SPlane2
 {
 	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
-	u32	nBlkLg, nBlkHt;			// Largeur et hauteur du plan en blocs 16. Pour éventuel remap à la relecture.
-	u8	nHasCmd;				// Sera surtout utile à la lecture par le jeu, pour skipper le plan et récupérer les monstres dans la section suivante.
+	u32	nBlkLg, nBlkHt;		// Width and height of the plan in blocks 16. For possible remap upon rereading.
+	u8	nHasCmd;		// Will be especially useful for reading through the game, to skip the plan and recover the monsters in the following section.
 	u8	nPad0, nPad1, nPad2;	// Padding.
 };
 #pragma pack()
 
- Les plans doivent être stockés dans l'ordre ! (Il peut y avoir des containers entre, notament
-de type e_FileSection_Cmd).
+Planes must be stored in order! (There may be containers between, notably
+of type e_FileSection_Cmd).
 
- Ensuite :
-1B : Nb d'octets du nom de fichier graphique.
-xB : Le nom de fichier graphique du plan, sans 0 terminal.
-
- Puis, s'il y en a les codes des blocs (u8) :
-(PlanLg * PlanHt)B : Les codes de chaque bloc de la planche.
- Pour savoir s'il y en a, on force le bit 'e_FlgFile_Plane_Codes' dans 'nFlags' de SPlane2 à l'écriture.
- Attention, à l'écriture, la taille du plan est celle de la planche.
- A la lecture, il faut absolument utiliser nBlkLg et nBlkHt de SPlane2, car la taille de la planche peut avoir changé.
+ Afterwards :
+1Byte  : Number of bytes of the graphic file name.
+xBytes : The graphic file name of the plane, without terminating 0.
+
+ Then, if there are any block codes (u8) :
+(PlanLg * PlanHt)B : The codes for each block of the board.
+ To find out if there are any, we force the 'e_FlgFile_Plane_Codes' bit in 'nFlags' of SPlane2 to be written.
+ Be careful, when writing, the size of the plane is that of the board.
+ When reading, you absolutely must use nBlkLg and nBlkHt from SPlane2, because the size of the board may have changed.
 
- Et enfin :
-(MapLg * MapHt)L : Le plan en lui même.
+ And finally :
+(MapLg * MapHt)L : The plane itself.
 
 
 
 * e_FileSection_Cmd :
 
- Pour stocker tout ce qui concerne les monstres d'un plan.
+ To store everything related to the monsters of a plane.
 
- Quand on tombe sur ce container, ça veut dire qu'il faut ajouter un fichier de commandes au dernier
-plan ajouté.
+ When we come across this container, it means that we must add a command file to the last one
+plan added.
 
- Après le header, on trouve les données suivantes concernant le fichier de commandes, sauvegardé
-dans le EDT (desfois qu'il disparaisse, qu'il change...) :
+ After the header, we find the following data concerning the saved command file
+in the EDT (sometimes it disappears, changes...) :
 
-// u8 : Nb de bytes du nom de fichier.
-// char * x : Nom de fichier, sans 0 terminal.
-// u32 : Date du fichier.
-// u32 : Nb de bytes dans le fichier de commandes.
-// char * x : Le fichier de commandes, sans 0 terminal.
+// u8 : Number of bytes of file namer.
+// char * x : Nom de fichier, File name, without terminating 0.
+// u32 : File date.
+// u32 : Number of bytes in the command file.
+// char * x : The batch file, without terminating 0.
 
- Puis les datas des monstres :
+ Then the monster data :
 
-// u32 : Nb de monstres.
-// xB : Datas des monstres, les uns à la suite des autres : SMst0 + x bytes de data.
+// u32 : Number of monsters.
+// xB : Monster data, one after the other: SMst0 + x bytes of data.
 
 #pragma pack(1)
-// Struct pour lecture/sauvegarde d'un monstre.
+// Struct for reading/saving a monster.
 struct SMst0
 {
 	u32	nPosX, nPosY;
-	u16	nMstNo;		// = No du bloc.
-	u16	nNbBytes;	// Nb de bytes utilisés.
+	u16	nMstNo;		// = Block no.
+	u16	nNbBytes;	// Number of bytes used.
 };
 #pragma pack()
-... suivi de nNbBytes octets, pour chaque monstre.
+... followed by nNbBytes bytes, for each monster..
 
 
 
 * e_FileSection_Misc :
 
- Pour stocker des données diverses.
+ To store various data.
 
- Après le header, on trouve les données suivantes :
+ After the header, we find the following data:
 
 #pragma pack(1)
-// Struct pour datas misc.
+// Struct for misc data.
 struct SMisc0
 {
-	u32	nFlags;						// gMisc.nFlags.
-	u8	nTransR, nTransG, nTransB;	// RGB de la couleur de transparence.
-	u8	nPad0;						// Padding.
-	u16	nVisuLg, nVisuHt;			// Taille de la visu (en pixels).
+	u32	nFlags;				// gMisc.nFlags.
+	u8	nTransR, nTransG, nTransB;	// RGB of the transparency color.
+	u8	nPad0;				// Padding.
+	u16	nVisuLg, nVisuHt;		// Size of the view (in pixels).
 
-	u32	nBlank0, nBlank1, nBlank2, nBlank3, nBlank4;	// Au cas ou on ait besoin de sauver plus de trucs par la suite.
+	u32	nBlank0, nBlank1, nBlank2, nBlank3, nBlank4;	// In case we need to save more stuff later.
 };
 #pragma pack()
 
diff -rupN minislug.orig/edtile0/cmd.c minislug.new/edtile0/cmd.c
--- minislug.orig/edtile0/cmd.c	2013-07-22 14:14:18.000000000 +0200
+++ minislug.new/edtile0/cmd.c	2023-12-09 15:09:15.202849166 +0100
@@ -131,6 +131,7 @@ void Cmdfile_CmdFileExport(struct SCmdfi
 
 	// Ecriture.
 	nSz = fwrite(psCmdfile->pCmdfile, 1, strlen(psCmdfile->pCmdfile), fPt);
+	(void)nSz;
 	fclose(fPt);
 
 	// Date du fichier (update de la date de notre fichier, pour ne pas faire un update à la prochaine lecture).
Binary files minislug.orig/edtile0/cmd.o and minislug.new/edtile0/cmd.o differ
diff -rupN minislug.orig/edtile0/file.c minislug.new/edtile0/file.c
--- minislug.orig/edtile0/file.c	2013-07-22 15:49:54.000000000 +0200
+++ minislug.new/edtile0/file.c	2023-12-10 07:05:25.892319594 +0100
@@ -38,7 +38,7 @@ char * File_FilenameGet(struct SFile *ps
 #pragma pack(1)
 
 // Header de chaque container.
-struct SContainer0
+__attribute__((packed)) struct SContainer0
 {
 	u32	nSz;
 	u16	nType;
@@ -46,27 +46,27 @@ struct SContainer0
 };
 
 // Struct pour datas de la map.
-struct SMap0
+__attribute__((packed)) struct SMap0
 {
 	u32	nMapLg, nMapHt, nMapPosX, nMapPosY, nPlanesNb, nFirstWnd, nActivePlane;
 };
 
 // Struct pour datas d'un plan.
 /*
-struct SPlane0
+__attribute__((packed)) struct SPlane0
 {
 	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
 };
 */
 /*
-struct SPlane1
+__attribute__((packed)) struct SPlane1
 {
 	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
 	u8	nHasCmd;				// Sera surtout utile à la lecture par le jeu, pour skipper le plan et récupérer les monstres dans la section suivante.
 	u8	nPad0, nPad1, nPad2;	// Padding.
 };
 */
-struct SPlane2
+__attribute__((packed)) struct SPlane2
 {
 	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
 	u32	nBlkLg, nBlkHt;			// Largeur et hauteur du plan en blocs 16. Pour éventuel remap à la relecture.
@@ -75,7 +75,7 @@ struct SPlane2
 };
 
 // Struct pour datas misc. (Hum, corrigée et paddée correctement pour pack).
-struct SMisc0
+__attribute__((packed)) struct SMisc0
 {
 	u32	nFlags;						// gMisc.nFlags.
 	u8	nTransR, nTransG, nTransB;	// RGB de la couleur de transparence.
@@ -143,14 +143,15 @@ void File_Load(struct SFile *psFile)
 	{
 		fprintf(stderr, "File_Load(): Checksum error: Loaded = %08X / Calculated = %08X. Attempting to read file anyway.\n", nChecksum1, nChecksum0);
 
-		static	char	*pMsgTitle = "Load error";
+	#if defined(_WIN32)
 		char	pMsgStr[256];
-	#ifdef WIN32
+		static	char const pMsgTitle[] = "Load error";
 		sprintf(pMsgStr, "Checksum error:\nLoaded = %08X / Calculated = %08X.", nChecksum1, nChecksum0);
 		MessageBox(NULL, pMsgStr, pMsgTitle, MB_OK);
-	#endif
-	#ifdef __LINUX__
+	#elif defined( __linux__)
 // !!! A tester !!!
+		char	pMsgStr[256];
+		static	char const pMsgTitle[] = "Load error";
 		// Avec xmessage.
 		sprintf(pMsgStr, "xmessage -center \"*** %s ***\n\nChecksum error:\nLoaded = %08X / Calculated = %08X.\" -button OK", pMsgTitle, nChecksum1, nChecksum0);
 		system(pMsgStr);
diff -rupN minislug.orig/edtile0/file.h minislug.new/edtile0/file.h
--- minislug.orig/edtile0/file.h	2013-07-12 14:44:32.000000000 +0200
+++ minislug.new/edtile0/file.h	2023-12-10 04:33:38.902232106 +0100
@@ -2,7 +2,7 @@
 
 // Struct pour lecture/sauvegarde d'un monstre.
 #pragma pack(1)
-struct SMst0
+__attribute__((packed)) struct SMst0
 {
 	u32	nPosX, nPosY;
 	u16	nMstNo;		// = No du bloc.
Binary files minislug.orig/edtile0/file.o and minislug.new/edtile0/file.o differ
Binary files minislug.orig/edtile0/font.o and minislug.new/edtile0/font.o differ
diff -rupN minislug.orig/edtile0/includes.h minislug.new/edtile0/includes.h
--- minislug.orig/edtile0/includes.h	2013-07-24 13:48:20.000000000 +0200
+++ minislug.new/edtile0/includes.h	2023-12-09 19:53:22.849680712 +0100
@@ -5,15 +5,12 @@
 #include "SDL.h"
 #include <sys/stat.h>
 
-#ifdef __LINUX__
-	#include <stdlib.h>
-	#include <strings.h>
-	#include <sys/types.h>
-	#include <dirent.h>
-	#include <errno.h>
-#endif
-#ifdef WIN32
-//	#include <cstdlib>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+#ifdef _WIN32
 	#include <windows.h>
 #endif
 
Binary files minislug.orig/edtile0/infobox.o and minislug.new/edtile0/infobox.o differ
diff -rupN minislug.orig/edtile0/keyboard.c minislug.new/edtile0/keyboard.c
--- minislug.orig/edtile0/keyboard.c	2013-07-22 15:09:30.000000000 +0200
+++ minislug.new/edtile0/keyboard.c	2023-12-09 19:58:34.392618155 +0100
@@ -301,16 +301,12 @@ RMB: Cut/release brush.\n\
 \n\
 ";
 		psKbd->pKeys[SDLK_F1] = 0;
-#ifdef WIN32
+#if defined(_WIN32)
 		MessageBox(NULL, pHelpStr, pHelpTitle, MB_OK);
-#endif
-#ifdef __LINUX__
-//		// Avec printf.
-//		printf("*** %s ***\n", pHelpTitle);
-//		printf(pHelpStr);
+#elif defined(__linux__)
 
 		// Avec xmessage.
-		static	const char	*pCmdStr = "xmessage -center \"*** %s ***\n\n%s\" -button OK";
+		static char const pCmdStr[] = "xmessage -center \"*** %s ***\n\n%s\" -button OK";
 		char *pCmdLn;
 
 		if ((pCmdLn = (char *)malloc(strlen(pCmdStr) + strlen(pHelpTitle) + strlen(pHelpStr))) != NULL)
@@ -320,6 +316,10 @@ RMB: Cut/release brush.\n\
 			free(pCmdLn);
 			nUpdateDisp |= e_Update_All;
 		}
+#else
+		// Avec printf.
+		printf("*** %s ***\n", pHelpTitle);
+		printf("%s\n", pHelpStr);
 #endif
 	}
 
Binary files minislug.orig/edtile0/keyboard.o and minislug.new/edtile0/keyboard.o differ
diff -rupN minislug.orig/edtile0/main.c minislug.new/edtile0/main.c
--- minislug.orig/edtile0/main.c	2013-08-18 17:41:15.000000000 +0200
+++ minislug.new/edtile0/main.c	2023-12-10 06:57:15.046358992 +0100
@@ -151,8 +151,8 @@ enum
 s32 MyMsgBoxYesNo(const char *pStr, const char *pTitle)
 {
 	s32	nRetVal = e_MsgBoxCancel;
+#ifdef _WIN32
 	int	nRet;
-#ifdef WIN32
 	nRet = MessageBox(NULL, pStr, pTitle, MB_YESNOCANCEL | MB_ICONSTOP);
 	switch (nRet)
 	{
@@ -166,9 +166,10 @@ s32 MyMsgBoxYesNo(const char *pStr, cons
 		break;
 	}
 #endif
-#ifdef __LINUX__
+#ifdef __linux__
 	static	const char	*pCmdStr = "xmessage -center \"*** %s ***\n\n%s\" -button Yes,No,Cancel";
 	char *pCmdLn;
+	int	nRet;
 
 	if ((pCmdLn = (char *)malloc(strlen(pCmdStr) + strlen(pStr) + strlen(pTitle))) != NULL)
 	{
@@ -371,7 +372,7 @@ void Sub_GetArgInt(char **ppStr, u32 *pn
 // Recherche un fichier .EDT dans le répertoire courant.
 char * LookForEDT(void)
 {
-#ifdef __LINUX__
+#ifndef _WIN32
 	DIR	*dip;
 	struct dirent	*dit;
 
@@ -386,7 +387,9 @@ char * LookForEDT(void)
 	while ((dit = readdir(dip)) != NULL)
 	{
 		// Est-ce un fichier normal ?
+#ifdef DT_REG
 		if (dit->d_type == DT_REG)
+#endif
 		{
 			if (strlen(dit->d_name) > 4)
 			if (strcmp(&dit->d_name[strlen(dit->d_name) - 4], ".edt") == 0)
@@ -408,7 +411,7 @@ char * LookForEDT(void)
 	return (gFont.pString);
 #endif
 
-#ifdef WIN32
+#ifdef _WIN32
 	const char	*pRechFiles = "*.edt";
 	HANDLE	hFind;
 	WIN32_FIND_DATA	ffd;
@@ -493,7 +496,7 @@ u32 CheckCommandLine(int nArgc, char **p
 		printf("Read file.\n");
 		File_Load(&gFile);
 	}
-
+	(void)nNewFile;
 
 	// Passe 2 : Traitement des args.
 	u32	nPlaneNo;
@@ -756,20 +759,6 @@ u32 CheckCommandLine(int nArgc, char **p
 	return (0);
 }
 
-/*
-test peu concluant
-
-#ifdef __LINUX__
-#define	STD_OUTPUT	"/dev/tty"
-#endif
-#ifdef WIN32
-#define	STD_OUTPUT	"CON"
-#endif
-
-//	freopen(STD_OUTPUT, "w", stdout);
-//	freopen(STD_OUTPUT, "w", stderr);
-*/
-
 //=============================================================================
 
 // Main.
Binary files minislug.orig/edtile0/main.o and minislug.new/edtile0/main.o differ
Binary files minislug.orig/edtile0/map.o and minislug.new/edtile0/map.o differ
Binary files minislug.orig/edtile0/mouse.o and minislug.new/edtile0/mouse.o differ
diff -rupN minislug.orig/edtile0/plane.c minislug.new/edtile0/plane.c
--- minislug.orig/edtile0/plane.c	2013-07-24 14:33:04.000000000 +0200
+++ minislug.new/edtile0/plane.c	2023-12-10 06:59:03.086203939 +0100
@@ -9,14 +9,6 @@ void Plane_MstPlaneLineInsert(struct SPl
 void Plane_MstPlaneLineDelete(struct SPlane *psPlane, u32 nLin);
 
 
-#ifdef __LINUX__
-// stricmp n'existe pas en Linux : C'est strcasecmp à la place, dans strings.h.
-int stricmp(char *pStr1, char *pStr2)
-{
-	return (strcasecmp(pStr1, pStr2));
-}
-#endif
-
 // Constructeur.
 struct SPlane * Plane_New(void)
 {
@@ -75,7 +67,7 @@ void Plane_Delete(struct SPlane *psPlane
 	free(psPlane);
 }
 
-typedef struct SPSDPicture * (*pLoadingFct)(char *);
+typedef struct SPSDPicture * (*pLoadingFct)(const char *);
 // Initialisation du plan.
 void Plane_PlaneInit(struct SPlane *psPlane, char *pFilename)
 {
@@ -90,7 +82,7 @@ void Plane_PlaneInit(struct SPlane *psPl
 	strcpy(psPlane->pPlnFilename, pFilename);
 
 	// On regarde l'extension du fichier graphique.
-	if (stricmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
+	if (strcasecmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
 	{
 		// Lecture du BMP.
 		psPlane->pGfx = SDL_LoadBMP(pFilename);
@@ -100,12 +92,12 @@ void Plane_PlaneInit(struct SPlane *psPl
 		}
 	}
 	else
-	if (stricmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
+	if (strcasecmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
 	{
 		pfFct = PSDLoad;
 	}
 	else
-	if (stricmp(pFilename + strlen(pFilename) - 3, "xcf") == 0)
+	if (strcasecmp(pFilename + strlen(pFilename) - 3, "xcf") == 0)
 	{
 		pfFct = XCFLoad;
 	}
Binary files minislug.orig/edtile0/plane.o and minislug.new/edtile0/plane.o differ
diff -rupN minislug.orig/edtile0/psd.c minislug.new/edtile0/psd.c
--- minislug.orig/edtile0/psd.c	2013-07-24 14:17:03.000000000 +0200
+++ minislug.new/edtile0/psd.c	2023-12-10 06:34:31.118318417 +0100
@@ -5,46 +5,28 @@
 
 //=============================================================================
 
-// Lecture d'un u16 au format Big Endian.
-u32	ReadBigEndianU16(u8 *pPtr)
-{
-	u32	nVar;
-	nVar = (pPtr[0] << 8) | pPtr[1];
-	return (nVar);
-}
-
-// Lecture d'un u32 au format Big Endian.
-u32	ReadBigEndianU32(u8 *pPtr)
-{
-	u32	nVar;
-	nVar = (pPtr[0] << 24) | (pPtr[1] << 16) | (pPtr[2] << 8) | pPtr[3];
-	return (nVar);
-}
-
-//=============================================================================
-
 // Déprotège un fichier PSD si nécessaire.
-void PSD_Unprotect(u8 *pBuf)
+static void PSD_Unprotect(u8 *pBuf)
 {
 	char	pNorm[4] = { '8'^0x80,'B'^0x81,'P'^0x82,'S'^0x83 };		// Avec un xor pour masquer la chaîne dans l'exe.
 	char	pProt[4] = { '8'^0x80,'b'^0x81,'p'^0x82,'s'^0x83 };
 	u32	i;
 	u8	nVar8;
 
-	// Enlève le masque.
+	// Take off the mask.
 	for (i = 0; i < 4; i++)
 	{
 		pNorm[i] ^= 0x80 + i;
 		pProt[i] ^= 0x80 + i;
 	}
-	// Comparaison.
+	// Comparison.
 	if (strncmp((char *)pBuf, pProt, 4) != 0) return;
 
-	// ** Le fichier est protégé, on retire la protection.
+	// ** The file is protected, we remove the protection.
 
-	// 4 premiers octets.
-	strncpy((char *)pBuf, pNorm, 4);
-	// Remise en ordre des valeurs H et W.
+	// First 4 bytes.
+	memcpy((char *)pBuf, pNorm, 4);
+	// Reordering of H and W values.
 	nVar8 = *(((u8 *)pBuf) + 21) ^ 0x82;
 	*(((u8 *)pBuf) + 21) = *(((u8 *)pBuf) + 16) ^ 0x14;
 	*(((u8 *)pBuf) + 16) = nVar8;
@@ -57,8 +39,28 @@ void PSD_Unprotect(u8 *pBuf)
 
 //=============================================================================
 
+// Lecture d'un u16 au format Big Endian.
+static u32	ReadBigEndianU16(u8 *pPtr)
+{
+	u32	nVar;
+	nVar = (pPtr[0] << 8) | pPtr[1];
+	return (nVar);
+}
+
+// Lecture d'un u32 au format Big Endian.
+static u32	ReadBigEndianU32(u8 *pPtr)
+{
+	u32	nVar;
+	nVar = (pPtr[0] << 24) | (pPtr[1] << 16) | (pPtr[2] << 8) | pPtr[3];
+	return (nVar);
+}
+
+//=============================================================================
+
+//#define	DEBUG_INFO	1	// Commenter pour supprimer.
+
 // PSD loader.
-struct SPSDPicture * PSDLoad(char *pPSDFilename)
+struct SPSDPicture * PSDLoad(const char *pPSDFilename)
 {
 	FILE	*fPt = NULL;
 	u8	*pBuf = NULL;
@@ -146,22 +148,30 @@ struct SPSDPicture * PSDLoad(char *pPSDF
 	// Depth (2 bytes)
 	nDepth = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Depth: %d\n", (int)nDepth);
+#ifdef DEBUG_INFO
+	printf("Depth: %d\n", (int)nDepth);
+#endif
 	// Mode (2 bytes)
 	// 2 = Indexed colors.
 	nMode = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Mode: %d\n", (int)nMode);
+#ifdef DEBUG_INFO
+	printf("Mode: %d\n", (int)nMode);
+#endif
 	// Depth et Mode ok ?
 	if (nDepth != 8 || nMode != 2)
 		{ fprintf(stderr, "PSDLoad(): Unsupported format. Depth = %d, Mode = %d\n", (int)nDepth, (int)nMode); goto _PSDErr; }
 
 	// Color mode data section. Pour le mode "2", toujours 768 bytes, non entremélés => 256 R, 256 G, 256 B.
-//	printf("\nColor mode data section\n");
+#ifdef DEBUG_INFO
+	printf("\nColor mode data section\n");
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pSection = pPtr + 4;
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 	//> Palette.
 	if (nTmp != 768)
 		{ fprintf(stderr, "PSDLoad(): Palette size != 768 (%d)\n", (int)nTmp); goto _PSDErr; }
@@ -170,30 +180,44 @@ struct SPSDPicture * PSDLoad(char *pPSDF
 		pPic->pColors[i].r = *(pSection + i);
 		pPic->pColors[i].g = *(pSection + 256 + i);
 		pPic->pColors[i].b = *(pSection + 512 + i);
-//		printf("Color %d : R = %d - G = %d - B = %d\n", (int)i, (int)*(pSection + i), (int)*(pSection + 256 + i), (int)*(pSection + 512 + i));
+#ifdef DEBUG_INFO
+		printf("Color %d : R = %d - G = %d - B = %d\n", (int)i, (int)*(pSection + i), (int)*(pSection + 256 + i), (int)*(pSection + 512 + i));
+#endif
 	}
 	//<
 
 
 	// Image ressources section. (On skippe).
-//	printf("\nImage ressources section\n");
+#ifdef DEBUG_INFO
+	printf("\nImage ressources section\n");
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 
 	// Layer and mask information section. (On skippe).
-//	printf("\nLayer and mask information section\n");
-//printf("Offs = %x\n", (int)(pPtr - pBuf));
+#ifdef DEBUG_INFO
+	printf("\nLayer and mask information section\n");
+	printf("Offs = %x\n", (int)(pPtr - pBuf));
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 
 	// Image data section.
-//	printf("\nImage data section\n");
-//printf("Offs = %x\n", (int)(pPtr - pBuf));
+#ifdef DEBUG_INFO
+	printf("\nImage data section\n");
+	printf("Offs = %x\n", (int)(pPtr - pBuf));
+#endif
 	nComp = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Compression method: %d\n", (int)nComp);
+#ifdef DEBUG_INFO
+	printf("Compression method: %d\n", (int)nComp);
+#endif
 
 
 /*
@@ -346,7 +370,7 @@ struct SXCFProperties
 };
 
 #ifdef DEBUG_INFO
-char *pXCFPropNames[PROP_Last] =
+static const char *const pXCFPropNames[PROP_Last] =
 {
 	"PROP_END",                //=  0,
 	"PROP_COLORMAP",           //=  1,
@@ -659,7 +683,7 @@ void XCF_CopyLayer(struct SPSDPicture *p
 }
 
 // XCF loader.
-struct SPSDPicture * XCFLoad(char *pXCFFilename)
+struct SPSDPicture * XCFLoad(const char *pXCFFilename)
 {
 	FILE	*fPt = NULL;
 	u8	*pBuf = NULL;
@@ -896,10 +920,10 @@ _XCFErr:
 //=============================================================================
 
 /*
-typedef struct SPSDPicture * (*pLoadingFct)(char *);
+typedef struct SPSDPicture * (*pLoadingFct)(const char *);
 
 // Lecture d'une image PSD/XCF 8 bits et passage dans une surface SDL.
-SDL_Surface * GeneLoadToSDLSurf(char *pFilename, pLoadingFct pFct)
+SDL_Surface * GeneLoadToSDLSurf(const char *pFilename, pLoadingFct pFct)
 {
 	struct SPSDPicture	*pPic;
 	SDL_Surface *pSDLSurf;
@@ -925,7 +949,6 @@ SDL_Surface * GeneLoadToSDLSurf(char *pF
 		SDL_LockSurface(pSDLSurf);
 		for (i = 0; i < pPic->nHeight; i++)
 			memcpy((u8 *)pSDLSurf->pixels + (i * pSDLSurf->pitch), pPic->pPlanes + (i * pPic->nWidth), pPic->nWidth);
-//			memcpy((u8 *)pSDLSurf->pixels + (i * pSDLSurf->pitch), pPic->pPlanes + ((i+(pPic->nHeight*1)) * pPic->nWidth), pPic->nWidth);
 		SDL_UnlockSurface(pSDLSurf);
 	}
 
@@ -936,13 +959,13 @@ SDL_Surface * GeneLoadToSDLSurf(char *pF
 }
 
 // Wrapper PSD.
-SDL_Surface * PSDLoadToSDLSurf(char *pPSDFilename)
+SDL_Surface * PSDLoadToSDLSurf(const char *pPSDFilename)
 {
 	return (GeneLoadToSDLSurf(pPSDFilename, PSDLoad));
 }
 
 // Wrapper XCF.
-SDL_Surface * XCFLoadToSDLSurf(char *pXCFFilename)
+SDL_Surface * XCFLoadToSDLSurf(const char *pXCFFilename)
 {
 	return (GeneLoadToSDLSurf(pXCFFilename, XCFLoad));
 }
diff -rupN minislug.orig/edtile0/psd.h minislug.new/edtile0/psd.h
--- minislug.orig/edtile0/psd.h	2013-07-24 14:16:24.000000000 +0200
+++ minislug.new/edtile0/psd.h	2023-12-10 06:28:11.438864595 +0100
@@ -11,7 +11,7 @@ struct SPSDPicture
 
 
 // Prototypes.
-struct SPSDPicture * PSDLoad(char *pPSDFilename);
-//SDL_Surface * PSDLoadToSDLSurf(char *pPSDFilename);
-struct SPSDPicture * XCFLoad(char *pXCFFilename);
-//SDL_Surface * XCFLoadToSDLSurf(char *pXCFFilename);
+struct SPSDPicture * PSDLoad(const char *pPSDFilename);
+SDL_Surface * PSDLoadToSDLSurf(const char *pPSDFilename);
+struct SPSDPicture * XCFLoad(const char *pXCFFilename);
+//SDL_Surface * XCFLoadToSDLSurf(const char *pXCFFilename);
Binary files minislug.orig/edtile0/psd.o and minislug.new/edtile0/psd.o differ
Binary files minislug.orig/edtile0/undo.o and minislug.new/edtile0/undo.o differ
Binary files minislug.orig/edtile0/visu.o and minislug.new/edtile0/visu.o differ
diff -rupN minislug.orig/exechk0/Makefile minislug.new/exechk0/Makefile
--- minislug.orig/exechk0/Makefile	2012-10-02 22:20:54.000000000 +0200
+++ minislug.new/exechk0/Makefile	2023-12-10 07:10:44.781859957 +0100
@@ -1,17 +1,17 @@
 # Mon Makefile
-#PATH = /usr/include/SDL
-TARGET = exechk 
+TARGET = exechk
 OBJECTS = main.o
  
-CFLAGS = -O3 -Wall -g -I/usr/include/SDL -L/usr/lib -fno-strict-aliasing -D__LINUX__ 
+CFLAGS = $(CPU_CFLAGS) -O2 -fomit-frame-pointer -Wall -fno-strict-aliasing
+LDFLAGS = -s
 LIBS = 
-CC = gcc
+CC = $(CROSS_PREFIX)gcc
 
 all: $(TARGET)
 
 $(TARGET): $(OBJECTS)
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS) 
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) 
 
 clean:
-	rm $(TARGET) $(OBJECTS)
+	rm -f $(TARGET) $(OBJECTS)
 
Binary files minislug.orig/exechk0/exechk and minislug.new/exechk0/exechk differ
Binary files minislug.orig/exechk0/main.o and minislug.new/exechk0/main.o differ
diff -rupN minislug.orig/minislug0/Makefile minislug.new/minislug0/Makefile
--- minislug.orig/minislug0/Makefile	2013-02-23 17:26:35.000000000 +0100
+++ minislug.new/minislug0/Makefile	2023-12-10 07:17:22.674619782 +0100
@@ -1,27 +1,28 @@
 # Makefile
 
-TARGET = minislug 
+TARGET = minislug
 OBJECTS = main.o anims.o animspr.o blkanim.o blkbkg.o boss.o dust.o fire.o font.o frame.o game.o gif.o interface.o loader.o menu.o monsters00.o monsters10.o monsters20.o monsters30.o monsters40.o monsters50.o mst.o preca.o psd.o scroll.o sfx.o sprites.o sprcache.o sprrz.o transit2d.o 
 
-CFLAGS = -O3 -Wall -s -I/usr/include/SDL -L/usr/lib -L. -fno-strict-aliasing -DNDEBUG 
-LIBS = -lSDL -s libymlib.a
-#LIBS = -lSDL
-#LIBS = -lSDL -lSDL_image
+SDL_CFLAGS := $(shell pkg-config --cflags sdl)
+SDL_LIBS := $(shell pkg-config --libs sdl)
+CFLAGS = $(CPU_CFLAGS) -O0 -g -Wall $(SDL_CFLAGS) -fno-strict-aliasing -DNDEBUG 
+LDFLAGS = -g
+LIBS = ymlib/libymlib.a $(SDL_LIBS)
 
-CC = gcc
-LINKER = g++
+CC = $(CROSS_PREFIX)gcc
+CXX = $(CROSS_PREFIX)g++
 
-all: $(TARGET)
+all: $(TARGET) swapdata
 
-#$(TARGET): $(OBJECTS)
-#	$(CC) $(CFLAGS) -o $@ $^ $(LIBS) 
+$(TARGET): $(OBJECTS) ymlib/libymlib.a
+	$(CXX) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) 
 
-$(TARGET): $(OBJECTS)
-	$(LINKER) $(CFLAGS) -o $@ $^ $(LIBS) 
+swapdata: swapdata.c
+	gcc -O2 -Wall -o $@ $<
 
-.cc.o:
-	$(CC) $(CFLAGS) -o $< 
+ymlib/libymlib.a:
+	$(MAKE) -C ymlib
 
 clean:
-	rm $(TARGET) $(OBJECTS)
-
+	$(MAKE) -C ymlib clean
+	rm -f $(TARGET) $(OBJECTS) swapdata
Binary files minislug.orig/minislug0/anims.o and minislug.new/minislug0/anims.o differ
Binary files minislug.orig/minislug0/animspr.o and minislug.new/minislug0/animspr.o differ
Binary files minislug.orig/minislug0/blkanim.o and minislug.new/minislug0/blkanim.o differ
Binary files minislug.orig/minislug0/blkbkg.o and minislug.new/minislug0/blkbkg.o differ
diff -rupN minislug.orig/minislug0/boss.c minislug.new/minislug0/boss.c
--- minislug.orig/minislug0/boss.c	2013-02-23 15:48:38.000000000 +0100
+++ minislug.new/minislug0/boss.c	2023-12-09 15:04:06.649937657 +0100
@@ -1808,7 +1808,7 @@ s32 Mst20_Main_Boss3(struct SMstCommon *
 	u32	i;
 	u32	nSpr2 = SPR_NoSprite;
 
-	u8	nTouch = 0;
+	//u8	nTouch = 0;
 
 	B3U_Manage(pMst);	// Gestion du mini UFO.
 	B3C_Manage(pMst);	// Gestion du canon.
@@ -1816,7 +1816,7 @@ s32 Mst20_Main_Boss3(struct SMstCommon *
 	switch (pMst->nPhase)
 	{
 	case e_MstB3_Idle:	// Le coeur attend.
-		nTouch = !pSpe->nExplo;
+		//nTouch = !pSpe->nExplo;
 
 //		nSpr2 = (pMst->nAnm == -1 ? e_Spr_Core_CoreGlow : AnmGetImage(pMst->nAnm));
 		// Glow + truc de lamer pour accélérer l'anim.
Binary files minislug.orig/minislug0/boss.o and minislug.new/minislug0/boss.o differ
Binary files minislug.orig/minislug0/dust.o and minislug.new/minislug0/dust.o differ
Binary files minislug.orig/minislug0/fire.o and minislug.new/minislug0/fire.o differ
Binary files minislug.orig/minislug0/font.o and minislug.new/minislug0/font.o differ
Binary files minislug.orig/minislug0/frame.o and minislug.new/minislug0/frame.o differ
diff -rupN minislug.orig/minislug0/game.c minislug.new/minislug0/game.c
--- minislug.orig/minislug0/game.c	2013-02-26 02:20:44.000000000 +0100
+++ minislug.new/minislug0/game.c	2023-12-09 15:06:56.093039339 +0100
@@ -2904,8 +2904,7 @@ void PlayerControl_SlugNoExit_Temp(void)
 
 void PlayerDisplay_SlugNoExit_Temp(void)
 {
-	u32	nSpr;
-	nSpr = AnmGetImage(gShoot.nPlayerAnm);		// Très important, pour faire avancer l'anim de mort et arriver sur le AnmEnd !
+	/*nSpr =*/ AnmGetImage(gShoot.nPlayerAnm);		// Très important, pour faire avancer l'anim de mort et arriver sur le AnmEnd !
 
 	// Pas de sprite de collision.
 	gShoot.nPlayerSprCol = SPR_NoSprite;
Binary files minislug.orig/minislug0/game.o and minislug.new/minislug0/game.o differ
diff -rupN minislug.orig/minislug0/gif.c minislug.new/minislug0/gif.c
--- minislug.orig/minislug0/gif.c	2013-02-23 16:06:39.000000000 +0100
+++ minislug.new/minislug0/gif.c	2023-12-10 09:00:11.902489712 +0100
@@ -12,16 +12,17 @@
 
 #include "includes.h"
 
-#define	LZW_REVERSE		1	// 1 = On renvoie les chaînes à l'envers, ce qui évite une recopie pour retourner les chaînes.
+#define	LZW_REVERSE		1	// 1 = We return the strings in reverse, which avoids having to copy again to return the strings.
 
 #define	GIF_TRAILER					0x3B
 #define	GIF_EXTENSION_INTRODUCER	0x21
 #define	GIF_IMAGE_SEPARATOR			0x2C
 
+#define le16(p) ((p)[0] | ((p)[1] << 8))
 
 
 // Lecture de bits dans un buffer.
-u32	GIF_GetBits(u8 *pBuf, u32 nBitStart, u32 nSz)
+static u32	GIF_GetBits(u8 *pBuf, u32 nBitStart, u32 nSz)
 {
 	s32	nRet = 0;
 	u8	nSrcMsk;
@@ -50,11 +51,11 @@ u32	GIF_GetBits(u8 *pBuf, u32 nBitStart,
 
 
 
-struct SDictionnaryRecord	gpStrBuf[4096];
-u32	gnDicNext;		// Next available position.
+static struct SDictionnaryRecord	gpStrBuf[4096];
+static u32	gnDicNext;		// Next available position.
 
 // Rajoute une chaîne au dictionnaire.
-void LZW_Add2Dictionnary(u32 nPrevCode, u8 nAppendChar)
+static void LZW_Add2Dictionnary(u32 nPrevCode, u8 nAppendChar)
 {
 	if (gnDicNext + 1 == 4096) return;	// Pas d'ajout si la table est pleine, on utilise la table telle quelle en attendant le "clear code".
 
@@ -65,7 +66,7 @@ void LZW_Add2Dictionnary(u32 nPrevCode,
 
 #if LZW_REVERSE == 0
 // Renvoie une chaîne du dictionnaire.
-void LZW_GetTranslation(u32 nStrCode, u8 *pStrDst, u32 *pnStrDstNb, u32 nClearCode)
+static void LZW_GetTranslation(u32 nStrCode, u8 *pStrDst, u32 *pnStrDstNb, u32 nClearCode)
 {
 	u8	pStrRev[4096];
 	u32	nStrRevNb;
@@ -98,7 +99,7 @@ void LZW_GetTranslation(u32 nStrCode, u8
 }
 #else
 // Renvoie une chaîne à l'envers du dictionnaire.
-void LZW_GetTranslation(u32 nStrCode, u8 *pStrRev, u32 *pnStrDstNb, u32 nClearCode)
+static void LZW_GetTranslation(u32 nStrCode, u8 *pStrRev, u32 *pnStrDstNb, u32 nClearCode)
 {
 	u32	nStrRevNb;
 
@@ -128,7 +129,7 @@ void LZW_GetTranslation(u32 nStrCode, u8
 #endif
 
 // Copie de la chaîne LZW dans le buffer.
-void GIF_LZWStrOutput(u8 **pImg, u8 *pStrDst, u32 nStrDstNb, u32 *l,
+static void GIF_LZWStrOutput(u8 **pImg, u8 *pStrDst, u32 nStrDstNb, u32 *l,
 	u32 nRenderTransparentClrIdx, u32 nBlkWidth, u32 nGifWidth)
 {
 	s32	i;
@@ -177,23 +178,25 @@ void GIF_GetNextImage(struct SGIFFile *p
 
 		// Logical Screen Descriptor.
 		pGif->pLogicalScrDesc = (struct SGIFBlk_LogicalScrDesc *)pBuf;
+		
 		pBuf += 7;
 		// Global Color Table (Optional).
-		if (pGif->pLogicalScrDesc->nGlobalClrTableFlag)
+		if (pGif->pLogicalScrDesc->flags & 0x80)
 		{
-			i = 3 * (1 << (pGif->pLogicalScrDesc->nGlobalClrTableSz + 1));	// Size of color table.
+			u8 BitsPerPixel = pGif->pLogicalScrDesc->flags & 7;
+			i = 3 * (1 << (BitsPerPixel + 1));	// Size of color table.
 			memcpy(pGif->pGlobalPal, pBuf, i);
 			pBuf += i;
 		}
 
 		// malloc du buffer pour l'image dépackée + buffer de depack (de la taille de l'image).
-		if ((pGif->pImg = (u8 *)malloc(pGif->pLogicalScrDesc->nLogScrWidth * pGif->pLogicalScrDesc->nLogScrHeight * 2)) == NULL)
+		if ((pGif->pImg = (u8 *)malloc(le16(pGif->pLogicalScrDesc->nLogScrWidth) * le16(pGif->pLogicalScrDesc->nLogScrHeight) * 2)) == NULL)
 		{
 			fprintf(stderr, "GIF_GetNextImage(): malloc failed (1). Aborted.\n");
 			pGif->pLogicalScrDesc = NULL;	// !! Sert pour l'init !!
 			return;
 		}
-		pGif->pPackedBuf = pGif->pImg + (pGif->pLogicalScrDesc->nLogScrWidth * pGif->pLogicalScrDesc->nLogScrHeight);
+		pGif->pPackedBuf = pGif->pImg + (le16(pGif->pLogicalScrDesc->nLogScrWidth) * le16(pGif->pLogicalScrDesc->nLogScrHeight));
 
 		// Misc inits.
 		pGif->nNextDisposal = 2;	// Pour le rendu de la première frame.
@@ -240,9 +243,10 @@ void GIF_GetNextImage(struct SGIFFile *p
 			// Par défaut, on pointe sur la palette générale.
 			pGif->pPal = pGif->pGlobalPal;
 			// Local color table ?
-			if (pImgDesc->nLocalClrTableFlag)
+			if (pImgDesc->flags & 0x80)
 			{
-				i = 3 * (1 << (pImgDesc->nLocalClrTableSz + 1));	// Size of color table.
+				u8 BitsPerPixel = pImgDesc->flags & 7;
+				i = 3 * (1 << (BitsPerPixel + 1));	// Size of color table.
 				memcpy(pGif->pLocalPal, pBuf, i);
 				pGif->pPal = pGif->pLocalPal;
 				pBuf += i;
@@ -289,7 +293,7 @@ void GIF_GetNextImage(struct SGIFFile *p
 			if (nDisposalMethod == 2)
 			{
 				// Byte par byte.
-//				for (i = 0; i < pGif->pLogicalScrDesc->nLogScrWidth * pGif->pLogicalScrDesc->nLogScrHeight; i++)
+//				for (i = 0; i < le16(pGif->pLogicalScrDesc->nLogScrWidth) * le16(pGif->pLogicalScrDesc->nLogScrHeight); i++)
 //					pGif->pImg[i] = pGif->pLogicalScrDesc->nBkgClrIdx;
 
 				// Par quads.
@@ -311,14 +315,14 @@ void GIF_GetNextImage(struct SGIFFile *p
 				nClr = (nTmp << 24) | (nTmp << 16) | (nTmp << 8) | nTmp;
 
 
-				u32	n4 = (pGif->pLogicalScrDesc->nLogScrWidth * pGif->pLogicalScrDesc->nLogScrHeight);
+				u32	n4 = (le16(pGif->pLogicalScrDesc->nLogScrWidth) * le16(pGif->pLogicalScrDesc->nLogScrHeight));
 				u32	n1 = n4 & 3;
 				n4 >>= 2;
 				for (; n4; n4--) *pTmp32++ = nClr;
 				pTmp8 = (u8 *)pTmp32;
 				for (; n1; n1--) *pTmp8++ = nClr;
 
-//				memset(pGif->pImg, pGif->pLogicalScrDesc->nBkgClrIdx, pGif->pLogicalScrDesc->nLogScrWidth * pGif->pLogicalScrDesc->nLogScrHeight);
+//				memset(pGif->pImg, pGif->pLogicalScrDesc->nBkgClrIdx, le16(pGif->pLogicalScrDesc->nLogScrWidth) * le16(pGif->pLogicalScrDesc->nLogScrHeight));
 
 			}
 
@@ -327,8 +331,8 @@ void GIF_GetNextImage(struct SGIFFile *p
 			// 2 - Depack.
 
 u32	l;
-l = pImgDesc->nImgWidth;
-u8	*pImg = pGif->pImg + (pImgDesc->nImgTop * pGif->pLogicalScrDesc->nLogScrWidth) + pImgDesc->nImgLeft;
+l = le16(pImgDesc->nImgWidth);
+u8	*pImg = pGif->pImg + (le16(pImgDesc->nImgTop) * le16(pGif->pLogicalScrDesc->nLogScrWidth)) + le16(pImgDesc->nImgLeft);
 
 			u8	pStrDst[4096];
 			u32	nStrDstNb;
@@ -379,7 +383,7 @@ _reset:
 			// output OLD_CODE
 			LZW_GetTranslation(nOldCode, pStrDst, &nStrDstNb, nClearCode);
 
-			GIF_LZWStrOutput(&pImg, pStrDst, nStrDstNb, &l, pGif->nTransparentColorIndex, pImgDesc->nImgWidth, pGif->pLogicalScrDesc->nLogScrWidth);
+			GIF_LZWStrOutput(&pImg, pStrDst, nStrDstNb, &l, pGif->nTransparentColorIndex, le16(pImgDesc->nImgWidth), le16(pGif->pLogicalScrDesc->nLogScrWidth));
 
 			while (1)
 			{
@@ -419,7 +423,7 @@ _reset:
 				}
 
 				// output STRING
-				GIF_LZWStrOutput(&pImg, pStrDst, nStrDstNb, &l, pGif->nTransparentColorIndex, pImgDesc->nImgWidth, pGif->pLogicalScrDesc->nLogScrWidth);
+				GIF_LZWStrOutput(&pImg, pStrDst, nStrDstNb, &l, pGif->nTransparentColorIndex, le16(pImgDesc->nImgWidth), le16(pGif->pLogicalScrDesc->nLogScrWidth));
 
 				// CHARACTER = first character in STRING
 				// add OLD_CODE + CHARACTER to the translation table
@@ -466,12 +470,12 @@ _reset:
 
 				// Y a-t'il une couleur de transparence pour le rendu de la frame ?
 				pGif->nTransparentColorIndex = 256;		// Par défaut, et 256 ne risque pas d'arriver sur 8 bits.
-				if (pGCExt->nTransparentClrFlag)
+				if (pGCExt->flags & 1)
 				{
 					pGif->nTransparentColorIndex = pGCExt->nTransparentClrIdx;
 				}
 				nDisposalMethod = pGif->nNextDisposal;			// Pour le rendu de cette frame.
-				pGif->nNextDisposal = pGCExt->nDisposalMethod;	// Pour le rendu de l'image suivante.
+				pGif->nNextDisposal = (pGCExt->flags >> 2) & 7;	// Pour le rendu de l'image suivante.
 
 				pBuf += pGCExt->nBlkSz + 1;
 			}
@@ -540,7 +544,7 @@ void GIF_Free(struct SGIFFile *pGif)
 }
 
 // Lecture d'un GIF.
-struct SGIFFile * GIF_Load(char *pFilename)
+struct SGIFFile * GIF_Load(const char *pFilename)
 {
 	struct	SGIFFile	*pGif = NULL;
 	FILE	*pFile = NULL;
diff -rupN minislug.orig/minislug0/gif.h minislug.new/minislug0/gif.h
--- minislug.orig/minislug0/gif.h	2013-02-23 16:07:26.000000000 +0100
+++ minislug.new/minislug0/gif.h	2023-12-10 08:57:31.422715801 +0100
@@ -3,51 +3,63 @@
 
 // Structures pour le GIF, alignées à l'octet.
 #pragma pack(1)
-struct SGIFBlk_LogicalScrDesc
+__attribute__((packed)) struct SGIFBlk_LogicalScrDesc
 {
-	u16	nLogScrWidth;
-	u16	nLogScrHeight;
+	u8	nLogScrWidth[2];
+	u8	nLogScrHeight[2];
+#if 0
 	u8	nGlobalClrTableSz:3,
 		nSortFlag:1,
 		nClrResolution:3,
 		nGlobalClrTableFlag:1;
+#else
+	u8 flags;
+#endif
 	u8	nBkgClrIdx;
 	u8	nPixelAspectRatio;
 };
 
-struct SGIFBlk_AppliExtension
+__attribute__((packed)) struct SGIFBlk_AppliExtension
 {
 	u8	nBlkSz;
 	u8	pAppliId[8];
 	u8	pAppliAuthCode[3];
 };
 
-struct SGIFBlk_GraphicControlExtension
+__attribute__((packed)) struct SGIFBlk_GraphicControlExtension
 {
 	u8	nBlkSz;
+#if 0
 	u8	nTransparentClrFlag:1,
 		nUserInputFlag:1,
 		nDisposalMethod:3,
 		nReserved:3;
-	u16	nDelayTime;
+#else
+	u8 flags;
+#endif
+	u8	nDelayTime[2];
 	u8	nTransparentClrIdx;
 };
 
-struct SGIFBlk_ImageDescriptor
+__attribute__((packed)) struct SGIFBlk_ImageDescriptor
 {
 	u8	nBlkId;		// 0x2C.
-	u16	nImgLeft;
-	u16	nImgTop;
-	u16	nImgWidth;
-	u16	nImgHeight;
+	u8	nImgLeft[2];
+	u8	nImgTop[2];
+	u8	nImgWidth[2];
+	u8	nImgHeight[2];
+#if 0
 	u8	nLocalClrTableSz:3,
 		nReserved:2,
 		nSortFlag:1,
 		nInterlaceFlag:1,
 		nLocalClrTableFlag:1;
+#else
+	u8 flags;
+#endif
 };
 
-struct SDictionnaryRecord
+__attribute__((packed)) struct SDictionnaryRecord
 {
 	u16	nPrevCode;		// Index du code précédent.
 	u8	nAppendChar;
@@ -78,7 +90,7 @@ struct	SGIFFile
 };
 
 // Prototypes.
-struct SGIFFile * GIF_Load(char *pFilename);
+struct SGIFFile * GIF_Load(const char *pFilename);
 void GIF_GetNextImage(struct SGIFFile *pGif);
 void GIF_Free(struct SGIFFile *pGif);
 
Binary files minislug.orig/minislug0/gif.o and minislug.new/minislug0/gif.o differ
Binary files minislug.orig/minislug0/high.scr and minislug.new/minislug0/high.scr differ
Binary files minislug.orig/minislug0/high.scr.bak and minislug.new/minislug0/high.scr.bak differ
Binary files minislug.orig/minislug0/interface.o and minislug.new/minislug0/interface.o differ
diff -rupN minislug.orig/minislug0/loader.c minislug.new/minislug0/loader.c
--- minislug.orig/minislug0/loader.c	2013-02-23 15:48:37.000000000 +0100
+++ minislug.new/minislug0/loader.c	2023-12-10 04:43:57.911311075 +0100
@@ -622,23 +622,23 @@ enum
 // Pragma pack 1 sur les structures à lire/écrire.
 #pragma pack(1)
 
-// Header de chaque container.
-struct SContainer0
+// Header of each container.
+__attribute__((packed)) struct SContainer0
 {
 	u32	nSz;
 	u16	nType;
 	u16	nPadding;
 };
 
-// Struct pour datas de la map.
-struct SMap0
+// Struct for map data.
+__attribute__((packed)) struct SMap0
 {
 	u32	nMapLg, nMapHt, nMapPosX, nMapPosY, nPlanesNb, nFirstWnd, nActivePlane;
 };
 
 #define	e_FlgFile_Plane_Codes	(1 << 31)		// Lecture/sauvegarde d'une page de code.
-// Struct pour datas d'un plan.
-struct SPlane2
+// Struct for plan data.
+__attribute__((packed)) struct SPlane2
 {
 	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
 	u32	nBlkLg, nBlkHt;			// Largeur et hauteur du plan en blocs 16. Pour éventuel remap à la relecture.
@@ -646,20 +646,8 @@ struct SPlane2
 	u8	nPad0, nPad1, nPad2;	// Padding.
 };
 
-/*
-// Struct pour datas misc.
-struct SMisc0
-{
-	u32	nFlags;						// gMisc.nFlags.
-	u8	nTransR, nTransG, nTransB;	// RGB de la couleur de transparence.
-	u16	nVisuLg, nVisuHt;			// Taille de la visu (en pixels).
-
-	u8	nPad0;	// Padding.
-	u32	nBlank0, nBlank1, nBlank2, nBlank3;	// Au cas ou on ait besoin de sauver plus de trucs par la suite.
-};
-*/
 // Struct pour datas misc. (Hum, corrigée et paddée correctement pour pack).
-struct SMisc0
+__attribute__((packed)) struct SMisc0
 {
 	u32	nFlags;						// gMisc.nFlags.
 	u8	nTransR, nTransG, nTransB;	// RGB de la couleur de transparence.
@@ -686,11 +674,11 @@ void LevelLoad(u32 nLevelNo)
 	u32	nPlaneNext = 0;		// Pour controler l'ordre de lecture des plans. Doit être dans l'ordre.
 	//char	pFilename[256];
 	//CPlane	*pPlane;
-	struct SMap0	sMap;
+	//struct SMap0	sMap;
 	u32	nPlaneSav_BlkLg, nPlaneSav_BlkHt;	// Lg et Ht de la planche sauvée dans le EDT.
 
 	char	pDir[256];	// Pour créer le nom du répertoire, à ajouter avant les noms de fichiers.
-	char	pLevFilename[256];	// Nom du fichier, précédé du répertoire.
+	char	pLevFilename[256 + 20];	// Nom du fichier, précédé du répertoire.
 	char	pFilename[256];		// Noms de fichiers annexes à lire (planches...).
 
 
@@ -762,7 +750,9 @@ printf("lev fn: %s\n", pLevFilename);
 		exit(1);
 	}
 	// Vérif version du fichier.
-	if (*(u16 *)(pBuf + 3) != 0x0100)
+	u16 nVersion;
+	memcpy(&nVersion, pBuf + 3, sizeof(nVersion));
+	if (nVersion != 0x100)
 	{
 		fprintf(stderr, "LoadLevel(): Unknown file version.\n");
 		exit(1);
@@ -810,12 +800,12 @@ printf("Header ok.\n");
 			//gMap.nMapPosX = ((SMap0 *)pBuf)->nMapPosX;
 			//gMap.nMapPosY = ((SMap0 *)pBuf)->nMapPosY;
 			// Pour plus tard.
-			sMap.nPlanesNb = ((struct SMap0 *)pBuf)->nPlanesNb;
+			// sMap.nPlanesNb = ((struct SMap0 *)pBuf)->nPlanesNb;
 			//sMap.nFirstWnd = ((SMap0 *)pBuf)->nFirstWnd;
 			//sMap.nActivePlane = ((SMap0 *)pBuf)->nActivePlane;
 
 #ifdef DEBUG_INFO
-			printf("lg=%d / ht=%d / nb pln=%d\n", (int)gMap.nMapLg, (int)gMap.nMapHt, (int)sMap.nPlanesNb);
+			printf("lg=%d / ht=%d / nb pln=%d\n", (int)gMap.nMapLg, (int)gMap.nMapHt, (int)((struct SMap0 *)pBuf)->nPlanesNb);
 #endif
 
 			// Par défaut, position de départ du joueur.
@@ -1015,7 +1005,7 @@ printf("Path: (%d, %d) Blk:%d.\n", (int)
 			struct SPSDPicture	*pPlanche = NULL;
 
 			// On regarde l'extension du fichier.
-			if (stricmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
+			if (strcasecmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
 			{
 				// BMP.
 				pGfx2 = SDL_LoadBMP(pFilename);
@@ -1025,7 +1015,7 @@ printf("Path: (%d, %d) Blk:%d.\n", (int)
 				}
 			}
 			else
-			if (stricmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
+			if (strcasecmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
 			{
 				// PSD.
 				pPlanche = PSDLoad(pFilename);
@@ -1358,10 +1348,15 @@ printf("Plane #%d, lg=%d, ht=%d\n", (int
 				while (nb)
 				{
 					// Header.
-					memcpy(pDstPt, pSrcPt, sizeof(struct SMstEdt0));
+					struct SMst0 *mst0 = (struct SMst0 *)pDstPt;
+					struct SMstEdt0 *emst0 = (struct SMstEdt0 *)pSrcPt;
+					mst0->nPosX = emst0->nPosX;
+					mst0->nPosY = emst0->nPosY;
+					mst0->nMstNo = emst0->nMstNo;
+					mst0->nNbBytes = emst0->nNbBytes;
 					pSrcPt += sizeof(struct SMstEdt0);
-					(*(struct SMst0 *)pDstPt).nIdx = k;		// Le fameux n° d'ordre.
-					m = (*(struct SMst0 *)pDstPt).nNbBytes;	// Nb de bytes de datas.
+					mst0->nIdx = k;		// Le fameux n° d'ordre.
+					m = mst0->nNbBytes;	// Nb de bytes de datas.
 					pDstPt += sizeof(struct SMst0);
 					// Datas.
 					memcpy(pDstPt, pSrcPt, m);
diff -rupN minislug.orig/minislug0/loader.h minislug.new/minislug0/loader.h
--- minislug.orig/minislug0/loader.h	2013-02-23 15:48:36.000000000 +0100
+++ minislug.new/minislug0/loader.h	2023-12-09 20:23:16.657363442 +0100
@@ -4,20 +4,20 @@
 // Struct pour lecture/sauvegarde d'un monstre.
 // !!! Ne surtout pas toucher, c'est aussi le format utilisé dans l'éditeur de map et qui est relu directement !!!
 #pragma pack(1)
-struct SMstEdt0
+__attribute__((packed)) struct SMstEdt0
 {
 	u32	nPosX, nPosY;
-	u16	nMstNo;		// = No du bloc.
-	u16	nNbBytes;	// Nb de bytes utilisés.
+	u16	nMstNo;		// = Block no.
+	u16	nNbBytes;	// Number of bytes used.
 };
 #pragma pack()
 
 struct SMst0
 {
 	u32	nPosX, nPosY;
-	u16	nMstNo;		// = No du bloc.
-	u16	nNbBytes;	// Nb de bytes utilisés.
-	u16	nIdx;		// Index du monstre, pour taper dans table pMstState.
+	u16	nMstNo;		// = Block no..
+	u16	nNbBytes;	// Number of bytes used.
+	u16	nIdx;		// Index of the monster, to type in table pMstState.
 	u16 _padding;
 };
 
Binary files minislug.orig/minislug0/loader.o and minislug.new/minislug0/loader.o differ
Binary files minislug.orig/minislug0/main.o and minislug.new/minislug0/main.o differ
diff -rupN minislug.orig/minislug0/menu.c minislug.new/minislug0/menu.c
--- minislug.orig/minislug0/menu.c	2013-02-26 02:27:12.000000000 +0100
+++ minislug.new/minislug0/menu.c	2023-12-10 08:51:07.433256777 +0100
@@ -17,9 +17,9 @@ enum
 #define HISC_Filename "high.scr"
 
 #pragma pack(1)
-struct SScore
+__attribute__((packed)) struct SScore
 {
-	char	pName[HISC_NameLg];
+	char	pName[(HISC_NameLg+3)&~3];
 	u32	nScore;
 };
 struct SScore	gpHighScores[HISC_Nb];
@@ -33,6 +33,8 @@ struct SMenuItm
 	char	*pTxt;
 };
 
+#define le16(p) ((p)[0] | ((p)[1] << 8))
+
 
 #define CURS_Acc 0x200
 
@@ -176,13 +178,13 @@ void GIF_Display(struct SGIFFile *pGif,
 	// Préparation.
 	nXMin = nPosX;
 	nYMin = nPosY;
-	nXMax = nPosX + pGif->pLogicalScrDesc->nLogScrWidth - 1;
-	nYMax = nPosY + pGif->pLogicalScrDesc->nLogScrHeight - 1;
+	nXMax = nPosX + le16(pGif->pLogicalScrDesc->nLogScrWidth) - 1;
+	nYMax = nPosY + le16(pGif->pLogicalScrDesc->nLogScrHeight) - 1;
 
 	nSprXMin = 0;
-	nSprXMax = pGif->pLogicalScrDesc->nLogScrWidth - 1;
+	nSprXMax = le16(pGif->pLogicalScrDesc->nLogScrWidth) - 1;
 	nSprYMin = 0;
-	nSprYMax = pGif->pLogicalScrDesc->nLogScrHeight - 1;
+	nSprYMax = le16(pGif->pLogicalScrDesc->nLogScrHeight) - 1;
 
 	// Clips.
 	if (nXMin < 0)
@@ -226,7 +228,7 @@ void GIF_Display(struct SGIFFile *pGif,
 
 //l	pScr += ((nYMin + nSprYMin) * SCR_Width) + nXMin;
 	pScr += ((nYMin + nSprYMin) * nScrLg) + nXMin;
-	pGfx += (nSprYMin * pGif->pLogicalScrDesc->nLogScrWidth);
+	pGfx += (nSprYMin * le16(pGif->pLogicalScrDesc->nLogScrWidth));
 
 /*
 printf("***\nSprXMin = %d / SprXMax = %d / SprYMin = %d / SprYMax = %d\n\
@@ -241,11 +243,11 @@ nXMin, nXMax, nYMin, nYMax);
 		for (ix = nSprXMin; ix <= nSprXMax; ix++)
 			*(pScr + ix) = pPal[*(pGfx + ix)];
 //			*(pScr + (iy * SCR_Width) + ix) =	// mais virer les 2 add qui suivent !
-//				pPal[*(pGfx + (iy * pGif->pLogicalScrDesc->nLogScrWidth) + ix)];
+//				pPal[*(pGfx + (iy * le16(pGif->pLogicalScrDesc->nLogScrWidth)) + ix)];
 
 //l		pScr += SCR_Width;
 		pScr += nScrLg;
-		pGfx += pGif->pLogicalScrDesc->nLogScrWidth;
+		pGfx += le16(pGif->pLogicalScrDesc->nLogScrWidth);
 	}
 */
 
@@ -258,7 +260,7 @@ nXMin, nXMax, nYMin, nYMax);
 			for (ix = nSprXMin; ix <= nSprXMax; ix++)
 				*(pScr + ix) = pPal[*(pGfx + ix)];
 			pScr += nScrLg;
-			pGfx += pGif->pLogicalScrDesc->nLogScrWidth;
+			pGfx += le16(pGif->pLogicalScrDesc->nLogScrWidth);
 		}
 	}
 	else
@@ -277,7 +279,7 @@ _SkipTrans:
 				*(pScr + ix) = pPal[*(pGfx + ix)];
 			}
 			pScr += nScrLg;
-			pGfx += pGif->pLogicalScrDesc->nLogScrWidth;
+			pGfx += le16(pGif->pLogicalScrDesc->nLogScrWidth);
 		}
 	}
 
@@ -659,10 +661,12 @@ s32 Scr_PutNameInTable(char *pName, u32
 	// Décalage de la table.
 	for (i = HISC_Nb - 2; i >= nRank; i--)
 	{
+		memset(&gpHighScores[i + 1], 0, sizeof(gpHighScores[i + 1]));
 		strcpy(gpHighScores[i + 1].pName, gpHighScores[i].pName);
 		gpHighScores[i + 1].nScore = gpHighScores[i].nScore;
 	}
 	// Le score à insérer.
+	memset(&gpHighScores[nRank], 0, sizeof(gpHighScores[nRank]));
 	strcpy(gpHighScores[nRank].pName, pName);
 	gpHighScores[nRank].nScore = nScore;
 
@@ -679,6 +683,7 @@ void Scr_RazTable(void)
 
 	for (i = 0; i < HISC_Nb; i++)
 	{
+		memset(&gpHighScores[i], 0, sizeof(gpHighScores[i]));
 		strcpy(gpHighScores[i].pName, pDefStr);
 		gpHighScores[i].nScore = 0;
 	}
diff -rupN minislug.orig/minislug0/menu.h minislug.new/minislug0/menu.h
--- minislug.orig/minislug0/menu.h	2013-02-23 16:11:04.000000000 +0100
+++ minislug.new/minislug0/menu.h	2023-12-09 20:23:42.510662707 +0100
@@ -61,7 +61,7 @@ enum
 };
 
 #pragma pack(1)
-struct SMSCfg
+__attribute__((packed)) struct SMSCfg
 {
 	u16	pKeys[e_CfgKey_MAX];
 	u16	nVideoMode;			// 0 = 320x224 / 1 = x2 / 2 = TV2x.
Binary files minislug.orig/minislug0/menu.o and minislug.new/minislug0/menu.o differ
Binary files minislug.orig/minislug0/minislug and minislug.new/minislug0/minislug differ
Binary files minislug.orig/minislug0/monsters00.o and minislug.new/minislug0/monsters00.o differ
Binary files minislug.orig/minislug0/monsters10.o and minislug.new/minislug0/monsters10.o differ
Binary files minislug.orig/minislug0/monsters20.o and minislug.new/minislug0/monsters20.o differ
Binary files minislug.orig/minislug0/monsters30.o and minislug.new/minislug0/monsters30.o differ
Binary files minislug.orig/minislug0/monsters40.o and minislug.new/minislug0/monsters40.o differ
Binary files minislug.orig/minislug0/monsters50.o and minislug.new/minislug0/monsters50.o differ
Binary files minislug.orig/minislug0/mst.o and minislug.new/minislug0/mst.o differ
Binary files minislug.orig/minislug0/preca.o and minislug.new/minislug0/preca.o differ
diff -rupN minislug.orig/minislug0/psd.c minislug.new/minislug0/psd.c
--- minislug.orig/minislug0/psd.c	2013-02-23 15:48:35.000000000 +0100
+++ minislug.new/minislug0/psd.c	2023-12-10 06:51:39.390174046 +0100
@@ -1,32 +1,44 @@
 
 #include "includes.h"
 
+/* all values in bug endian */
+struct psdheader {
+	/*  0 */ u8 magic[4];   /* "8BPS" or "8bps" */
+	/*  4 */ u8 version[2]; /* = 1 */
+	/*  6 */ u8 reserved[6];
+	/* 12 */ u8 planes[2];
+	/* 14 */ u8 height[4];
+	/* 18 */ u8 width[4];
+	/* 22 */ u8 depth[2];
+	/* 24 */ u8 mode[2];
+	/* 26 */ u8 palettesize[4];
+};
 
 
 //=============================================================================
 
 // Déprotège un fichier PSD si nécessaire.
-void PSD_Unprotect(u8 *pBuf)
+static void PSD_Unprotect(u8 *pBuf)
 {
 	char	pNorm[4] = { '8'^0x80,'B'^0x81,'P'^0x82,'S'^0x83 };		// Avec un xor pour masquer la chaîne dans l'exe.
 	char	pProt[4] = { '8'^0x80,'b'^0x81,'p'^0x82,'s'^0x83 };
 	u32	i;
 	u8	nVar8;
 
-	// Enlève le masque.
+	// Take off the mask.
 	for (i = 0; i < 4; i++)
 	{
 		pNorm[i] ^= 0x80 + i;
 		pProt[i] ^= 0x80 + i;
 	}
-	// Comparaison.
+	// Comparison.
 	if (strncmp((char *)pBuf, pProt, 4) != 0) return;
 
-	// ** Le fichier est protégé, on retire la protection.
+	// ** The file is protected, we remove the protection.
 
-	// 4 premiers octets.
-	strncpy((char *)pBuf, pNorm, 4);
-	// Remise en ordre des valeurs H et W.
+	// First 4 bytes.
+	memcpy((char *)pBuf, pNorm, 4);
+	// Reordering of H and W values.
 	nVar8 = *(((u8 *)pBuf) + 21) ^ 0x82;
 	*(((u8 *)pBuf) + 21) = *(((u8 *)pBuf) + 16) ^ 0x14;
 	*(((u8 *)pBuf) + 16) = nVar8;
@@ -40,7 +52,7 @@ void PSD_Unprotect(u8 *pBuf)
 //=============================================================================
 
 // Lecture d'un u16 au format Big Endian.
-u32	ReadBigEndianU16(u8 *pPtr)
+static u32	ReadBigEndianU16(u8 *pPtr)
 {
 	u32	nVar;
 	nVar = (pPtr[0] << 8) | pPtr[1];
@@ -48,18 +60,19 @@ u32	ReadBigEndianU16(u8 *pPtr)
 }
 
 // Lecture d'un u32 au format Big Endian.
-u32	ReadBigEndianU32(u8 *pPtr)
+static u32	ReadBigEndianU32(u8 *pPtr)
 {
 	u32	nVar;
 	nVar = (pPtr[0] << 24) | (pPtr[1] << 16) | (pPtr[2] << 8) | pPtr[3];
 	return (nVar);
 }
 
+//=============================================================================
 
 //#define	DEBUG_INFO	1	// Commenter pour supprimer.
 
 // PSD loader.
-struct SPSDPicture * PSDLoad(char *pPSDFilename)
+struct SPSDPicture * PSDLoad(const char *pPSDFilename)
 {
 	FILE	*fPt = NULL;
 	u8	*pBuf = NULL;
@@ -74,7 +87,6 @@ struct SPSDPicture * PSDLoad(char *pPSDF
 	u32	i;
 
 
-
 	//> Chargement du fichier.
 	fPt = fopen(pPSDFilename, "rb");
 	if (fPt == NULL)
@@ -148,22 +160,30 @@ struct SPSDPicture * PSDLoad(char *pPSDF
 	// Depth (2 bytes)
 	nDepth = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Depth: %d\n", (int)nDepth);
+#ifdef DEBUG_INFO
+	printf("Depth: %d\n", (int)nDepth);
+#endif
 	// Mode (2 bytes)
 	// 2 = Indexed colors.
 	nMode = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Mode: %d\n", (int)nMode);
+#ifdef DEBUG_INFO
+	printf("Mode: %d\n", (int)nMode);
+#endif
 	// Depth et Mode ok ?
 	if (nDepth != 8 || nMode != 2)
 		{ fprintf(stderr, "PSDLoad(): Unsupported format. Depth = %d, Mode = %d\n", (int)nDepth, (int)nMode); goto _PSDErr; }
 
 	// Color mode data section. Pour le mode "2", toujours 768 bytes, non entremélés => 256 R, 256 G, 256 B.
-//	printf("\nColor mode data section\n");
+#ifdef DEBUG_INFO
+	printf("\nColor mode data section\n");
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pSection = pPtr + 4;
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 	//> Palette.
 	if (nTmp != 768)
 		{ fprintf(stderr, "PSDLoad(): Palette size != 768 (%d)\n", (int)nTmp); goto _PSDErr; }
@@ -172,30 +192,44 @@ struct SPSDPicture * PSDLoad(char *pPSDF
 		pPic->pColors[i].r = *(pSection + i);
 		pPic->pColors[i].g = *(pSection + 256 + i);
 		pPic->pColors[i].b = *(pSection + 512 + i);
-//		printf("Color %d : R = %d - G = %d - B = %d\n", (int)i, (int)*(pSection + i), (int)*(pSection + 256 + i), (int)*(pSection + 512 + i));
+#ifdef DEBUG_INFO
+		printf("Color %d : R = %d - G = %d - B = %d\n", (int)i, (int)*(pSection + i), (int)*(pSection + 256 + i), (int)*(pSection + 512 + i));
+#endif
 	}
 	//<
 
 
 	// Image ressources section. (On skippe).
-//	printf("\nImage ressources section\n");
+#ifdef DEBUG_INFO
+	printf("\nImage ressources section\n");
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 
 	// Layer and mask information section. (On skippe).
-//	printf("\nLayer and mask information section\n");
-//printf("Offs = %x\n", (int)(pPtr - pBuf));
+#ifdef DEBUG_INFO
+	printf("\nLayer and mask information section\n");
+	printf("Offs = %x\n", (int)(pPtr - pBuf));
+#endif
 	nTmp = ReadBigEndianU32(pPtr);
 	pPtr += nTmp + 4;
-//	printf("Size: %d\n", (int)nTmp);
+#ifdef DEBUG_INFO
+	printf("Size: %d\n", (int)nTmp);
+#endif
 
 	// Image data section.
-//	printf("\nImage data section\n");
-//printf("Offs = %x\n", (int)(pPtr - pBuf));
+#ifdef DEBUG_INFO
+	printf("\nImage data section\n");
+	printf("Offs = %x\n", (int)(pPtr - pBuf));
+#endif
 	nComp = ReadBigEndianU16(pPtr);
 	pPtr += 2;
-//	printf("Compression method: %d\n", (int)nComp);
+#ifdef DEBUG_INFO
+	printf("Compression method: %d\n", (int)nComp);
+#endif
 
 
 /*
@@ -300,7 +334,7 @@ _PSDErr:
 }
 
 // Lecture d'une image PSD 8 bits et passage dans une surface SDL.
-SDL_Surface * PSDLoadToSDLSurf(char *pPSDFilename)
+SDL_Surface * PSDLoadToSDLSurf(const char *pPSDFilename)
 {
 	struct SPSDPicture	*pPic;
 	SDL_Surface *pSDLSurf;
diff -rupN minislug.orig/minislug0/psd.h minislug.new/minislug0/psd.h
--- minislug.orig/minislug0/psd.h	2013-02-23 15:48:38.000000000 +0100
+++ minislug.new/minislug0/psd.h	2023-12-10 06:28:18.158854928 +0100
@@ -10,7 +10,7 @@ struct SPSDPicture
 };
 
 
-struct SPSDPicture * PSDLoad(char *pPSDFilename);
-SDL_Surface * PSDLoadToSDLSurf(char *pPSDFilename);
+struct SPSDPicture * PSDLoad(const char *pPSDFilename);
+SDL_Surface * PSDLoadToSDLSurf(const char *pPSDFilename);
 
 
Binary files minislug.orig/minislug0/psd.o and minislug.new/minislug0/psd.o differ
Binary files minislug.orig/minislug0/scroll.o and minislug.new/minislug0/scroll.o differ
Binary files minislug.orig/minislug0/sfx.o and minislug.new/minislug0/sfx.o differ
Binary files minislug.orig/minislug0/sprcache.o and minislug.new/minislug0/sprcache.o differ
diff -rupN minislug.orig/minislug0/sprites.c minislug.new/minislug0/sprites.c
--- minislug.orig/minislug0/sprites.c	2013-02-23 15:48:38.000000000 +0100
+++ minislug.new/minislug0/sprites.c	2023-12-10 06:53:32.590011586 +0100
@@ -14,14 +14,17 @@
 #define	SPR_PAL_SZ	256
 #endif
 
-//#ifdef __LINUX__
-#if defined (__LINUX__) || defined (__APPLE__)
-// stricmp n'existe pas en Linux : C'est strcasecmp à la place, dans strings.h.
-int stricmp(char *pStr1, char *pStr2)
+#pragma pack(1)
+__attribute__((packed)) struct SSprite0
 {
-	return (strcasecmp(pStr1, pStr2));
-}
-#endif
+	s16	nPtRefX, nPtRefY;	// Points de ref.
+	u16	nLg, nHt;			// Largeur et hauteur du sprite.
+	u32	nGfx8Offset;	// Pour stockage temporaire de l'offset pendant la lecture des planches.
+	u16	nRemapPalNo;		// N° de la palette de remappage.
+
+	struct SSprRect	pRect[SPRRECT_MAX_ZONES];	// Rectangles, points...
+};
+#pragma pack()
 
 
 // Pour capture des sprites.
@@ -94,7 +97,7 @@ void SprInitEngine(void)
 }
 
 // Secure fopen.
-FILE * sec_fopen(char *pFilename, char *pMode)
+static FILE * sec_fopen(const char *pFilename, const char *pMode)
 {
 	FILE	*fPt;
 
@@ -133,7 +136,7 @@ u32 SprChecksum(u8 *pData, u32 nDataSz)
 }
 
 #if SPR_SAVE == 1		// Lecture des fichiers graphiques et sauvegarde des datas.
-void SprBinSave_sub(char *pFilename, u8 *pSrc, u32 nSavSz)
+void SprBinSave_sub(const char *pFilename, u8 *pSrc, u32 nSavSz)
 {
 	FILE	*fPt;
 	u32	nSz;
@@ -158,7 +161,7 @@ void SprBinariesSave(void)
 {
 	// Définitions.
 #if defined (CPU64)
-	SprBinSave_sub("gfx/sprdef64.bin", (u8 *)gpSprDef, sizeof(struct SSprite) * gnSprNbSprites);
+	SprBinSave_sub("gfx/sprdef64.bin", (u8 *)gpSprDef, xsizeof(struct SSprite) * gnSprNbSprites);
 #else
 	SprBinSave_sub("gfx/sprdef.bin", (u8 *)gpSprDef, sizeof(struct SSprite) * gnSprNbSprites);
 #endif
@@ -169,7 +172,7 @@ void SprBinariesSave(void)
 
 }
 #else
-u8 * SprBinLoad_sub(char *pFilename, u32 *pnSz)
+static u8 * SprBinLoad_sub(const char *pFilename, u32 *pnSz)
 {
 	FILE	*fPt;
 	u32	nSz1, nSz2, nSz3;
@@ -922,13 +925,13 @@ void SprLoadPSD(char *pFilename)
 void SprLoadGfx(char *pFilename)//, SDL_Color *pSprPal, u32 nPalIdx)
 {
 	// On regarde l'extension du fichier.
-	if (stricmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
+	if (strcasecmp(pFilename + strlen(pFilename) - 3, "bmp") == 0)
 	{
 		// Extraction des sprites depuis un BMP.
 		SprLoadBMP(pFilename);//pSprPal, nPalIdx);
 	}
 	else
-	if (stricmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
+	if (strcasecmp(pFilename + strlen(pFilename) - 3, "psd") == 0)
 	{
 		// Extraction des sprites depuis un PSD.
 		SprLoadPSD(pFilename);//, pSprPal, nPalIdx);
diff -rupN minislug.orig/minislug0/sprites.h minislug.new/minislug0/sprites.h
--- minislug.orig/minislug0/sprites.h	2013-02-23 15:48:37.000000000 +0100
+++ minislug.new/minislug0/sprites.h	2023-12-10 06:53:16.583367891 +0100
@@ -23,18 +23,15 @@ enum
 };
 
 #pragma pack(1)
-struct SSprRect
+__attribute__((packed)) struct SSprRect
 {
-//	u32	nType;
-//	s32	nX1, nY1, nX2, nY2;
 	u16	nType;
 	s16	nX1, nY1, nX2, nY2;
 };
+#pragma pack()
 
 struct SSprite
 {
-//	s32	nPtRefX, nPtRefY;	// Points de ref.
-//	u32	nLg, nHt;			// Largeur et hauteur du sprite.
 	s16	nPtRefX, nPtRefY;	// Points de ref.
 	u16	nLg, nHt;			// Largeur et hauteur du sprite.
 	union
@@ -42,19 +39,16 @@ struct SSprite
 		u8	*pGfx8;
 		u32	nGfx8Offset;	// Pour stockage temporaire de l'offset pendant la lecture des planches.
 	};
-//	u32	nRemapPalNo;		// N° de la palette de remappage.
 	u16	nRemapPalNo;		// N° de la palette de remappage.
 
 	struct SSprRect	pRect[SPRRECT_MAX_ZONES];	// Rectangles, points...
-
 };
-#pragma pack()
 
 
 // Prototypes.
 void SprInitEngine(void);
 void SprRelease(void);
-void SprLoadGfx(char *pFilename);
+void SprLoadGfx(const char *pFilename);
 void SprEndCapture(void);
 
 void SprPaletteConversion(void);
@@ -76,10 +70,3 @@ void SprDisplayAll_Pass2(void);
 struct SSprite *SprGetDesc(u32 nSprNo);
 u32 SprCheckColBox(u32 nSpr1, s32 nPosX1, s32 nPosY1, u32 nSpr2, s32 nPosX2, s32 nPosY2);
 u32 SprGetRect(u32 nSprNo, u32 nZone, struct SSprRect *pRectDst);
-
-//#ifdef __LINUX__
-#if defined (__LINUX__) || defined (__APPLE__)
-int stricmp(char *pStr1, char *pStr2);
-#endif
-
-
Binary files minislug.orig/minislug0/sprites.o and minislug.new/minislug0/sprites.o differ
Binary files minislug.orig/minislug0/sprrz.o and minislug.new/minislug0/sprrz.o differ
Binary files minislug.orig/minislug0/swapdata and minislug.new/minislug0/swapdata differ
diff -rupN minislug.orig/minislug0/swapdata.c minislug.new/minislug0/swapdata.c
--- minislug.orig/minislug0/swapdata.c	1970-01-01 01:00:00.000000000 +0100
+++ minislug.new/minislug0/swapdata.c	2023-12-09 19:27:08.655114067 +0100
@@ -0,0 +1,803 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include "ctypes.h"
+#include "menu.h"
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE 1
+#endif
+
+/*
+ * cannot use "sprites.h" here,
+ * because the void * in the union is not saved to the file
+ * Make sure these structures match
+ */
+#define	SPRRECT_MAX_ZONES	3
+__attribute__((packed)) struct SSprRect
+{
+	u16	nType;
+	s16	nX1, nY1, nX2, nY2;
+};
+
+__attribute__((packed)) struct SSprite
+{
+	s16	nPtRefX, nPtRefY;
+	u16	nLg, nHt;
+	u32	nGfx8Offset;
+	u16	nRemapPalNo;
+
+	struct SSprRect	pRect[SPRRECT_MAX_ZONES];
+};
+
+
+
+#define swap32(x) __builtin_bswap32(x)
+#define swap16(x) __builtin_bswap16(x)
+
+int to_foreign = TRUE;
+
+
+static u32 SprChecksum(u8 *pdata, u32 nDataSz, int swap)
+{
+	u32	i;
+	u32	nRem;
+	u32	nSum;
+	u32 d;
+	u32 *p32data;
+	
+	nRem = nDataSz & 3;
+	nDataSz >>= 2;
+	nSum = 0;
+	p32data = (uint32_t *)pdata;
+	for (i = 0; i < nDataSz; i++)
+	{
+		d = *p32data;
+		if (swap)
+			d = swap32(d);
+		nSum += d;
+		p32data++;
+	}
+	pdata = (uint8_t *)p32data;
+	for (i = 0; i < nRem; i++)
+	{
+		nSum += *pdata;
+		pdata++;
+	}
+
+	return nSum;
+}
+
+
+static int swap_binsave(const char *filename)
+{
+	FILE *fp;
+	size_t nSz, nSz2, nSz3;
+	uint32_t nChkRead, nChkCalc;
+	u8 *pBuf;
+	uint32_t NbSprites;
+	uint32_t t;
+	int swapped;
+	struct SSprite *s;
+	
+	if ((fp = fopen(filename, "rb")) == NULL)
+	{
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		return FALSE;
+	}
+	fseek(fp, 0, SEEK_END);
+	nSz = ftell(fp);
+	fseek(fp, 0, SEEK_SET);
+	if (nSz <= sizeof(u32))
+	{
+		fprintf(stderr, "%s: Wrong file size (%d bytes).\n", filename, (int)nSz);
+		fclose(fp);
+		return FALSE;
+	}
+	nSz -= sizeof(u32);
+		
+	if ((pBuf = (u8 *)malloc(nSz)) == NULL)
+	{
+		fclose(fp);
+		fprintf(stderr, "swap_binsave(): malloc error.\n");
+		return FALSE;
+	}
+
+	nSz2 = fread(pBuf, 1, nSz, fp);
+	nSz3 = fread(&nChkRead, 1, sizeof(u32), fp);
+	fclose(fp);
+	NbSprites = nSz / sizeof(struct SSprite);
+
+	if (nSz != nSz2 || nSz3 != sizeof(u32) || (NbSprites * sizeof(struct SSprite)) != nSz)
+	{
+		free(pBuf);
+		fprintf(stderr, "%s: Error while reading file, wrong size.\n", filename);
+		return FALSE;
+	}
+	s = (struct SSprite *)pBuf;
+
+	/*
+	 * no magic in the files :(
+	 * we can only guess by looking at the sprite offsets
+	 */
+	swapped = FALSE;
+	for (t = 0; t < NbSprites; t++)
+	{
+		if (s[t].nGfx8Offset > 0x1000000)
+			swapped = TRUE;
+	}
+
+	if (swapped)
+	{
+		free(pBuf);
+		fprintf(stderr, "swap_binsave(%s): already swapped\n", filename);
+		return TRUE;
+	}
+
+	if (!to_foreign)
+		nChkRead = swap32(nChkRead);
+
+	nChkCalc = SprChecksum(pBuf, nSz, !to_foreign);
+
+	if (nChkCalc != nChkRead)
+	{
+		fprintf(stderr, "%s: Data has been corrupted. Aborted. %08x != %08x\n", filename, nChkRead, nChkCalc);
+		free(pBuf);
+		return FALSE;
+	}
+	{
+		int i;
+	
+		for (t = 0; t < NbSprites; t++)
+		{
+			s[t].nPtRefX = swap16(s[t].nPtRefX);
+			s[t].nPtRefY = swap16(s[t].nPtRefY);
+			s[t].nLg = swap16(s[t].nLg);
+			s[t].nHt = swap16(s[t].nHt);
+			s[t].nGfx8Offset = swap32(s[t].nGfx8Offset);
+			s[t].nRemapPalNo = swap16(s[t].nRemapPalNo);
+			for (i = 0; i < SPRRECT_MAX_ZONES; i++)
+			{
+				s[t].pRect[i].nType = swap16(s[t].pRect[i].nType);
+				s[t].pRect[i].nX1 = swap16(s[t].pRect[i].nX1);
+				s[t].pRect[i].nY1 = swap16(s[t].pRect[i].nY1);
+				s[t].pRect[i].nX2 = swap16(s[t].pRect[i].nX2);
+				s[t].pRect[i].nY2 = swap16(s[t].pRect[i].nY2);
+			}
+		}
+	}
+
+	if ((fp = fopen(filename, "wb")) == NULL)
+	{
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		free(pBuf);
+		return FALSE;
+	}
+	nChkCalc = SprChecksum(pBuf, nSz, to_foreign);
+	nChkRead = to_foreign ? swap32(nChkCalc) : nChkCalc;
+
+	nSz2 = fwrite(pBuf, 1, nSz, fp);
+	nSz3 = fwrite(&nChkRead, 1, sizeof(u32), fp);
+	fclose(fp);
+	free(pBuf);
+	
+	if (nSz != nSz2 || nSz3 != sizeof(u32))
+	{
+		fprintf(stderr, "%s: %s.\n", filename, strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+
+static int swap_bin(const char *filename)
+{
+	FILE *fp;
+	size_t nSz, nSz2, nSz3;
+	uint32_t nChkRead, nChkCalc;
+	u8 *pBuf;
+	
+	if ((fp = fopen(filename, "rb")) == NULL)
+	{
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		return FALSE;
+	}
+	fseek(fp, 0, SEEK_END);
+	nSz = ftell(fp);
+	fseek(fp, 0, SEEK_SET);
+	if (nSz <= sizeof(u32))
+	{
+		fprintf(stderr, "%s: Wrong file size (%d bytes).\n", filename, (int)nSz);
+		fclose(fp);
+		return FALSE;
+	}
+	nSz -= sizeof(u32);
+		
+	if ((pBuf = (u8 *)malloc(nSz)) == NULL)
+	{
+		fclose(fp);
+		fprintf(stderr, "swap_binsave(): malloc error.\n");
+		return FALSE;
+	}
+
+	nSz2 = fread(pBuf, 1, nSz, fp);
+	nSz3 = fread(&nChkRead, 1, sizeof(u32), fp);
+	fclose(fp);
+
+	if (nSz != nSz2 || nSz3 != sizeof(u32))
+	{
+		free(pBuf);
+		fprintf(stderr, "%s: Error while reading file, wrong size.\n", filename);
+		return FALSE;
+	}
+
+	if (!to_foreign)
+		nChkRead = swap32(nChkRead);
+
+	nChkCalc = SprChecksum(pBuf, nSz, !to_foreign);
+
+	if (nChkCalc != nChkRead)
+	{
+		nChkCalc = SprChecksum(pBuf, nSz, to_foreign);
+		if (nChkCalc != swap32(nChkRead))
+		{
+			fprintf(stderr, "%s: Data has been corrupted. Aborted. %08x != %08x\n", filename, nChkRead, nChkCalc);
+			free(pBuf);
+			return FALSE;
+		}
+	}
+
+	/*
+	 * nothing to swap. Just have to update checksum
+	 */
+	if ((fp = fopen(filename, "wb")) == NULL)
+	{
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		free(pBuf);
+		return FALSE;
+	}
+	nChkCalc = SprChecksum(pBuf, nSz, to_foreign);
+	nChkRead = to_foreign ? swap32(nChkCalc) : nChkCalc;
+
+	nSz2 = fwrite(pBuf, 1, nSz, fp);
+	nSz3 = fwrite(&nChkRead, 1, sizeof(u32), fp);
+	fclose(fp);
+	free(pBuf);
+	
+	if (nSz != nSz2 || nSz3 != sizeof(u32))
+	{
+		fprintf(stderr, "%s: %s.\n", filename, strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+
+static u32 CfgChecksumCalc(struct SMSCfg *cfg, int swap)
+{
+	int i;
+	u32 nSum = 0;
+	u16 d;
+	
+	for (i = 0; i < e_CfgKey_MAX; i++)
+	{
+		d = cfg->pKeys[i];
+		if (swap)
+			d = swap16(d);
+		nSum += d;
+	}
+	d = cfg->nVideoMode;
+	if (swap)
+		d = swap16(d);
+	nSum += d;
+
+	if (swap)
+		nSum = swap16(nSum);
+	return nSum;
+}
+
+
+#define SDLK_UP 273
+
+static int swap_cfg(const char *filename)
+{
+	FILE *fp;
+	size_t nSz;
+	u16 cksum;
+	struct SMSCfg cfg;
+	int i;
+
+	fp = fopen(filename, "rb");
+	if (fp == NULL)
+	{
+		fprintf(stderr, "%s: %s.\n", filename, strerror(errno));
+		return FALSE;
+	}
+	nSz = fread(&cfg, 1, sizeof(cfg), fp);
+	fclose(fp);
+	if (nSz != sizeof(cfg))
+	{
+		fprintf(stderr, "swap_cfg(): read error.\n");
+		return FALSE;
+	}
+	if (cfg.pKeys[e_CfgKey_Up] == (to_foreign ? swap16(SDLK_UP) : SDLK_UP))
+	{
+		fprintf(stderr, "%s: already swapped.\n", filename);
+		return TRUE;
+	}
+
+	cksum = CfgChecksumCalc(&cfg, !to_foreign);
+	if (cfg.nChecksum != cksum)
+	{
+		fprintf(stderr, "%s: Checksum error.\n", filename);
+		return FALSE;
+	}
+	for (i = 0; i < e_CfgKey_MAX; i++)
+		cfg.pKeys[i] = swap16(cfg.pKeys[i]);
+	cfg.nVideoMode = swap16(cfg.nVideoMode);
+	cfg.nChecksum = CfgChecksumCalc(&cfg, to_foreign);
+
+	fp = fopen(filename, "wb");
+	if (fp == NULL)
+	{
+		fprintf(stderr, "%s: %s.\n", filename, strerror(errno));
+		return FALSE;
+	}
+
+	nSz = fwrite(&cfg, 1, sizeof(cfg), fp);
+	fclose(fp);
+	if (nSz != sizeof(cfg))
+	{
+		fprintf(stderr, "swap_cfg(): write error.\n");
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+#define LEVEL_VERSION 0x100
+
+struct SContainer0
+{
+	u32	nSz;
+	u16	nType;
+	u16	nPadding;
+};
+
+struct SMst0
+{
+	u32	nPosX, nPosY;
+	u16	nMstNo;		// = Block no..
+	u16	nNbBytes;	// Number of bytes used.
+};
+
+struct SMap
+{
+	u32	nMapLg;
+	u32	nMapHt;
+	u32	nPlanesNb;
+
+	u32	nHeroPlane;
+
+	u32	nPathGndNb;					// Nb de blocs de path.
+	u32	nPathAirNb;					// Nb de blocs de path.
+
+	u32	nPlayerStartPosX, nPlayerStartPosY;
+
+	u32	nTranspColorKey;			// Valeur à passer à SDL_SetColorKey() pour la transparence des plans.
+};
+
+struct SMap0
+{
+	u32	nMapLg, nMapHt, nMapPosX, nMapPosY, nPlanesNb, nFirstWnd, nActivePlane;
+};
+
+enum
+{
+	e_FileSection_Map = 0,
+	e_FileSection_Plane,
+	e_FileSection_Cmd,
+	e_FileSection_Misc,
+};
+
+struct SPlane2
+{
+	u32	nPlaneNo, nFlags, nWndPosX, nWndPosY;
+	u32	nBlkLg, nBlkHt;
+	u8 nHasCmd;
+	u8 nPad0, nPad1, nPad2;
+};
+
+struct SMisc0
+{
+	u32	nFlags;						// gMisc.nFlags.
+	u8	nTransR, nTransG, nTransB;	// RGB de la couleur de transparence.
+	u8	nPad0;						// Padding.
+	u16	nVisuLg, nVisuHt;			// Taille de la visu (en pixels).
+
+	u32	nBlank0, nBlank1, nBlank2, nBlank3, nChecksum;	// Au cas ou on ait besoin de sauver plus de trucs par la suite.
+};
+
+#define	MAP_BLK_HERO	120
+#define	MAP_BLK_PATH_GND_MIN	80
+#define	MAP_BLK_PATH_GND_MAX	97
+#define	MAP_BLK_PATH_AIR_MIN	100
+#define	MAP_BLK_PATH_AIR_MAX	117
+
+#define	e_FlgFile_Plane_Codes	((u32)1 << 31)		// Lecture/sauvegarde d'une page de code.
+
+static int swap_level(const char *filename)
+{
+	FILE *fp;
+	size_t nFileSzToLoad, nSz, nSz2;
+	u8 *pBuf, *p, *pCur, *pContainer;
+	u16 nVersion;
+	u32 tmp;
+	struct SMap gMap;
+	u32	nType;
+	u32	nMapSection = 0;
+	u32	nPlaneNext = 0;
+	u32 j;
+	u32	nPlaneSav_BlkLg, nPlaneSav_BlkHt, nFlags, nPlaneNo;
+
+	if ((fp = fopen(filename, "rb")) == NULL)
+	{
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		return FALSE;
+	}
+	fseek(fp, 0, SEEK_END);
+	nFileSzToLoad = ftell(fp);
+	fseek(fp, 0, SEEK_SET);
+	if (nFileSzToLoad <= 5)
+	{
+		fprintf(stderr, "%s: Wrong file size (%d bytes).\n", filename, (int)nFileSzToLoad);
+		fclose(fp);
+		return FALSE;
+	}
+		
+	if ((pBuf = (u8 *)malloc(nFileSzToLoad)) == NULL)
+	{
+		fclose(fp);
+		fprintf(stderr, "swap_binsave(): malloc error.\n");
+		return FALSE;
+	}
+
+	nSz2 = fread(pBuf, 1, nFileSzToLoad, fp);
+	fclose(fp);
+
+	if (nFileSzToLoad != nSz2)
+	{
+		free(pBuf);
+		fprintf(stderr, "%s: Error while reading file, wrong size.\n", filename);
+		return FALSE;
+	}
+
+	memcpy(&nVersion, pBuf + 3, sizeof(nVersion));
+	if (strncmp((char *)pBuf, "EDT", 3) != 0)
+	{
+		free(pBuf);
+		fprintf(stderr, "%s: Wrong header.\n", filename);
+		return FALSE;
+	}
+	
+	if (nVersion == (to_foreign ? swap16(LEVEL_VERSION) : LEVEL_VERSION))
+	{
+		free(pBuf);
+		fprintf(stderr, "swap_level(%s): already swapped\n", filename);
+		return TRUE;
+	}
+	nVersion = swap16(nVersion);
+	if (nVersion != (to_foreign ? swap16(LEVEL_VERSION) : LEVEL_VERSION))
+	{
+		free(pBuf);
+		fprintf(stderr, "swap_level(%s): Magic number not found. Aborted.\n", filename);
+		return FALSE;
+	}
+
+	gMap.nPlanesNb = 0;
+	gMap.nHeroPlane = 0;
+	gMap.nMapLg = 0;
+	gMap.nMapHt = 0;
+
+	p = pBuf;
+
+	for (;;)
+	{
+		if (nSz2 < sizeof(struct SContainer0))
+			break;
+
+		{
+			struct SContainer0 *scont0 = (struct SContainer0 *)p;
+
+			tmp = scont0->nSz;
+			scont0->nSz = swap32(tmp);
+			if (!to_foreign) tmp = swap32(tmp);
+			nSz = tmp;
+			tmp = scont0->nType;
+			scont0->nType = swap16(tmp);
+			if (!to_foreign) tmp = swap16(tmp);
+			nType = tmp;
+			scont0->nPadding = swap16(scont0->nPadding);
+
+			pContainer = p;
+			p += sizeof(struct SContainer0);
+		}
+		
+		switch (nType)
+		{
+		case e_FileSection_Map:
+			if (nMapSection)
+			{
+				fprintf(stderr, "%s: Duplicate map section found! Section ignored.\n", filename);
+			} else
+			{
+				struct SMap0 *map0 = (struct SMap0 *) p;
+				
+				tmp = map0->nMapLg;
+				map0->nMapLg = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				gMap.nMapLg = tmp;
+				tmp = map0->nMapHt;
+				map0->nMapHt = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				gMap.nMapHt = tmp;
+				map0->nMapPosX = swap32(map0->nMapPosX);
+				map0->nMapPosY = swap32(map0->nMapPosY);
+				map0->nPlanesNb = swap32(map0->nPlanesNb);
+				map0->nFirstWnd = swap32(map0->nFirstWnd);
+				map0->nActivePlane = swap32(map0->nActivePlane);
+				
+				gMap.nPlayerStartPosX = 5;
+				gMap.nPlayerStartPosY = 5;
+
+				nMapSection = 1;
+			}
+			break;
+
+		case e_FileSection_Plane:
+			{
+				struct SPlane2 *splane2 = (struct SPlane2 *)p;
+
+				if (nMapSection == 0)
+				{
+					fprintf(stderr, "%s: Plane section found prior to map section! Section ignored.\n", filename);
+					break;
+				}
+				tmp = splane2->nPlaneNo;
+				splane2->nPlaneNo = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				nPlaneNo = tmp;
+
+				tmp = splane2->nFlags;
+				splane2->nFlags = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				nFlags = tmp;
+				splane2->nWndPosX = swap32(splane2->nWndPosX);
+				splane2->nWndPosX = swap32(splane2->nWndPosY);
+		
+				tmp = splane2->nBlkLg;
+				splane2->nBlkLg = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				nPlaneSav_BlkLg = tmp;
+				tmp = splane2->nBlkHt;
+				splane2->nBlkHt = swap32(tmp);
+				if (!to_foreign) tmp = swap32(tmp);
+				nPlaneSav_BlkHt = tmp;
+
+				if (nPlaneNo != nPlaneNext)
+				{
+					fprintf(stderr, "%s: Plane section: Wrong plane number found. Section ignored.\n", filename);
+					break;
+				}
+	
+				if (splane2->nHasCmd)
+				{
+					s32 *p32;
+					pCur = p + sizeof(struct SPlane2);
+					j = *pCur;
+					pCur++;
+					pCur += j;
+	
+					gMap.nPathGndNb = 0;
+					gMap.nPathAirNb = 0;
+					p32 = (s32 *)pCur;
+					for (j = 0; j < gMap.nMapLg * gMap.nMapHt; j++)
+					{
+						tmp = p32[j];
+						p32[j] = swap32(tmp);
+						if (!to_foreign) tmp = swap32(tmp);
+						
+						if (tmp == MAP_BLK_HERO)
+						{
+							u32 nBlX, nBlY;
+
+							nBlY = j / gMap.nMapLg;
+							nBlX = j - (nBlY * gMap.nMapLg);
+							gMap.nPlayerStartPosX = nBlX;
+							gMap.nPlayerStartPosY = nBlY;
+							gMap.nHeroPlane = gMap.nPlanesNb - 1;
+						}
+
+						if (tmp >= MAP_BLK_PATH_GND_MIN && tmp <= MAP_BLK_PATH_GND_MAX)
+							gMap.nPathGndNb++;
+						if (tmp >= MAP_BLK_PATH_AIR_MIN && tmp <= MAP_BLK_PATH_AIR_MAX)
+							gMap.nPathAirNb++;
+					}
+
+					nPlaneNext++;
+					break;
+				}
+
+				pCur = p + sizeof(struct SPlane2);
+	
+				j = *pCur;
+				pCur++;
+				pCur += j;
+	
+				if (nFlags & e_FlgFile_Plane_Codes)
+				{
+					pCur += nPlaneSav_BlkLg * nPlaneSav_BlkHt;
+				}
+				{
+					s32 *p32;
+					u32 ri, rj;
+					
+					p32 = (s32 *)pCur;
+					
+					for (j = 0; j < gMap.nMapLg * gMap.nMapHt; j++)
+					{
+						tmp = p32[j];
+						p32[j] = swap32(tmp);
+					}
+					for (ri = 0; ri < gMap.nMapLg; ri++)
+						if (p32[ri] == -1)
+							break;
+					for (rj = 0; rj < gMap.nMapHt; rj++)
+						if (p32[rj * gMap.nMapLg] == -1)
+							break;
+					if (ri == 0 || rj == 0)
+					{
+						free(pBuf);
+						fprintf(stderr, "%s: Plane %d: Null plane size found! (w=%d, h=%d). Aborted.\n",
+							filename, (int) gMap.nPlanesNb, (int) ri, (int) rj);
+						return FALSE;
+					}
+				}
+				
+				gMap.nPlanesNb++;
+				nPlaneNext++;
+			}
+			break;
+
+		case e_FileSection_Cmd:
+			if (nMapSection == 0)
+			{
+				fprintf(stderr, "%s: Cmd section found prior to map section! Section ignored.\n", filename);
+				break;
+			}
+
+			pCur = pBuf;
+
+			/* skip filename */
+			j = *pCur;
+			pCur++;
+			pCur += j;
+			
+			/* Date */
+			tmp = *(u32 *)pCur;
+			*(u32 *)pCur = swap32(tmp);
+			pCur += 4;
+			
+			/* cmd size */
+			tmp = *(u32 *)pCur;
+			*(u32 *)pCur = swap32(tmp);
+			if (!to_foreign) tmp = swap32(tmp);
+			j = tmp;
+			pCur += 4;
+			
+			{
+				u8 *pSrcPt;
+				u32 nb;
+
+				pSrcPt = pCur;
+				nb = j;
+				while (nb)
+				{
+					struct SMst0 *mst = (struct SMst0 *)pSrcPt;
+					mst->nPosX = swap32(mst->nPosX);
+					mst->nPosY = swap32(mst->nPosY);
+					mst->nMstNo = swap16(mst->nMstNo);
+					tmp = mst->nNbBytes;
+					mst->nNbBytes = swap16(tmp);
+					if (!to_foreign) tmp = swap16(tmp);
+					pSrcPt += sizeof(struct SMst0);
+					pSrcPt += tmp;
+					nb--;
+				}
+			}
+
+			break;
+
+		case e_FileSection_Misc:
+			{
+				struct SMisc0 *m = (struct SMisc0 *)p;
+				
+				m->nFlags = swap32(m->nFlags);
+				m->nVisuLg = swap16(m->nVisuLg);
+				m->nVisuHt = swap16(m->nVisuHt);
+				m->nBlank0 = swap32(m->nBlank0);
+				m->nBlank1 = swap32(m->nBlank1);
+				m->nBlank2 = swap32(m->nBlank2);
+				m->nBlank3 = swap32(m->nBlank3);
+				m->nChecksum = swap32(m->nChecksum);
+			}
+			break;
+		
+		default:
+			free(pBuf);
+			fprintf(stderr, "%s: unknown container type %d\n", filename, nType);
+			return FALSE;
+		}
+		
+		p = pContainer + nSz;
+		if (nSz > nSz2)
+		{
+			free(pBuf);
+			fprintf(stderr, "%s: file corrupted\n", filename);
+			return FALSE;
+		}
+		nSz2 -= nSz;
+	}
+	
+	if ((fp = fopen(filename, "wb")) == NULL)
+	{
+		free(pBuf);
+		fprintf(stderr, "%s: %s\n", filename, strerror(errno));
+		return FALSE;
+	}
+
+	nSz2 = fwrite(pBuf, 1, nFileSzToLoad, fp);
+	fclose(fp);
+	free(pBuf);
+	
+	if (nFileSzToLoad != nSz2)
+	{
+		fprintf(stderr, "%s: %s.\n", filename, strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+int main(int argc, char **argv)
+{
+	int ret = TRUE;
+	int i;
+	
+	to_foreign = TRUE;
+	argc--;
+	argv++;
+	if (argc >= 1 && strcmp(argv[0], "-l") == 0)
+	{
+		to_foreign = FALSE;
+		argc--;
+		argv++;
+	}
+	
+	ret &= swap_binsave("gfx/sprdef.bin");
+	ret &= swap_bin("gfx/sprpal.bin");
+	ret &= swap_bin("gfx/sprbuf.bin");
+	ret &= swap_cfg("mslug.cfg");
+	for (i = 0; i < argc; i++)
+		ret &= swap_level(argv[i]);
+
+	return ret ? 0 : 1;
+}
Binary files minislug.orig/minislug0/transit2d.o and minislug.new/minislug0/transit2d.o differ
Binary files minislug.orig/minislug0/vgcore.15504 and minislug.new/minislug0/vgcore.15504 differ
Binary files minislug.orig/minislug0/vgcore.15811 and minislug.new/minislug0/vgcore.15811 differ
Binary files minislug.orig/minislug0/vgcore.16039 and minislug.new/minislug0/vgcore.16039 differ
diff -rupN minislug.orig/minislug0/ymlib/LzhLib.cpp minislug.new/minislug0/ymlib/LzhLib.cpp
--- minislug.orig/minislug0/ymlib/LzhLib.cpp	2012-10-16 23:48:52.000000000 +0200
+++ minislug.new/minislug0/ymlib/LzhLib.cpp	2023-12-09 11:02:58.592333494 +0100
@@ -32,6 +32,7 @@
 -----------------------------------------------------------------------------*/
 
 #include <memory.h>
+#include <string.h>
 #include "YmTypes.h"
 #include "LZH.H"
 
Binary files minislug.orig/minislug0/ymlib/LzhLib.o and minislug.new/minislug0/ymlib/LzhLib.o differ
diff -rupN minislug.orig/minislug0/ymlib/Makefile minislug.new/minislug0/ymlib/Makefile
--- minislug.orig/minislug0/ymlib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ minislug.new/minislug0/ymlib/Makefile	2023-12-10 07:20:58.280975681 +0100
@@ -0,0 +1,21 @@
+# Makefile to build the static lib 'libymlib.a'
+
+TARGET = libymlib.a 
+OBJECTS = digidrum.o Ym2149Ex.o YmMusic.o LzhLib.o YmLoad.o YmUserInterface.o
+
+CFLAGS = $(CPU_CFLAGS) -O0 -g -Wall -Wno-write-strings -DNDEBUG 
+LDFLAGS = -s
+CXX = $(CROSS_PREFIX)g++
+
+all: $(TARGET)
+
+$(TARGET): $(OBJECTS)
+	rm -f $@
+	$(CROSS_PREFIX)ar rcs -o $@ $^ 
+
+.cpp.o:
+	$(CXX) $(CFLAGS) -c -o $@ $< 
+
+clean:
+	rm -f $(OBJECTS) $(TARGET)
+
diff -rupN minislug.orig/minislug0/ymlib/Ym2149Ex.cpp minislug.new/minislug0/ymlib/Ym2149Ex.cpp
--- minislug.orig/minislug0/ymlib/Ym2149Ex.cpp	2012-10-16 23:48:52.000000000 +0200
+++ minislug.new/minislug0/ymlib/Ym2149Ex.cpp	2023-12-10 07:31:07.843430340 +0100
@@ -236,6 +236,8 @@ void	CYm2149Ex::reset(void)
 {
 
 	for (int i=0;i<14;i++)
+		registers[i] = 0;
+	for (int i=0;i<14;i++)
 		writeRegister(i,0);
 
 	writeRegister(7,0xff);
Binary files minislug.orig/minislug0/ymlib/Ym2149Ex.o and minislug.new/minislug0/ymlib/Ym2149Ex.o differ
diff -rupN minislug.orig/minislug0/ymlib/YmLoad.h minislug.new/minislug0/ymlib/YmLoad.h
--- minislug.orig/minislug0/ymlib/YmLoad.h	2012-10-16 23:48:52.000000000 +0200
+++ minislug.new/minislug0/ymlib/YmLoad.h	2023-12-10 03:41:04.787037658 +0100
@@ -47,7 +47,7 @@ typedef struct
 	ymu8	reserved[5];
 	ymu8	level;
 	ymu8	name_lenght;
-} lzhHeader_t;
+} __attribute__((packed)) lzhHeader_t;
 #pragma pack()
 
 #ifdef __cplusplus
Binary files minislug.orig/minislug0/ymlib/YmLoad.o and minislug.new/minislug0/ymlib/YmLoad.o differ
Binary files minislug.orig/minislug0/ymlib/YmMusic.o and minislug.new/minislug0/ymlib/YmMusic.o differ
Binary files minislug.orig/minislug0/ymlib/YmUserInterface.o and minislug.new/minislug0/ymlib/YmUserInterface.o differ
Binary files minislug.orig/minislug0/ymlib/digidrum.o and minislug.new/minislug0/ymlib/digidrum.o differ
Binary files minislug.orig/minislug0/ymlib/libymlib.a and minislug.new/minislug0/ymlib/libymlib.a differ
diff -rupN minislug.orig/psdprot0/Makefile minislug.new/psdprot0/Makefile
--- minislug.orig/psdprot0/Makefile	2012-10-02 22:35:10.000000000 +0200
+++ minislug.new/psdprot0/Makefile	2023-12-10 07:10:44.781859957 +0100
@@ -1,17 +1,17 @@
 # Mon Makefile
-#PATH = /usr/include/SDL
-TARGET = psdprot 
+TARGET = psdprot
 OBJECTS = main.o
  
-CFLAGS = -O3 -Wall -I/usr/include/SDL -L/usr/lib -fno-strict-aliasing -D__LINUX__ 
+CFLAGS = $(CPU_CFLAGS) -O2 -fomit-frame-pointer -Wall -fno-strict-aliasing
+LDFLAGS = -s
 LIBS = 
-CC = gcc
+CC = $(CROSS_PREFIX)gcc
 
 all: $(TARGET)
 
 $(TARGET): $(OBJECTS)
-	$(CC) $(CFLAGS) -o $@ $^ $(LIBS) 
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) 
 
 clean:
-	rm $(TARGET) $(OBJECTS)
+	rm -f $(TARGET) $(OBJECTS)
 
diff -rupN minislug.orig/psdprot0/main.c minislug.new/psdprot0/main.c
--- minislug.orig/psdprot0/main.c	2012-09-09 13:06:26.000000000 +0200
+++ minislug.new/psdprot0/main.c	2023-12-10 07:00:16.526098541 +0100
@@ -3,14 +3,12 @@
 // Clément '17o2!!' CORDE
 
 
-#ifdef __LINUX__
-//	#include <unistd.h>		// chdir()
-	#include <strings.h>
-	#include <sys/types.h>
-	#include <dirent.h>
-	#include <errno.h>
-#endif
-#ifdef WIN32
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <errno.h>
+#ifdef _WIN32
 	#include <windows.h>
 	#include <direct.h>		// _chdir()
 #endif
@@ -94,7 +92,7 @@ u32 PSD_Protect(u8 *pBuf)
 	if (gPrm.nMode == e_Mode_Protect)
 	{ // Protection.
 		// 4 premiers octets.
-		strncpy((char *)pBuf, pProt, 4);
+		memcpy((char *)pBuf, pProt, 4);
 		// Mélange des valeurs H et W.
 		nVar8 = *(((u8 *)pBuf) + 16) ^ 0x82;
 		*(((u8 *)pBuf) + 16) = *(((u8 *)pBuf) + 21) ^ 0x14;
@@ -108,7 +106,7 @@ u32 PSD_Protect(u8 *pBuf)
 	else
 	{ // Déprotection.
 		// 4 premiers octets.
-		strncpy((char *)pBuf, pNorm, 4);
+		memcpy((char *)pBuf, pNorm, 4);
 		// Remise en ordre des valeurs H et W.
 		nVar8 = *(((u8 *)pBuf) + 21) ^ 0x82;
 		*(((u8 *)pBuf) + 21) = *(((u8 *)pBuf) + 16) ^ 0x14;
@@ -126,14 +124,6 @@ u32 PSD_Protect(u8 *pBuf)
 
 //=============================================================================
 
-#ifdef __LINUX__
-// stricmp n'existe pas en Linux : C'est strcasecmp à la place, dans strings.h.
-int stricmp(char *pStr1, char *pStr2)
-{
-	return (strcasecmp(pStr1, pStr2));
-}
-#endif
-
 // Lecture du fichier.
 void FileLoad(char *pFilename)
 {
@@ -209,7 +199,8 @@ u32 FilesSearch(char *pNewDir)
 	strcpy(pCurDir, pNewDir);
 	strcat(pCurDir, "/");
 
-#ifdef __LINUX__
+#ifndef _WIN32
+	{
 	DIR	*dip;
 	struct dirent	*dit;
 	int	nDirPos;
@@ -227,10 +218,12 @@ u32 FilesSearch(char *pNewDir)
 	while ((dit = readdir(dip)) != NULL)
 	{
 		// Est-ce un fichier normal ?
+#ifdef DT_REG
 		if (dit->d_type != DT_REG) continue;
+#endif
 		// C'est un ".psd" ?
 		if (strlen(dit->d_name) > strlen(pExt))
-		if (stricmp(&dit->d_name[strlen(dit->d_name) - strlen(pExt)], pExt) == 0)
+		if (strcasecmp(&dit->d_name[strlen(dit->d_name) - strlen(pExt)], pExt) == 0)
 		{
 			strcpy(&pCurDir[nDirPos], dit->d_name);
 			printf("%s ", pCurDir);
@@ -260,10 +253,19 @@ u32 FilesSearch(char *pNewDir)
 	while ((dit = readdir(dip)) != NULL)
 	{
 		// Est-ce un répertoire ?
+#ifdef DT_REG
 		if (dit->d_type != DT_DIR) continue;
+#endif
 
 		if (strcmp(dit->d_name, ".") == 0 || strcmp(dit->d_name, "..") == 0) continue;
 		strcpy(&pCurDir[nDirPos], dit->d_name);
+#ifndef DT_REG
+		{
+			struct stat s;
+			if (stat(pCurDir, &s) != 0) continue;
+			if (!S_ISDIR(s.st_mode)) continue;
+		}
+#endif
 		nFilesNb += FilesSearch(pCurDir);
 	}
 	// Fermeture du répertoire.
@@ -272,9 +274,11 @@ u32 FilesSearch(char *pNewDir)
 		fprintf(stderr, "FilesSearch(): 'closedir' error.\n");
 		exit(0);
 	}
+	}
 #endif
 
-#ifdef WIN32
+#ifdef _WIN32
+	{
 	WIN32_FIND_DATA ffd;
 	HANDLE hFind;
 
@@ -296,7 +300,7 @@ u32 FilesSearch(char *pNewDir)
 		// Fichier.
 		// C'est un ".psd" ?
 		if (strlen(ffd.cFileName) > strlen(pExt))
-		if (stricmp(&ffd.cFileName[strlen(ffd.cFileName) - strlen(pExt)], pExt) == 0)
+		if (strcasecmp(&ffd.cFileName[strlen(ffd.cFileName) - strlen(pExt)], pExt) == 0)
 		{
 			printf("%s%s ", pCurDir, ffd.cFileName);
 			FileLoad(ffd.cFileName);
@@ -334,6 +338,7 @@ _dir:
 	}
 	while (FindNextFile(hFind, &ffd) != 0);
 	FindClose(hFind);
+	}
 #endif
 
 	return (nFilesNb);
Binary files minislug.orig/psdprot0/main.o and minislug.new/psdprot0/main.o differ
Binary files minislug.orig/psdprot0/psdprot and minislug.new/psdprot0/psdprot differ
